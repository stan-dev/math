<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Stan Math Library: stan::math::stack_alloc Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Stan Math Library
   &#160;<span id="projectnumber">2.12.0</span>
   </div>
   <div id="projectbrief">reverse mode automatic differentiation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1math.html">math</a></li><li class="navelem"><a class="el" href="classstan_1_1math_1_1stack__alloc.html">stack_alloc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstan_1_1math_1_1stack__alloc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stan::math::stack_alloc Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An instance of this class provides a memory pool through which blocks of raw memory may be allocated and then collected simultaneously.  
 <a href="classstan_1_1math_1_1stack__alloc.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6008eaa183ed07fb744799103926baac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#a6008eaa183ed07fb744799103926baac">stack_alloc</a> (size_t initial_nbytes=DEFAULT_INITIAL_NBYTES)</td></tr>
<tr class="memdesc:a6008eaa183ed07fb744799103926baac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a resizable stack allocator initially holding the specified number of bytes.  <a href="#a6008eaa183ed07fb744799103926baac">More...</a><br /></td></tr>
<tr class="separator:a6008eaa183ed07fb744799103926baac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946367b4b88dd893103db604c5f23669"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#a946367b4b88dd893103db604c5f23669">~stack_alloc</a> ()</td></tr>
<tr class="memdesc:a946367b4b88dd893103db604c5f23669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this memory allocator.  <a href="#a946367b4b88dd893103db604c5f23669">More...</a><br /></td></tr>
<tr class="separator:a946367b4b88dd893103db604c5f23669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af867f7a48394cc0422a58f0253cb6c96"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#af867f7a48394cc0422a58f0253cb6c96">alloc</a> (size_t len)</td></tr>
<tr class="memdesc:af867f7a48394cc0422a58f0253cb6c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a newly allocated block of memory of the appropriate size managed by the stack allocator.  <a href="#af867f7a48394cc0422a58f0253cb6c96">More...</a><br /></td></tr>
<tr class="separator:af867f7a48394cc0422a58f0253cb6c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00d799a98c424893745b20166cff14b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac00d799a98c424893745b20166cff14b"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#ac00d799a98c424893745b20166cff14b">alloc_array</a> (size_t n)</td></tr>
<tr class="memdesc:ac00d799a98c424893745b20166cff14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an array on the arena of the specified size to hold values of the specified template parameter type.  <a href="#ac00d799a98c424893745b20166cff14b">More...</a><br /></td></tr>
<tr class="separator:ac00d799a98c424893745b20166cff14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af298b06ae054599532498a1ccff4caeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#af298b06ae054599532498a1ccff4caeb">recover_all</a> ()</td></tr>
<tr class="memdesc:af298b06ae054599532498a1ccff4caeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover all the memory used by the stack allocator.  <a href="#af298b06ae054599532498a1ccff4caeb">More...</a><br /></td></tr>
<tr class="separator:af298b06ae054599532498a1ccff4caeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba5f8d013107c6a37f75e186bd6dfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#abdba5f8d013107c6a37f75e186bd6dfc">start_nested</a> ()</td></tr>
<tr class="memdesc:abdba5f8d013107c6a37f75e186bd6dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store current positions before doing nested operation so can recover back to start.  <a href="#abdba5f8d013107c6a37f75e186bd6dfc">More...</a><br /></td></tr>
<tr class="separator:abdba5f8d013107c6a37f75e186bd6dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7184bae2a2082fa7f683723379af7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#a9e7184bae2a2082fa7f683723379af7b">recover_nested</a> ()</td></tr>
<tr class="memdesc:a9e7184bae2a2082fa7f683723379af7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">recover memory back to the last start_nested call.  <a href="#a9e7184bae2a2082fa7f683723379af7b">More...</a><br /></td></tr>
<tr class="separator:a9e7184bae2a2082fa7f683723379af7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65518d98ebd980303efa6cc3af76073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#af65518d98ebd980303efa6cc3af76073">free_all</a> ()</td></tr>
<tr class="memdesc:af65518d98ebd980303efa6cc3af76073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory used by the stack allocator other than the initial block allocation back to the system.  <a href="#af65518d98ebd980303efa6cc3af76073">More...</a><br /></td></tr>
<tr class="separator:af65518d98ebd980303efa6cc3af76073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72fe7b15ca3086766445e2672e0b504"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html#ac72fe7b15ca3086766445e2672e0b504">bytes_allocated</a> ()</td></tr>
<tr class="memdesc:ac72fe7b15ca3086766445e2672e0b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes allocated to this instance by the heap.  <a href="#ac72fe7b15ca3086766445e2672e0b504">More...</a><br /></td></tr>
<tr class="separator:ac72fe7b15ca3086766445e2672e0b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An instance of this class provides a memory pool through which blocks of raw memory may be allocated and then collected simultaneously. </p>
<p>This class is useful in settings where large numbers of small objects are allocated and then collected all at once. This may include objects whose destructors have no effect.</p>
<p>Memory is allocated on a stack of blocks. Each block allocated is twice as large as the previous one. The memory may be recovered, with the blocks being reused, or all blocks may be freed, resetting the stack of blocks to its original state.</p>
<p>Alignment up to 8 byte boundaries guaranteed for the first malloc, and after that it's up to the caller. On 64-bit architectures, all struct values should be padded to 8-byte boundaries if they contain an 8-byte member or a virtual function. </p>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00071">71</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6008eaa183ed07fb744799103926baac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stan::math::stack_alloc::stack_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initial_nbytes</em> = <code>DEFAULT_INITIAL_NBYTES</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a resizable stack allocator initially holding the specified number of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_nbytes</td><td>Initial number of bytes for the allocator. Defaults to <code>(1 &lt;&lt; 16) = 64KB</code> initial bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the underlying malloc is not 8-byte aligned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00127">127</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a946367b4b88dd893103db604c5f23669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">stan::math::stack_alloc::~stack_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy this memory allocator. </p>
<p>This is implemented as a no-op as there is no destruction required. </p>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00143">143</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af867f7a48394cc0422a58f0253cb6c96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* stan::math::stack_alloc::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a newly allocated block of memory of the appropriate size managed by the stack allocator. </p>
<p>The allocated pointer will be 8-byte aligned.</p>
<p>This function may call C++'s <code>malloc()</code> function, with any exceptions percolated throught this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory. </dd></dl>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00162">162</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac00d799a98c424893745b20166cff14b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* stan::math::stack_alloc::alloc_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate an array on the arena of the specified size to hold values of the specified template parameter type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of entries in allocated array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>size of array to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new array allocated on the arena. </dd></dl>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00182">182</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac72fe7b15ca3086766445e2672e0b504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::stack_alloc::bytes_allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of bytes allocated to this instance by the heap. </p>
<p>This is not the same as the number of bytes allocated through calls to memalloc_. The latter number is not calculatable because space is wasted at the end of blocks if the next alloc request doesn't fit. (Perhaps we could trim down to what is actually used?)</p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes allocated to this instance </dd></dl>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00250">250</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af65518d98ebd980303efa6cc3af76073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stack_alloc::free_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all memory used by the stack allocator other than the initial block allocation back to the system. </p>
<p>Note: the destructor will free all memory. </p>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00230">230</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af298b06ae054599532498a1ccff4caeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stack_alloc::recover_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recover all the memory used by the stack allocator. </p>
<p>The stack of memory blocks allocated so far will be available for further allocations. To free memory back to the system, use the function <a class="el" href="classstan_1_1math_1_1stack__alloc.html#af65518d98ebd980303efa6cc3af76073" title="Free all memory used by the stack allocator other than the initial block allocation back to the syste...">free_all()</a>. </p>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00192">192</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e7184bae2a2082fa7f683723379af7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stack_alloc::recover_nested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recover memory back to the last start_nested call. </p>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00211">211</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdba5f8d013107c6a37f75e186bd6dfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stack_alloc::start_nested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store current positions before doing nested operation so can recover back to start. </p>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00202">202</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>stan/math/memory/<a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a></li>
</ul>
</div><!-- contents -->
<hr/>
<div class="conents" style="font-size:80%;">
  <span style="float:left; margin=0 1em 0 1em;">
  &nbsp;&nbsp;&nbsp;&nbsp;
  [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
  </span>
  <span style="float:right; margin=0 1em 0 1em;">
  <i>&copy; 2011&ndash;2016,
  Stan Development Team.
  &nbsp;&nbsp;&nbsp;&nbsp;
  </i>
  </span>
</div>
