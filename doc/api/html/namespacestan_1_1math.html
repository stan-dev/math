<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Stan Math Library: stan::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stan Math Library
   &#160;<span id="projectnumber">2.6.3</span>
   </div>
   <div id="projectbrief">probability, sampling &amp; optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stan::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrices and templated mathematical functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestan_1_1math_1_1detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html">stack_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of this class provides a memory pool through which blocks of raw memory may be allocated and then collected simultaneously.  <a href="classstan_1_1math_1_1stack__alloc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__observer.html">coupled_ode_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer for the coupled states.  <a href="structstan_1_1math_1_1coupled__ode__observer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system.html">coupled_ode_system</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template class for a coupled ordinary differential equation system, which adds sensitivities to the base system.  <a href="structstan_1_1math_1_1coupled__ode__system.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01double_01_4.html">coupled_ode_system&lt; F, double, double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ode system for known initial values and known parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01double_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01std_1_1vector_3_01_t_01_4_01_4.html">index_type&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of index for a standard vector.  <a href="structstan_1_1math_1_1index__type_3_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator.html">accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1array__builder.html">array_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for building up arrays in an expression (rather than in statements) using an argumentchaining <a class="el" href="structstan_1_1math_1_1array__builder.html#a085e0190d7a41c4e33bfa9f542b1d62a">add()</a> method and a getter method <a class="el" href="structstan_1_1math_1_1array__builder.html#a725410c59aa282c6b23c52fd252aa1a3">array()</a> to return the result.  <a href="structstan_1_1math_1_1array__builder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html">common_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1common__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_00_01_eiged8accfa00e73f240c58ad02ac582ba93.html">common_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01_r_00_01_c_01_4.html">LDLT_factor&lt; T, R, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> is a thin wrapper on Eigen::LDLT to allow for reusing factorizations and efficient autodiff of things like log determinants and solutions to linear systems.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01_r_00_01_c_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00-1_01_4_01_4.html">promote_scalar_struct&lt; T, Eigen::Matrix&lt; S,-1,-1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00-1_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00-1_01_4_01_4.html">promote_scalar_struct&lt; T, Eigen::Matrix&lt; S, 1,-1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00-1_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00_011_01_4_01_4.html">promote_scalar_struct&lt; T, Eigen::Matrix&lt; S,-1, 1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00-1_00_011_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1e90c042d64d8c3a6b9383f570932df58.html">promote_scalar_type&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a matrix whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1e90c042d64d8c3a6b9383f570932df58.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html">promote_scalar_type&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, 1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a vector whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html">promote_scalar_type&lt; T, Eigen::Matrix&lt; S, 1, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a row vector whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter.html">promoter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_t_00_01_t_01_4.html">promoter&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01std_1_1vector_3_01_f_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promoter&lt; std::vector&lt; F &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promoter&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_eigen_1_1_matrix_3_01_f_00_01_r_00_01_c_01_4_00_01_eigen_1_142b48fda94601374e41a81325f3f7b84.html">promoter&lt; Eigen::Matrix&lt; F, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promoter_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_eigen_1_12d7fadf0560f1f2f3abc5388b7666f9c.html">promoter&lt; Eigen::Matrix&lt; T, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1welford__covar__estimator.html">welford_covar_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1welford__var__estimator.html">welford_var_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html">index_type&lt; Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining typedef for the type of index for an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1math_1_1index__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type.html">store_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01double_01_4.html">store_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01int_01_4.html">store_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type.html">pass_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01double_01_4.html">pass_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01int_01_4.html">pass_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view.html">seq_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, 1, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">seq_view&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_t_01_4_01_4.html">seq_view&lt; T, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01std_1_1vector_3_01_t_01_4_01_4_01_4.html">seq_view&lt; T, std::vector&lt; std::vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01double_00_01std_1_1vector_3_01int_01_4_01_4.html">seq_view&lt; double, std::vector&lt; int &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html">value_type&lt; Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1math_1_1value__type_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct.html">promote_scalar_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_t_01_4.html">promote_scalar_struct&lt; T, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_scalar_struct&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold static function for promoting underlying scalar types.  <a href="structstan_1_1math_1_1promote__scalar__struct_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for converting a convertible type.  <a href="structstan_1_1math_1_1promote__scalar__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_scalar_type&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a container whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1child__type.html">child_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute child type of T.  <a href="structstan_1_1math_1_1child__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4.html">child_type&lt; T_struct&lt; T_child &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for template classes / structs.  <a href="structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1include__summand.html">include_summand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate whether a summand needs to be included in a proportional (log) probability calculation.  <a href="structstan_1_1math_1_1include__summand.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for the metaprogram to compute the index type of a container.  <a href="structstan_1_1math_1_1index__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01const_01_t_01_4.html">index_type&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for metaprogram to compute the type of indexes used in a constant container type.  <a href="structstan_1_1math_1_1index__type_3_01const_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1partials__vari.html">partials_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_operands_and_partials.html">OperandsAndPartials</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable implementation that stores operands and derivatives with respect to the variable.  <a href="structstan_1_1math_1_1_operands_and_partials.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type.html">value_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute the type of values stored in a container.  <a href="structstan_1_1math_1_1value__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type_3_01const_01_t_01_4.html">value_type&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for metaprogram to compute the type of values stored in a constant container.  <a href="structstan_1_1math_1_1value__type_3_01const_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1value__type_3_01std_1_1vector_3_01_t_01_4_01_4.html">value_type&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of values stored in a standard vector.  <a href="structstan_1_1math_1_1value__type_3_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sum__v__vari.html">sum_v_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for sums of variables constructed with standard vectors.  <a href="classstan_1_1math_1_1sum__v__vari.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01stan_1_1math_1_1var_01_4.html">coupled_ode_system&lt; F, double, stan::math::var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ODE system for known initial values and unknown parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01double_00_01stan_1_1math_1_1var_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1math_1_1var_00_01double_01_4.html">coupled_ode_system&lt; F, stan::math::var, double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ODE system for unknown initial values and known parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1math_1_1var_00_01double_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1math_1_1var_00_01stan_1_1math_1_1var_01_4.html">coupled_ode_system&lt; F, stan::math::var, stan::math::var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupled ode system for unknown intial values and unknown parameters.  <a href="structstan_1_1math_1_1coupled__ode__system_3_01_f_00_01stan_1_1math_1_1var_00_01stan_1_1math_1_1var_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_autodiff_stack_storage.html">AutodiffStackStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1chainable.html">chainable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for variable implementations that handles memory management and applying the chain rule.  <a href="classstan_1_1math_1_1chainable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1chainable__alloc.html">chainable_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classstan_1_1math_1_1chainable__alloc.html" title="A chainable_alloc is an object which is constructed and destructed normally but the memory lifespan i...">chainable_alloc</a> is an object which is constructed and destructed normally but the memory lifespan is managed along with the arena allocator for the gradient calculation.  <a href="classstan_1_1math_1_1chainable__alloc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__ddv__vari.html">op_ddv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dv__vari.html">op_dv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dvd__vari.html">op_dvd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dvv__vari.html">op_dvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1gevv__vvv__vari.html">gevv_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__matrix__vari.html">op_matrix_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomp__v__vari.html">precomp_v_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomp__vv__vari.html">precomp_vv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomp__vvv__vari.html">precomp_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomputed__gradients__vari.html">precomputed_gradients_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable implementation taking a sequence of operands and partial derivatives with respect to the operands.  <a href="classstan_1_1math_1_1precomputed__gradients__vari.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stored__gradient__vari.html">stored_gradient_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A var implementation that stores the daughter variable implementation pointers and the partial derivative with respect to the result explicitly in arrays constructed on the auto-diff memory stack.  <a href="classstan_1_1math_1_1stored__gradient__vari.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__v__vari.html">op_v_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1var.html">var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Independent (input) and dependent (output) variables for gradients.  <a href="classstan_1_1math_1_1var.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari.html">vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation base class.  <a href="classstan_1_1math_1_1vari.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vd__vari.html">op_vd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vdd__vari.html">op_vdd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vdv__vari.html">op_vdv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vector__vari.html">op_vector_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vv__vari.html">op_vv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vvd__vari.html">op_vvd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vvv__vari.html">op_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__alloc.html">LDLT_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This object stores the actual (double typed) LDLT factorization of an Eigen::Matrix&lt;var&gt; along with pointers to its vari's which allow the *_ldlt functions to save memory.  <a href="classstan_1_1math_1_1_l_d_l_t__alloc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01stan_1_1math_1_1var_00_01_r_00_01_c_01_4.html">LDLT_factor&lt; stan::math::var, R, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template specialization of src/stan/math/matrix/LDLT_factor.hpp for <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> which can be used with all the *_ldlt functions.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01stan_1_1math_1_1var_00_01_r_00_01_c_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sum__eigen__v__vari.html">sum_eigen_v_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing sums with constructors for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a>.  <a href="classstan_1_1math_1_1sum__eigen__v__vari.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;<br class="typebreak"/>
::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a></td></tr>
<tr class="memdesc:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for sizes and indexes in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix with double e.  <a href="#a98ff1baf06b8c5e2fc241bba99d0a97d">More...</a><br/></td></tr>
<tr class="separator:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12edd55403c6b7a6a7a859aef1990df5"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; double &gt;, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a12edd55403c6b7a6a7a859aef1990df5">matrix_fd</a></td></tr>
<tr class="separator:a12edd55403c6b7a6a7a859aef1990df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a8f07814e249e758d3347cbf3ce23f"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;<br class="typebreak"/>
 &gt;, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac1a8f07814e249e758d3347cbf3ce23f">matrix_ffd</a></td></tr>
<tr class="separator:ac1a8f07814e249e758d3347cbf3ce23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961a316bf3b39b578ec6382096da3e9a"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; double &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a961a316bf3b39b578ec6382096da3e9a">vector_fd</a></td></tr>
<tr class="separator:a961a316bf3b39b578ec6382096da3e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846bbc633c1a4c67cd805bbf61f42be0"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;<br class="typebreak"/>
 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a846bbc633c1a4c67cd805bbf61f42be0">vector_ffd</a></td></tr>
<tr class="separator:a846bbc633c1a4c67cd805bbf61f42be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e8ecf4499143a1d39440a4ce690de6"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; double &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a93e8ecf4499143a1d39440a4ce690de6">row_vector_fd</a></td></tr>
<tr class="separator:a93e8ecf4499143a1d39440a4ce690de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05b8f0a467a66e088270a5707a9f3b7"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;<br class="typebreak"/>
 &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae05b8f0a467a66e088270a5707a9f3b7">row_vector_ffd</a></td></tr>
<tr class="separator:ae05b8f0a467a66e088270a5707a9f3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401abbdecf03e1aaa673aae55ea22fad"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a401abbdecf03e1aaa673aae55ea22fad">matrix_fv</a></td></tr>
<tr class="separator:a401abbdecf03e1aaa673aae55ea22fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad1f7cc49caf90a56fe364405e1187"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
 &gt;, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af7ad1f7cc49caf90a56fe364405e1187">matrix_ffv</a></td></tr>
<tr class="separator:af7ad1f7cc49caf90a56fe364405e1187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5065cc81264dfe941f8e9a3ecfe5ee85"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5065cc81264dfe941f8e9a3ecfe5ee85">vector_fv</a></td></tr>
<tr class="separator:a5065cc81264dfe941f8e9a3ecfe5ee85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d0aff99d591327d929ee87054978ce"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab1d0aff99d591327d929ee87054978ce">vector_ffv</a></td></tr>
<tr class="separator:ab1d0aff99d591327d929ee87054978ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87031870214da337be0da09913bc9158"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87031870214da337be0da09913bc9158">row_vector_fv</a></td></tr>
<tr class="separator:a87031870214da337be0da09913bc9158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0159cba837b1310fe0c68b21ce555d5b"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a><br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
 &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0159cba837b1310fe0c68b21ce555d5b">row_vector_ffv</a></td></tr>
<tr class="separator:a0159cba837b1310fe0c68b21ce555d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735db87876a1e603cdfb3c8b3c41aab6"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a></td></tr>
<tr class="memdesc:a735db87876a1e603cdfb3c8b3c41aab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for matrix of double values.  <a href="#a735db87876a1e603cdfb3c8b3c41aab6">More...</a><br/></td></tr>
<tr class="separator:a735db87876a1e603cdfb3c8b3c41aab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e96c15b87fbd704ab9bcf77e7597db"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac9e96c15b87fbd704ab9bcf77e7597db">vector_d</a></td></tr>
<tr class="memdesc:ac9e96c15b87fbd704ab9bcf77e7597db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (column) vector of double values.  <a href="#ac9e96c15b87fbd704ab9bcf77e7597db">More...</a><br/></td></tr>
<tr class="separator:ac9e96c15b87fbd704ab9bcf77e7597db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61a9b8f4000b9e69bf2d1dcfb34c984"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac61a9b8f4000b9e69bf2d1dcfb34c984">row_vector_d</a></td></tr>
<tr class="memdesc:ac61a9b8f4000b9e69bf2d1dcfb34c984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (row) vector of double values.  <a href="#ac61a9b8f4000b9e69bf2d1dcfb34c984">More...</a><br/></td></tr>
<tr class="separator:ac61a9b8f4000b9e69bf2d1dcfb34c984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947fbc8520096439705d2072a18b43c0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structstan_1_1math_1_1_autodiff_stack_storage.html">AutodiffStackStorage</a><br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1chainable.html">chainable</a>, <a class="el" href="classstan_1_1math_1_1chainable__alloc.html">chainable_alloc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a947fbc8520096439705d2072a18b43c0">ChainableStack</a></td></tr>
<tr class="separator:a947fbc8520096439705d2072a18b43c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec679edf26abd1fdf8cf56053caf8e"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a></td></tr>
<tr class="memdesc:a5eec679edf26abd1fdf8cf56053caf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a matrix holding <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code> values.  <a href="#a5eec679edf26abd1fdf8cf56053caf8e">More...</a><br/></td></tr>
<tr class="separator:a5eec679edf26abd1fdf8cf56053caf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d3137027b10bc7758d4c1763b58a8e"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa7d3137027b10bc7758d4c1763b58a8e">vector_v</a></td></tr>
<tr class="memdesc:aa7d3137027b10bc7758d4c1763b58a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a (column) vector holding <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code> values.  <a href="#aa7d3137027b10bc7758d4c1763b58a8e">More...</a><br/></td></tr>
<tr class="separator:aa7d3137027b10bc7758d4c1763b58a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05401bf8bb7f886d11b1ee90495fe153"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a05401bf8bb7f886d11b1ee90495fe153">row_vector_v</a></td></tr>
<tr class="memdesc:a05401bf8bb7f886d11b1ee90495fe153"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a row vector holding <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code> values.  <a href="#a05401bf8bb7f886d11b1ee90495fe153">More...</a><br/></td></tr>
<tr class="separator:a05401bf8bb7f886d11b1ee90495fe153"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac86474622fba4524c529c4b8024e4ceb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac86474622fba4524c529c4b8024e4ceb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac86474622fba4524c529c4b8024e4ceb">log_sum_exp</a> (const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v)</td></tr>
<tr class="separator:ac86474622fba4524c529c4b8024e4ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5dda5a9c244efdbd023cc01d47cbf4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e5dda5a9c244efdbd023cc01d47cbf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e5dda5a9c244efdbd023cc01d47cbf4">sum</a> (const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;m)</td></tr>
<tr class="memdesc:a5e5dda5a9c244efdbd023cc01d47cbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the entries of the specified standard vector.  <a href="#a5e5dda5a9c244efdbd023cc01d47cbf4">More...</a><br/></td></tr>
<tr class="separator:a5e5dda5a9c244efdbd023cc01d47cbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a0614c9ba674f03e3d1b7586e99d27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51a0614c9ba674f03e3d1b7586e99d27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a51a0614c9ba674f03e3d1b7586e99d27">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a51a0614c9ba674f03e3d1b7586e99d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbabb3f7eeef5d7605eefad9c2fbef7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3fbabb3f7eeef5d7605eefad9c2fbef7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3fbabb3f7eeef5d7605eefad9c2fbef7">operator+</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a3fbabb3f7eeef5d7605eefad9c2fbef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbceec5a6822fd0c58529d6f64208f3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbceec5a6822fd0c58529d6f64208f3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adbceec5a6822fd0c58529d6f64208f3b">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:adbceec5a6822fd0c58529d6f64208f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eba6f623c3c2c0714e2eabbae90290f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1eba6f623c3c2c0714e2eabbae90290f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1eba6f623c3c2c0714e2eabbae90290f">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a1eba6f623c3c2c0714e2eabbae90290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aad69947e40bd42636143eadd38621"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02aad69947e40bd42636143eadd38621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a02aad69947e40bd42636143eadd38621">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a02aad69947e40bd42636143eadd38621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4e969693a718ffefbe5d45916ddef3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef4e969693a718ffefbe5d45916ddef3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aef4e969693a718ffefbe5d45916ddef3">operator/</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aef4e969693a718ffefbe5d45916ddef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431129b4a75d77ab60f6cd749bef5a11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a431129b4a75d77ab60f6cd749bef5a11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a431129b4a75d77ab60f6cd749bef5a11">operator==</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a431129b4a75d77ab60f6cd749bef5a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15161ab182b02d135f79a13d68c7318d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15161ab182b02d135f79a13d68c7318d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a15161ab182b02d135f79a13d68c7318d">operator==</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:a15161ab182b02d135f79a13d68c7318d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4930059b979a995acd759a0746bfc201"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4930059b979a995acd759a0746bfc201"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4930059b979a995acd759a0746bfc201">operator==</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a4930059b979a995acd759a0746bfc201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fefa51b18df1adec77e49f4e792fbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17fefa51b18df1adec77e49f4e792fbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a17fefa51b18df1adec77e49f4e792fbc">operator&gt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a17fefa51b18df1adec77e49f4e792fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c850c94b22aab8ffd895bdf8faebded"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c850c94b22aab8ffd895bdf8faebded"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9c850c94b22aab8ffd895bdf8faebded">operator&gt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:a9c850c94b22aab8ffd895bdf8faebded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7b92bb244d32edb94b17c8039ae826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba7b92bb244d32edb94b17c8039ae826"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aba7b92bb244d32edb94b17c8039ae826">operator&gt;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:aba7b92bb244d32edb94b17c8039ae826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5dee5c21281cc75cad8ebf9f6c43b98f">operator&gt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2097caea2b790905ee2948ef72727df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2097caea2b790905ee2948ef72727df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac2097caea2b790905ee2948ef72727df">operator&gt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:ac2097caea2b790905ee2948ef72727df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813edaa4311e1a4c206952f75a85eba8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a813edaa4311e1a4c206952f75a85eba8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a813edaa4311e1a4c206952f75a85eba8">operator&gt;=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a813edaa4311e1a4c206952f75a85eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c489941c560664036ee190c9028360"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2c489941c560664036ee190c9028360"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af2c489941c560664036ee190c9028360">operator&lt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:af2c489941c560664036ee190c9028360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0194df340cc3564835ff04086374cf97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0194df340cc3564835ff04086374cf97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0194df340cc3564835ff04086374cf97">operator&lt;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a0194df340cc3564835ff04086374cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a50b0c7ff4961eb7333aa81f685da55f4">operator&lt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450ef8aaef08c3137f70a087ae3905c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a450ef8aaef08c3137f70a087ae3905c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a450ef8aaef08c3137f70a087ae3905c6">operator&lt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a450ef8aaef08c3137f70a087ae3905c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95d660226997cbba13176cec459adaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab95d660226997cbba13176cec459adaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab95d660226997cbba13176cec459adaf">operator&lt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:ab95d660226997cbba13176cec459adaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5de0aa5a40e981ece663f96ad41997"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca5de0aa5a40e981ece663f96ad41997"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca5de0aa5a40e981ece663f96ad41997">operator&lt;=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:aca5de0aa5a40e981ece663f96ad41997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc9ba66175e049c6020fe363231d694"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afcc9ba66175e049c6020fe363231d694"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afcc9ba66175e049c6020fe363231d694">operator*</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:afcc9ba66175e049c6020fe363231d694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad613e6b4387544fecd361475490d9dd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad613e6b4387544fecd361475490d9dd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad613e6b4387544fecd361475490d9dd3">operator*</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ad613e6b4387544fecd361475490d9dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee4488ea32a5bf3cce50117e14b2d07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ee4488ea32a5bf3cce50117e14b2d07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5ee4488ea32a5bf3cce50117e14b2d07">operator*</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a5ee4488ea32a5bf3cce50117e14b2d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65438bf17da7bbedb06bc7c381cea865"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65438bf17da7bbedb06bc7c381cea865"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a65438bf17da7bbedb06bc7c381cea865">operator!=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a65438bf17da7bbedb06bc7c381cea865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e121241958fdcc4d2190bc532e9bc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41e121241958fdcc4d2190bc532e9bc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a41e121241958fdcc4d2190bc532e9bc5">operator!=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:a41e121241958fdcc4d2190bc532e9bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae982faec66434385fda1c728b0b2bf3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae982faec66434385fda1c728b0b2bf3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae982faec66434385fda1c728b0b2bf3d">operator!=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ae982faec66434385fda1c728b0b2bf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a200e70e0f2b422b6623cf4b19d04da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a200e70e0f2b422b6623cf4b19d04da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6a200e70e0f2b422b6623cf4b19d04da">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a6a200e70e0f2b422b6623cf4b19d04da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d89d23df91de283beda449d480b437"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87d89d23df91de283beda449d480b437"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87d89d23df91de283beda449d480b437">operator-</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a87d89d23df91de283beda449d480b437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8dea434972aa3008e352349069e206"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd8dea434972aa3008e352349069e206"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd8dea434972aa3008e352349069e206">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:afd8dea434972aa3008e352349069e206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeee50b418200d06eb867d0ef3b3125"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedeee50b418200d06eb867d0ef3b3125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aedeee50b418200d06eb867d0ef3b3125">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aedeee50b418200d06eb867d0ef3b3125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b6eb8c9db16d8321d8f2f18632be1"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ad63b6eb8c9db16d8321d8f2f18632be1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, 1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad63b6eb8c9db16d8321d8f2f18632be1">columns_dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:ad63b6eb8c9db16d8321d8f2f18632be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415662a8443b30a03b559fad4be26e85"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a415662a8443b30a03b559fad4be26e85"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, 1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a415662a8443b30a03b559fad4be26e85">columns_dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a415662a8443b30a03b559fad4be26e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca0a75054cee6793caf8b97f47f8fa7"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a8ca0a75054cee6793caf8b97f47f8fa7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, 1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8ca0a75054cee6793caf8b97f47f8fa7">columns_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a8ca0a75054cee6793caf8b97f47f8fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3663d900f7f0bdd57e808301ff142ee1"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a3663d900f7f0bdd57e808301ff142ee1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, 1, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3663d900f7f0bdd57e808301ff142ee1">columns_dot_self</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;x)</td></tr>
<tr class="separator:a3663d900f7f0bdd57e808301ff142ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd303ef11dc0c73cda2f743a3b67fbf1"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:abd303ef11dc0c73cda2f743a3b67fbf1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, C, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abd303ef11dc0c73cda2f743a3b67fbf1">crossprod</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;m)</td></tr>
<tr class="separator:abd303ef11dc0c73cda2f743a3b67fbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ab2582fc9a5a31d3d4f38a6420174e"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a63ab2582fc9a5a31d3d4f38a6420174e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a63ab2582fc9a5a31d3d4f38a6420174e">determinant</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a63ab2582fc9a5a31d3d4f38a6420174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbb4ba8df580321dbf92d0c563cc523"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0bbb4ba8df580321dbf92d0c563cc523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0bbb4ba8df580321dbf92d0c563cc523">divide</a> (const T1 &amp;v, const T2 &amp;c)</td></tr>
<tr class="separator:a0bbb4ba8df580321dbf92d0c563cc523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f35909d12ac43b74d180a49d68b674"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ab1f35909d12ac43b74d180a49d68b674"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab1f35909d12ac43b74d180a49d68b674">divide</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:ab1f35909d12ac43b74d180a49d68b674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbe71733db295fc195305aee8437732"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:abfbe71733db295fc195305aee8437732"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abfbe71733db295fc195305aee8437732">divide</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;v, const double c)</td></tr>
<tr class="separator:abfbe71733db295fc195305aee8437732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab549dab5e1bff51b30678fbd8d1f8a41"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ab549dab5e1bff51b30678fbd8d1f8a41"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab549dab5e1bff51b30678fbd8d1f8a41">divide</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:ab549dab5e1bff51b30678fbd8d1f8a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbbe36fe5dcdd2996fe40afdd874983"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a2cbbe36fe5dcdd2996fe40afdd874983"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2cbbe36fe5dcdd2996fe40afdd874983">operator/</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:a2cbbe36fe5dcdd2996fe40afdd874983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b310fd13ba04c615b74671f262b25d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a48b310fd13ba04c615b74671f262b25d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a48b310fd13ba04c615b74671f262b25d">operator/</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;v, const double c)</td></tr>
<tr class="separator:a48b310fd13ba04c615b74671f262b25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7174185d7dd2b83e370d535d35870c4a"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a7174185d7dd2b83e370d535d35870c4a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7174185d7dd2b83e370d535d35870c4a">operator/</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:a7174185d7dd2b83e370d535d35870c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495321127b7e0ebdd4d52654d226e16b"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a495321127b7e0ebdd4d52654d226e16b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a495321127b7e0ebdd4d52654d226e16b">dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a495321127b7e0ebdd4d52654d226e16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55524d5b711066af73968df35ddeb2c"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:af55524d5b711066af73968df35ddeb2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af55524d5b711066af73968df35ddeb2c">dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:af55524d5b711066af73968df35ddeb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f6624e3a637cb98d3ae10a42a44135"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a74f6624e3a637cb98d3ae10a42a44135"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a74f6624e3a637cb98d3ae10a42a44135">dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a74f6624e3a637cb98d3ae10a42a44135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a386f813bee88dc6d771ba0f0c90f82"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a4a386f813bee88dc6d771ba0f0c90f82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4a386f813bee88dc6d771ba0f0c90f82">dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2, <a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> &amp;<a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="separator:a4a386f813bee88dc6d771ba0f0c90f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58d380f8784b977f1372ca00caa779e"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:af58d380f8784b977f1372ca00caa779e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af58d380f8784b977f1372ca00caa779e">dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2, <a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> &amp;<a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="separator:af58d380f8784b977f1372ca00caa779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7893eb903c5877be710060cc1f733ece"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a7893eb903c5877be710060cc1f733ece"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7893eb903c5877be710060cc1f733ece">dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2, <a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> &amp;<a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="separator:a7893eb903c5877be710060cc1f733ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfb7deab1e93815803096f298e722a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3dfb7deab1e93815803096f298e722a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3dfb7deab1e93815803096f298e722a3">dot_product</a> (const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v1, const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v2)</td></tr>
<tr class="separator:a3dfb7deab1e93815803096f298e722a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade870e95240c98560c7146fc1569811e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade870e95240c98560c7146fc1569811e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ade870e95240c98560c7146fc1569811e">dot_product</a> (const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v2)</td></tr>
<tr class="separator:ade870e95240c98560c7146fc1569811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092173dbe404bf00d732a86b18ed7cc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a092173dbe404bf00d732a86b18ed7cc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a092173dbe404bf00d732a86b18ed7cc0">dot_product</a> (const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2)</td></tr>
<tr class="separator:a092173dbe404bf00d732a86b18ed7cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2848b5eca56fff0922803874f97b58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d2848b5eca56fff0922803874f97b58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d2848b5eca56fff0922803874f97b58">dot_product</a> (const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v1, const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v2, <a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> &amp;<a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="separator:a4d2848b5eca56fff0922803874f97b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af240b31f8d6bc2c9acce4b8fc3ebd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6af240b31f8d6bc2c9acce4b8fc3ebd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af6af240b31f8d6bc2c9acce4b8fc3ebd">dot_product</a> (const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v2, <a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> &amp;<a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="separator:af6af240b31f8d6bc2c9acce4b8fc3ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590dde9498d871fff74858d1f7ef2667"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a590dde9498d871fff74858d1f7ef2667"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a590dde9498d871fff74858d1f7ef2667">dot_product</a> (const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2, <a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> &amp;<a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="separator:a590dde9498d871fff74858d1f7ef2667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edae52ce70f3f0a9f7eb15f3416007c"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a1edae52ce70f3f0a9f7eb15f3416007c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1edae52ce70f3f0a9f7eb15f3416007c">dot_self</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;v)</td></tr>
<tr class="separator:a1edae52ce70f3f0a9f7eb15f3416007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab64bf2ca0e8e628e49119ed995c1c67"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aab64bf2ca0e8e628e49119ed995c1c67"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab64bf2ca0e8e628e49119ed995c1c67">inverse</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;m)</td></tr>
<tr class="separator:aab64bf2ca0e8e628e49119ed995c1c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f88bd206be351748e56aebf7e58289a"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a6f88bd206be351748e56aebf7e58289a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f88bd206be351748e56aebf7e58289a">log_determinant</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a6f88bd206be351748e56aebf7e58289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558975cc79251cd99966f99ed8795ddc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a558975cc79251cd99966f99ed8795ddc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;<br class="typebreak"/>
, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a558975cc79251cd99966f99ed8795ddc">log_softmax</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt; &amp;alpha)</td></tr>
<tr class="separator:a558975cc79251cd99966f99ed8795ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a4bb0a8db85be07d98d3b2e2fc96c4"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a34a4bb0a8db85be07d98d3b2e2fc96c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34a4bb0a8db85be07d98d3b2e2fc96c4">log_sum_exp</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;v)</td></tr>
<tr class="separator:a34a4bb0a8db85be07d98d3b2e2fc96c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f50d0ea5c9343dae0945012924f127c"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a0f50d0ea5c9343dae0945012924f127c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0f50d0ea5c9343dae0945012924f127c">mdivide_left</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a0f50d0ea5c9343dae0945012924f127c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9c580ecf4fc5b7a9e7523325a6cbe5"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a1b9c580ecf4fc5b7a9e7523325a6cbe5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1b9c580ecf4fc5b7a9e7523325a6cbe5">mdivide_left</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a1b9c580ecf4fc5b7a9e7523325a6cbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933154f105a6d18864cfca8a8e2ff12c"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a933154f105a6d18864cfca8a8e2ff12c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a933154f105a6d18864cfca8a8e2ff12c">mdivide_left</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a933154f105a6d18864cfca8a8e2ff12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63890dd40cd8ad08a55c3b4e8616c741"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2, typename T2 &gt; </td></tr>
<tr class="memitem:a63890dd40cd8ad08a55c3b4e8616c741"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a63890dd40cd8ad08a55c3b4e8616c741">mdivide_left_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a63890dd40cd8ad08a55c3b4e8616c741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#a63890dd40cd8ad08a55c3b4e8616c741">More...</a><br/></td></tr>
<tr class="separator:a63890dd40cd8ad08a55c3b4e8616c741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb79c8ce7ae730ba02342b4241aeac1"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a7eb79c8ce7ae730ba02342b4241aeac1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7eb79c8ce7ae730ba02342b4241aeac1">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a7eb79c8ce7ae730ba02342b4241aeac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e366981089fe4cd134efa82492ced2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a98e366981089fe4cd134efa82492ced2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a98e366981089fe4cd134efa82492ced2">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a98e366981089fe4cd134efa82492ced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6c4407f5ae843d0c12e15863591d22"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5d6c4407f5ae843d0c12e15863591d22"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5d6c4407f5ae843d0c12e15863591d22">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a5d6c4407f5ae843d0c12e15863591d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad09daa535a7aeda34199d43a8e9e29"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a2ad09daa535a7aeda34199d43a8e9e29"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2ad09daa535a7aeda34199d43a8e9e29">mdivide_right</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a2ad09daa535a7aeda34199d43a8e9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f6566409d59f27b6f3086afeb0b18b"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a56f6566409d59f27b6f3086afeb0b18b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a56f6566409d59f27b6f3086afeb0b18b">mdivide_right</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a56f6566409d59f27b6f3086afeb0b18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9769485dc9f11852020b153b2ffe8bff"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a9769485dc9f11852020b153b2ffe8bff"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9769485dc9f11852020b153b2ffe8bff">mdivide_right</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a9769485dc9f11852020b153b2ffe8bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5309461c7fc32ca494e80af0722766af"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5309461c7fc32ca494e80af0722766af"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5309461c7fc32ca494e80af0722766af">mdivide_right_tri_low</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a5309461c7fc32ca494e80af0722766af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cb38185a25a0971268ba6507af8667"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a51cb38185a25a0971268ba6507af8667"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a51cb38185a25a0971268ba6507af8667">mdivide_right_tri_low</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a51cb38185a25a0971268ba6507af8667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046824a9236dae195f0c0e5eb69dd8a6"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a046824a9236dae195f0c0e5eb69dd8a6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a046824a9236dae195f0c0e5eb69dd8a6">mdivide_right_tri_low</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a046824a9236dae195f0c0e5eb69dd8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a69b84ead3c81cbaff702ac429e1cc"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:a35a69b84ead3c81cbaff702ac429e1cc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a35a69b84ead3c81cbaff702ac429e1cc">multiply</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;m, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:a35a69b84ead3c81cbaff702ac429e1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa473aa547cf1bb658edb99fd1182e989"><td class="memTemplParams" colspan="2">template&lt;typename T , int R2, int C2&gt; </td></tr>
<tr class="memitem:aa473aa547cf1bb658edb99fd1182e989"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa473aa547cf1bb658edb99fd1182e989">multiply</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;m, const double c)</td></tr>
<tr class="separator:aa473aa547cf1bb658edb99fd1182e989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ca3cf29874f3f7a3334b0b7e5db09b"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:a81ca3cf29874f3f7a3334b0b7e5db09b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a81ca3cf29874f3f7a3334b0b7e5db09b">multiply</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;m, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:a81ca3cf29874f3f7a3334b0b7e5db09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00de5667a1e8f49293a35bcd21e86104"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:a00de5667a1e8f49293a35bcd21e86104"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a00de5667a1e8f49293a35bcd21e86104">multiply</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;m)</td></tr>
<tr class="separator:a00de5667a1e8f49293a35bcd21e86104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58b9aa1f80267935b6dc1bf57a20090"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:ad58b9aa1f80267935b6dc1bf57a20090"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad58b9aa1f80267935b6dc1bf57a20090">multiply</a> (const double c, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;m)</td></tr>
<tr class="separator:ad58b9aa1f80267935b6dc1bf57a20090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ef18d2345a17eb4044bb4697c18ca3"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:a18ef18d2345a17eb4044bb4697c18ca3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a18ef18d2345a17eb4044bb4697c18ca3">multiply</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;c, const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;m)</td></tr>
<tr class="separator:a18ef18d2345a17eb4044bb4697c18ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dea45b5f0a70316514dadfa5bd5ea2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a79dea45b5f0a70316514dadfa5bd5ea2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a79dea45b5f0a70316514dadfa5bd5ea2">multiply</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:a79dea45b5f0a70316514dadfa5bd5ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34755674f81a0403550b728a50b390d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aa34755674f81a0403550b728a50b390d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa34755674f81a0403550b728a50b390d">multiply</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:aa34755674f81a0403550b728a50b390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fc2abfda7f892c5eeb8fec8f8cd765"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a22fc2abfda7f892c5eeb8fec8f8cd765"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a22fc2abfda7f892c5eeb8fec8f8cd765">multiply</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:a22fc2abfda7f892c5eeb8fec8f8cd765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69034d7594d58dd7f6362caa5aebe03d"><td class="memTemplParams" colspan="2">template&lt;typename T , int C1, int R2&gt; </td></tr>
<tr class="memitem:a69034d7594d58dd7f6362caa5aebe03d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69034d7594d58dd7f6362caa5aebe03d">multiply</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, 1, C1 &gt; &amp;rv, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, 1 &gt; &amp;v)</td></tr>
<tr class="separator:a69034d7594d58dd7f6362caa5aebe03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64b783b01a987d981c17cbcc33e4b6"><td class="memTemplParams" colspan="2">template&lt;typename T , int C1, int R2&gt; </td></tr>
<tr class="memitem:ace64b783b01a987d981c17cbcc33e4b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ace64b783b01a987d981c17cbcc33e4b6">multiply</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, 1, C1 &gt; &amp;rv, const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;v)</td></tr>
<tr class="separator:ace64b783b01a987d981c17cbcc33e4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af8534a80b35c3af6a6cf23cdddd46c"><td class="memTemplParams" colspan="2">template&lt;typename T , int C1, int R2&gt; </td></tr>
<tr class="memitem:a7af8534a80b35c3af6a6cf23cdddd46c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7af8534a80b35c3af6a6cf23cdddd46c">multiply</a> (const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;rv, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, 1 &gt; &amp;v)</td></tr>
<tr class="separator:a7af8534a80b35c3af6a6cf23cdddd46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d671dcfc6f4c1b4896c5d8bc4568acf"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a0d671dcfc6f4c1b4896c5d8bc4568acf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0d671dcfc6f4c1b4896c5d8bc4568acf">multiply_lower_tri_self_transpose</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a0d671dcfc6f4c1b4896c5d8bc4568acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4badef735ea8b1cbfca31cbe49a534cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4badef735ea8b1cbfca31cbe49a534cf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;<br class="typebreak"/>
, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4badef735ea8b1cbfca31cbe49a534cf">qr_Q</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:a4badef735ea8b1cbfca31cbe49a534cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c6e003d4aa779acef714b05a153c1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2c6e003d4aa779acef714b05a153c1c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;<br class="typebreak"/>
, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae2c6e003d4aa779acef714b05a153c1c">qr_R</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:ae2c6e003d4aa779acef714b05a153c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060626b1758db1e659c0820f77eb7dcf"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a060626b1758db1e659c0820f77eb7dcf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a060626b1758db1e659c0820f77eb7dcf">rows_dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a060626b1758db1e659c0820f77eb7dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5f5461d67d595a0c0fd720ae6cd6bd"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aab5f5461d67d595a0c0fd720ae6cd6bd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab5f5461d67d595a0c0fd720ae6cd6bd">rows_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:aab5f5461d67d595a0c0fd720ae6cd6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b02f2791c9c5a29811bf411e5f6e4b"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ac6b02f2791c9c5a29811bf411e5f6e4b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac6b02f2791c9c5a29811bf411e5f6e4b">rows_dot_product</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:ac6b02f2791c9c5a29811bf411e5f6e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6208b5b257e2a7efac35e88ab93e8c"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a6b6208b5b257e2a7efac35e88ab93e8c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6b6208b5b257e2a7efac35e88ab93e8c">rows_dot_self</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;x)</td></tr>
<tr class="separator:a6b6208b5b257e2a7efac35e88ab93e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f57ef7820025c7b350f84c3aebfe45e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f57ef7820025c7b350f84c3aebfe45e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;<br class="typebreak"/>
, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f57ef7820025c7b350f84c3aebfe45e">softmax</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt; &amp;alpha)</td></tr>
<tr class="separator:a6f57ef7820025c7b350f84c3aebfe45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941784bb46a4a2fabf3deacebbd71ec5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a941784bb46a4a2fabf3deacebbd71ec5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a941784bb46a4a2fabf3deacebbd71ec5">sort_asc</a> (std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; xs)</td></tr>
<tr class="separator:a941784bb46a4a2fabf3deacebbd71ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4181de091dfd2ded22cefa4df86720e6"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a4181de091dfd2ded22cefa4df86720e6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4181de091dfd2ded22cefa4df86720e6">sort_asc</a> (Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; xs)</td></tr>
<tr class="separator:a4181de091dfd2ded22cefa4df86720e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c06412237c5d6879a4c07f0706303e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c06412237c5d6879a4c07f0706303e9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c06412237c5d6879a4c07f0706303e9">sort_desc</a> (std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; xs)</td></tr>
<tr class="separator:a7c06412237c5d6879a4c07f0706303e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e74300574eb2a6e80e0f4cb029596e"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a27e74300574eb2a6e80e0f4cb029596e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a27e74300574eb2a6e80e0f4cb029596e">sort_desc</a> (Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; xs)</td></tr>
<tr class="separator:a27e74300574eb2a6e80e0f4cb029596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ac5708411da911ccf11be4a5f511f5"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a03ac5708411da911ccf11be4a5f511f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a03ac5708411da911ccf11be4a5f511f5">sum</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a03ac5708411da911ccf11be4a5f511f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the entries of the specified matrix.  <a href="#a03ac5708411da911ccf11be4a5f511f5">More...</a><br/></td></tr>
<tr class="separator:a03ac5708411da911ccf11be4a5f511f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab379e9a9f74dab16c41d82978cc4b58e"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ab379e9a9f74dab16c41d82978cc4b58e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab379e9a9f74dab16c41d82978cc4b58e">tcrossprod</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt; &amp;m)</td></tr>
<tr class="separator:ab379e9a9f74dab16c41d82978cc4b58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19a5837a9b5c3e219e5081d8dca3c89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad19a5837a9b5c3e219e5081d8dca3c89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad19a5837a9b5c3e219e5081d8dca3c89">to_fvar</a> (const T &amp;x)</td></tr>
<tr class="separator:ad19a5837a9b5c3e219e5081d8dca3c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9d67d772eeec5340fde5d2753a14b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d9d67d772eeec5340fde5d2753a14b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5d9d67d772eeec5340fde5d2753a14b7">to_fvar</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a5d9d67d772eeec5340fde5d2753a14b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb48ecaf381b03e60f9df8bab82e60c"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:adfb48ecaf381b03e60f9df8bab82e60c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adfb48ecaf381b03e60f9df8bab82e60c">to_fvar</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:adfb48ecaf381b03e60f9df8bab82e60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a866da3d4ca122849b1e0ab9b38687a"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a6a866da3d4ca122849b1e0ab9b38687a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;<br class="typebreak"/>
, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6a866da3d4ca122849b1e0ab9b38687a">to_fvar</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a6a866da3d4ca122849b1e0ab9b38687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb79996a9efea5b41d2d61ac2e0ecd3"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aafb79996a9efea5b41d2d61ac2e0ecd3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aafb79996a9efea5b41d2d61ac2e0ecd3">to_fvar</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;val, const Eigen::Matrix&lt; T, R, C &gt; &amp;deriv)</td></tr>
<tr class="separator:aafb79996a9efea5b41d2d61ac2e0ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd59dd23ba6d346713d117001b99507f"><td class="memTemplParams" colspan="2">template&lt;int RD, int CD, int RA, int CA, int RB, int CB, typename T &gt; </td></tr>
<tr class="memitem:acd59dd23ba6d346713d117001b99507f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acd59dd23ba6d346713d117001b99507f">trace_gen_quad_form</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, RD, CD &gt; &amp;D, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:acd59dd23ba6d346713d117001b99507f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6077d5db50f265d5279c62ff5922e0f"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB, typename T &gt; </td></tr>
<tr class="memitem:af6077d5db50f265d5279c62ff5922e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af6077d5db50f265d5279c62ff5922e0f">trace_quad_form</a> (const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:af6077d5db50f265d5279c62ff5922e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd625b9cec928434683f6c6502094f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a9cd625b9cec928434683f6c6502094f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9cd625b9cec928434683f6c6502094f4">gradient</a> (const F &amp;f, const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;x, T &amp;fx, Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;grad_fx)</td></tr>
<tr class="memdesc:a9cd625b9cec928434683f6c6502094f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <a href="#a9cd625b9cec928434683f6c6502094f4">More...</a><br/></td></tr>
<tr class="separator:a9cd625b9cec928434683f6c6502094f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c855fa18077624b60fb19bfe1045b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a72c855fa18077624b60fb19bfe1045b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a72c855fa18077624b60fb19bfe1045b2">jacobian</a> (const F &amp;f, const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;x, Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;fx, Eigen::Matrix&lt; T, Dynamic, Dynamic &gt; &amp;J)</td></tr>
<tr class="separator:a72c855fa18077624b60fb19bfe1045b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae560b842e3ed6e5939dc2177bf158265"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae560b842e3ed6e5939dc2177bf158265"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae560b842e3ed6e5939dc2177bf158265">abs</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae560b842e3ed6e5939dc2177bf158265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6952d8c23d69dc891dbe78e7d4ea7a80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6952d8c23d69dc891dbe78e7d4ea7a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6952d8c23d69dc891dbe78e7d4ea7a80">acos</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a6952d8c23d69dc891dbe78e7d4ea7a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033720f1a26c44aa9d7fb4dcf547155"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae033720f1a26c44aa9d7fb4dcf547155"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae033720f1a26c44aa9d7fb4dcf547155">acosh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae033720f1a26c44aa9d7fb4dcf547155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab75d0165599717cfd1e90f7edcf250"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ab75d0165599717cfd1e90f7edcf250"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1ab75d0165599717cfd1e90f7edcf250">asin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a1ab75d0165599717cfd1e90f7edcf250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68af8aec6bd04b4d40e5bce59f82b97c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68af8aec6bd04b4d40e5bce59f82b97c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a68af8aec6bd04b4d40e5bce59f82b97c">asinh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a68af8aec6bd04b4d40e5bce59f82b97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0398656b862b1b2eb80145f4877b11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f0398656b862b1b2eb80145f4877b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f0398656b862b1b2eb80145f4877b11">atan</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a6f0398656b862b1b2eb80145f4877b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4868ee5c5ab673ee54e5dce3be37f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c4868ee5c5ab673ee54e5dce3be37f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a0c4868ee5c5ab673ee54e5dce3be37f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee48dfb63f75612a566b876f59d4a8df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee48dfb63f75612a566b876f59d4a8df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aee48dfb63f75612a566b876f59d4a8df">atan2</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aee48dfb63f75612a566b876f59d4a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a4864b96b98584311eea08a6ff609e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28a4864b96b98584311eea08a6ff609e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a28a4864b96b98584311eea08a6ff609e">atan2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a28a4864b96b98584311eea08a6ff609e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e31606b2cbc69573ec0d7693c8b2a2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e31606b2cbc69573ec0d7693c8b2a2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e31606b2cbc69573ec0d7693c8b2a2c">atanh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a9e31606b2cbc69573ec0d7693c8b2a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f08e25e46df323a2429edc45d1c8954"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f08e25e46df323a2429edc45d1c8954"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0f08e25e46df323a2429edc45d1c8954">bessel_first_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a0f08e25e46df323a2429edc45d1c8954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b227eac2dd4cbc55462ecebe940294"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0b227eac2dd4cbc55462ecebe940294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0b227eac2dd4cbc55462ecebe940294">bessel_second_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab0b227eac2dd4cbc55462ecebe940294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d069b5730083b0203812d63c6f62f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0d069b5730083b0203812d63c6f62f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae0d069b5730083b0203812d63c6f62f3">binary_log_loss</a> (const int y, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y_hat)</td></tr>
<tr class="separator:ae0d069b5730083b0203812d63c6f62f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ae920ef2089bb1686eb51c3dc153b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3ae920ef2089bb1686eb51c3dc153b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab3ae920ef2089bb1686eb51c3dc153b4">binomial_coefficient_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ab3ae920ef2089bb1686eb51c3dc153b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113b2443c22c0859cc797b7c1bdea59f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a113b2443c22c0859cc797b7c1bdea59f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a113b2443c22c0859cc797b7c1bdea59f">binomial_coefficient_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a113b2443c22c0859cc797b7c1bdea59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6816ab0a50a160820063ffe087a826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d6816ab0a50a160820063ffe087a826"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d6816ab0a50a160820063ffe087a826">binomial_coefficient_log</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a6d6816ab0a50a160820063ffe087a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c0dfe5862fc53f1a18d76f14a1dc7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64c0dfe5862fc53f1a18d76f14a1dc7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a64c0dfe5862fc53f1a18d76f14a1dc7e">cbrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a64c0dfe5862fc53f1a18d76f14a1dc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b2e9b4a947b81917612a8d1d547afb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1b2e9b4a947b81917612a8d1d547afb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab1b2e9b4a947b81917612a8d1d547afb">ceil</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab1b2e9b4a947b81917612a8d1d547afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cb3a9041ae0b7855b398c3e11cda48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6cb3a9041ae0b7855b398c3e11cda48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae6cb3a9041ae0b7855b398c3e11cda48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fa5213b343a52756c138107ac180b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee4fa5213b343a52756c138107ac180b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aee4fa5213b343a52756c138107ac180b">cosh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aee4fa5213b343a52756c138107ac180b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69702aaa101bf602072fa7bf5fccb48a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69702aaa101bf602072fa7bf5fccb48a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69702aaa101bf602072fa7bf5fccb48a">digamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a69702aaa101bf602072fa7bf5fccb48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283efca22c0544054a6534443e6e762"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa283efca22c0544054a6534443e6e762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa283efca22c0544054a6534443e6e762">erf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa283efca22c0544054a6534443e6e762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c763e4f09069eed96a4e96e33ea8ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4c763e4f09069eed96a4e96e33ea8ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab4c763e4f09069eed96a4e96e33ea8ea">erfc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab4c763e4f09069eed96a4e96e33ea8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f31444e8584e4debf0d6b706d66880"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11f31444e8584e4debf0d6b706d66880"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a11f31444e8584e4debf0d6b706d66880">exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a11f31444e8584e4debf0d6b706d66880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a577694c8f584e56160580fe0821b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c3a577694c8f584e56160580fe0821b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8c3a577694c8f584e56160580fe0821b">exp2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a8c3a577694c8f584e56160580fe0821b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a76b658b94fcf8943f4fb41c586ec94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a76b658b94fcf8943f4fb41c586ec94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a76b658b94fcf8943f4fb41c586ec94">expm1</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a8a76b658b94fcf8943f4fb41c586ec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c79c9be5c64873b74f3c6924fef6911"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c79c9be5c64873b74f3c6924fef6911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6c79c9be5c64873b74f3c6924fef6911">fabs</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a6c79c9be5c64873b74f3c6924fef6911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3974a012285e3d020d46cc454812ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae3974a012285e3d020d46cc454812ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aae3974a012285e3d020d46cc454812ed">falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:aae3974a012285e3d020d46cc454812ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203c9c81e4a4b48e47e052422fcf679d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a203c9c81e4a4b48e47e052422fcf679d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a203c9c81e4a4b48e47e052422fcf679d">falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const double n)</td></tr>
<tr class="separator:a203c9c81e4a4b48e47e052422fcf679d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3c08d051a8e4bc83c6ad9132af4099"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a3c08d051a8e4bc83c6ad9132af4099"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5a3c08d051a8e4bc83c6ad9132af4099">falling_factorial</a> (const double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a5a3c08d051a8e4bc83c6ad9132af4099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535e91c206d8cfd9e61042c25108f23a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a535e91c206d8cfd9e61042c25108f23a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a535e91c206d8cfd9e61042c25108f23a">fdim</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a535e91c206d8cfd9e61042c25108f23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af93d6decc446332dedd367db295bcb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9af93d6decc446332dedd367db295bcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9af93d6decc446332dedd367db295bcb">fdim</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a9af93d6decc446332dedd367db295bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9448d07d7e87cd638f65ce95350c0e8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9448d07d7e87cd638f65ce95350c0e8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9448d07d7e87cd638f65ce95350c0e8b">fdim</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a9448d07d7e87cd638f65ce95350c0e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e5a2666b377e37fe807765ba5f6aaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16e5a2666b377e37fe807765ba5f6aaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16e5a2666b377e37fe807765ba5f6aaf">floor</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a16e5a2666b377e37fe807765ba5f6aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52e5d20122b9db1d2ec7c57417d19b3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ad52e5d20122b9db1d2ec7c57417d19b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2, T3 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad52e5d20122b9db1d2ec7c57417d19b3">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:ad52e5d20122b9db1d2ec7c57417d19b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add operation (C99).  <a href="#ad52e5d20122b9db1d2ec7c57417d19b3">More...</a><br/></td></tr>
<tr class="separator:ad52e5d20122b9db1d2ec7c57417d19b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc95573545bf325172b18d2ec6b4f3f4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:abc95573545bf325172b18d2ec6b4f3f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2, T3 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abc95573545bf325172b18d2ec6b4f3f4">fma</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:abc95573545bf325172b18d2ec6b4f3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="#abc95573545bf325172b18d2ec6b4f3f4">More...</a><br/></td></tr>
<tr class="separator:abc95573545bf325172b18d2ec6b4f3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb72eea615a5b2effad60c4f5c1ccbc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:aebb72eea615a5b2effad60c4f5c1ccbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2, T3 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aebb72eea615a5b2effad60c4f5c1ccbc">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:aebb72eea615a5b2effad60c4f5c1ccbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="#aebb72eea615a5b2effad60c4f5c1ccbc">More...</a><br/></td></tr>
<tr class="separator:aebb72eea615a5b2effad60c4f5c1ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e283e1daef5282717309ddb1302d5dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a1e283e1daef5282717309ddb1302d5dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2, T3 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1e283e1daef5282717309ddb1302d5dc">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:a1e283e1daef5282717309ddb1302d5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="#a1e283e1daef5282717309ddb1302d5dc">More...</a><br/></td></tr>
<tr class="separator:a1e283e1daef5282717309ddb1302d5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085357acaef6e7ac8f3e7d16e6b38aa3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a085357acaef6e7ac8f3e7d16e6b38aa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2, T3 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a085357acaef6e7ac8f3e7d16e6b38aa3">fma</a> (const T1 &amp;x1, const T2 &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:a085357acaef6e7ac8f3e7d16e6b38aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="#a085357acaef6e7ac8f3e7d16e6b38aa3">More...</a><br/></td></tr>
<tr class="separator:a085357acaef6e7ac8f3e7d16e6b38aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf7c6a98ccaf08b9964b9d9258c6d13"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:afaf7c6a98ccaf08b9964b9d9258c6d13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2, T3 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afaf7c6a98ccaf08b9964b9d9258c6d13">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:afaf7c6a98ccaf08b9964b9d9258c6d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="#afaf7c6a98ccaf08b9964b9d9258c6d13">More...</a><br/></td></tr>
<tr class="separator:afaf7c6a98ccaf08b9964b9d9258c6d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f25245e8d92c7e406808b1aad777a9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a31f25245e8d92c7e406808b1aad777a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T1, T2, T3 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a31f25245e8d92c7e406808b1aad777a9">fma</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:a31f25245e8d92c7e406808b1aad777a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="#a31f25245e8d92c7e406808b1aad777a9">More...</a><br/></td></tr>
<tr class="separator:a31f25245e8d92c7e406808b1aad777a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0dc47791c87f86c9f93d2cba273c25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f0dc47791c87f86c9f93d2cba273c25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f0dc47791c87f86c9f93d2cba273c25">fmax</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a1f0dc47791c87f86c9f93d2cba273c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8de59f858592b97409ca71d68f4442"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb8de59f858592b97409ca71d68f4442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adb8de59f858592b97409ca71d68f4442">fmax</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:adb8de59f858592b97409ca71d68f4442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0fec224f4c675618141528549640ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad0fec224f4c675618141528549640ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aad0fec224f4c675618141528549640ba">fmax</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:aad0fec224f4c675618141528549640ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae765dc2aa344a1893f66bffbdab0267c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae765dc2aa344a1893f66bffbdab0267c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae765dc2aa344a1893f66bffbdab0267c">fmin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ae765dc2aa344a1893f66bffbdab0267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade89f8b882cb15b0478176fd997cd1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ade89f8b882cb15b0478176fd997cd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6ade89f8b882cb15b0478176fd997cd1">fmin</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a6ade89f8b882cb15b0478176fd997cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cdcc6569e6ac1d6a40d2f7157566a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00cdcc6569e6ac1d6a40d2f7157566a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a00cdcc6569e6ac1d6a40d2f7157566a1">fmin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a00cdcc6569e6ac1d6a40d2f7157566a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f40b2c56584ebd33037769fddc4d3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9f40b2c56584ebd33037769fddc4d3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac9f40b2c56584ebd33037769fddc4d3f">fmod</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ac9f40b2c56584ebd33037769fddc4d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0970b532a9f823834c492e98356e730"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0970b532a9f823834c492e98356e730"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad0970b532a9f823834c492e98356e730">fmod</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:ad0970b532a9f823834c492e98356e730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdbe01b71fb403869c2fa9ebb1fb90c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fdbe01b71fb403869c2fa9ebb1fb90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5fdbe01b71fb403869c2fa9ebb1fb90c">fmod</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a5fdbe01b71fb403869c2fa9ebb1fb90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fad89bd8e78eee42230dd92bcf1b15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0fad89bd8e78eee42230dd92bcf1b15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa0fad89bd8e78eee42230dd92bcf1b15">gamma_p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aa0fad89bd8e78eee42230dd92bcf1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd446def1c6803882dfa29838addc79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdd446def1c6803882dfa29838addc79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abdd446def1c6803882dfa29838addc79">gamma_p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:abdd446def1c6803882dfa29838addc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764de29e557ee65caaff1b94388a9367"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a764de29e557ee65caaff1b94388a9367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a764de29e557ee65caaff1b94388a9367">gamma_p</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a764de29e557ee65caaff1b94388a9367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743267027c96ebef239be63589a6d594"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a743267027c96ebef239be63589a6d594"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a743267027c96ebef239be63589a6d594">gamma_q</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a743267027c96ebef239be63589a6d594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c57ec58c3534caee0c89fbdf56ed28d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c57ec58c3534caee0c89fbdf56ed28d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c57ec58c3534caee0c89fbdf56ed28d">gamma_q</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a7c57ec58c3534caee0c89fbdf56ed28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac85a7ace8ea6fdaa4fd19a40e8c87b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ac85a7ace8ea6fdaa4fd19a40e8c87b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2ac85a7ace8ea6fdaa4fd19a40e8c87b">gamma_q</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a2ac85a7ace8ea6fdaa4fd19a40e8c87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb6dcbe4585fc38ff9374aa5164582f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fb6dcbe4585fc38ff9374aa5164582f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8fb6dcbe4585fc38ff9374aa5164582f">grad_inc_beta</a> (<a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &amp;g1, <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &amp;g2, <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; a, <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; b, <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; z)</td></tr>
<tr class="separator:a8fb6dcbe4585fc38ff9374aa5164582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd88cd5e3b00b9d099acd2482ca6fbf2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd88cd5e3b00b9d099acd2482ca6fbf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acd88cd5e3b00b9d099acd2482ca6fbf2">hypot</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:acd88cd5e3b00b9d099acd2482ca6fbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490944d221f2b68baf4092667f490ae8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a490944d221f2b68baf4092667f490ae8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a490944d221f2b68baf4092667f490ae8">hypot</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a490944d221f2b68baf4092667f490ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2f4416bf256405e515c0640dec5fe2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd2f4416bf256405e515c0640dec5fe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd2f4416bf256405e515c0640dec5fe2">hypot</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:afd2f4416bf256405e515c0640dec5fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9988ca802426ba048ba5d5d9ad71e2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9988ca802426ba048ba5d5d9ad71e2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af9988ca802426ba048ba5d5d9ad71e2e">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:af9988ca802426ba048ba5d5d9ad71e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5386561ba622e05cb64345fdad6a3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a5386561ba622e05cb64345fdad6a3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2a5386561ba622e05cb64345fdad6a3b">inv</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a2a5386561ba622e05cb64345fdad6a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba00ed1e73c3a2366226aa4c83e4d8b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba00ed1e73c3a2366226aa4c83e4d8b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aba00ed1e73c3a2366226aa4c83e4d8b9">inv_cloglog</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aba00ed1e73c3a2366226aa4c83e4d8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a22ee34432be58edb4b6ed9469370a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76a22ee34432be58edb4b6ed9469370a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a76a22ee34432be58edb4b6ed9469370a">inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a76a22ee34432be58edb4b6ed9469370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2d4971bfd22beacb304bdd5b9d3395"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca2d4971bfd22beacb304bdd5b9d3395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca2d4971bfd22beacb304bdd5b9d3395">inv_sqrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aca2d4971bfd22beacb304bdd5b9d3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c1f6b0f3c9f48fa30e09f2d929336d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7c1f6b0f3c9f48fa30e09f2d929336d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa7c1f6b0f3c9f48fa30e09f2d929336d">inv_square</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa7c1f6b0f3c9f48fa30e09f2d929336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad359149ebad087910f96e62f88287c1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad359149ebad087910f96e62f88287c1f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad359149ebad087910f96e62f88287c1f">is_inf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ad359149ebad087910f96e62f88287c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is infinite and 0 otherwise.  <a href="#ad359149ebad087910f96e62f88287c1f">More...</a><br/></td></tr>
<tr class="separator:ad359149ebad087910f96e62f88287c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921dd9cd85ce1a6fca79c7b07cd80b99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921dd9cd85ce1a6fca79c7b07cd80b99"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a921dd9cd85ce1a6fca79c7b07cd80b99">is_nan</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a921dd9cd85ce1a6fca79c7b07cd80b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is NaN and 0 otherwise.  <a href="#a921dd9cd85ce1a6fca79c7b07cd80b99">More...</a><br/></td></tr>
<tr class="separator:a921dd9cd85ce1a6fca79c7b07cd80b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51be9d210e223a8aa4241e2d725e295"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac51be9d210e223a8aa4241e2d725e295"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac51be9d210e223a8aa4241e2d725e295">lbeta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ac51be9d210e223a8aa4241e2d725e295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef6e7b5ed43b5410d852961a8050647"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ef6e7b5ed43b5410d852961a8050647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2ef6e7b5ed43b5410d852961a8050647">lbeta</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a2ef6e7b5ed43b5410d852961a8050647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c0745f2a667014a98b6113cc80b2a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00c0745f2a667014a98b6113cc80b2a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a00c0745f2a667014a98b6113cc80b2a5">lbeta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a00c0745f2a667014a98b6113cc80b2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead76f03bdbc60484ad760fc31bad40f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aead76f03bdbc60484ad760fc31bad40f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aead76f03bdbc60484ad760fc31bad40f">lgamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aead76f03bdbc60484ad760fc31bad40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46d6e08f7b6e9b9e8941572d30b104e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad46d6e08f7b6e9b9e8941572d30b104e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt; T, int &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad46d6e08f7b6e9b9e8941572d30b104e">lmgamma</a> (int x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ad46d6e08f7b6e9b9e8941572d30b104e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915ada1e5971c467aa16ee926997a442"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a915ada1e5971c467aa16ee926997a442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a915ada1e5971c467aa16ee926997a442">log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a915ada1e5971c467aa16ee926997a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808cbb5ac4003f28e2538805ebe338ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a808cbb5ac4003f28e2538805ebe338ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a808cbb5ac4003f28e2538805ebe338ef">log10</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a808cbb5ac4003f28e2538805ebe338ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d92a982acd829e77b3f5b975baa6aed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d92a982acd829e77b3f5b975baa6aed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8d92a982acd829e77b3f5b975baa6aed">log1m</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a8d92a982acd829e77b3f5b975baa6aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7760d28e8fddf268113469b44463de07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7760d28e8fddf268113469b44463de07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7760d28e8fddf268113469b44463de07">log1m_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a7760d28e8fddf268113469b44463de07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f286f8a9043aee8a1a844493da0d55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79f286f8a9043aee8a1a844493da0d55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a79f286f8a9043aee8a1a844493da0d55">log1m_inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a79f286f8a9043aee8a1a844493da0d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16e57e82fb1e17f74ef43592748ff32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa16e57e82fb1e17f74ef43592748ff32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa16e57e82fb1e17f74ef43592748ff32">log1p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa16e57e82fb1e17f74ef43592748ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe928ad2b96b802f6d488ba43167489"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fe928ad2b96b802f6d488ba43167489"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0fe928ad2b96b802f6d488ba43167489">log1p_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a0fe928ad2b96b802f6d488ba43167489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eea39b4ca603cff7518068499884364"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4eea39b4ca603cff7518068499884364"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4eea39b4ca603cff7518068499884364">log2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a4eea39b4ca603cff7518068499884364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba84f8c43b399f555647a0402a710ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ba84f8c43b399f555647a0402a710ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1ba84f8c43b399f555647a0402a710ef">log_diff_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a1ba84f8c43b399f555647a0402a710ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34180da33deb01d13fcf6c5907d1309e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a34180da33deb01d13fcf6c5907d1309e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34180da33deb01d13fcf6c5907d1309e">log_diff_exp</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2)</td></tr>
<tr class="separator:a34180da33deb01d13fcf6c5907d1309e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246fe73ae519573f2232d2f44ac379be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a246fe73ae519573f2232d2f44ac379be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a246fe73ae519573f2232d2f44ac379be">log_diff_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2)</td></tr>
<tr class="separator:a246fe73ae519573f2232d2f44ac379be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e4116dfd00db87062ef7c0f76e8c27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58e4116dfd00db87062ef7c0f76e8c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a58e4116dfd00db87062ef7c0f76e8c27">log_falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a58e4116dfd00db87062ef7c0f76e8c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f457257e68af25bdccd60c4da5c1449"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f457257e68af25bdccd60c4da5c1449"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f457257e68af25bdccd60c4da5c1449">log_falling_factorial</a> (const double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a3f457257e68af25bdccd60c4da5c1449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50150f9605147c167f749bf31c9e42a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50150f9605147c167f749bf31c9e42a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a50150f9605147c167f749bf31c9e42a2">log_falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const double n)</td></tr>
<tr class="separator:a50150f9605147c167f749bf31c9e42a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2fe56bce70a04dd11e8a5a32b1b51c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd2fe56bce70a04dd11e8a5a32b1b51c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acd2fe56bce70a04dd11e8a5a32b1b51c">log_inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:acd2fe56bce70a04dd11e8a5a32b1b51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c93f2640b5f95b586b9521b09e52c31"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , int N&gt; </td></tr>
<tr class="memitem:a9c93f2640b5f95b586b9521b09e52c31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9c93f2640b5f95b586b9521b09e52c31">log_mix_partial_helper</a> (const T_theta &amp;theta, const T_lambda1 &amp;lambda1, const T_lambda2 &amp;lambda2, typename promote_args&lt; T_theta, T_lambda1, T_lambda2 &gt;::type(&amp;partials_array)[N])</td></tr>
<tr class="separator:a9c93f2640b5f95b586b9521b09e52c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014f4431773309ae7fd1420b0f6aa99f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a014f4431773309ae7fd1420b0f6aa99f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a014f4431773309ae7fd1420b0f6aa99f">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="memdesc:a014f4431773309ae7fd1420b0f6aa99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities and its derivative at each.  <a href="#a014f4431773309ae7fd1420b0f6aa99f">More...</a><br/></td></tr>
<tr class="separator:a014f4431773309ae7fd1420b0f6aa99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed956136160f52953529970a3ae4ef40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed956136160f52953529970a3ae4ef40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aed956136160f52953529970a3ae4ef40">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const double lambda2)</td></tr>
<tr class="separator:aed956136160f52953529970a3ae4ef40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f58fdf08759c58af217840a92ed4e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53f58fdf08759c58af217840a92ed4e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53f58fdf08759c58af217840a92ed4e8">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const double lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:a53f58fdf08759c58af217840a92ed4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1210cb19932c4552f899d1582929e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd1210cb19932c4552f899d1582929e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd1210cb19932c4552f899d1582929e9">log_mix</a> (const double theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:afd1210cb19932c4552f899d1582929e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780462344be6c31a646da6cfbeb6c421"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a780462344be6c31a646da6cfbeb6c421"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a780462344be6c31a646da6cfbeb6c421">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const double lambda1, const double lambda2)</td></tr>
<tr class="separator:a780462344be6c31a646da6cfbeb6c421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd9e68e3b8dc002039c1afda1dce392"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebd9e68e3b8dc002039c1afda1dce392"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aebd9e68e3b8dc002039c1afda1dce392">log_mix</a> (const double theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const double lambda2)</td></tr>
<tr class="separator:aebd9e68e3b8dc002039c1afda1dce392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eaca2241efa84971cb2aaa4efacbb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35eaca2241efa84971cb2aaa4efacbb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a35eaca2241efa84971cb2aaa4efacbb0">log_mix</a> (const double theta, const double lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:a35eaca2241efa84971cb2aaa4efacbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aff0dd42a2b0b33ac55e9a45f35b1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4aff0dd42a2b0b33ac55e9a45f35b1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa4aff0dd42a2b0b33ac55e9a45f35b1e">log_rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:aa4aff0dd42a2b0b33ac55e9a45f35b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d954744a945ff1f82a27d2eedb887f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08d954744a945ff1f82a27d2eedb887f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a08d954744a945ff1f82a27d2eedb887f">log_rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const double n)</td></tr>
<tr class="separator:a08d954744a945ff1f82a27d2eedb887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab4f0019045b98139b0626204e8f2a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ab4f0019045b98139b0626204e8f2a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5ab4f0019045b98139b0626204e8f2a2">log_rising_factorial</a> (const double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a5ab4f0019045b98139b0626204e8f2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177e64b45d304afc52540d776de8dbe1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a177e64b45d304afc52540d776de8dbe1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a177e64b45d304afc52540d776de8dbe1">log_sum_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a177e64b45d304afc52540d776de8dbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0497ca733bb52ba08323b12ed654bc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0497ca733bb52ba08323b12ed654bc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa0497ca733bb52ba08323b12ed654bc8">log_sum_exp</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aa0497ca733bb52ba08323b12ed654bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43880eef5d3a9017c9ab46fa2d1ef65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab43880eef5d3a9017c9ab46fa2d1ef65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab43880eef5d3a9017c9ab46fa2d1ef65">log_sum_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:ab43880eef5d3a9017c9ab46fa2d1ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab025eaf1e6f5c920f69c37e7a7f8b319"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab025eaf1e6f5c920f69c37e7a7f8b319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab025eaf1e6f5c920f69c37e7a7f8b319">logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab025eaf1e6f5c920f69c37e7a7f8b319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb3160540f6fe745abb846df2174742"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcb3160540f6fe745abb846df2174742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adcb3160540f6fe745abb846df2174742">modified_bessel_first_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:adcb3160540f6fe745abb846df2174742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3277f8bf3ed3b3e36a61dedd4ed0449b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3277f8bf3ed3b3e36a61dedd4ed0449b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3277f8bf3ed3b3e36a61dedd4ed0449b">modified_bessel_second_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a3277f8bf3ed3b3e36a61dedd4ed0449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055efd6bb49a1df5ea4da98d1078d0e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a055efd6bb49a1df5ea4da98d1078d0e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a055efd6bb49a1df5ea4da98d1078d0e6">multiply_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a055efd6bb49a1df5ea4da98d1078d0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafa25b9871a31fc9bad3b23e43f24e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abafa25b9871a31fc9bad3b23e43f24e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abafa25b9871a31fc9bad3b23e43f24e4">multiply_log</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:abafa25b9871a31fc9bad3b23e43f24e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0df8fa73f8f9435f44780baa1379dc6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0df8fa73f8f9435f44780baa1379dc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0df8fa73f8f9435f44780baa1379dc6">multiply_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:ac0df8fa73f8f9435f44780baa1379dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b09a69d6aeee461a009b6355889e9e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b09a69d6aeee461a009b6355889e9e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9b09a69d6aeee461a009b6355889e9e4">owens_t</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a9b09a69d6aeee461a009b6355889e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69de529b5013ba833af1ea6eff199194"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69de529b5013ba833af1ea6eff199194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69de529b5013ba833af1ea6eff199194">owens_t</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a69de529b5013ba833af1ea6eff199194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316ab3b95493d045d77de4f8b96ed56a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a316ab3b95493d045d77de4f8b96ed56a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a316ab3b95493d045d77de4f8b96ed56a">owens_t</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a316ab3b95493d045d77de4f8b96ed56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73a2c7f20161172ffee17c7c880019f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac73a2c7f20161172ffee17c7c880019f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac73a2c7f20161172ffee17c7c880019f">Phi</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ac73a2c7f20161172ffee17c7c880019f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27caea996a79cd150f26db44fd635684"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27caea996a79cd150f26db44fd635684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a27caea996a79cd150f26db44fd635684">pow</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a27caea996a79cd150f26db44fd635684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab594b61f84170ba4b4b887f6a911a0d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab594b61f84170ba4b4b887f6a911a0d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab594b61f84170ba4b4b887f6a911a0d6">pow</a> (const double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ab594b61f84170ba4b4b887f6a911a0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8ae604ced89240175e69281577be04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b8ae604ced89240175e69281577be04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7b8ae604ced89240175e69281577be04">pow</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const double x2)</td></tr>
<tr class="separator:a7b8ae604ced89240175e69281577be04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24337e3af682981f05d1cc022e675891"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24337e3af682981f05d1cc022e675891"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a24337e3af682981f05d1cc022e675891">primitive_value</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a24337e3af682981f05d1cc022e675891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive value of the specified forward-mode autodiff variable.  <a href="#a24337e3af682981f05d1cc022e675891">More...</a><br/></td></tr>
<tr class="separator:a24337e3af682981f05d1cc022e675891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5aa264060b3c4ed7954f07dc0fcf138"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5aa264060b3c4ed7954f07dc0fcf138"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac5aa264060b3c4ed7954f07dc0fcf138">rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:ac5aa264060b3c4ed7954f07dc0fcf138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a96a3d8a0a67f4ab99175db6b4e859"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60a96a3d8a0a67f4ab99175db6b4e859"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a60a96a3d8a0a67f4ab99175db6b4e859">rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const double n)</td></tr>
<tr class="separator:a60a96a3d8a0a67f4ab99175db6b4e859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1964156202b850138f2accd71ff18724"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1964156202b850138f2accd71ff18724"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1964156202b850138f2accd71ff18724">rising_factorial</a> (const double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a1964156202b850138f2accd71ff18724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb73c37a4cec41a69516391a2336fb11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb73c37a4cec41a69516391a2336fb11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adb73c37a4cec41a69516391a2336fb11">round</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:adb73c37a4cec41a69516391a2336fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3f2dd84567a0566cfdd7eb10e13607"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff3f2dd84567a0566cfdd7eb10e13607"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aff3f2dd84567a0566cfdd7eb10e13607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646a34790ca2b692b2a8c74c4e4fb726"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a646a34790ca2b692b2a8c74c4e4fb726"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a646a34790ca2b692b2a8c74c4e4fb726">sinh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a646a34790ca2b692b2a8c74c4e4fb726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5231d132852d58cd3fe610221c9766f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5231d132852d58cd3fe610221c9766f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa5231d132852d58cd3fe610221c9766f">sqrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa5231d132852d58cd3fe610221c9766f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ed68bdfff9b340a187964ef7684091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1ed68bdfff9b340a187964ef7684091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab1ed68bdfff9b340a187964ef7684091">square</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab1ed68bdfff9b340a187964ef7684091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09b685b660830075f80caaf8a350676"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae09b685b660830075f80caaf8a350676"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae09b685b660830075f80caaf8a350676">tan</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae09b685b660830075f80caaf8a350676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11dc45fd471bec1a19462ce58f434b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae11dc45fd471bec1a19462ce58f434b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae11dc45fd471bec1a19462ce58f434b8">tanh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae11dc45fd471bec1a19462ce58f434b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73eaf0a5d0593bb8610234e0d69e7cec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73eaf0a5d0593bb8610234e0d69e7cec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73eaf0a5d0593bb8610234e0d69e7cec">tgamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a73eaf0a5d0593bb8610234e0d69e7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79abc1d4f747b3c26c07b2b1e4871603"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79abc1d4f747b3c26c07b2b1e4871603"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a79abc1d4f747b3c26c07b2b1e4871603">trunc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a79abc1d4f747b3c26c07b2b1e4871603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f8f9d951f4d48c457dcecad5e326b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a541f8f9d951f4d48c457dcecad5e326b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a541f8f9d951f4d48c457dcecad5e326b">value_of</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a541f8f9d951f4d48c457dcecad5e326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="#a541f8f9d951f4d48c457dcecad5e326b">More...</a><br/></td></tr>
<tr class="separator:a541f8f9d951f4d48c457dcecad5e326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a00b8cbdec7c35e7c93b0f47dae3c5498">value_of_rec</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="#a00b8cbdec7c35e7c93b0f47dae3c5498">More...</a><br/></td></tr>
<tr class="separator:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7add35b0758b1d0541f7e919c36412f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7add35b0758b1d0541f7e919c36412f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7add35b0758b1d0541f7e919c36412f9">is_aligned</a> (T *ptr, unsigned int bytes_aligned)</td></tr>
<tr class="memdesc:a7add35b0758b1d0541f7e919c36412f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified pointer is aligned on the number of bytes.  <a href="#a7add35b0758b1d0541f7e919c36412f9">More...</a><br/></td></tr>
<tr class="separator:a7add35b0758b1d0541f7e919c36412f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597dca74b96a4287c6f848489288d44"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0597dca74b96a4287c6f848489288d44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0597dca74b96a4287c6f848489288d44">derivative</a> (const F &amp;f, const T &amp;x, T &amp;fx, T &amp;dfx_dx)</td></tr>
<tr class="memdesc:a0597dca74b96a4287c6f848489288d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the specified univariate function at the specified argument.  <a href="#a0597dca74b96a4287c6f848489288d44">More...</a><br/></td></tr>
<tr class="separator:a0597dca74b96a4287c6f848489288d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138f3242eba971c17756586ace2c15d3"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a138f3242eba971c17756586ace2c15d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a138f3242eba971c17756586ace2c15d3">finite_diff_grad_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double,-1, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double,-1,-1 &gt; &amp;hess, std::vector&lt; Eigen::Matrix&lt; double,-1,-1 &gt; &gt; &amp;grad_hess_fx, const double epsilon=1e-04)</td></tr>
<tr class="memdesc:a138f3242eba971c17756586ace2c15d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the hessian of the specified function at the specified argument using second-order autodiff and first-order finite difference.  <a href="#a138f3242eba971c17756586ace2c15d3">More...</a><br/></td></tr>
<tr class="separator:a138f3242eba971c17756586ace2c15d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e0d2efc95d0241c473938c5850a0a6"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a66e0d2efc95d0241c473938c5850a0a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66e0d2efc95d0241c473938c5850a0a6">grad_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;H, std::vector&lt; Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &gt; &amp;grad_H)</td></tr>
<tr class="memdesc:a66e0d2efc95d0241c473938c5850a0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the Hessian, and the gradient of the Hessian of the specified function at the specified argument.  <a href="#a66e0d2efc95d0241c473938c5850a0a6">More...</a><br/></td></tr>
<tr class="separator:a66e0d2efc95d0241c473938c5850a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f2f8fea732e1e05f78ed0dd394b33f"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a53f2f8fea732e1e05f78ed0dd394b33f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53f2f8fea732e1e05f78ed0dd394b33f">grad_tr_mat_times_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;M, Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;grad_tr_MH)</td></tr>
<tr class="separator:a53f2f8fea732e1e05f78ed0dd394b33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf96fceee3cea400cdf078180c61c04"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F &gt; </td></tr>
<tr class="memitem:a7cf96fceee3cea400cdf078180c61c04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7cf96fceee3cea400cdf078180c61c04">gradient_dot_vector</a> (const F &amp;f, const Eigen::Matrix&lt; T1, Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T2, Dynamic, 1 &gt; &amp;v, T1 &amp;fx, T1 &amp;grad_fx_dot_v)</td></tr>
<tr class="separator:a7cf96fceee3cea400cdf078180c61c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c5d2b24b7de8a268a02b1f0705b42"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a096c5d2b24b7de8a268a02b1f0705b42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a096c5d2b24b7de8a268a02b1f0705b42">hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;<a class="el" href="namespacestan_1_1math.html#ae6c32f9b52bef3a296432df037f96af3">grad</a>, Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;H)</td></tr>
<tr class="memdesc:a096c5d2b24b7de8a268a02b1f0705b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the gradient, and the Hessian, of the specified function at the specified argument in O(N^2) time and O(N^2) space.  <a href="#a096c5d2b24b7de8a268a02b1f0705b42">More...</a><br/></td></tr>
<tr class="separator:a096c5d2b24b7de8a268a02b1f0705b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8989a5749e54167301ac0720992d08"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:acb8989a5749e54167301ac0720992d08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acb8989a5749e54167301ac0720992d08">hessian</a> (const F &amp;f, const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;x, T &amp;fx, Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;<a class="el" href="namespacestan_1_1math.html#ae6c32f9b52bef3a296432df037f96af3">grad</a>, Eigen::Matrix&lt; T, Dynamic, Dynamic &gt; &amp;H)</td></tr>
<tr class="separator:acb8989a5749e54167301ac0720992d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399d8cf66bb4db2d5139566b9da2c5f3"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a399d8cf66bb4db2d5139566b9da2c5f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a399d8cf66bb4db2d5139566b9da2c5f3">hessian_times_vector</a> (const F &amp;f, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;v, double &amp;fx, Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;Hv)</td></tr>
<tr class="separator:a399d8cf66bb4db2d5139566b9da2c5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1021570cd0ba1864f2f346cf2d78f13e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a1021570cd0ba1864f2f346cf2d78f13e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1021570cd0ba1864f2f346cf2d78f13e">hessian_times_vector</a> (const F &amp;f, const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;v, T &amp;fx, Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;Hv)</td></tr>
<tr class="separator:a1021570cd0ba1864f2f346cf2d78f13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb5b4072a22debb013dab8742e321df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:adbb5b4072a22debb013dab8742e321df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adbb5b4072a22debb013dab8742e321df">partial_derivative</a> (const F &amp;f, const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;x, int n, T &amp;fx, T &amp;dfx_dxn)</td></tr>
<tr class="memdesc:adbb5b4072a22debb013dab8742e321df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the partial derivative of the specified multiivariate function at the specified argument.  <a href="#adbb5b4072a22debb013dab8742e321df">More...</a><br/></td></tr>
<tr class="separator:adbb5b4072a22debb013dab8742e321df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86020a972c6efc6b3407c3cfc30f4a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae86020a972c6efc6b3407c3cfc30f4a6">dist</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:ae86020a972c6efc6b3407c3cfc30f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b73319bd8df9dad1d3902997d8e89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd3b73319bd8df9dad1d3902997d8e89">dot</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:afd3b73319bd8df9dad1d3902997d8e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a4ef7c701db7984297d153580c8d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a6a4ef7c701db7984297d153580c8d4">dot_self</a> (const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:a8a6a4ef7c701db7984297d153580c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e67f9b1692743a9db4462e98bb49ef5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e67f9b1692743a9db4462e98bb49ef5">log_sum_exp</a> (const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="memdesc:a9e67f9b1692743a9db4462e98bb49ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified sequence of values.  <a href="#a9e67f9b1692743a9db4462e98bb49ef5">More...</a><br/></td></tr>
<tr class="separator:a9e67f9b1692743a9db4462e98bb49ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d78d2735a35451f02bcd2f4da24886"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3d78d2735a35451f02bcd2f4da24886"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad3d78d2735a35451f02bcd2f4da24886">rep_array</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:ad3d78d2735a35451f02bcd2f4da24886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8edf0b7ec2ad24b1fda26a8d58513106">rep_array</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="separator:a8edf0b7ec2ad24b1fda26a8d58513106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53054db4cfa6672654fbaedafbdae242"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53054db4cfa6672654fbaedafbdae242"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; std::vector&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53054db4cfa6672654fbaedafbdae242">rep_array</a> (const T &amp;x, int k, int m, int n)</td></tr>
<tr class="separator:a53054db4cfa6672654fbaedafbdae242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb786f14699d69c39cfdd49893a8006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2eb786f14699d69c39cfdd49893a8006">scaled_add</a> (std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y, const double lambda)</td></tr>
<tr class="separator:a2eb786f14699d69c39cfdd49893a8006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4c5e5b76b18a41b28f646104b3cd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e4c5e5b76b18a41b28f646104b3cd46">sub</a> (std::vector&lt; double &gt; &amp;x, std::vector&lt; double &gt; &amp;y, std::vector&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:a9e4c5e5b76b18a41b28f646104b3cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efee0b4f8879a114af50b7e9802745c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1efee0b4f8879a114af50b7e9802745c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1efee0b4f8879a114af50b7e9802745c">sum</a> (const std::vector&lt; T &gt; &amp;xs)</td></tr>
<tr class="memdesc:a1efee0b4f8879a114af50b7e9802745c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the values in the specified standard vector.  <a href="#a1efee0b4f8879a114af50b7e9802745c">More...</a><br/></td></tr>
<tr class="separator:a1efee0b4f8879a114af50b7e9802745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c148a430fffb6b4a865d25742b3412"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a57c148a430fffb6b4a865d25742b3412"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a><br class="typebreak"/>
&lt; T1, T2 &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a57c148a430fffb6b4a865d25742b3412">integrate_ode</a> (const F &amp;f, const std::vector&lt; T1 &gt; y0, const double t0, const std::vector&lt; double &gt; &amp;ts, const std::vector&lt; T2 &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs)</td></tr>
<tr class="memdesc:a57c148a430fffb6b4a865d25742b3412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solutions for the specified system of ordinary differential equations given the specified initial state, initial times, times of desired solution, and parameters and data, writing error and warning messages to the specified stream.  <a href="#a57c148a430fffb6b4a865d25742b3412">More...</a><br/></td></tr>
<tr class="separator:a57c148a430fffb6b4a865d25742b3412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b3c1ad17fc5567f1599fa9d0a218620">check_cholesky_factor</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid Cholesky factor.  <a href="#a2b3c1ad17fc5567f1599fa9d0a218620">More...</a><br/></td></tr>
<tr class="separator:a2b3c1ad17fc5567f1599fa9d0a218620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f24b6f8e2a52523ae37a7ff2664e9b5">check_cholesky_factor_corr</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid Cholesky factor of a correlation matrix.  <a href="#a3f24b6f8e2a52523ae37a7ff2664e9b5">More...</a><br/></td></tr>
<tr class="separator:a3f24b6f8e2a52523ae37a7ff2664e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0a60f741f97efac53254839f24ff8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , int R, int C&gt; </td></tr>
<tr class="memitem:a16b0a60f741f97efac53254839f24ff8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16b0a60f741f97efac53254839f24ff8">check_column_index</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, R, C &gt; &amp;y, const size_t i)</td></tr>
<tr class="memdesc:a16b0a60f741f97efac53254839f24ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified index is a valid column of the matrix.  <a href="#a16b0a60f741f97efac53254839f24ff8">More...</a><br/></td></tr>
<tr class="separator:a16b0a60f741f97efac53254839f24ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41204c48d930b46e81329d8b00a0793e"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a41204c48d930b46e81329d8b00a0793e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a41204c48d930b46e81329d8b00a0793e">check_corr_matrix</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a41204c48d930b46e81329d8b00a0793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid correlation matrix.  <a href="#a41204c48d930b46e81329d8b00a0793e">More...</a><br/></td></tr>
<tr class="separator:a41204c48d930b46e81329d8b00a0793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb915b09e2e60dd76885b6d68655790c"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aeb915b09e2e60dd76885b6d68655790c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeb915b09e2e60dd76885b6d68655790c">check_cov_matrix</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:aeb915b09e2e60dd76885b6d68655790c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a valid covariance matrix.  <a href="#aeb915b09e2e60dd76885b6d68655790c">More...</a><br/></td></tr>
<tr class="separator:aeb915b09e2e60dd76885b6d68655790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7547b05717280b1cc041309803ec797d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a7547b05717280b1cc041309803ec797d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7547b05717280b1cc041309803ec797d">check_ldlt_factor</a> (const char *function, const char *name, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;A)</td></tr>
<tr class="memdesc:a7547b05717280b1cc041309803ec797d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the argument is a valid <code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a></code>.  <a href="#a7547b05717280b1cc041309803ec797d">More...</a><br/></td></tr>
<tr class="separator:a7547b05717280b1cc041309803ec797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe34ba3113cc8f10f179873edb9b60ed"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:afe34ba3113cc8f10f179873edb9b60ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afe34ba3113cc8f10f179873edb9b60ed">check_lower_triangular</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:afe34ba3113cc8f10f179873edb9b60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is lower triangular.  <a href="#afe34ba3113cc8f10f179873edb9b60ed">More...</a><br/></td></tr>
<tr class="separator:afe34ba3113cc8f10f179873edb9b60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1149504bbf29d464f23508ca5eccc0a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aa1149504bbf29d464f23508ca5eccc0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1149504bbf29d464f23508ca5eccc0a">check_matching_dims</a> (const char *function, const char *name1, const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;y1, const char *name2, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;y2)</td></tr>
<tr class="memdesc:aa1149504bbf29d464f23508ca5eccc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the two matrices are of the same size.  <a href="#aa1149504bbf29d464f23508ca5eccc0a">More...</a><br/></td></tr>
<tr class="separator:aa1149504bbf29d464f23508ca5eccc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="memTemplParams" colspan="2">template&lt;typename T_y1 , typename T_y2 &gt; </td></tr>
<tr class="memitem:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a52ba893fcf6fc650e992c13d41fbc3ae">check_matching_sizes</a> (const char *function, const char *name1, const T_y1 &amp;y1, const char *name2, const T_y2 &amp;y2)</td></tr>
<tr class="memdesc:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if two structures at the same size.  <a href="#a52ba893fcf6fc650e992c13d41fbc3ae">More...</a><br/></td></tr>
<tr class="separator:a52ba893fcf6fc650e992c13d41fbc3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3cfbb4f09fe34b9ece32be051f16ce66">check_multiplicable</a> (const char *function, const char *name1, const T1 &amp;y1, const char *name2, const T2 &amp;y2)</td></tr>
<tr class="memdesc:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrices can be multiplied.  <a href="#a3cfbb4f09fe34b9ece32be051f16ce66">More...</a><br/></td></tr>
<tr class="separator:a3cfbb4f09fe34b9ece32be051f16ce66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7b212a4431aeedca59b2e94c84f788"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a2a7b212a4431aeedca59b2e94c84f788"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2a7b212a4431aeedca59b2e94c84f788">check_ordered</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a2a7b212a4431aeedca59b2e94c84f788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is sorted into strictly increasing order.  <a href="#a2a7b212a4431aeedca59b2e94c84f788">More...</a><br/></td></tr>
<tr class="separator:a2a7b212a4431aeedca59b2e94c84f788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55e7669a804e68bc9d39ecd06318b23"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:af55e7669a804e68bc9d39ecd06318b23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af55e7669a804e68bc9d39ecd06318b23">check_ordered</a> (const char *function, const char *name, const std::vector&lt; T_y &gt; &amp;y)</td></tr>
<tr class="memdesc:af55e7669a804e68bc9d39ecd06318b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is sorted into strictly increasing order.  <a href="#af55e7669a804e68bc9d39ecd06318b23">More...</a><br/></td></tr>
<tr class="separator:af55e7669a804e68bc9d39ecd06318b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0133fd07702f5253126a385703b7d73"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ac0133fd07702f5253126a385703b7d73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0133fd07702f5253126a385703b7d73">check_pos_definite</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:ac0133fd07702f5253126a385703b7d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified square, symmetric matrix is positive definite.  <a href="#ac0133fd07702f5253126a385703b7d73">More...</a><br/></td></tr>
<tr class="separator:ac0133fd07702f5253126a385703b7d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26244f58d5a4dfd49181b39d9b4569b"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aa26244f58d5a4dfd49181b39d9b4569b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa26244f58d5a4dfd49181b39d9b4569b">check_pos_semidefinite</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:aa26244f58d5a4dfd49181b39d9b4569b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is positive definite.  <a href="#aa26244f58d5a4dfd49181b39d9b4569b">More...</a><br/></td></tr>
<tr class="separator:aa26244f58d5a4dfd49181b39d9b4569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f00a8c0f07c5a82145a14712437673"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a87f00a8c0f07c5a82145a14712437673"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87f00a8c0f07c5a82145a14712437673">check_positive_ordered</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a87f00a8c0f07c5a82145a14712437673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector contains non-negative values and is sorted into strictly increasing order.  <a href="#a87f00a8c0f07c5a82145a14712437673">More...</a><br/></td></tr>
<tr class="separator:a87f00a8c0f07c5a82145a14712437673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd4dcac328824f71f31d6861b8610ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adcd4dcac328824f71f31d6861b8610ee">check_range</a> (const char *function, const char *name, const int <a class="el" href="namespacestan_1_1math.html#a5da0ef87756d3dbd20ca4ff5a3efa10d">max</a>, const int index, const int nested_level, const char *error_msg)</td></tr>
<tr class="memdesc:adcd4dcac328824f71f31d6861b8610ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if specified index is within range.  <a href="#adcd4dcac328824f71f31d6861b8610ee">More...</a><br/></td></tr>
<tr class="separator:adcd4dcac328824f71f31d6861b8610ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8822ad6a9b8706465e8e1f90c336e3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8822ad6a9b8706465e8e1f90c336e3c2">check_range</a> (const char *function, const char *name, const int <a class="el" href="namespacestan_1_1math.html#a5da0ef87756d3dbd20ca4ff5a3efa10d">max</a>, const int index, const char *error_msg)</td></tr>
<tr class="memdesc:a8822ad6a9b8706465e8e1f90c336e3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if specified index is within range.  <a href="#a8822ad6a9b8706465e8e1f90c336e3c2">More...</a><br/></td></tr>
<tr class="separator:a8822ad6a9b8706465e8e1f90c336e3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e76ffb67d3c6c6c225b0ba7b991f449"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7e76ffb67d3c6c6c225b0ba7b991f449">check_range</a> (const char *function, const char *name, const int <a class="el" href="namespacestan_1_1math.html#a5da0ef87756d3dbd20ca4ff5a3efa10d">max</a>, const int index)</td></tr>
<tr class="memdesc:a7e76ffb67d3c6c6c225b0ba7b991f449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if specified index is within range.  <a href="#a7e76ffb67d3c6c6c225b0ba7b991f449">More...</a><br/></td></tr>
<tr class="separator:a7e76ffb67d3c6c6c225b0ba7b991f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb080867499e68f688b0dcb5c8f4e061"><td class="memTemplParams" colspan="2">template&lt;typename T_y , int R, int C&gt; </td></tr>
<tr class="memitem:acb080867499e68f688b0dcb5c8f4e061"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acb080867499e68f688b0dcb5c8f4e061">check_row_index</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, R, C &gt; &amp;y, size_t i)</td></tr>
<tr class="memdesc:acb080867499e68f688b0dcb5c8f4e061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified index is a valid row of the matrix.  <a href="#acb080867499e68f688b0dcb5c8f4e061">More...</a><br/></td></tr>
<tr class="separator:acb080867499e68f688b0dcb5c8f4e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6affd19d4999c427291a2bbb07bce304"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:a6affd19d4999c427291a2bbb07bce304"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6affd19d4999c427291a2bbb07bce304">check_simplex</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="memdesc:a6affd19d4999c427291a2bbb07bce304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is simplex.  <a href="#a6affd19d4999c427291a2bbb07bce304">More...</a><br/></td></tr>
<tr class="separator:a6affd19d4999c427291a2bbb07bce304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d5ef4f11dbce1a670766034b416339"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a30d5ef4f11dbce1a670766034b416339"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a30d5ef4f11dbce1a670766034b416339">check_spsd_matrix</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a30d5ef4f11dbce1a670766034b416339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is a square, symmetric, and positive semi-definite.  <a href="#a30d5ef4f11dbce1a670766034b416339">More...</a><br/></td></tr>
<tr class="separator:a30d5ef4f11dbce1a670766034b416339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a94cfaa76ca5bc3f0ea5ad1d5b9f80727">check_square</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is square.  <a href="#a94cfaa76ca5bc3f0ea5ad1d5b9f80727">More...</a><br/></td></tr>
<tr class="separator:a94cfaa76ca5bc3f0ea5ad1d5b9f80727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed873db07e833c14413c319a5bb9837"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ed873db07e833c14413c319a5bb9837"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7ed873db07e833c14413c319a5bb9837">check_std_vector_index</a> (const char *function, const char *name, const std::vector&lt; T &gt; &amp;y, int i)</td></tr>
<tr class="memdesc:a7ed873db07e833c14413c319a5bb9837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified index is valid in std vector.  <a href="#a7ed873db07e833c14413c319a5bb9837">More...</a><br/></td></tr>
<tr class="separator:a7ed873db07e833c14413c319a5bb9837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57384e961806a959d95a5444fd8d7190"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a57384e961806a959d95a5444fd8d7190"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a57384e961806a959d95a5444fd8d7190">check_symmetric</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a57384e961806a959d95a5444fd8d7190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix is symmetric.  <a href="#a57384e961806a959d95a5444fd8d7190">More...</a><br/></td></tr>
<tr class="separator:a57384e961806a959d95a5444fd8d7190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e15ece9efbe2751549da6a598964c9"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:a14e15ece9efbe2751549da6a598964c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a14e15ece9efbe2751549da6a598964c9">check_unit_vector</a> (const char *function, const char *name, const Eigen::Matrix&lt; T_prob, Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="memdesc:a14e15ece9efbe2751549da6a598964c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified vector is unit vector.  <a href="#a14e15ece9efbe2751549da6a598964c9">More...</a><br/></td></tr>
<tr class="separator:a14e15ece9efbe2751549da6a598964c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5b78e5ddf65db13aaa65a6c58205fbf2">check_vector</a> (const char *function, const char *name, const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is either a row vector or column vector.  <a href="#a5b78e5ddf65db13aaa65a6c58205fbf2">More...</a><br/></td></tr>
<tr class="separator:a5b78e5ddf65db13aaa65a6c58205fbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abb591fca3d88d2a5d587ce6172b62bf4">validate_non_negative_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="separator:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7092cc09ee412719d685be41a04982a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:ab7092cc09ee412719d685be41a04982a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab7092cc09ee412719d685be41a04982a">add</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:ab7092cc09ee412719d685be41a04982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrices.  <a href="#ab7092cc09ee412719d685be41a04982a">More...</a><br/></td></tr>
<tr class="separator:ab7092cc09ee412719d685be41a04982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c2f0966abaf6f80131423add52053d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a60c2f0966abaf6f80131423add52053d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a60c2f0966abaf6f80131423add52053d">add</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, const T2 &amp;c)</td></tr>
<tr class="memdesc:a60c2f0966abaf6f80131423add52053d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrix and specified scalar.  <a href="#a60c2f0966abaf6f80131423add52053d">More...</a><br/></td></tr>
<tr class="separator:a60c2f0966abaf6f80131423add52053d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8d8a7b33160a0c7304efc26fb46db"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:ac7b8d8a7b33160a0c7304efc26fb46db"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac7b8d8a7b33160a0c7304efc26fb46db">add</a> (const T1 &amp;c, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ac7b8d8a7b33160a0c7304efc26fb46db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified scalar and specified matrix.  <a href="#ac7b8d8a7b33160a0c7304efc26fb46db">More...</a><br/></td></tr>
<tr class="separator:ac7b8d8a7b33160a0c7304efc26fb46db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2aa85e5119417b44958458dd714cff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a9f2aa85e5119417b44958458dd714cff"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T1, T2 &gt;::type, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9f2aa85e5119417b44958458dd714cff">append_col</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a9f2aa85e5119417b44958458dd714cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix.  <a href="#a9f2aa85e5119417b44958458dd714cff">More...</a><br/></td></tr>
<tr class="separator:a9f2aa85e5119417b44958458dd714cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10572fe52ef6b2ddbe94aa1549310289"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int C1, int C2&gt; </td></tr>
<tr class="memitem:a10572fe52ef6b2ddbe94aa1549310289"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T1, T2 &gt;::type, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a10572fe52ef6b2ddbe94aa1549310289">append_col</a> (const Eigen::Matrix&lt; T1, 1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, 1, C2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a10572fe52ef6b2ddbe94aa1549310289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of concatenaing the first row vector followed by the second row vector side by side, with the result being a row vector.  <a href="#a10572fe52ef6b2ddbe94aa1549310289">More...</a><br/></td></tr>
<tr class="separator:a10572fe52ef6b2ddbe94aa1549310289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1462dc3a656316092e0557cdc276f377"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a1462dc3a656316092e0557cdc276f377"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1462dc3a656316092e0557cdc276f377">append_col</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T, R2, C2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a1462dc3a656316092e0557cdc276f377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix.  <a href="#a1462dc3a656316092e0557cdc276f377">More...</a><br/></td></tr>
<tr class="separator:a1462dc3a656316092e0557cdc276f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba839958285c999e1f3bb5706bb9b6"><td class="memTemplParams" colspan="2">template&lt;typename T , int C1, int C2&gt; </td></tr>
<tr class="memitem:ac5ba839958285c999e1f3bb5706bb9b6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac5ba839958285c999e1f3bb5706bb9b6">append_col</a> (const Eigen::Matrix&lt; T, 1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T, 1, C2 &gt; &amp;B)</td></tr>
<tr class="memdesc:ac5ba839958285c999e1f3bb5706bb9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of concatenaing the first row vector followed by the second row vector side by side, with the result being a row vector.  <a href="#ac5ba839958285c999e1f3bb5706bb9b6">More...</a><br/></td></tr>
<tr class="separator:ac5ba839958285c999e1f3bb5706bb9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed867c5cdbb34fe1c10ad212665c8611"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aed867c5cdbb34fe1c10ad212665c8611"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T1, T2 &gt;::type, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aed867c5cdbb34fe1c10ad212665c8611">append_row</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;B)</td></tr>
<tr class="memdesc:aed867c5cdbb34fe1c10ad212665c8611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the rows of the first argument matrix on top of the second argument matrix.  <a href="#aed867c5cdbb34fe1c10ad212665c8611">More...</a><br/></td></tr>
<tr class="separator:aed867c5cdbb34fe1c10ad212665c8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ac4765524854d6b14af8def58431dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int R2&gt; </td></tr>
<tr class="memitem:ad3ac4765524854d6b14af8def58431dc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T1, T2 &gt;::type, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad3ac4765524854d6b14af8def58431dc">append_row</a> (const Eigen::Matrix&lt; T1, R1, 1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, 1 &gt; &amp;B)</td></tr>
<tr class="memdesc:ad3ac4765524854d6b14af8def58431dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the first vector on top of the second vector, with the result being a vector.  <a href="#ad3ac4765524854d6b14af8def58431dc">More...</a><br/></td></tr>
<tr class="separator:ad3ac4765524854d6b14af8def58431dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8edbdc61c53db90c4dd6039221f5a71"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ae8edbdc61c53db90c4dd6039221f5a71"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae8edbdc61c53db90c4dd6039221f5a71">append_row</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T, R2, C2 &gt; &amp;B)</td></tr>
<tr class="memdesc:ae8edbdc61c53db90c4dd6039221f5a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the rows of the first argument matrix on top of the second argument matrix.  <a href="#ae8edbdc61c53db90c4dd6039221f5a71">More...</a><br/></td></tr>
<tr class="separator:ae8edbdc61c53db90c4dd6039221f5a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66107dc00c528f6d692bbde30d6af90c"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int R2&gt; </td></tr>
<tr class="memitem:a66107dc00c528f6d692bbde30d6af90c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66107dc00c528f6d692bbde30d6af90c">append_row</a> (const Eigen::Matrix&lt; T, R1, 1 &gt; &amp;A, const Eigen::Matrix&lt; T, R2, 1 &gt; &amp;B)</td></tr>
<tr class="memdesc:a66107dc00c528f6d692bbde30d6af90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the first vector on top of the second vector, with the result being a vector.  <a href="#a66107dc00c528f6d692bbde30d6af90c">More...</a><br/></td></tr>
<tr class="separator:a66107dc00c528f6d692bbde30d6af90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f394c15ea3eb97743382631f91801cf"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a5f394c15ea3eb97743382631f91801cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf">assign</a> (LHS &amp;lhs, const RHS &amp;rhs)</td></tr>
<tr class="memdesc:a5f394c15ea3eb97743382631f91801cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a5f394c15ea3eb97743382631f91801cf">More...</a><br/></td></tr>
<tr class="separator:a5f394c15ea3eb97743382631f91801cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5371f0f914e9b79a0700577e5557c0b7"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a5371f0f914e9b79a0700577e5557c0b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5371f0f914e9b79a0700577e5557c0b7">assign</a> (Eigen::Matrix&lt; LHS, R1, C1 &gt; &amp;x, const Eigen::Matrix&lt; RHS, R2, C2 &gt; &amp;y)</td></tr>
<tr class="memdesc:a5371f0f914e9b79a0700577e5557c0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a5371f0f914e9b79a0700577e5557c0b7">More...</a><br/></td></tr>
<tr class="separator:a5371f0f914e9b79a0700577e5557c0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R, int C&gt; </td></tr>
<tr class="memitem:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0a80c719463c4e3caa03df731e2c2cb9">assign</a> (Eigen::Matrix&lt; LHS, R, C &gt; &amp;x, const Eigen::Matrix&lt; RHS, R, C &gt; &amp;y)</td></tr>
<tr class="memdesc:a0a80c719463c4e3caa03df731e2c2cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a0a80c719463c4e3caa03df731e2c2cb9">More...</a><br/></td></tr>
<tr class="separator:a0a80c719463c4e3caa03df731e2c2cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , int R, int C&gt; </td></tr>
<tr class="memitem:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa4af3a90ad3b5ec1507dfc1823fdb8da">assign</a> (Eigen::Block&lt; LHS &gt; x, const Eigen::Matrix&lt; RHS, R, C &gt; &amp;y)</td></tr>
<tr class="memdesc:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#aa4af3a90ad3b5ec1507dfc1823fdb8da">More...</a><br/></td></tr>
<tr class="separator:aa4af3a90ad3b5ec1507dfc1823fdb8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr class="memitem:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2c6dec98c71fd478c2ee16bc274b464d">assign</a> (std::vector&lt; LHS &gt; &amp;x, const std::vector&lt; RHS &gt; &amp;y)</td></tr>
<tr class="memdesc:a2c6dec98c71fd478c2ee16bc274b464d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="#a2c6dec98c71fd478c2ee16bc274b464d">More...</a><br/></td></tr>
<tr class="separator:a2c6dec98c71fd478c2ee16bc274b464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd7c65ea100e48abc72f3c1e96fcdbe9">autocorrelation</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;ac, Eigen::FFT&lt; T &gt; &amp;fft)</td></tr>
<tr class="memdesc:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <a href="#afd7c65ea100e48abc72f3c1e96fcdbe9">More...</a><br/></td></tr>
<tr class="separator:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999404b2520dcd466c62c6ba3ca61f89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a999404b2520dcd466c62c6ba3ca61f89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a999404b2520dcd466c62c6ba3ca61f89">autocorrelation</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;ac)</td></tr>
<tr class="memdesc:a999404b2520dcd466c62c6ba3ca61f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result.  <a href="#a999404b2520dcd466c62c6ba3ca61f89">More...</a><br/></td></tr>
<tr class="separator:a999404b2520dcd466c62c6ba3ca61f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab515e37311a3070dbc66e69d31359a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab515e37311a3070dbc66e69d31359a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab515e37311a3070dbc66e69d31359a5">autocovariance</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;acov, Eigen::FFT&lt; T &gt; &amp;fft)</td></tr>
<tr class="memdesc:aab515e37311a3070dbc66e69d31359a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <a href="#aab515e37311a3070dbc66e69d31359a5">More...</a><br/></td></tr>
<tr class="separator:aab515e37311a3070dbc66e69d31359a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acdfe56505f9cbe96a18fc00f76fe79fd">autocovariance</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;acov)</td></tr>
<tr class="memdesc:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result.  <a href="#acdfe56505f9cbe96a18fc00f76fe79fd">More...</a><br/></td></tr>
<tr class="separator:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be3cf865daa6eca4a859f97ffaa8f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69be3cf865daa6eca4a859f97ffaa8f7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69be3cf865daa6eca4a859f97ffaa8f7">block</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:a69be3cf865daa6eca4a859f97ffaa8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1, j-1).  <a href="#a69be3cf865daa6eca4a859f97ffaa8f7">More...</a><br/></td></tr>
<tr class="separator:a69be3cf865daa6eca4a859f97ffaa8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d24004ec984f89b342414ff6312d0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9d24004ec984f89b342414ff6312d0a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab9d24004ec984f89b342414ff6312d0a">cholesky_corr_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y, int K)</td></tr>
<tr class="separator:ab9d24004ec984f89b342414ff6312d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6649012a7c4d7108fb5dc5ebd6a13683"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6649012a7c4d7108fb5dc5ebd6a13683"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6649012a7c4d7108fb5dc5ebd6a13683">cholesky_corr_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y, int K, T &amp;lp)</td></tr>
<tr class="separator:a6649012a7c4d7108fb5dc5ebd6a13683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed4fbb1adce01dfc445cae326e4c482"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeed4fbb1adce01dfc445cae326e4c482"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeed4fbb1adce01dfc445cae326e4c482">cholesky_corr_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x)</td></tr>
<tr class="separator:aeed4fbb1adce01dfc445cae326e4c482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d798c4cab5a0716a0e338de38617c8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d798c4cab5a0716a0e338de38617c8e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d798c4cab5a0716a0e338de38617c8e">cholesky_decompose</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a4d798c4cab5a0716a0e338de38617c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <a href="#a4d798c4cab5a0716a0e338de38617c8e">More...</a><br/></td></tr>
<tr class="separator:a4d798c4cab5a0716a0e338de38617c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2be4ed6bbf19487de29cfc85718ed3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2be4ed6bbf19487de29cfc85718ed3b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae2be4ed6bbf19487de29cfc85718ed3b">cholesky_factor_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, int M, int N)</td></tr>
<tr class="memdesc:ae2be4ed6bbf19487de29cfc85718ed3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector.  <a href="#ae2be4ed6bbf19487de29cfc85718ed3b">More...</a><br/></td></tr>
<tr class="separator:ae2be4ed6bbf19487de29cfc85718ed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb630493ae2edfb2dbc9caeda00dfff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8eb630493ae2edfb2dbc9caeda00dfff"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8eb630493ae2edfb2dbc9caeda00dfff">cholesky_factor_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, int M, int N, T &amp;lp)</td></tr>
<tr class="memdesc:a8eb630493ae2edfb2dbc9caeda00dfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector and increment the specified log probability reference with the log Jacobian adjustment of the transform.  <a href="#a8eb630493ae2edfb2dbc9caeda00dfff">More...</a><br/></td></tr>
<tr class="separator:a8eb630493ae2edfb2dbc9caeda00dfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d45c92d30d1120cfa4b71a766e1712"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9d45c92d30d1120cfa4b71a766e1712"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad9d45c92d30d1120cfa4b71a766e1712">cholesky_factor_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:ad9d45c92d30d1120cfa4b71a766e1712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained vector of parameters correspdonding to the specified Cholesky factor.  <a href="#ad9d45c92d30d1120cfa4b71a766e1712">More...</a><br/></td></tr>
<tr class="separator:ad9d45c92d30d1120cfa4b71a766e1712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d822499055d9eefe6cd543ad06e1d3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d822499055d9eefe6cd543ad06e1d3b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d822499055d9eefe6cd543ad06e1d3b">col</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t j)</td></tr>
<tr class="memdesc:a3d822499055d9eefe6cd543ad06e1d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified matrix using start-at-1 indexing.  <a href="#a3d822499055d9eefe6cd543ad06e1d3b">More...</a><br/></td></tr>
<tr class="separator:a3d822499055d9eefe6cd543ad06e1d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871bccc233a4dcd764ffece5a3f9a399"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a871bccc233a4dcd764ffece5a3f9a399"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a871bccc233a4dcd764ffece5a3f9a399">cols</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a871bccc233a4dcd764ffece5a3f9a399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d03b34aa7329a68f31d1c7bc500c5c8">columns_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#a6d03b34aa7329a68f31d1c7bc500c5c8">More...</a><br/></td></tr>
<tr class="separator:a6d03b34aa7329a68f31d1c7bc500c5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc404fd71124d7cea29d4f6d1a767b9"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a3cc404fd71124d7cea29d4f6d1a767b9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 1, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3cc404fd71124d7cea29d4f6d1a767b9">columns_dot_self</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a3cc404fd71124d7cea29d4f6d1a767b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="#a3cc404fd71124d7cea29d4f6d1a767b9">More...</a><br/></td></tr>
<tr class="separator:a3cc404fd71124d7cea29d4f6d1a767b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8321b61db6a84b5d9041777643d53550"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8321b61db6a84b5d9041777643d53550"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8321b61db6a84b5d9041777643d53550">corr_matrix_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, typename <a class="el" href="structstan_1_1math_1_1index__type.html">math::index_type</a>&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type k)</td></tr>
<tr class="memdesc:a8321b61db6a84b5d9041777643d53550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="#a8321b61db6a84b5d9041777643d53550">More...</a><br/></td></tr>
<tr class="separator:a8321b61db6a84b5d9041777643d53550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f2b4839829eda2b539a09da332a7fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65f2b4839829eda2b539a09da332a7fa"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a65f2b4839829eda2b539a09da332a7fa">corr_matrix_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, typename <a class="el" href="structstan_1_1math_1_1index__type.html">math::index_type</a>&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type k, T &amp;lp)</td></tr>
<tr class="memdesc:a65f2b4839829eda2b539a09da332a7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="#a65f2b4839829eda2b539a09da332a7fa">More...</a><br/></td></tr>
<tr class="separator:a65f2b4839829eda2b539a09da332a7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f63590ae0c736b6113d578d0899da1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34f63590ae0c736b6113d578d0899da1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34f63590ae0c736b6113d578d0899da1">corr_matrix_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a34f63590ae0c736b6113d578d0899da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained partial correlations that define the specified correlation matrix when transformed.  <a href="#a34f63590ae0c736b6113d578d0899da1">More...</a><br/></td></tr>
<tr class="separator:a34f63590ae0c736b6113d578d0899da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad6b90cf2d3d3d25d2cf64a12effede"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ad6b90cf2d3d3d25d2cf64a12effede"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1ad6b90cf2d3d3d25d2cf64a12effede">cov_matrix_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, typename <a class="el" href="structstan_1_1math_1_1index__type.html">math::index_type</a>&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type K)</td></tr>
<tr class="memdesc:a1ad6b90cf2d3d3d25d2cf64a12effede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <a href="#a1ad6b90cf2d3d3d25d2cf64a12effede">More...</a><br/></td></tr>
<tr class="separator:a1ad6b90cf2d3d3d25d2cf64a12effede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417c6032fe62186f7c8fb5452e4173d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a417c6032fe62186f7c8fb5452e4173d8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a417c6032fe62186f7c8fb5452e4173d8">cov_matrix_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, typename <a class="el" href="structstan_1_1math_1_1index__type.html">math::index_type</a>&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;::type K, T &amp;lp)</td></tr>
<tr class="memdesc:a417c6032fe62186f7c8fb5452e4173d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <a href="#a417c6032fe62186f7c8fb5452e4173d8">More...</a><br/></td></tr>
<tr class="separator:a417c6032fe62186f7c8fb5452e4173d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e398c69a5845680ca945fa9ec6ec401"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e398c69a5845680ca945fa9ec6ec401"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e398c69a5845680ca945fa9ec6ec401">cov_matrix_constrain_lkj</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t k)</td></tr>
<tr class="memdesc:a6e398c69a5845680ca945fa9ec6ec401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values.  <a href="#a6e398c69a5845680ca945fa9ec6ec401">More...</a><br/></td></tr>
<tr class="separator:a6e398c69a5845680ca945fa9ec6ec401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad179abe18f235b3000ad7a000b3abb29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad179abe18f235b3000ad7a000b3abb29"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad179abe18f235b3000ad7a000b3abb29">cov_matrix_constrain_lkj</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t k, T &amp;lp)</td></tr>
<tr class="memdesc:ad179abe18f235b3000ad7a000b3abb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values and increment the specified log probability reference with the log absolute Jacobian determinant.  <a href="#ad179abe18f235b3000ad7a000b3abb29">More...</a><br/></td></tr>
<tr class="separator:ad179abe18f235b3000ad7a000b3abb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485d3c2cd12e516bb13a1d48f9a43386"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a485d3c2cd12e516bb13a1d48f9a43386"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a485d3c2cd12e516bb13a1d48f9a43386">cov_matrix_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a485d3c2cd12e516bb13a1d48f9a43386"><td class="mdescLeft">&#160;</td><td class="mdescRight">The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K specified matrix is freed to return a vector of size K + (K choose 2).  <a href="#a485d3c2cd12e516bb13a1d48f9a43386">More...</a><br/></td></tr>
<tr class="separator:a485d3c2cd12e516bb13a1d48f9a43386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9021324082d4241367fdd17da025a32d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9021324082d4241367fdd17da025a32d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9021324082d4241367fdd17da025a32d">cov_matrix_free_lkj</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y)</td></tr>
<tr class="memdesc:a9021324082d4241367fdd17da025a32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained partial correlations and deviations that transform to the specified covariance matrix.  <a href="#a9021324082d4241367fdd17da025a32d">More...</a><br/></td></tr>
<tr class="separator:a9021324082d4241367fdd17da025a32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cc3a137ff3220bdd0137a52a4b9714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a62cc3a137ff3220bdd0137a52a4b9714">crossprod</a> (const <a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a> &amp;M)</td></tr>
<tr class="memdesc:a62cc3a137ff3220bdd0137a52a4b9714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <a href="#a62cc3a137ff3220bdd0137a52a4b9714">More...</a><br/></td></tr>
<tr class="separator:a62cc3a137ff3220bdd0137a52a4b9714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7340f6be8ae1e121c6d854005560fef5">cumulative_sum</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a7340f6be8ae1e121c6d854005560fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="#a7340f6be8ae1e121c6d854005560fef5">More...</a><br/></td></tr>
<tr class="separator:a7340f6be8ae1e121c6d854005560fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fcacf229225bb313cf894cc1406a17"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a92fcacf229225bb313cf894cc1406a17"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a92fcacf229225bb313cf894cc1406a17">cumulative_sum</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a92fcacf229225bb313cf894cc1406a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified matrix.  <a href="#a92fcacf229225bb313cf894cc1406a17">More...</a><br/></td></tr>
<tr class="separator:a92fcacf229225bb313cf894cc1406a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab65e9ab0e6f725c7e11068b0be2af84f">determinant</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the specified square matrix.  <a href="#ab65e9ab0e6f725c7e11068b0be2af84f">More...</a><br/></td></tr>
<tr class="separator:ab65e9ab0e6f725c7e11068b0be2af84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8174ad2b40453c1bfcbdf59bf76e030d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8174ad2b40453c1bfcbdf59bf76e030d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8174ad2b40453c1bfcbdf59bf76e030d">diag_matrix</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a8174ad2b40453c1bfcbdf59bf76e030d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <a href="#a8174ad2b40453c1bfcbdf59bf76e030d">More...</a><br/></td></tr>
<tr class="separator:a8174ad2b40453c1bfcbdf59bf76e030d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada475ab6293a9b7e5d3e6c1f92315008"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ada475ab6293a9b7e5d3e6c1f92315008"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ada475ab6293a9b7e5d3e6c1f92315008">diag_post_multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:ada475ab6293a9b7e5d3e6c1f92315008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97acdd27ef5fca2cd111010f6fccf6b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a97acdd27ef5fca2cd111010f6fccf6b8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R2, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a97acdd27ef5fca2cd111010f6fccf6b8">diag_pre_multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="separator:a97acdd27ef5fca2cd111010f6fccf6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e96160f66cf84ab9a4bae027645e5a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e96160f66cf84ab9a4bae027645e5a5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2e96160f66cf84ab9a4bae027645e5a5">diagonal</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a2e96160f66cf84ab9a4bae027645e5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of the diagonal elements of the specified matrix.  <a href="#a2e96160f66cf84ab9a4bae027645e5a5">More...</a><br/></td></tr>
<tr class="separator:a2e96160f66cf84ab9a4bae027645e5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9073e39033e56eb31344091f0170fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b9073e39033e56eb31344091f0170fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b9073e39033e56eb31344091f0170fd">dims</a> (const T &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:a2b9073e39033e56eb31344091f0170fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a2dcde478c06e3543511821618902"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:af95a2dcde478c06e3543511821618902"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af95a2dcde478c06e3543511821618902">dims</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:af95a2dcde478c06e3543511821618902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467589eef4220a87d457c8a268a1fd5d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a467589eef4220a87d457c8a268a1fd5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a467589eef4220a87d457c8a268a1fd5d">dims</a> (const std::vector&lt; T &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:a467589eef4220a87d457c8a268a1fd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a33777ee768c7032331ca8b92e5323384">dims</a> (const T &amp;x)</td></tr>
<tr class="separator:a33777ee768c7032331ca8b92e5323384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0a62287bdf0c0420386fccc0a13ca9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:acc0a62287bdf0c0420386fccc0a13ca9"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acc0a62287bdf0c0420386fccc0a13ca9">distance</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:acc0a62287bdf0c0420386fccc0a13ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between the specified vectors.  <a href="#acc0a62287bdf0c0420386fccc0a13ca9">More...</a><br/></td></tr>
<tr class="separator:acc0a62287bdf0c0420386fccc0a13ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a082ee76b34a2ea656d2c8ab9186c1a2b">divide</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;m, T c)</td></tr>
<tr class="memdesc:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix divided by specified scalar.  <a href="#a082ee76b34a2ea656d2c8ab9186c1a2b">More...</a><br/></td></tr>
<tr class="separator:a082ee76b34a2ea656d2c8ab9186c1a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d73851895fb151fdf79e55bf33e98e"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:af8d73851895fb151fdf79e55bf33e98e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8d73851895fb151fdf79e55bf33e98e">dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:af8d73851895fb151fdf79e55bf33e98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#af8d73851895fb151fdf79e55bf33e98e">More...</a><br/></td></tr>
<tr class="separator:af8d73851895fb151fdf79e55bf33e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58da447df259e9e092e8fd910b338e1f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a58da447df259e9e092e8fd910b338e1f">dot_product</a> (const double *v1, const double *v2, size_t <a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="memdesc:a58da447df259e9e092e8fd910b338e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays of doubles.  <a href="#a58da447df259e9e092e8fd910b338e1f">More...</a><br/></td></tr>
<tr class="separator:a58da447df259e9e092e8fd910b338e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd93708bf432b3bd3d284958972ede"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab7cd93708bf432b3bd3d284958972ede">dot_product</a> (const std::vector&lt; double &gt; &amp;v1, const std::vector&lt; double &gt; &amp;v2)</td></tr>
<tr class="memdesc:ab7cd93708bf432b3bd3d284958972ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays of doubles.  <a href="#ab7cd93708bf432b3bd3d284958972ede">More...</a><br/></td></tr>
<tr class="separator:ab7cd93708bf432b3bd3d284958972ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81ab85d390fcb594884773a85fac657"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ac81ab85d390fcb594884773a85fac657"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac81ab85d390fcb594884773a85fac657">dot_self</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ac81ab85d390fcb594884773a85fac657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vector with itself.  <a href="#ac81ab85d390fcb594884773a85fac657">More...</a><br/></td></tr>
<tr class="separator:ac81ab85d390fcb594884773a85fac657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e454ec91241f2f6e70aa05e7b7698ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e454ec91241f2f6e70aa05e7b7698ff"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2e454ec91241f2f6e70aa05e7b7698ff">eigenvalues_sym</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a2e454ec91241f2f6e70aa05e7b7698ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of the specified symmetric matrix in descending order of magnitude.  <a href="#a2e454ec91241f2f6e70aa05e7b7698ff">More...</a><br/></td></tr>
<tr class="separator:a2e454ec91241f2f6e70aa05e7b7698ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd77067fef0a78dd5d8f9527969631e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fd77067fef0a78dd5d8f9527969631e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9fd77067fef0a78dd5d8f9527969631e">eigenvectors_sym</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:a9fd77067fef0a78dd5d8f9527969631e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3cc187f569c795118c72bcc1e5c58"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a75c3cc187f569c795118c72bcc1e5c58"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a75c3cc187f569c795118c72bcc1e5c58">elt_divide</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a75c3cc187f569c795118c72bcc1e5c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrices.  <a href="#a75c3cc187f569c795118c72bcc1e5c58">More...</a><br/></td></tr>
<tr class="separator:a75c3cc187f569c795118c72bcc1e5c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d04e1b1dde0ea7455380ec27d4528"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:adc5d04e1b1dde0ea7455380ec27d4528"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adc5d04e1b1dde0ea7455380ec27d4528">elt_divide</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, T2 s)</td></tr>
<tr class="memdesc:adc5d04e1b1dde0ea7455380ec27d4528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrix by the specified scalar.  <a href="#adc5d04e1b1dde0ea7455380ec27d4528">More...</a><br/></td></tr>
<tr class="separator:adc5d04e1b1dde0ea7455380ec27d4528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d728ca306346624b833cee2777c23d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:ad4d728ca306346624b833cee2777c23d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad4d728ca306346624b833cee2777c23d">elt_divide</a> (T1 s, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ad4d728ca306346624b833cee2777c23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified scalar by the specified matrix.  <a href="#ad4d728ca306346624b833cee2777c23d">More...</a><br/></td></tr>
<tr class="separator:ad4d728ca306346624b833cee2777c23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edc3d65b32928692984bd66a1b3bb56"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a2edc3d65b32928692984bd66a1b3bb56"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2edc3d65b32928692984bd66a1b3bb56">elt_multiply</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a2edc3d65b32928692984bd66a1b3bb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise multiplication of the specified matrices.  <a href="#a2edc3d65b32928692984bd66a1b3bb56">More...</a><br/></td></tr>
<tr class="separator:a2edc3d65b32928692984bd66a1b3bb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad4663394747a548b42f8cbe9def1f7"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols&gt; </td></tr>
<tr class="memitem:a7ad4663394747a548b42f8cbe9def1f7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7ad4663394747a548b42f8cbe9def1f7">exp</a> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="memdesc:a7ad4663394747a548b42f8cbe9def1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element-wise exponentiation of the matrix or vector.  <a href="#a7ad4663394747a548b42f8cbe9def1f7">More...</a><br/></td></tr>
<tr class="separator:a7ad4663394747a548b42f8cbe9def1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bd08f492d4ae400850ecb98b9b6cb9"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols&gt; </td></tr>
<tr class="memitem:ab3bd08f492d4ae400850ecb98b9b6cb9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab3bd08f492d4ae400850ecb98b9b6cb9">exp</a> (const Eigen::Matrix&lt; double, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="separator:ab3bd08f492d4ae400850ecb98b9b6cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6ef71b2e1a2a216a031d8403458bdd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d6ef71b2e1a2a216a031d8403458bdd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9d6ef71b2e1a2a216a031d8403458bdd">factor_cov_matrix</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Sigma, Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;sds)</td></tr>
<tr class="memdesc:a9d6ef71b2e1a2a216a031d8403458bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is intended to make starting values, given a covariance matrix Sigma.  <a href="#a9d6ef71b2e1a2a216a031d8403458bdd">More...</a><br/></td></tr>
<tr class="separator:a9d6ef71b2e1a2a216a031d8403458bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d09763679360f53f07ae20e8efc262"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6d09763679360f53f07ae20e8efc262"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa6d09763679360f53f07ae20e8efc262">factor_U</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;U, Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs)</td></tr>
<tr class="memdesc:aa6d09763679360f53f07ae20e8efc262"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is intended to make starting values, given a unit upper-triangular matrix U such that U'DU is a correlation matrix.  <a href="#aa6d09763679360f53f07ae20e8efc262">More...</a><br/></td></tr>
<tr class="separator:aa6d09763679360f53f07ae20e8efc262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d362e53d3d40b61e68fdd08dc5eb38b">fill</a> (T &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#a6d362e53d3d40b61e68fdd08dc5eb38b">More...</a><br/></td></tr>
<tr class="separator:a6d362e53d3d40b61e68fdd08dc5eb38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e791042ed648602eed1754679feff4"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C, typename S &gt; </td></tr>
<tr class="memitem:a73e791042ed648602eed1754679feff4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73e791042ed648602eed1754679feff4">fill</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a73e791042ed648602eed1754679feff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#a73e791042ed648602eed1754679feff4">More...</a><br/></td></tr>
<tr class="separator:a73e791042ed648602eed1754679feff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f5d81c4d45f2407096def8810ffe00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:aa7f5d81c4d45f2407096def8810ffe00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa7f5d81c4d45f2407096def8810ffe00">fill</a> (std::vector&lt; T &gt; &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:aa7f5d81c4d45f2407096def8810ffe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="#aa7f5d81c4d45f2407096def8810ffe00">More...</a><br/></td></tr>
<tr class="separator:aa7f5d81c4d45f2407096def8810ffe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7535c86e2c9ee9d5391a8cc63187317e">get_base1</a> (const std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a7535c86e2c9ee9d5391a8cc63187317e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="#a7535c86e2c9ee9d5391a8cc63187317e">More...</a><br/></td></tr>
<tr class="separator:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca7c84b936da0d3422507927cf9a68cc">get_base1</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aca7c84b936da0d3422507927cf9a68cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aca7c84b936da0d3422507927cf9a68cc">More...</a><br/></td></tr>
<tr class="separator:aca7c84b936da0d3422507927cf9a68cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a714e39ba9fcbbd90c787a51d511c9af1">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a714e39ba9fcbbd90c787a51d511c9af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a714e39ba9fcbbd90c787a51d511c9af1">More...</a><br/></td></tr>
<tr class="separator:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa23b355397df347249da513307fd6667">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aa23b355397df347249da513307fd6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aa23b355397df347249da513307fd6667">More...</a><br/></td></tr>
<tr class="separator:aa23b355397df347249da513307fd6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a25c1fac0445beea55c521c94f360e13e">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a25c1fac0445beea55c521c94f360e13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a25c1fac0445beea55c521c94f360e13e">More...</a><br/></td></tr>
<tr class="separator:a25c1fac0445beea55c521c94f360e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a20a82151947fc8816c5ce5b7bc6d8abd">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a20a82151947fc8816c5ce5b7bc6d8abd">More...</a><br/></td></tr>
<tr class="separator:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6fb72caff19c8ce19dc6e3c25c79f7b8">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a6fb72caff19c8ce19dc6e3c25c79f7b8">More...</a><br/></td></tr>
<tr class="separator:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#accc97dd76490d575638ebb22da233a53">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:accc97dd76490d575638ebb22da233a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#accc97dd76490d575638ebb22da233a53">More...</a><br/></td></tr>
<tr class="separator:accc97dd76490d575638ebb22da233a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5ea3228150cb118441cced9ed49a92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d5ea3228150cb118441cced9ed49a92"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8d5ea3228150cb118441cced9ed49a92">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a8d5ea3228150cb118441cced9ed49a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <a href="#a8d5ea3228150cb118441cced9ed49a92">More...</a><br/></td></tr>
<tr class="separator:a8d5ea3228150cb118441cced9ed49a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51091bb67549e42c241f4e08e7d291d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51091bb67549e42c241f4e08e7d291d6"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a51091bb67549e42c241f4e08e7d291d6">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a51091bb67549e42c241f4e08e7d291d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="#a51091bb67549e42c241f4e08e7d291d6">More...</a><br/></td></tr>
<tr class="separator:a51091bb67549e42c241f4e08e7d291d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0dbeed50ff3f8630ea3cd54f9ecb804">get_base1</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <a href="#ab0dbeed50ff3f8630ea3cd54f9ecb804">More...</a><br/></td></tr>
<tr class="separator:ab0dbeed50ff3f8630ea3cd54f9ecb804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9dcd5236495d3f581b31dd05b9a227"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf9dcd5236495d3f581b31dd05b9a227"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abf9dcd5236495d3f581b31dd05b9a227">get_base1</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:abf9dcd5236495d3f581b31dd05b9a227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <a href="#abf9dcd5236495d3f581b31dd05b9a227">More...</a><br/></td></tr>
<tr class="separator:abf9dcd5236495d3f581b31dd05b9a227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac54b1427fd9d0765f0200dc9caa830f9">get_base1_lhs</a> (std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ac54b1427fd9d0765f0200dc9caa830f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="#ac54b1427fd9d0765f0200dc9caa830f9">More...</a><br/></td></tr>
<tr class="separator:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d5711f99869d05a6263218f3256e582">get_base1_lhs</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a4d5711f99869d05a6263218f3256e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a4d5711f99869d05a6263218f3256e582">More...</a><br/></td></tr>
<tr class="separator:a4d5711f99869d05a6263218f3256e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a37f3ceaa6197904ef662f1edc8245e1a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a37f3ceaa6197904ef662f1edc8245e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a37f3ceaa6197904ef662f1edc8245e1a">More...</a><br/></td></tr>
<tr class="separator:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3132eb36eaf861cfbd119b38e0a85a15">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a3132eb36eaf861cfbd119b38e0a85a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a3132eb36eaf861cfbd119b38e0a85a15">More...</a><br/></td></tr>
<tr class="separator:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afbcc061003aabcaf675f4415adc80c0a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:afbcc061003aabcaf675f4415adc80c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#afbcc061003aabcaf675f4415adc80c0a">More...</a><br/></td></tr>
<tr class="separator:afbcc061003aabcaf675f4415adc80c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1958245532761be08be7ac9bc781f3a7">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a1958245532761be08be7ac9bc781f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a1958245532761be08be7ac9bc781f3a7">More...</a><br/></td></tr>
<tr class="separator:a1958245532761be08be7ac9bc781f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aedc7fc712ebe439bec1892c8f69447cd">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aedc7fc712ebe439bec1892c8f69447cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#aedc7fc712ebe439bec1892c8f69447cd">More...</a><br/></td></tr>
<tr class="separator:aedc7fc712ebe439bec1892c8f69447cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a64467731d9abfaf97ea8d541d528142c">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a64467731d9abfaf97ea8d541d528142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="#a64467731d9abfaf97ea8d541d528142c">More...</a><br/></td></tr>
<tr class="separator:a64467731d9abfaf97ea8d541d528142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0843cd960568745e5ace70f2c45ec6c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0843cd960568745e5ace70f2c45ec6c3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0843cd960568745e5ace70f2c45ec6c3">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a0843cd960568745e5ace70f2c45ec6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <a href="#a0843cd960568745e5ace70f2c45ec6c3">More...</a><br/></td></tr>
<tr class="separator:a0843cd960568745e5ace70f2c45ec6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8cb7e6e670cddcdf5527ec92fa3ff37">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="#af8cb7e6e670cddcdf5527ec92fa3ff37">More...</a><br/></td></tr>
<tr class="separator:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adffeab694f7588c92dc97b6736e5be7b">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:adffeab694f7588c92dc97b6736e5be7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <a href="#adffeab694f7588c92dc97b6736e5be7b">More...</a><br/></td></tr>
<tr class="separator:adffeab694f7588c92dc97b6736e5be7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6133d90708e16760b6394c6ca6a305ff">get_base1_lhs</a> (Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6133d90708e16760b6394c6ca6a305ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <a href="#a6133d90708e16760b6394c6ca6a305ff">More...</a><br/></td></tr>
<tr class="separator:a6133d90708e16760b6394c6ca6a305ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fd1b6e6ba9738332204bae823dc006"><td class="memTemplParams" colspan="2">template&lt;typename T_lp , typename T_lp_accum &gt; </td></tr>
<tr class="memitem:ac0fd1b6e6ba9738332204bae823dc006"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_lp, T_lp_accum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0fd1b6e6ba9738332204bae823dc006">get_lp</a> (const T_lp &amp;lp, const <a class="el" href="classstan_1_1math_1_1accumulator.html">stan::math::accumulator</a>&lt; T_lp_accum &gt; &amp;lp_accum)</td></tr>
<tr class="separator:ac0fd1b6e6ba9738332204bae823dc006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae824fde6dc6e0f4ac3d37b86fb266414"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae824fde6dc6e0f4ac3d37b86fb266414"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae824fde6dc6e0f4ac3d37b86fb266414">head</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t n)</td></tr>
<tr class="memdesc:ae824fde6dc6e0f4ac3d37b86fb266414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector from the front of the specified vector.  <a href="#ae824fde6dc6e0f4ac3d37b86fb266414">More...</a><br/></td></tr>
<tr class="separator:ae824fde6dc6e0f4ac3d37b86fb266414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1d4ceb7d5aac027e9ec6adcb18755a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada1d4ceb7d5aac027e9ec6adcb18755a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ada1d4ceb7d5aac027e9ec6adcb18755a">head</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, size_t n)</td></tr>
<tr class="memdesc:ada1d4ceb7d5aac027e9ec6adcb18755a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row vector from the front of the specified row vector.  <a href="#ada1d4ceb7d5aac027e9ec6adcb18755a">More...</a><br/></td></tr>
<tr class="separator:ada1d4ceb7d5aac027e9ec6adcb18755a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e746ba14994b318a0a192a97a0a28db">head</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="memdesc:a5e746ba14994b318a0a192a97a0a28db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a standard vector from the front of the specified standard vector.  <a href="#a5e746ba14994b318a0a192a97a0a28db">More...</a><br/></td></tr>
<tr class="separator:a5e746ba14994b318a0a192a97a0a28db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81e05dfd6918524dafff10715f21a8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af81e05dfd6918524dafff10715f21a8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af81e05dfd6918524dafff10715f21a8d">initialize</a> (T &amp;x, const T &amp;v)</td></tr>
<tr class="separator:af81e05dfd6918524dafff10715f21a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad7882cc7a7e2e07016e006d2092427"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a5ad7882cc7a7e2e07016e006d2092427"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; V &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5ad7882cc7a7e2e07016e006d2092427">initialize</a> (T &amp;x, V v)</td></tr>
<tr class="separator:a5ad7882cc7a7e2e07016e006d2092427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C, typename V &gt; </td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1cb47e7569cabd57a1c0c6816ca48293">initialize</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad27706378f77dc22746ad74721d495d4">initialize</a> (std::vector&lt; T &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:ad27706378f77dc22746ad74721d495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621964cbb3b06ba80811cd58e3048a0"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ad621964cbb3b06ba80811cd58e3048a0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad621964cbb3b06ba80811cd58e3048a0">inverse</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ad621964cbb3b06ba80811cd58e3048a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified matrix.  <a href="#ad621964cbb3b06ba80811cd58e3048a0">More...</a><br/></td></tr>
<tr class="separator:ad621964cbb3b06ba80811cd58e3048a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d2c003918b45e95edb84ea58b84c68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69d2c003918b45e95edb84ea58b84c68"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69d2c003918b45e95edb84ea58b84c68">inverse_spd</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a69d2c003918b45e95edb84ea58b84c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified symmetric, pos/neg-definite matrix.  <a href="#a69d2c003918b45e95edb84ea58b84c68">More...</a><br/></td></tr>
<tr class="separator:a69d2c003918b45e95edb84ea58b84c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b52b30a04e9a9f216b49ef06ab7a61"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows, int Cols&gt; </td></tr>
<tr class="memitem:ac3b52b30a04e9a9f216b49ef06ab7a61"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac3b52b30a04e9a9f216b49ef06ab7a61">log</a> (const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;m)</td></tr>
<tr class="memdesc:ac3b52b30a04e9a9f216b49ef06ab7a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element-wise logarithm of the matrix or vector.  <a href="#ac3b52b30a04e9a9f216b49ef06ab7a61">More...</a><br/></td></tr>
<tr class="separator:ac3b52b30a04e9a9f216b49ef06ab7a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca29dad18932e3ca17ac52fd0238b364"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:aca29dad18932e3ca17ac52fd0238b364"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca29dad18932e3ca17ac52fd0238b364">log_determinant</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:aca29dad18932e3ca17ac52fd0238b364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="#aca29dad18932e3ca17ac52fd0238b364">More...</a><br/></td></tr>
<tr class="separator:aca29dad18932e3ca17ac52fd0238b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d95f632b80e8653fe5891209bdeda45"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a1d95f632b80e8653fe5891209bdeda45"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1d95f632b80e8653fe5891209bdeda45">log_determinant_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;A)</td></tr>
<tr class="separator:a1d95f632b80e8653fe5891209bdeda45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a296d4414d0193108c70b350a05cfc"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae9a296d4414d0193108c70b350a05cfc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae9a296d4414d0193108c70b350a05cfc">log_determinant_spd</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ae9a296d4414d0193108c70b350a05cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="#ae9a296d4414d0193108c70b350a05cfc">More...</a><br/></td></tr>
<tr class="separator:ae9a296d4414d0193108c70b350a05cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f60a82d68ef90f7cd5e9f02f121a5d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f60a82d68ef90f7cd5e9f02f121a5d1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0f60a82d68ef90f7cd5e9f02f121a5d1">log_softmax</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a0f60a82d68ef90f7cd5e9f02f121a5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the softmax of the specified vector.  <a href="#a0f60a82d68ef90f7cd5e9f02f121a5d1">More...</a><br/></td></tr>
<tr class="separator:a0f60a82d68ef90f7cd5e9f02f121a5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fb47266493c7da21a6508944d65bdf"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ac1fb47266493c7da21a6508944d65bdf"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac1fb47266493c7da21a6508944d65bdf">log_sum_exp</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:ac1fb47266493c7da21a6508944d65bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <a href="#ac1fb47266493c7da21a6508944d65bdf">More...</a><br/></td></tr>
<tr class="separator:ac1fb47266493c7da21a6508944d65bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d39c88943f3fb8e45759c62d68953b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71d39c88943f3fb8e45759c62d68953b"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Array&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a71d39c88943f3fb8e45759c62d68953b">make_nu</a> (const T eta, const size_t K)</td></tr>
<tr class="memdesc:a71d39c88943f3fb8e45759c62d68953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the degrees of freedom for the t distribution that corresponds to the shape parameter in the Lewandowski et.  <a href="#a71d39c88943f3fb8e45759c62d68953b">More...</a><br/></td></tr>
<tr class="separator:a71d39c88943f3fb8e45759c62d68953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5da0ef87756d3dbd20ca4ff5a3efa10d">max</a> (const std::vector&lt; int &gt; &amp;x)</td></tr>
<tr class="memdesc:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified column vector.  <a href="#a5da0ef87756d3dbd20ca4ff5a3efa10d">More...</a><br/></td></tr>
<tr class="separator:a5da0ef87756d3dbd20ca4ff5a3efa10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde414919e0e4dcfa72d565679819091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acde414919e0e4dcfa72d565679819091"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acde414919e0e4dcfa72d565679819091">max</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:acde414919e0e4dcfa72d565679819091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified column vector.  <a href="#acde414919e0e4dcfa72d565679819091">More...</a><br/></td></tr>
<tr class="separator:acde414919e0e4dcfa72d565679819091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f299773dc20e8305fc16df1be8d029"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae3f299773dc20e8305fc16df1be8d029"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3f299773dc20e8305fc16df1be8d029">max</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:ae3f299773dc20e8305fc16df1be8d029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum coefficient in the specified vector, row vector, or matrix.  <a href="#ae3f299773dc20e8305fc16df1be8d029">More...</a><br/></td></tr>
<tr class="separator:ae3f299773dc20e8305fc16df1be8d029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e254b9ffb28a6fe6820f9f84412907"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a78e254b9ffb28a6fe6820f9f84412907"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a78e254b9ffb28a6fe6820f9f84412907">mdivide_left</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a78e254b9ffb28a6fe6820f9f84412907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <a href="#a78e254b9ffb28a6fe6820f9f84412907">More...</a><br/></td></tr>
<tr class="separator:a78e254b9ffb28a6fe6820f9f84412907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06ecbc0a8e5cc50c42861bb20f1b0e"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8d06ecbc0a8e5cc50c42861bb20f1b0e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8d06ecbc0a8e5cc50c42861bb20f1b0e">mdivide_left_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a8d06ecbc0a8e5cc50c42861bb20f1b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#a8d06ecbc0a8e5cc50c42861bb20f1b0e">More...</a><br/></td></tr>
<tr class="separator:a8d06ecbc0a8e5cc50c42861bb20f1b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e78140ced17ce9be79c29b9f23321b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:af0e78140ced17ce9be79c29b9f23321b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af0e78140ced17ce9be79c29b9f23321b">mdivide_left_spd</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:af0e78140ced17ce9be79c29b9f23321b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <a href="#af0e78140ced17ce9be79c29b9f23321b">More...</a><br/></td></tr>
<tr class="separator:af0e78140ced17ce9be79c29b9f23321b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ef591181f40598fd3c012c6e5e354d"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ab9ef591181f40598fd3c012c6e5e354d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab9ef591181f40598fd3c012c6e5e354d">mdivide_left_tri</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:ab9ef591181f40598fd3c012c6e5e354d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <a href="#ab9ef591181f40598fd3c012c6e5e354d">More...</a><br/></td></tr>
<tr class="separator:ab9ef591181f40598fd3c012c6e5e354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e94b2554b4728e4932aded1d71eb026"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:a1e94b2554b4728e4932aded1d71eb026"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1e94b2554b4728e4932aded1d71eb026">mdivide_left_tri</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A)</td></tr>
<tr class="memdesc:a1e94b2554b4728e4932aded1d71eb026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <a href="#a1e94b2554b4728e4932aded1d71eb026">More...</a><br/></td></tr>
<tr class="separator:a1e94b2554b4728e4932aded1d71eb026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154c4bb61dd8dce054238940b75aeaac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a154c4bb61dd8dce054238940b75aeaac"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a154c4bb61dd8dce054238940b75aeaac">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a154c4bb61dd8dce054238940b75aeaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd9357ad5b52be5547eecdde95e968b"><td class="memTemplParams" colspan="2">template&lt;typename T , int R1, int C1&gt; </td></tr>
<tr class="memitem:afdd9357ad5b52be5547eecdde95e968b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afdd9357ad5b52be5547eecdde95e968b">mdivide_left_tri_low</a> (const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;A)</td></tr>
<tr class="separator:afdd9357ad5b52be5547eecdde95e968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc8c5bb0af596842ae6cc7f11556f56"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a3fc8c5bb0af596842ae6cc7f11556f56"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3fc8c5bb0af596842ae6cc7f11556f56">mdivide_right</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a3fc8c5bb0af596842ae6cc7f11556f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <a href="#a3fc8c5bb0af596842ae6cc7f11556f56">More...</a><br/></td></tr>
<tr class="separator:a3fc8c5bb0af596842ae6cc7f11556f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f8ca30a27a0a70d32477a9fb4c4e25"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ad9f8ca30a27a0a70d32477a9fb4c4e25"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad9f8ca30a27a0a70d32477a9fb4c4e25">mdivide_right_ldlt</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:ad9f8ca30a27a0a70d32477a9fb4c4e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#ad9f8ca30a27a0a70d32477a9fb4c4e25">More...</a><br/></td></tr>
<tr class="separator:ad9f8ca30a27a0a70d32477a9fb4c4e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4edbfe01ea37356acd24cc948425c8"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a1f4edbfe01ea37356acd24cc948425c8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f4edbfe01ea37356acd24cc948425c8">mdivide_right_ldlt</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;b, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R2, C2 &gt; &amp;A)</td></tr>
<tr class="separator:a1f4edbfe01ea37356acd24cc948425c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73c90537220c0205f5355895a14621c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ab73c90537220c0205f5355895a14621c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab73c90537220c0205f5355895a14621c">mdivide_right_spd</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:ab73c90537220c0205f5355895a14621c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <a href="#ab73c90537220c0205f5355895a14621c">More...</a><br/></td></tr>
<tr class="separator:ab73c90537220c0205f5355895a14621c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a692492445dff37a2594267d530796"><td class="memTemplParams" colspan="2">template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a43a692492445dff37a2594267d530796"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a43a692492445dff37a2594267d530796">mdivide_right_tri</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a43a692492445dff37a2594267d530796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <a href="#a43a692492445dff37a2594267d530796">More...</a><br/></td></tr>
<tr class="separator:a43a692492445dff37a2594267d530796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38aef2711a500bdb997863f0dc6b5d17"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a38aef2711a500bdb997863f0dc6b5d17"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a38aef2711a500bdb997863f0dc6b5d17">mdivide_right_tri_low</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;b, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;A)</td></tr>
<tr class="memdesc:a38aef2711a500bdb997863f0dc6b5d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system tri(A)x=b when tri(A) is a lower triangular view of the matrix A.  <a href="#a38aef2711a500bdb997863f0dc6b5d17">More...</a><br/></td></tr>
<tr class="separator:a38aef2711a500bdb997863f0dc6b5d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3443c4ac994b039a7f055c55c5afa8a3">mean</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a3443c4ac994b039a7f055c55c5afa8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified standard vector.  <a href="#a3443c4ac994b039a7f055c55c5afa8a3">More...</a><br/></td></tr>
<tr class="separator:a3443c4ac994b039a7f055c55c5afa8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074c0041b93407c473fd26a7c45dc88"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a8074c0041b93407c473fd26a7c45dc88"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8074c0041b93407c473fd26a7c45dc88">mean</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a8074c0041b93407c473fd26a7c45dc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified vector, row vector, or matrix.  <a href="#a8074c0041b93407c473fd26a7c45dc88">More...</a><br/></td></tr>
<tr class="separator:a8074c0041b93407c473fd26a7c45dc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f076860549f63d55c0e4985dce78099"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f076860549f63d55c0e4985dce78099">min</a> (const std::vector&lt; int &gt; &amp;x)</td></tr>
<tr class="memdesc:a3f076860549f63d55c0e4985dce78099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified column vector.  <a href="#a3f076860549f63d55c0e4985dce78099">More...</a><br/></td></tr>
<tr class="separator:a3f076860549f63d55c0e4985dce78099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9e9c3a01030d96fd4c8f28e2ed8d3d61">min</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified column vector.  <a href="#a9e9c3a01030d96fd4c8f28e2ed8d3d61">More...</a><br/></td></tr>
<tr class="separator:a9e9c3a01030d96fd4c8f28e2ed8d3d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f2380e5c54a549e0f74ffd51204d33"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a86f2380e5c54a549e0f74ffd51204d33"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a86f2380e5c54a549e0f74ffd51204d33">min</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a86f2380e5c54a549e0f74ffd51204d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified matrix, vector, or row vector.  <a href="#a86f2380e5c54a549e0f74ffd51204d33">More...</a><br/></td></tr>
<tr class="separator:a86f2380e5c54a549e0f74ffd51204d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b343d6dc12982c2b76c453650c0797"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87b343d6dc12982c2b76c453650c0797"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87b343d6dc12982c2b76c453650c0797">minus</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a87b343d6dc12982c2b76c453650c0797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negation of the specified scalar or matrix.  <a href="#a87b343d6dc12982c2b76c453650c0797">More...</a><br/></td></tr>
<tr class="separator:a87b343d6dc12982c2b76c453650c0797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919d4a6495c489841df3d0423200b147"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a919d4a6495c489841df3d0423200b147"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a919d4a6495c489841df3d0423200b147">multiply</a> (const Eigen::Matrix&lt; double, R, C &gt; &amp;m, T c)</td></tr>
<tr class="memdesc:a919d4a6495c489841df3d0423200b147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar.  <a href="#a919d4a6495c489841df3d0423200b147">More...</a><br/></td></tr>
<tr class="separator:a919d4a6495c489841df3d0423200b147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memTemplParams" colspan="2">template&lt;int R, int C, typename T &gt; </td></tr>
<tr class="memitem:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
::value, Eigen::Matrix&lt; double, <br class="typebreak"/>
R, C &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5a2b6dbfb5543b73dac8496091745ec1">multiply</a> (T c, const Eigen::Matrix&lt; double, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a5a2b6dbfb5543b73dac8496091745ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified scalar multiplied by specified matrix.  <a href="#a5a2b6dbfb5543b73dac8496091745ec1">More...</a><br/></td></tr>
<tr class="separator:a5a2b6dbfb5543b73dac8496091745ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefbdef5245cd4f80dcee30d2a36131f"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aeefbdef5245cd4f80dcee30d2a36131f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeefbdef5245cd4f80dcee30d2a36131f">multiply</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:aeefbdef5245cd4f80dcee30d2a36131f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <a href="#aeefbdef5245cd4f80dcee30d2a36131f">More...</a><br/></td></tr>
<tr class="separator:aeefbdef5245cd4f80dcee30d2a36131f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e67698775aaac248efa49b646ca2a51"><td class="memTemplParams" colspan="2">template&lt;int C1, int R2&gt; </td></tr>
<tr class="memitem:a6e67698775aaac248efa49b646ca2a51"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e67698775aaac248efa49b646ca2a51">multiply</a> (const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;rv, const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:a6e67698775aaac248efa49b646ca2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scalar product of the specified row vector and specified column vector.  <a href="#a6e67698775aaac248efa49b646ca2a51">More...</a><br/></td></tr>
<tr class="separator:a6e67698775aaac248efa49b646ca2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c953951f141b35277fe2308777cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c0c953951f141b35277fe2308777cff">multiply_lower_tri_self_transpose</a> (const <a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a> &amp;L)</td></tr>
<tr class="memdesc:a3c0c953951f141b35277fe2308777cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <a href="#a3c0c953951f141b35277fe2308777cff">More...</a><br/></td></tr>
<tr class="separator:a3c0c953951f141b35277fe2308777cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac360c5b10dbf87d81e346f2be7d19ade"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac360c5b10dbf87d81e346f2be7d19ade"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac360c5b10dbf87d81e346f2be7d19ade">num_elements</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ac360c5b10dbf87d81e346f2be7d19ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1, the number of elements in a primitive type.  <a href="#ac360c5b10dbf87d81e346f2be7d19ade">More...</a><br/></td></tr>
<tr class="separator:ac360c5b10dbf87d81e346f2be7d19ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e716815601bf5055a2d7fbfd8a757ea"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a3e716815601bf5055a2d7fbfd8a757ea"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3e716815601bf5055a2d7fbfd8a757ea">num_elements</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e716815601bf5055a2d7fbfd8a757ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the specified matrix.  <a href="#a3e716815601bf5055a2d7fbfd8a757ea">More...</a><br/></td></tr>
<tr class="separator:a3e716815601bf5055a2d7fbfd8a757ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a5d6d7f867666902fcd0adbe602920"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38a5d6d7f867666902fcd0adbe602920"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a38a5d6d7f867666902fcd0adbe602920">num_elements</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a38a5d6d7f867666902fcd0adbe602920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the specified vector.  <a href="#a38a5d6d7f867666902fcd0adbe602920">More...</a><br/></td></tr>
<tr class="separator:a38a5d6d7f867666902fcd0adbe602920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5062f9b21b2fb755ad3189fe236bed93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5062f9b21b2fb755ad3189fe236bed93"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5062f9b21b2fb755ad3189fe236bed93">ordered_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:a5062f9b21b2fb755ad3189fe236bed93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing ordered vector derived from the specified free vector.  <a href="#a5062f9b21b2fb755ad3189fe236bed93">More...</a><br/></td></tr>
<tr class="separator:a5062f9b21b2fb755ad3189fe236bed93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5638796e15590c237b7eaece1531631"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5638796e15590c237b7eaece1531631"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae5638796e15590c237b7eaece1531631">ordered_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, T &amp;lp)</td></tr>
<tr class="memdesc:ae5638796e15590c237b7eaece1531631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="#ae5638796e15590c237b7eaece1531631">More...</a><br/></td></tr>
<tr class="separator:ae5638796e15590c237b7eaece1531631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b3a9baaf02aeee0c15d763efa06b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a679b3a9baaf02aeee0c15d763efa06b0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a679b3a9baaf02aeee0c15d763efa06b0">ordered_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a679b3a9baaf02aeee0c15d763efa06b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained scalars that transform to the specified positive ordered vector.  <a href="#a679b3a9baaf02aeee0c15d763efa06b0">More...</a><br/></td></tr>
<tr class="separator:a679b3a9baaf02aeee0c15d763efa06b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada937f012b7d54cebdf8d9414f6fdbad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada937f012b7d54cebdf8d9414f6fdbad"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ada937f012b7d54cebdf8d9414f6fdbad">positive_ordered_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:ada937f012b7d54cebdf8d9414f6fdbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing positive ordered vector derived from the specified free vector.  <a href="#ada937f012b7d54cebdf8d9414f6fdbad">More...</a><br/></td></tr>
<tr class="separator:ada937f012b7d54cebdf8d9414f6fdbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7879746a7bed2564ae72c2916658e5a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7879746a7bed2564ae72c2916658e5a5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7879746a7bed2564ae72c2916658e5a5">positive_ordered_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, T &amp;lp)</td></tr>
<tr class="memdesc:a7879746a7bed2564ae72c2916658e5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing positive ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="#a7879746a7bed2564ae72c2916658e5a5">More...</a><br/></td></tr>
<tr class="separator:a7879746a7bed2564ae72c2916658e5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81e69a15e82f86eefba93f8dcd3966e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af81e69a15e82f86eefba93f8dcd3966e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af81e69a15e82f86eefba93f8dcd3966e">positive_ordered_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:af81e69a15e82f86eefba93f8dcd3966e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained scalars that transform to the specified positive ordered vector.  <a href="#af81e69a15e82f86eefba93f8dcd3966e">More...</a><br/></td></tr>
<tr class="separator:af81e69a15e82f86eefba93f8dcd3966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1649a895ec6e79097d5645a3f8b8a1e6">prod</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified standard vector.  <a href="#a1649a895ec6e79097d5645a3f8b8a1e6">More...</a><br/></td></tr>
<tr class="separator:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7082de8742d87f7a0fa0842207341c9"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ad7082de8742d87f7a0fa0842207341c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad7082de8742d87f7a0fa0842207341c9">prod</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ad7082de8742d87f7a0fa0842207341c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified column vector.  <a href="#ad7082de8742d87f7a0fa0842207341c9">More...</a><br/></td></tr>
<tr class="separator:ad7082de8742d87f7a0fa0842207341c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300cf63dd3332cff2161fdc32aec4026"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F &gt; </td></tr>
<tr class="memitem:a300cf63dd3332cff2161fdc32aec4026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a>&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a300cf63dd3332cff2161fdc32aec4026">promote_common</a> (const F &amp;u)</td></tr>
<tr class="separator:a300cf63dd3332cff2161fdc32aec4026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9559f36eb30f7c55b3576d8540b6bad2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9559f36eb30f7c55b3576d8540b6bad2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9559f36eb30f7c55b3576d8540b6bad2">qr_Q</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:a9559f36eb30f7c55b3576d8540b6bad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb8132560117eeef1a07ced4b144598"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebb8132560117eeef1a07ced4b144598"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aebb8132560117eeef1a07ced4b144598">qr_R</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="separator:aebb8132560117eeef1a07ced4b144598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f53cb144d0e550d5113e565a91a947"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB, typename T &gt; </td></tr>
<tr class="memitem:a88f53cb144d0e550d5113e565a91a947"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, CB, CB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88f53cb144d0e550d5113e565a91a947">quad_form</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a88f53cb144d0e550d5113e565a91a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute B^T A B.  <a href="#a88f53cb144d0e550d5113e565a91a947">More...</a><br/></td></tr>
<tr class="separator:a88f53cb144d0e550d5113e565a91a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8166027d80ecdbc607ef3c1c44fd1e8d"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, typename T &gt; </td></tr>
<tr class="memitem:a8166027d80ecdbc607ef3c1c44fd1e8d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8166027d80ecdbc607ef3c1c44fd1e8d">quad_form</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a8166027d80ecdbc607ef3c1c44fd1e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55363638ef70a37127901ecb57962048"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a55363638ef70a37127901ecb57962048"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; typename promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, Dynamic, <br class="typebreak"/>
Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a55363638ef70a37127901ecb57962048">quad_form_diag</a> (const Matrix&lt; T1, Dynamic, Dynamic &gt; &amp;mat, const Matrix&lt; T2, R, C &gt; &amp;vec)</td></tr>
<tr class="separator:a55363638ef70a37127901ecb57962048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4936ab9c3dab8c4194195de5aa398394"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB, typename T &gt; </td></tr>
<tr class="memitem:a4936ab9c3dab8c4194195de5aa398394"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, CB, CB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4936ab9c3dab8c4194195de5aa398394">quad_form_sym</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:a4936ab9c3dab8c4194195de5aa398394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0b2bfea6c360dcc5739fd908b39d60"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, typename T &gt; </td></tr>
<tr class="memitem:a8b0b2bfea6c360dcc5739fd908b39d60"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8b0b2bfea6c360dcc5739fd908b39d60">quad_form_sym</a> (const Eigen::Matrix&lt; T, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a8b0b2bfea6c360dcc5739fd908b39d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1baa9539e0a8d4ea50aa16b73d736d93">rank</a> (const std::vector&lt; T &gt; &amp;v, int s)</td></tr>
<tr class="memdesc:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="#a1baa9539e0a8d4ea50aa16b73d736d93">More...</a><br/></td></tr>
<tr class="separator:a1baa9539e0a8d4ea50aa16b73d736d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808d3133624cd36ac410ba872ea653c2"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a808d3133624cd36ac410ba872ea653c2"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a808d3133624cd36ac410ba872ea653c2">rank</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v, int s)</td></tr>
<tr class="memdesc:a808d3133624cd36ac410ba872ea653c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="#a808d3133624cd36ac410ba872ea653c2">More...</a><br/></td></tr>
<tr class="separator:a808d3133624cd36ac410ba872ea653c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f4b9ccc58d2d03aec434abb0795e41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57f4b9ccc58d2d03aec434abb0795e41"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a57f4b9ccc58d2d03aec434abb0795e41">read_corr_L</a> (const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, const size_t K)</td></tr>
<tr class="memdesc:a57f4b9ccc58d2d03aec434abb0795e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <a href="#a57f4b9ccc58d2d03aec434abb0795e41">More...</a><br/></td></tr>
<tr class="separator:a57f4b9ccc58d2d03aec434abb0795e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d327921ea7356872f0eec002c0b032"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6d327921ea7356872f0eec002c0b032"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af6d327921ea7356872f0eec002c0b032">read_corr_L</a> (const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, const size_t K, T &amp;log_prob)</td></tr>
<tr class="memdesc:af6d327921ea7356872f0eec002c0b032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <a href="#af6d327921ea7356872f0eec002c0b032">More...</a><br/></td></tr>
<tr class="separator:af6d327921ea7356872f0eec002c0b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2510336c2dac321c32b171f8ef407a06"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2510336c2dac321c32b171f8ef407a06"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2510336c2dac321c32b171f8ef407a06">read_corr_matrix</a> (const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, const size_t K)</td></tr>
<tr class="memdesc:a2510336c2dac321c32b171f8ef407a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <a href="#a2510336c2dac321c32b171f8ef407a06">More...</a><br/></td></tr>
<tr class="separator:a2510336c2dac321c32b171f8ef407a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c8a74b36fb456b0baf2d049427487b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09c8a74b36fb456b0baf2d049427487b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09c8a74b36fb456b0baf2d049427487b">read_corr_matrix</a> (const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, const size_t K, T &amp;log_prob)</td></tr>
<tr class="memdesc:a09c8a74b36fb456b0baf2d049427487b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <a href="#a09c8a74b36fb456b0baf2d049427487b">More...</a><br/></td></tr>
<tr class="separator:a09c8a74b36fb456b0baf2d049427487b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dc4b0fb00808b0d444b2c656c44c28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34dc4b0fb00808b0d444b2c656c44c28"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34dc4b0fb00808b0d444b2c656c44c28">read_cov_L</a> (const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;sds, T &amp;log_prob)</td></tr>
<tr class="memdesc:a34dc4b0fb00808b0d444b2c656c44c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function that should be called prior to evaluating the density of any elliptical distribution.  <a href="#a34dc4b0fb00808b0d444b2c656c44c28">More...</a><br/></td></tr>
<tr class="separator:a34dc4b0fb00808b0d444b2c656c44c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf731d715f789bfad7dbb712851c52e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecf731d715f789bfad7dbb712851c52e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aecf731d715f789bfad7dbb712851c52e">read_cov_matrix</a> (const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;sds, T &amp;log_prob)</td></tr>
<tr class="memdesc:aecf731d715f789bfad7dbb712851c52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generally worse alternative to call prior to evaluating the density of an elliptical distribution.  <a href="#aecf731d715f789bfad7dbb712851c52e">More...</a><br/></td></tr>
<tr class="separator:aecf731d715f789bfad7dbb712851c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bca98247a2b43a06388e08eade3ea5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60bca98247a2b43a06388e08eade3ea5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a60bca98247a2b43a06388e08eade3ea5">read_cov_matrix</a> (const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;CPCs, const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;sds)</td></tr>
<tr class="memdesc:a60bca98247a2b43a06388e08eade3ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a covariance matrix from CPCs and standard deviations.  <a href="#a60bca98247a2b43a06388e08eade3ea5">More...</a><br/></td></tr>
<tr class="separator:a60bca98247a2b43a06388e08eade3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc2f4a71f9187885d1fa61a79285eec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacc2f4a71f9187885d1fa61a79285eec"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, Eigen::Dynamic, <br class="typebreak"/>
Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aacc2f4a71f9187885d1fa61a79285eec">rep_matrix</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="separator:aacc2f4a71f9187885d1fa61a79285eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e90dfa0b0247bee1e9c739d5aee3b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44e90dfa0b0247bee1e9c739d5aee3b8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44e90dfa0b0247bee1e9c739d5aee3b8">rep_matrix</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, int n)</td></tr>
<tr class="separator:a44e90dfa0b0247bee1e9c739d5aee3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe06e42d623e4c975cd636d06bcd383"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbe06e42d623e4c975cd636d06bcd383"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acbe06e42d623e4c975cd636d06bcd383">rep_matrix</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, int m)</td></tr>
<tr class="separator:acbe06e42d623e4c975cd636d06bcd383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9320ac189d0991ef6200daed95bd3c2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9320ac189d0991ef6200daed95bd3c2d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9320ac189d0991ef6200daed95bd3c2d">rep_row_vector</a> (const T &amp;x, int m)</td></tr>
<tr class="separator:a9320ac189d0991ef6200daed95bd3c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f6ee7be13a0f7fa7cffa12204ba88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a323f6ee7be13a0f7fa7cffa12204ba88"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a323f6ee7be13a0f7fa7cffa12204ba88">rep_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a323f6ee7be13a0f7fa7cffa12204ba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf3ffa6d67a158348134225c9d3090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8abf3ffa6d67a158348134225c9d3090"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8abf3ffa6d67a158348134225c9d3090">resize</a> (T &amp;x, std::vector&lt; size_t &gt; <a class="el" href="namespacestan_1_1math.html#a2b9073e39033e56eb31344091f0170fd">dims</a>)</td></tr>
<tr class="memdesc:a8abf3ffa6d67a158348134225c9d3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices.  <a href="#a8abf3ffa6d67a158348134225c9d3090">More...</a><br/></td></tr>
<tr class="separator:a8abf3ffa6d67a158348134225c9d3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e74182d133e210dda425a689f2fb3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab98e74182d133e210dda425a689f2fb3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab98e74182d133e210dda425a689f2fb3">row</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i)</td></tr>
<tr class="memdesc:ab98e74182d133e210dda425a689f2fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified matrix, using start-at-1 indexing.  <a href="#ab98e74182d133e210dda425a689f2fb3">More...</a><br/></td></tr>
<tr class="separator:ab98e74182d133e210dda425a689f2fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb157990709e17068a450238d0a579fb"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:adb157990709e17068a450238d0a579fb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adb157990709e17068a450238d0a579fb">rows</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:adb157990709e17068a450238d0a579fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1fb33918f8c4e61cc7709905db012c"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6e1fb33918f8c4e61cc7709905db012c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6e1fb33918f8c4e61cc7709905db012c">rows_dot_product</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a6e1fb33918f8c4e61cc7709905db012c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="#a6e1fb33918f8c4e61cc7709905db012c">More...</a><br/></td></tr>
<tr class="separator:a6e1fb33918f8c4e61cc7709905db012c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae75387d4a15a928dfe2be6c987e2cb"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a1ae75387d4a15a928dfe2be6c987e2cb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1ae75387d4a15a928dfe2be6c987e2cb">rows_dot_self</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a1ae75387d4a15a928dfe2be6c987e2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <a href="#a1ae75387d4a15a928dfe2be6c987e2cb">More...</a><br/></td></tr>
<tr class="separator:a1ae75387d4a15a928dfe2be6c987e2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd02fe795ea38c98f4a02befed309f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34fd02fe795ea38c98f4a02befed309f"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34fd02fe795ea38c98f4a02befed309f">sd</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a34fd02fe795ea38c98f4a02befed309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified column vector.  <a href="#a34fd02fe795ea38c98f4a02befed309f">More...</a><br/></td></tr>
<tr class="separator:a34fd02fe795ea38c98f4a02befed309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1cb72c1528f0ff383033c642341147"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a8e1cb72c1528f0ff383033c642341147"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8e1cb72c1528f0ff383033c642341147">sd</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a8e1cb72c1528f0ff383033c642341147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified vector, row vector, or matrix.  <a href="#a8e1cb72c1528f0ff383033c642341147">More...</a><br/></td></tr>
<tr class="separator:a8e1cb72c1528f0ff383033c642341147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87f51c66f702f242b3c5d207896f5d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad87f51c66f702f242b3c5d207896f5d8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad87f51c66f702f242b3c5d207896f5d8">segment</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t i, size_t n)</td></tr>
<tr class="memdesc:ad87f51c66f702f242b3c5d207896f5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector starting from the specified element - 1 of the specified vector.  <a href="#ad87f51c66f702f242b3c5d207896f5d8">More...</a><br/></td></tr>
<tr class="separator:ad87f51c66f702f242b3c5d207896f5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6068f2afa41aeec7f65229719dfda963"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6068f2afa41aeec7f65229719dfda963"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6068f2afa41aeec7f65229719dfda963">segment</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;v, size_t i, size_t n)</td></tr>
<tr class="separator:a6068f2afa41aeec7f65229719dfda963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a721232b5c8e7c068a120719255f5fb0c">segment</a> (const std::vector&lt; T &gt; &amp;sv, size_t i, size_t n)</td></tr>
<tr class="separator:a721232b5c8e7c068a120719255f5fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6341abfdbb8a7f35432a73f27b131688"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6341abfdbb8a7f35432a73f27b131688"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6341abfdbb8a7f35432a73f27b131688">simplex_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a6341abfdbb8a7f35432a73f27b131688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <a href="#a6341abfdbb8a7f35432a73f27b131688">More...</a><br/></td></tr>
<tr class="separator:a6341abfdbb8a7f35432a73f27b131688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552a1c130bd90d93271bc9169b2e0ce2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a552a1c130bd90d93271bc9169b2e0ce2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a552a1c130bd90d93271bc9169b2e0ce2">simplex_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y, T &amp;lp)</td></tr>
<tr class="memdesc:a552a1c130bd90d93271bc9169b2e0ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="#a552a1c130bd90d93271bc9169b2e0ce2">More...</a><br/></td></tr>
<tr class="separator:a552a1c130bd90d93271bc9169b2e0ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110fab43edbb2ebb9206643900083971"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a110fab43edbb2ebb9206643900083971"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a110fab43edbb2ebb9206643900083971">simplex_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:a110fab43edbb2ebb9206643900083971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unconstrained vector that when transformed produces the specified simplex.  <a href="#a110fab43edbb2ebb9206643900083971">More...</a><br/></td></tr>
<tr class="separator:a110fab43edbb2ebb9206643900083971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56518b3d36f8b7ce72c9b8f4b77c8f22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56518b3d36f8b7ce72c9b8f4b77c8f22"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a56518b3d36f8b7ce72c9b8f4b77c8f22">singular_values</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a56518b3d36f8b7ce72c9b8f4b77c8f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of the singular values of the specified matrix in decreasing order of magnitude.  <a href="#a56518b3d36f8b7ce72c9b8f4b77c8f22">More...</a><br/></td></tr>
<tr class="separator:a56518b3d36f8b7ce72c9b8f4b77c8f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9966aade9c4515d33d3ffa7305462"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1f9966aade9c4515d33d3ffa7305462"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">size</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa1f9966aade9c4515d33d3ffa7305462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd226ffb6c2a089f2e133b74b5fed2b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd226ffb6c2a089f2e133b74b5fed2b0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acd226ffb6c2a089f2e133b74b5fed2b0">softmax</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:acd226ffb6c2a089f2e133b74b5fed2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified vector.  <a href="#acd226ffb6c2a089f2e133b74b5fed2b0">More...</a><br/></td></tr>
<tr class="separator:acd226ffb6c2a089f2e133b74b5fed2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a80f5418b16ea26e9bc6d2a8f9b764897">sort_asc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in ascending order.  <a href="#a80f5418b16ea26e9bc6d2a8f9b764897">More...</a><br/></td></tr>
<tr class="separator:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0b2712eab9b95535c0589455ed11cfc">sort_desc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:ab0b2712eab9b95535c0589455ed11cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in descending order.  <a href="#ab0b2712eab9b95535c0589455ed11cfc">More...</a><br/></td></tr>
<tr class="separator:ab0b2712eab9b95535c0589455ed11cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e46c9e96c0e88cc503e4b903247cce"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:af9e46c9e96c0e88cc503e4b903247cce"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af9e46c9e96c0e88cc503e4b903247cce">sort_asc</a> (Eigen::Matrix&lt; T, R, C &gt; xs)</td></tr>
<tr class="memdesc:af9e46c9e96c0e88cc503e4b903247cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in ascending order.  <a href="#af9e46c9e96c0e88cc503e4b903247cce">More...</a><br/></td></tr>
<tr class="separator:af9e46c9e96c0e88cc503e4b903247cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60648efc106b7596ddc356b765b6df81"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a60648efc106b7596ddc356b765b6df81"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a60648efc106b7596ddc356b765b6df81">sort_desc</a> (Eigen::Matrix&lt; T, R, C &gt; xs)</td></tr>
<tr class="memdesc:a60648efc106b7596ddc356b765b6df81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in descending order.  <a href="#a60648efc106b7596ddc356b765b6df81">More...</a><br/></td></tr>
<tr class="separator:a60648efc106b7596ddc356b765b6df81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4a13ccb29cba05ef0daa9712ee9bf7a3">sort_indices_asc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <a href="#a4a13ccb29cba05ef0daa9712ee9bf7a3">More...</a><br/></td></tr>
<tr class="separator:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a27f6f9085eb850e9e0fcb98df345aeba">sort_indices_desc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a27f6f9085eb850e9e0fcb98df345aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <a href="#a27f6f9085eb850e9e0fcb98df345aeba">More...</a><br/></td></tr>
<tr class="separator:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292e430d422bfe4984f9eaa1d20840ab"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a292e430d422bfe4984f9eaa1d20840ab"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a292e430d422bfe4984f9eaa1d20840ab">squared_distance</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a292e430d422bfe4984f9eaa1d20840ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance between the specified vectors.  <a href="#a292e430d422bfe4984f9eaa1d20840ab">More...</a><br/></td></tr>
<tr class="separator:a292e430d422bfe4984f9eaa1d20840ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c14b7fd70050f03a07fdf73a1df06d2">stan_print</a> (std::ostream *o, const T &amp;x)</td></tr>
<tr class="separator:a7c14b7fd70050f03a07fdf73a1df06d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a37cb2d874adcc950cb0439af044f549f">stan_print</a> (std::ostream *o, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a37cb2d874adcc950cb0439af044f549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94f7170ee85d4b353f55e3a044d2345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae94f7170ee85d4b353f55e3a044d2345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae94f7170ee85d4b353f55e3a044d2345">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x)</td></tr>
<tr class="separator:ae94f7170ee85d4b353f55e3a044d2345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad9c9057d71cf2795d0042f665c0f89c1">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x)</td></tr>
<tr class="separator:ad9c9057d71cf2795d0042f665c0f89c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adffa61a0521d0c07b8c4cd7ccbbb4aca">stan_print</a> (std::ostream *o, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x)</td></tr>
<tr class="separator:adffa61a0521d0c07b8c4cd7ccbbb4aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943cb439569c2dc588661a1cc171e2d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a943cb439569c2dc588661a1cc171e2d2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a943cb439569c2dc588661a1cc171e2d2">sub_col</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t nrows)</td></tr>
<tr class="memdesc:a943cb439569c2dc588661a1cc171e2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x 1 subcolumn starting at (i-1, j-1).  <a href="#a943cb439569c2dc588661a1cc171e2d2">More...</a><br/></td></tr>
<tr class="separator:a943cb439569c2dc588661a1cc171e2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019d635ee39f24b69c3f27e96bba4be1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a019d635ee39f24b69c3f27e96bba4be1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a019d635ee39f24b69c3f27e96bba4be1">sub_row</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m, size_t i, size_t j, size_t ncols)</td></tr>
<tr class="memdesc:a019d635ee39f24b69c3f27e96bba4be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x nrows subrow starting at (i-1, j-1).  <a href="#a019d635ee39f24b69c3f27e96bba4be1">More...</a><br/></td></tr>
<tr class="separator:a019d635ee39f24b69c3f27e96bba4be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba678d90cda4868c14d6d6bc6b509d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a38ba678d90cda4868c14d6d6bc6b509d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a38ba678d90cda4868c14d6d6bc6b509d">subtract</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m1, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m2)</td></tr>
<tr class="memdesc:a38ba678d90cda4868c14d6d6bc6b509d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the second specified matrix from the first specified matrix.  <a href="#a38ba678d90cda4868c14d6d6bc6b509d">More...</a><br/></td></tr>
<tr class="separator:a38ba678d90cda4868c14d6d6bc6b509d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fb2ca306088487251df70b19e73aff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a46fb2ca306088487251df70b19e73aff"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a46fb2ca306088487251df70b19e73aff">subtract</a> (const T1 &amp;c, const Eigen::Matrix&lt; T2, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a46fb2ca306088487251df70b19e73aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a3f79fa67648f8145c6692d19334b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a9a8a3f79fa67648f8145c6692d19334b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9a8a3f79fa67648f8145c6692d19334b">subtract</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;m, const T2 &amp;c)</td></tr>
<tr class="separator:a9a8a3f79fa67648f8145c6692d19334b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c32c2d7e895378feb11c99091765ad"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a44c32c2d7e895378feb11c99091765ad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44c32c2d7e895378feb11c99091765ad">sum</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:a44c32c2d7e895378feb11c99091765ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified column vector.  <a href="#a44c32c2d7e895378feb11c99091765ad">More...</a><br/></td></tr>
<tr class="separator:a44c32c2d7e895378feb11c99091765ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55548f1b502d1dd6283268b79fc41507"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55548f1b502d1dd6283268b79fc41507"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a55548f1b502d1dd6283268b79fc41507">tail</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, size_t n)</td></tr>
<tr class="memdesc:a55548f1b502d1dd6283268b79fc41507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector from the back of the specified vector.  <a href="#a55548f1b502d1dd6283268b79fc41507">More...</a><br/></td></tr>
<tr class="separator:a55548f1b502d1dd6283268b79fc41507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d79ddf4f28c8bd68ae569b94fb693c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d79ddf4f28c8bd68ae569b94fb693c6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7d79ddf4f28c8bd68ae569b94fb693c6">tail</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, size_t n)</td></tr>
<tr class="memdesc:a7d79ddf4f28c8bd68ae569b94fb693c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row vector from the back of the specified row vector.  <a href="#a7d79ddf4f28c8bd68ae569b94fb693c6">More...</a><br/></td></tr>
<tr class="separator:a7d79ddf4f28c8bd68ae569b94fb693c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9956cf78180c6340f61667e797cf7055">tail</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="separator:a9956cf78180c6340f61667e797cf7055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b07b3f7d18cdb710806c5793a83d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16b07b3f7d18cdb710806c5793a83d31">tcrossprod</a> (const <a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a> &amp;M)</td></tr>
<tr class="memdesc:a16b07b3f7d18cdb710806c5793a83d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="#a16b07b3f7d18cdb710806c5793a83d31">More...</a><br/></td></tr>
<tr class="separator:a16b07b3f7d18cdb710806c5793a83d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c990ca9770c6c37d883d87eb82eb6d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a88c990ca9770c6c37d883d87eb82eb6d"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88c990ca9770c6c37d883d87eb82eb6d">to_array_1d</a> (const Matrix&lt; T, R, C &gt; &amp;matrix)</td></tr>
<tr class="separator:a88c990ca9770c6c37d883d87eb82eb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad927f0ff9564aa04073f673d5e6bddfa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad927f0ff9564aa04073f673d5e6bddfa"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad927f0ff9564aa04073f673d5e6bddfa">to_array_1d</a> (const vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ad927f0ff9564aa04073f673d5e6bddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8108c33b0612c8fe8f47767fa1ca6ad1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8108c33b0612c8fe8f47767fa1ca6ad1"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; typename <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a><br class="typebreak"/>
&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8108c33b0612c8fe8f47767fa1ca6ad1">to_array_1d</a> (const vector&lt; vector&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="separator:a8108c33b0612c8fe8f47767fa1ca6ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdd0729c27213abdf446412e7f7793c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cdd0729c27213abdf446412e7f7793c"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cdd0729c27213abdf446412e7f7793c">to_array_2d</a> (const Matrix&lt; T, Dynamic, Dynamic &gt; &amp;matrix)</td></tr>
<tr class="separator:a6cdd0729c27213abdf446412e7f7793c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a142c1899afa9dea4bdc053e959bf7"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a95a142c1899afa9dea4bdc053e959bf7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a95a142c1899afa9dea4bdc053e959bf7">to_matrix</a> (Matrix&lt; T, R, C &gt; matrix)</td></tr>
<tr class="separator:a95a142c1899afa9dea4bdc053e959bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d53d7c1ac5bb3a3eff436d70b2cfbd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d53d7c1ac5bb3a3eff436d70b2cfbd6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d53d7c1ac5bb3a3eff436d70b2cfbd6">to_matrix</a> (const vector&lt; vector&lt; T &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:a3d53d7c1ac5bb3a3eff436d70b2cfbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5894e034cf63df686f4a32b78facbf"><td class="memItemLeft" align="right" valign="top">Matrix&lt; double, Dynamic, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaa5894e034cf63df686f4a32b78facbf">to_matrix</a> (const vector&lt; vector&lt; int &gt; &gt; &amp;vec)</td></tr>
<tr class="separator:aaa5894e034cf63df686f4a32b78facbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c7bf292d2f253217a813e6327899ce"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a69c7bf292d2f253217a813e6327899ce"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, 1, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69c7bf292d2f253217a813e6327899ce">to_row_vector</a> (const Matrix&lt; T, R, C &gt; &amp;matrix)</td></tr>
<tr class="separator:a69c7bf292d2f253217a813e6327899ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb83869b0604ee1a484547330db06f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8eb83869b0604ee1a484547330db06f"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, 1, Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab8eb83869b0604ee1a484547330db06f">to_row_vector</a> (const vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:ab8eb83869b0604ee1a484547330db06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e184ac2d303916513687b326bb01035"><td class="memItemLeft" align="right" valign="top">Matrix&lt; double, 1, Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0e184ac2d303916513687b326bb01035">to_row_vector</a> (const vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:a0e184ac2d303916513687b326bb01035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aa02a20972263242e2f6a8785cf58d"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae2aa02a20972263242e2f6a8785cf58d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae2aa02a20972263242e2f6a8785cf58d">to_vector</a> (const Matrix&lt; T, R, C &gt; &amp;matrix)</td></tr>
<tr class="separator:ae2aa02a20972263242e2f6a8785cf58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc7916ec81b929389e94c7fd725fd87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cc7916ec81b929389e94c7fd725fd87"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1cc7916ec81b929389e94c7fd725fd87">to_vector</a> (const vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a1cc7916ec81b929389e94c7fd725fd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc3b48fe1676d80fd5775f97f2b6a9a"><td class="memItemLeft" align="right" valign="top">Matrix&lt; double, Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2fc3b48fe1676d80fd5775f97f2b6a9a">to_vector</a> (const vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:a2fc3b48fe1676d80fd5775f97f2b6a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7001fd7e0296d5dae6ab0a88e1a28547">trace</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;m)</td></tr>
<tr class="memdesc:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of the specified matrix.  <a href="#a7001fd7e0296d5dae6ab0a88e1a28547">More...</a><br/></td></tr>
<tr class="separator:a7001fd7e0296d5dae6ab0a88e1a28547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb2aa245d794e2a6c352038f4811a37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fb2aa245d794e2a6c352038f4811a37"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8fb2aa245d794e2a6c352038f4811a37">trace</a> (const T &amp;m)</td></tr>
<tr class="separator:a8fb2aa245d794e2a6c352038f4811a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03da89fcbd2829c84a5beeb9ccbf2ccf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , int R1, int C1, int R2, int C2, int R3, int C3&gt; </td></tr>
<tr class="memitem:a03da89fcbd2829c84a5beeb9ccbf2ccf"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T1 &gt;::value <br class="typebreak"/>
&amp;&amp;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T2 &gt;::value <br class="typebreak"/>
&amp;&amp;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T3 &gt;::value, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2, T3 &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a03da89fcbd2829c84a5beeb9ccbf2ccf">trace_gen_inv_quad_form_ldlt</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;D, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;B)</td></tr>
<tr class="separator:a03da89fcbd2829c84a5beeb9ccbf2ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d402800ee27ba77d03dc3ec365d22e"><td class="memTemplParams" colspan="2">template&lt;int RD, int CD, int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a09d402800ee27ba77d03dc3ec365d22e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09d402800ee27ba77d03dc3ec365d22e">trace_gen_quad_form</a> (const Eigen::Matrix&lt; double, RD, CD &gt; &amp;D, const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a09d402800ee27ba77d03dc3ec365d22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(D B^T A B).  <a href="#a09d402800ee27ba77d03dc3ec365d22e">More...</a><br/></td></tr>
<tr class="separator:a09d402800ee27ba77d03dc3ec365d22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddc5785e5e629683ca0c3d11346d025"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R2, int C2, int R3, int C3&gt; </td></tr>
<tr class="memitem:aaddc5785e5e629683ca0c3d11346d025"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T1 &gt;::value <br class="typebreak"/>
&amp;&amp;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T2 &gt;::value, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaddc5785e5e629683ca0c3d11346d025">trace_inv_quad_form_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; T2, R3, C3 &gt; &amp;B)</td></tr>
<tr class="separator:aaddc5785e5e629683ca0c3d11346d025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097af33142548fd565d1dab2233fa3e5"><td class="memTemplParams" colspan="2">template&lt;int RA, int CA, int RB, int CB&gt; </td></tr>
<tr class="memitem:a097af33142548fd565d1dab2233fa3e5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a097af33142548fd565d1dab2233fa3e5">trace_quad_form</a> (const Eigen::Matrix&lt; double, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; double, RB, CB &gt; &amp;B)</td></tr>
<tr class="memdesc:a097af33142548fd565d1dab2233fa3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(B^T A B).  <a href="#a097af33142548fd565d1dab2233fa3e5">More...</a><br/></td></tr>
<tr class="separator:a097af33142548fd565d1dab2233fa3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f315f3af384f2d49a3a26eaef209ac"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a89f315f3af384f2d49a3a26eaef209ac"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a89f315f3af384f2d49a3a26eaef209ac">transpose</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a89f315f3af384f2d49a3a26eaef209ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a07474ecb0ca5f4fdbed0ce6957300f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a07474ecb0ca5f4fdbed0ce6957300f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3a07474ecb0ca5f4fdbed0ce6957300f">unit_vector_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a3a07474ecb0ca5f4fdbed0ce6957300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="#a3a07474ecb0ca5f4fdbed0ce6957300f">More...</a><br/></td></tr>
<tr class="separator:a3a07474ecb0ca5f4fdbed0ce6957300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac069d9e617c38341a12a33c73a7090d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac069d9e617c38341a12a33c73a7090d6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac069d9e617c38341a12a33c73a7090d6">unit_vector_constrain</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;y, T &amp;lp)</td></tr>
<tr class="memdesc:ac069d9e617c38341a12a33c73a7090d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="#ac069d9e617c38341a12a33c73a7090d6">More...</a><br/></td></tr>
<tr class="separator:ac069d9e617c38341a12a33c73a7090d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fb60ad466e375f68798ff25881e378"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65fb60ad466e375f68798ff25881e378"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a65fb60ad466e375f68798ff25881e378">unit_vector_free</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x)</td></tr>
<tr class="separator:a65fb60ad466e375f68798ff25881e378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ac4b37c5723681111ef69072288fd4"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ad6ac4b37c5723681111ef69072288fd4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename <br class="typebreak"/>
<a class="el" href="structstan_1_1math_1_1child__type.html">child_type</a>&lt; T &gt;::type, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad6ac4b37c5723681111ef69072288fd4">value_of</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;M)</td></tr>
<tr class="memdesc:ad6ac4b37c5723681111ef69072288fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix of type T to a matrix of doubles.  <a href="#ad6ac4b37c5723681111ef69072288fd4">More...</a><br/></td></tr>
<tr class="separator:ad6ac4b37c5723681111ef69072288fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b0847f7611d8f396a1f4e112200185"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:ae6b0847f7611d8f396a1f4e112200185"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae6b0847f7611d8f396a1f4e112200185">value_of_rec</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;M)</td></tr>
<tr class="memdesc:ae6b0847f7611d8f396a1f4e112200185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix of type T to a matrix of doubles.  <a href="#ae6b0847f7611d8f396a1f4e112200185">More...</a><br/></td></tr>
<tr class="separator:ae6b0847f7611d8f396a1f4e112200185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa433ac2fc47bbd40a6d87f62574dff85">variance</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa433ac2fc47bbd40a6d87f62574dff85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector.  <a href="#aa433ac2fc47bbd40a6d87f62574dff85">More...</a><br/></td></tr>
<tr class="separator:aa433ac2fc47bbd40a6d87f62574dff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f055da8754c2215aac70d7787692f54"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a1f055da8754c2215aac70d7787692f54"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f055da8754c2215aac70d7787692f54">variance</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a1f055da8754c2215aac70d7787692f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified column vector.  <a href="#a1f055da8754c2215aac70d7787692f54">More...</a><br/></td></tr>
<tr class="separator:a1f055da8754c2215aac70d7787692f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34b9d54bbdc2b13f358a73a3dface45"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab34b9d54bbdc2b13f358a73a3dface45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab34b9d54bbdc2b13f358a73a3dface45">finite_diff_gradient</a> (const F &amp;f, const Eigen::Matrix&lt; double,-1, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double,-1, 1 &gt; &amp;grad_fx, const double epsilon=1e-03)</td></tr>
<tr class="memdesc:ab34b9d54bbdc2b13f358a73a3dface45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument using finite difference.  <a href="#ab34b9d54bbdc2b13f358a73a3dface45">More...</a><br/></td></tr>
<tr class="separator:ab34b9d54bbdc2b13f358a73a3dface45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfae14a02b57bee53b454f64b58c0b1"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a9cfae14a02b57bee53b454f64b58c0b1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9cfae14a02b57bee53b454f64b58c0b1">finite_diff_hess_helper</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const int lambda, const double epsilon=1e-03)</td></tr>
<tr class="separator:a9cfae14a02b57bee53b454f64b58c0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6ed64f691a457cb6691d7b478b4a1d"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a8b6ed64f691a457cb6691d7b478b4a1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8b6ed64f691a457cb6691d7b478b4a1d">finite_diff_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double,-1, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double,-1, 1 &gt; &amp;grad_fx, Eigen::Matrix&lt; double,-1,-1 &gt; &amp;hess_fx, const double epsilon=1e-03)</td></tr>
<tr class="memdesc:a8b6ed64f691a457cb6691d7b478b4a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the Hessian of the specified function at the specified argument using second-order finite difference.  <a href="#a8b6ed64f691a457cb6691d7b478b4a1d">More...</a><br/></td></tr>
<tr class="separator:a8b6ed64f691a457cb6691d7b478b4a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ce356e75d8d7be0126bb00c401afa"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob &gt; </td></tr>
<tr class="memitem:a583ce356e75d8d7be0126bb00c401afa"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a583ce356e75d8d7be0126bb00c401afa">categorical_log</a> (int n, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="separator:a583ce356e75d8d7be0126bb00c401afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e12bdd3e7ba1450f8b44ea5a59b0dd"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:a41e12bdd3e7ba1450f8b44ea5a59b0dd"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a41e12bdd3e7ba1450f8b44ea5a59b0dd">categorical_log</a> (const typename <a class="el" href="structstan_1_1math_1_1index__type.html">math::index_type</a>&lt; Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &gt;::type n, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="separator:a41e12bdd3e7ba1450f8b44ea5a59b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e388c974ca67ecc06e9c67f75067f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob &gt; </td></tr>
<tr class="memitem:a089e388c974ca67ecc06e9c67f75067f"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a089e388c974ca67ecc06e9c67f75067f">categorical_log</a> (const std::vector&lt; int &gt; &amp;ns, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="separator:a089e388c974ca67ecc06e9c67f75067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabce8d1a6154b04d2689f604b2e2373b"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:aabce8d1a6154b04d2689f604b2e2373b"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aabce8d1a6154b04d2689f604b2e2373b">categorical_log</a> (const std::vector&lt; int &gt; &amp;ns, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="separator:aabce8d1a6154b04d2689f604b2e2373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35594af0b1635f8bc2817ca8a2c767f2"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob &gt; </td></tr>
<tr class="memitem:a35594af0b1635f8bc2817ca8a2c767f2"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a35594af0b1635f8bc2817ca8a2c767f2">categorical_logit_log</a> (int n, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;beta)</td></tr>
<tr class="separator:a35594af0b1635f8bc2817ca8a2c767f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea64526bd00e285844c6eb1246ccf431"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:aea64526bd00e285844c6eb1246ccf431"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aea64526bd00e285844c6eb1246ccf431">categorical_logit_log</a> (int n, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;beta)</td></tr>
<tr class="separator:aea64526bd00e285844c6eb1246ccf431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06f8075869ffd32c8a0385e57bc2170"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob &gt; </td></tr>
<tr class="memitem:ac06f8075869ffd32c8a0385e57bc2170"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac06f8075869ffd32c8a0385e57bc2170">categorical_logit_log</a> (const std::vector&lt; int &gt; &amp;ns, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;beta)</td></tr>
<tr class="separator:ac06f8075869ffd32c8a0385e57bc2170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35ff747de556a8f351efda0e986a832"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:ac35ff747de556a8f351efda0e986a832"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac35ff747de556a8f351efda0e986a832">categorical_logit_log</a> (const std::vector&lt; int &gt; &amp;ns, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;beta)</td></tr>
<tr class="separator:ac35ff747de556a8f351efda0e986a832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f8b55cdaa59f3fe7718d5b45889cda6">categorical_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;theta, RNG &amp;rng)</td></tr>
<tr class="separator:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301c4fce1eeb151070f72a81c33ccde4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_sample_size &gt; </td></tr>
<tr class="memitem:a301c4fce1eeb151070f72a81c33ccde4"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob, T_prior_sample_size &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a301c4fce1eeb151070f72a81c33ccde4">dirichlet_log</a> (const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta, const Eigen::Matrix&lt; T_prior_sample_size, Eigen::Dynamic, 1 &gt; &amp;alpha)</td></tr>
<tr class="memdesc:a301c4fce1eeb151070f72a81c33ccde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha.  <a href="#a301c4fce1eeb151070f72a81c33ccde4">More...</a><br/></td></tr>
<tr class="separator:a301c4fce1eeb151070f72a81c33ccde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610a90b8b664189d397c8549c2aa0214"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_prior_sample_size &gt; </td></tr>
<tr class="memitem:a610a90b8b664189d397c8549c2aa0214"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob, T_prior_sample_size &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a610a90b8b664189d397c8549c2aa0214">dirichlet_log</a> (const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta, const Eigen::Matrix&lt; T_prior_sample_size, Eigen::Dynamic, 1 &gt; &amp;alpha)</td></tr>
<tr class="separator:a610a90b8b664189d397c8549c2aa0214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb288324f889b7da57f2960570f459ea"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:acb288324f889b7da57f2960570f459ea"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acb288324f889b7da57f2960570f459ea">dirichlet_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="memdesc:acb288324f889b7da57f2960570f459ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Dirichlet distribution with specified parameters and pseudo-random number generator.  <a href="#acb288324f889b7da57f2960570f459ea">More...</a><br/></td></tr>
<tr class="separator:acb288324f889b7da57f2960570f459ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439b46e03e6dbd7269b60989cf31de85"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:a439b46e03e6dbd7269b60989cf31de85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_F, T_G, T_V, <br class="typebreak"/>
T_W, T_m0, T_C0 &gt;::type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a439b46e03e6dbd7269b60989cf31de85">gaussian_dlm_obs_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;F, const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;G, const Eigen::Matrix&lt; T_V, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;V, const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;m0, const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;C0)</td></tr>
<tr class="memdesc:a439b46e03e6dbd7269b60989cf31de85"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a Gaussian dynamic linear model (GDLM).  <a href="#a439b46e03e6dbd7269b60989cf31de85">More...</a><br/></td></tr>
<tr class="separator:a439b46e03e6dbd7269b60989cf31de85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7da6e923e5a19bed55c94a109d2e4cd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:ad7da6e923e5a19bed55c94a109d2e4cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_F, T_G, T_V, <br class="typebreak"/>
T_W, T_m0, T_C0 &gt;::type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad7da6e923e5a19bed55c94a109d2e4cd">gaussian_dlm_obs_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;F, const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;G, const Eigen::Matrix&lt; T_V, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;V, const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;m0, const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;C0)</td></tr>
<tr class="separator:ad7da6e923e5a19bed55c94a109d2e4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a72bf8a0cfb7fd70089f9fb7fb5ce9a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:a9a72bf8a0cfb7fd70089f9fb7fb5ce9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_F, T_G, T_V, <br class="typebreak"/>
T_W, T_m0, T_C0 &gt;::type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9a72bf8a0cfb7fd70089f9fb7fb5ce9a">gaussian_dlm_obs_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;F, const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;G, const Eigen::Matrix&lt; T_V, Eigen::Dynamic, 1 &gt; &amp;V, const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;m0, const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;C0)</td></tr>
<tr class="memdesc:a9a72bf8a0cfb7fd70089f9fb7fb5ce9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a Gaussian dynamic linear model (GDLM) with uncorrelated observation disturbances.  <a href="#a9a72bf8a0cfb7fd70089f9fb7fb5ce9a">More...</a><br/></td></tr>
<tr class="separator:a9a72bf8a0cfb7fd70089f9fb7fb5ce9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ad1baa9f1a423304ac19aa0e345075"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:a99ad1baa9f1a423304ac19aa0e345075"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, typename <br class="typebreak"/>
<a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_F, T_G, T_V, <br class="typebreak"/>
T_W, T_m0, T_C0 &gt;::type &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a99ad1baa9f1a423304ac19aa0e345075">gaussian_dlm_obs_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;F, const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;G, const Eigen::Matrix&lt; T_V, Eigen::Dynamic, 1 &gt; &amp;V, const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;m0, const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;C0)</td></tr>
<tr class="separator:a99ad1baa9f1a423304ac19aa0e345075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c063912bf059644103aaf8787f71e9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a56c063912bf059644103aaf8787f71e9"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_dof, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a56c063912bf059644103aaf8787f71e9">inv_wishart_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const T_dof &amp;nu, const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S)</td></tr>
<tr class="memdesc:a56c063912bf059644103aaf8787f71e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Inverse-Wishart density for the given W, degrees of freedom, and scale matrix.  <a href="#a56c063912bf059644103aaf8787f71e9">More...</a><br/></td></tr>
<tr class="separator:a56c063912bf059644103aaf8787f71e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f8f9a5add1c91cbe30c887265da81f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a96f8f9a5add1c91cbe30c887265da81f"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_dof, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a96f8f9a5add1c91cbe30c887265da81f">inv_wishart_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const T_dof &amp;nu, const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S)</td></tr>
<tr class="separator:a96f8f9a5add1c91cbe30c887265da81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639b9495c8bb2917100b52b7ed889d3c"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a639b9495c8bb2917100b52b7ed889d3c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a639b9495c8bb2917100b52b7ed889d3c">inv_wishart_rng</a> (const double nu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:a639b9495c8bb2917100b52b7ed889d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0399f5f1c54dbda27be7f12d7d888e1d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:a0399f5f1c54dbda27be7f12d7d888e1d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_covar, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0399f5f1c54dbda27be7f12d7d888e1d">lkj_corr_cholesky_log</a> (const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:a0399f5f1c54dbda27be7f12d7d888e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e9853bf29b95ed22f4342bd2ac1629"><td class="memTemplParams" colspan="2">template&lt;typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:ac6e9853bf29b95ed22f4342bd2ac1629"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_covar, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac6e9853bf29b95ed22f4342bd2ac1629">lkj_corr_cholesky_log</a> (const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:ac6e9853bf29b95ed22f4342bd2ac1629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873e4c1def8700568d76f9296bbd8d24"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a873e4c1def8700568d76f9296bbd8d24"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a873e4c1def8700568d76f9296bbd8d24">lkj_corr_cholesky_rng</a> (const size_t K, const double eta, RNG &amp;rng)</td></tr>
<tr class="separator:a873e4c1def8700568d76f9296bbd8d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3832e36ec9ea72ce740753adb3b0d132"><td class="memTemplParams" colspan="2">template&lt;typename T_shape &gt; </td></tr>
<tr class="memitem:a3832e36ec9ea72ce740753adb3b0d132"><td class="memTemplItemLeft" align="right" valign="top">T_shape&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3832e36ec9ea72ce740753adb3b0d132">do_lkj_constant</a> (const T_shape &amp;eta, const unsigned int &amp;K)</td></tr>
<tr class="separator:a3832e36ec9ea72ce740753adb3b0d132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cb454dc9397439a74c185da61a3d5e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:af0cb454dc9397439a74c185da61a3d5e"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af0cb454dc9397439a74c185da61a3d5e">lkj_corr_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:af0cb454dc9397439a74c185da61a3d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015685882d7704cd76e15e5966e42b5e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:a015685882d7704cd76e15e5966e42b5e"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a015685882d7704cd76e15e5966e42b5e">lkj_corr_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:a015685882d7704cd76e15e5966e42b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a32027fc9306df3c5a0418fa44826fa"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a7a32027fc9306df3c5a0418fa44826fa"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7a32027fc9306df3c5a0418fa44826fa">lkj_corr_rng</a> (const size_t K, const double eta, RNG &amp;rng)</td></tr>
<tr class="separator:a7a32027fc9306df3c5a0418fa44826fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5d029cbf5c052432705dc9ad334df6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a4d5d029cbf5c052432705dc9ad334df6"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_loc, T_scale, T_shape &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d5d029cbf5c052432705dc9ad334df6">lkj_cov_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_loc, Eigen::Dynamic, 1 &gt; &amp;mu, const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, 1 &gt; &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:a4d5d029cbf5c052432705dc9ad334df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfaea69c195f4531f7688a19fc7bd14"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a3cfaea69c195f4531f7688a19fc7bd14"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_loc, T_scale, T_shape &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3cfaea69c195f4531f7688a19fc7bd14">lkj_cov_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_loc, Eigen::Dynamic, 1 &gt; &amp;mu, const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, 1 &gt; &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:a3cfaea69c195f4531f7688a19fc7bd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5295c9eddd1e8643bb1c9fa0fb284917"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a5295c9eddd1e8643bb1c9fa0fb284917"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_loc, T_scale, T_shape &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5295c9eddd1e8643bb1c9fa0fb284917">lkj_cov_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:a5295c9eddd1e8643bb1c9fa0fb284917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a8d3846d804d39d6f0883e54aa2c7e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ab0a8d3846d804d39d6f0883e54aa2c7e"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_loc, T_scale, T_shape &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab0a8d3846d804d39d6f0883e54aa2c7e">lkj_cov_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:ab0a8d3846d804d39d6f0883e54aa2c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb895ef1190ad6e77185e70a3fa66d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D &gt; </td></tr>
<tr class="memitem:a3feb895ef1190ad6e77185e70a3fa66d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_Mu, T_Sigma, T_D &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3feb895ef1190ad6e77185e70a3fa66d">matrix_normal_prec_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_Mu, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Mu, const Eigen::Matrix&lt; T_Sigma, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Sigma, const Eigen::Matrix&lt; T_D, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;D)</td></tr>
<tr class="memdesc:a3feb895ef1190ad6e77185e70a3fa66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the matrix normal density for the given y, mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices.  <a href="#a3feb895ef1190ad6e77185e70a3fa66d">More...</a><br/></td></tr>
<tr class="separator:a3feb895ef1190ad6e77185e70a3fa66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add509bb48f33e775f906f8e9e0c0c4f9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_Mu , typename T_Sigma , typename T_D &gt; </td></tr>
<tr class="memitem:add509bb48f33e775f906f8e9e0c0c4f9"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_Mu, T_Sigma, T_D &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add509bb48f33e775f906f8e9e0c0c4f9">matrix_normal_prec_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_Mu, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Mu, const Eigen::Matrix&lt; T_Sigma, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Sigma, const Eigen::Matrix&lt; T_D, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;D)</td></tr>
<tr class="separator:add509bb48f33e775f906f8e9e0c0c4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d240bac837d28cf3d5922de0271cf8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:a07d240bac837d28cf3d5922de0271cf8"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_covar, T_w &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a07d240bac837d28cf3d5922de0271cf8">multi_gp_cholesky_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;L, const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a07d240bac837d28cf3d5922de0271cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, w, and a Cholesky factor L of the kernel matrix Sigma.  <a href="#a07d240bac837d28cf3d5922de0271cf8">More...</a><br/></td></tr>
<tr class="separator:a07d240bac837d28cf3d5922de0271cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ed8a0eabcdfa57bc7fde011d30bf8c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:a44ed8a0eabcdfa57bc7fde011d30bf8c"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_covar, T_w &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44ed8a0eabcdfa57bc7fde011d30bf8c">multi_gp_cholesky_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;L, const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;w)</td></tr>
<tr class="separator:a44ed8a0eabcdfa57bc7fde011d30bf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b27063a645fbb1e20add3cc5f2aed5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:a74b27063a645fbb1e20add3cc5f2aed5"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_covar, T_w &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a74b27063a645fbb1e20add3cc5f2aed5">multi_gp_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Sigma, const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a74b27063a645fbb1e20add3cc5f2aed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, Sigma, and w.  <a href="#a74b27063a645fbb1e20add3cc5f2aed5">More...</a><br/></td></tr>
<tr class="separator:a74b27063a645fbb1e20add3cc5f2aed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3535a644a9ec735e4c5ed0951909d1ab"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:a3535a644a9ec735e4c5ed0951909d1ab"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_covar, T_w &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3535a644a9ec735e4c5ed0951909d1ab">multi_gp_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Sigma, const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;w)</td></tr>
<tr class="separator:a3535a644a9ec735e4c5ed0951909d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c48789407296b1fd9497d3e27ef26d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a73c48789407296b1fd9497d3e27ef26d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_covar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73c48789407296b1fd9497d3e27ef26d">multi_normal_cholesky_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="memdesc:a73c48789407296b1fd9497d3e27ef26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix.  <a href="#a73c48789407296b1fd9497d3e27ef26d">More...</a><br/></td></tr>
<tr class="separator:a73c48789407296b1fd9497d3e27ef26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5aed6517d1de44fc193a8bf7b018bfe"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:af5aed6517d1de44fc193a8bf7b018bfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_covar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af5aed6517d1de44fc193a8bf7b018bfe">multi_normal_cholesky_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:af5aed6517d1de44fc193a8bf7b018bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a05ae7884660def13b35c9d3d59a708"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a0a05ae7884660def13b35c9d3d59a708"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0a05ae7884660def13b35c9d3d59a708">multi_normal_cholesky_rng</a> (const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;mu, const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:a0a05ae7884660def13b35c9d3d59a708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa873591f0954b506eb709537a73f8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a69fa873591f0954b506eb709537a73f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_covar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a69fa873591f0954b506eb709537a73f8">multi_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a69fa873591f0954b506eb709537a73f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c98c7961178da90570cb63499eb2b8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a38c98c7961178da90570cb63499eb2b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_covar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a38c98c7961178da90570cb63499eb2b8">multi_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a38c98c7961178da90570cb63499eb2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fb51aaff3da3d727bc12a3cdd106c5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a83fb51aaff3da3d727bc12a3cdd106c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_covar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a83fb51aaff3da3d727bc12a3cdd106c5">multi_normal_prec_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a83fb51aaff3da3d727bc12a3cdd106c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79191e304518140dbaf8feaab2c90aab"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a79191e304518140dbaf8feaab2c90aab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_covar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a79191e304518140dbaf8feaab2c90aab">multi_normal_prec_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a79191e304518140dbaf8feaab2c90aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c260fca0e710ffa12410e53da4cbc0"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a46c260fca0e710ffa12410e53da4cbc0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a46c260fca0e710ffa12410e53da4cbc0">multi_normal_rng</a> (const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;mu, const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:a46c260fca0e710ffa12410e53da4cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b9a72ca7018cbf7883d7104345b4f6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ac7b9a72ca7018cbf7883d7104345b4f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac7b9a72ca7018cbf7883d7104345b4f6">multi_student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="memdesc:ac7b9a72ca7018cbf7883d7104345b4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the multivariate Student t distribution at the specified arguments.  <a href="#ac7b9a72ca7018cbf7883d7104345b4f6">More...</a><br/></td></tr>
<tr class="separator:ac7b9a72ca7018cbf7883d7104345b4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1b7da1cebae4c8db3067f614c777aa"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a1e1b7da1cebae4c8db3067f614c777aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1e1b7da1cebae4c8db3067f614c777aa">multi_student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="separator:a1e1b7da1cebae4c8db3067f614c777aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9dfb65a8ae0210632ae0c42b2ae5c6"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aca9dfb65a8ae0210632ae0c42b2ae5c6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aca9dfb65a8ae0210632ae0c42b2ae5c6">multi_student_t_rng</a> (const double nu, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;mu, const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;s, RNG &amp;rng)</td></tr>
<tr class="separator:aca9dfb65a8ae0210632ae0c42b2ae5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b47c026be99de35988287412664e3d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob &gt; </td></tr>
<tr class="memitem:a65b47c026be99de35988287412664e3d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a65b47c026be99de35988287412664e3d">multinomial_log</a> (const std::vector&lt; int &gt; &amp;ns, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="separator:a65b47c026be99de35988287412664e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23c14c3cb5d40c6fa46b89ddc5d5285"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:ae23c14c3cb5d40c6fa46b89ddc5d5285"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae23c14c3cb5d40c6fa46b89ddc5d5285">multinomial_log</a> (const std::vector&lt; int &gt; &amp;ns, const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;theta)</td></tr>
<tr class="separator:ae23c14c3cb5d40c6fa46b89ddc5d5285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab77cc7ea8b9f49a61abe7576c8331"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a99ab77cc7ea8b9f49a61abe7576c8331"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a99ab77cc7ea8b9f49a61abe7576c8331">multinomial_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;theta, const int N, RNG &amp;rng)</td></tr>
<tr class="separator:a99ab77cc7ea8b9f49a61abe7576c8331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e08116b9ebf4a6592aa9f8fa393669"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4e08116b9ebf4a6592aa9f8fa393669"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad4e08116b9ebf4a6592aa9f8fa393669">log_inv_logit_diff</a> (const T &amp;alpha, const T &amp;beta)</td></tr>
<tr class="separator:ad4e08116b9ebf4a6592aa9f8fa393669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae845ae3d07989bc9976a15f52caa997"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_lambda , typename T_cut &gt; </td></tr>
<tr class="memitem:aae845ae3d07989bc9976a15f52caa997"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_lambda, T_cut &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aae845ae3d07989bc9976a15f52caa997">ordered_logistic_log</a> (int y, const T_lambda &amp;lambda, const Eigen::Matrix&lt; T_cut, Eigen::Dynamic, 1 &gt; &amp;c)</td></tr>
<tr class="memdesc:aae845ae3d07989bc9976a15f52caa997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the specified integer outcome given the continuous location and specified cutpoints in an ordered logistic model.  <a href="#aae845ae3d07989bc9976a15f52caa997">More...</a><br/></td></tr>
<tr class="separator:aae845ae3d07989bc9976a15f52caa997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5623d34d128b956b6dfb2031150c8c87"><td class="memTemplParams" colspan="2">template&lt;typename T_lambda , typename T_cut &gt; </td></tr>
<tr class="memitem:a5623d34d128b956b6dfb2031150c8c87"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_lambda, T_cut &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5623d34d128b956b6dfb2031150c8c87">ordered_logistic_log</a> (int y, const T_lambda &amp;lambda, const Eigen::Matrix&lt; T_cut, Eigen::Dynamic, 1 &gt; &amp;c)</td></tr>
<tr class="separator:a5623d34d128b956b6dfb2031150c8c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432a3d83d286fe609fc79c6ef4f8ea74"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a432a3d83d286fe609fc79c6ef4f8ea74"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a432a3d83d286fe609fc79c6ef4f8ea74">ordered_logistic_rng</a> (const double eta, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;c, RNG &amp;rng)</td></tr>
<tr class="separator:a432a3d83d286fe609fc79c6ef4f8ea74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91db893054b635d18034d06c161365a1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a91db893054b635d18034d06c161365a1"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_dof, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a91db893054b635d18034d06c161365a1">wishart_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const T_dof &amp;nu, const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S)</td></tr>
<tr class="memdesc:a91db893054b635d18034d06c161365a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Wishart density for the given W, degrees of freedom, and scale matrix.  <a href="#a91db893054b635d18034d06c161365a1">More...</a><br/></td></tr>
<tr class="separator:a91db893054b635d18034d06c161365a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a06ccbb12ca44a08544000372dbf1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a951a06ccbb12ca44a08544000372dbf1"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_y, T_dof, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a951a06ccbb12ca44a08544000372dbf1">wishart_log</a> (const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;W, const T_dof &amp;nu, const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S)</td></tr>
<tr class="separator:a951a06ccbb12ca44a08544000372dbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7025b4916694aa80aa0d758a11647b5d"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a7025b4916694aa80aa0d758a11647b5d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7025b4916694aa80aa0d758a11647b5d">wishart_rng</a> (const double nu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:a7025b4916694aa80aa0d758a11647b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d53b31b377bc3fc120d6469af3d99e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a16d53b31b377bc3fc120d6469af3d99e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a16d53b31b377bc3fc120d6469af3d99e">check_bounded</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, const T_high &amp;high)</td></tr>
<tr class="memdesc:a16d53b31b377bc3fc120d6469af3d99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the value is between the low and high values, inclusively.  <a href="#a16d53b31b377bc3fc120d6469af3d99e">More...</a><br/></td></tr>
<tr class="separator:a16d53b31b377bc3fc120d6469af3d99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6b6ab798e2f2a2ffad6b244efab0a58f">check_consistent_size</a> (const char *function, const char *name, const T &amp;x, size_t expected_size)</td></tr>
<tr class="memdesc:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x is consistent, which is defined to be <code>expected_size</code> if x is a vector or 1 if x is not a vector.  <a href="#a6b6ab798e2f2a2ffad6b244efab0a58f">More...</a><br/></td></tr>
<tr class="separator:a6b6ab798e2f2a2ffad6b244efab0a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8e8b8fb2cc649fc1f34e75d0b1fe2ca3">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2)</td></tr>
<tr class="memdesc:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x1 is consistent with x2.  <a href="#a8e8b8fb2cc649fc1f34e75d0b1fe2ca3">More...</a><br/></td></tr>
<tr class="separator:a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2fa5d10851fe1307ed7a0ffb768ff861">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const char *name3, const T3 &amp;x3)</td></tr>
<tr class="memdesc:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x1, x2, and x3 are consistent.  <a href="#a2fa5d10851fe1307ed7a0ffb768ff861">More...</a><br/></td></tr>
<tr class="separator:a2fa5d10851fe1307ed7a0ffb768ff861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817ff4687b2d9d98f7f7bf82e9286266"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:a817ff4687b2d9d98f7f7bf82e9286266"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a817ff4687b2d9d98f7f7bf82e9286266">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const char *name3, const T3 &amp;x3, const char *name4, const T4 &amp;x4)</td></tr>
<tr class="memdesc:a817ff4687b2d9d98f7f7bf82e9286266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the dimension of x1, x2, x3, and x4 are consistent.  <a href="#a817ff4687b2d9d98f7f7bf82e9286266">More...</a><br/></td></tr>
<tr class="separator:a817ff4687b2d9d98f7f7bf82e9286266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8496e1bd1273f06de6712e3fb81e2c3f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </td></tr>
<tr class="memitem:a8496e1bd1273f06de6712e3fb81e2c3f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8496e1bd1273f06de6712e3fb81e2c3f">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const char *name3, const T3 &amp;x3, const char *name4, const T4 &amp;x4, const char *name5, const T5 &amp;x5)</td></tr>
<tr class="separator:a8496e1bd1273f06de6712e3fb81e2c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_eq &gt; </td></tr>
<tr class="memitem:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1d8cfae284cdae1bb7e83d2a136f9a04">check_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_eq &amp;eq)</td></tr>
<tr class="memdesc:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is equal to <code>eq</code>.  <a href="#a1d8cfae284cdae1bb7e83d2a136f9a04">More...</a><br/></td></tr>
<tr class="separator:a1d8cfae284cdae1bb7e83d2a136f9a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf014e7733b17748049ccc5f3565de3"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a5bf014e7733b17748049ccc5f3565de3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5bf014e7733b17748049ccc5f3565de3">check_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a5bf014e7733b17748049ccc5f3565de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is finite.  <a href="#a5bf014e7733b17748049ccc5f3565de3">More...</a><br/></td></tr>
<tr class="separator:a5bf014e7733b17748049ccc5f3565de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low &gt; </td></tr>
<tr class="memitem:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad60ac97b8f74b7c5ce2feb4bdb9e09e0">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low)</td></tr>
<tr class="memdesc:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is strictly greater than <code>low</code>.  <a href="#ad60ac97b8f74b7c5ce2feb4bdb9e09e0">More...</a><br/></td></tr>
<tr class="separator:ad60ac97b8f74b7c5ce2feb4bdb9e09e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5b19f8930c14681349d8444142487e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low &gt; </td></tr>
<tr class="memitem:a3d5b19f8930c14681349d8444142487e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d5b19f8930c14681349d8444142487e">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low)</td></tr>
<tr class="memdesc:a3d5b19f8930c14681349d8444142487e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is greater or equal than <code>low</code>.  <a href="#a3d5b19f8930c14681349d8444142487e">More...</a><br/></td></tr>
<tr class="separator:a3d5b19f8930c14681349d8444142487e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab225792149dceaec443ce09b93f8744"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:aab225792149dceaec443ce09b93f8744"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab225792149dceaec443ce09b93f8744">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high)</td></tr>
<tr class="memdesc:aab225792149dceaec443ce09b93f8744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is strictly less than <code>high</code>.  <a href="#aab225792149dceaec443ce09b93f8744">More...</a><br/></td></tr>
<tr class="separator:aab225792149dceaec443ce09b93f8744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9dd0895901bf876eca824b41f04003"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:a5e9dd0895901bf876eca824b41f04003"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e9dd0895901bf876eca824b41f04003">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high)</td></tr>
<tr class="memdesc:a5e9dd0895901bf876eca824b41f04003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is less or equal to <code>high</code>.  <a href="#a5e9dd0895901bf876eca824b41f04003">More...</a><br/></td></tr>
<tr class="separator:a5e9dd0895901bf876eca824b41f04003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6be100befb6d08504cf5af8440b236"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a7a6be100befb6d08504cf5af8440b236"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7a6be100befb6d08504cf5af8440b236">check_nonnegative</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a7a6be100befb6d08504cf5af8440b236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is non-negative.  <a href="#a7a6be100befb6d08504cf5af8440b236">More...</a><br/></td></tr>
<tr class="separator:a7a6be100befb6d08504cf5af8440b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c3c23033e47a923ed5ce26a4deeba5"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a97c3c23033e47a923ed5ce26a4deeba5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a97c3c23033e47a923ed5ce26a4deeba5">check_nonzero_size</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a97c3c23033e47a923ed5ce26a4deeba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified matrix/vector is of non-zero size.  <a href="#a97c3c23033e47a923ed5ce26a4deeba5">More...</a><br/></td></tr>
<tr class="separator:a97c3c23033e47a923ed5ce26a4deeba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7942532ef8f89cee24af75a383835ee1"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a7942532ef8f89cee24af75a383835ee1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7942532ef8f89cee24af75a383835ee1">check_not_nan</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a7942532ef8f89cee24af75a383835ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is not <code>NaN</code>.  <a href="#a7942532ef8f89cee24af75a383835ee1">More...</a><br/></td></tr>
<tr class="separator:a7942532ef8f89cee24af75a383835ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814694b1125e641ca7b2e7269c82f966"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a814694b1125e641ca7b2e7269c82f966"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a814694b1125e641ca7b2e7269c82f966">check_positive</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a814694b1125e641ca7b2e7269c82f966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is positive.  <a href="#a814694b1125e641ca7b2e7269c82f966">More...</a><br/></td></tr>
<tr class="separator:a814694b1125e641ca7b2e7269c82f966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0725693b09e454f5c8327ac89cf0245"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:af0725693b09e454f5c8327ac89cf0245"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af0725693b09e454f5c8327ac89cf0245">check_positive_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:af0725693b09e454f5c8327ac89cf0245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is positive and finite.  <a href="#af0725693b09e454f5c8327ac89cf0245">More...</a><br/></td></tr>
<tr class="separator:af0725693b09e454f5c8327ac89cf0245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe1398a136f3dc36d246a2ea747500"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac6fe1398a136f3dc36d246a2ea747500">check_positive_size</a> (const char *function, const char *name, const char *expr, const int <a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">size</a>)</td></tr>
<tr class="memdesc:ac6fe1398a136f3dc36d246a2ea747500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>size</code> is positive.  <a href="#ac6fe1398a136f3dc36d246a2ea747500">More...</a><br/></td></tr>
<tr class="separator:ac6fe1398a136f3dc36d246a2ea747500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa547146eaac690e79a611e50a6dffb4d"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:aa547146eaac690e79a611e50a6dffb4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa547146eaac690e79a611e50a6dffb4d">check_size_match</a> (const char *function, const char *name_i, T_size1 i, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:aa547146eaac690e79a611e50a6dffb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the provided sizes match.  <a href="#aa547146eaac690e79a611e50a6dffb4d">More...</a><br/></td></tr>
<tr class="separator:aa547146eaac690e79a611e50a6dffb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c66b22fce7bd878b687d550299eb248"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a0c66b22fce7bd878b687d550299eb248"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0c66b22fce7bd878b687d550299eb248">check_size_match</a> (const char *function, const char *expr_i, const char *name_i, T_size1 i, const char *expr_j, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:a0c66b22fce7bd878b687d550299eb248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the provided sizes match.  <a href="#a0c66b22fce7bd878b687d550299eb248">More...</a><br/></td></tr>
<tr class="separator:a0c66b22fce7bd878b687d550299eb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeebafad688145fc64353e4f455d014bd">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:aeebafad688145fc64353e4f455d014bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#aeebafad688145fc64353e4f455d014bd">More...</a><br/></td></tr>
<tr class="separator:aeebafad688145fc64353e4f455d014bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a108d489a4a749c8e429b519d9e26c157">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:a108d489a4a749c8e429b519d9e26c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#a108d489a4a749c8e429b519d9e26c157">More...</a><br/></td></tr>
<tr class="separator:a108d489a4a749c8e429b519d9e26c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23bfe9ebcb5747ed175a59b2182072"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c23bfe9ebcb5747ed175a59b2182072"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7c23bfe9ebcb5747ed175a59b2182072">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a7c23bfe9ebcb5747ed175a59b2182072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#a7c23bfe9ebcb5747ed175a59b2182072">More...</a><br/></td></tr>
<tr class="separator:a7c23bfe9ebcb5747ed175a59b2182072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f55be80da8ff729d5850c653d2b28d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3f55be80da8ff729d5850c653d2b28d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3f55be80da8ff729d5850c653d2b28d">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg)</td></tr>
<tr class="memdesc:ae3f55be80da8ff729d5850c653d2b28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="#ae3f55be80da8ff729d5850c653d2b28d">More...</a><br/></td></tr>
<tr class="separator:ae3f55be80da8ff729d5850c653d2b28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9bcb1af5657f92ccadf5204fc43377fd">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a9bcb1af5657f92ccadf5204fc43377fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <a href="#a9bcb1af5657f92ccadf5204fc43377fd">More...</a><br/></td></tr>
<tr class="separator:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aacf5709c614035ef60053a348e18554c">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:aacf5709c614035ef60053a348e18554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <a href="#aacf5709c614035ef60053a348e18554c">More...</a><br/></td></tr>
<tr class="separator:aacf5709c614035ef60053a348e18554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b2630385b99ef7045818ba8fe2a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add7b2630385b99ef7045818ba8fe2a97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add7b2630385b99ef7045818ba8fe2a97">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:add7b2630385b99ef7045818ba8fe2a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <a href="#add7b2630385b99ef7045818ba8fe2a97">More...</a><br/></td></tr>
<tr class="separator:add7b2630385b99ef7045818ba8fe2a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a8690ee903eea7e5847e4d93483f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a309a8690ee903eea7e5847e4d93483f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a309a8690ee903eea7e5847e4d93483f4">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, const size_t i, const char *msg)</td></tr>
<tr class="memdesc:a309a8690ee903eea7e5847e4d93483f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <a href="#a309a8690ee903eea7e5847e4d93483f4">More...</a><br/></td></tr>
<tr class="separator:a309a8690ee903eea7e5847e4d93483f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34583d3983ee4d61d09004ce3e278250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34583d3983ee4d61d09004ce3e278250">out_of_range</a> (const char *function, const int <a class="el" href="namespacestan_1_1math.html#a5da0ef87756d3dbd20ca4ff5a3efa10d">max</a>, const int index, const char *msg1=&quot;&quot;, const char *msg2=&quot;&quot;)</td></tr>
<tr class="memdesc:a34583d3983ee4d61d09004ce3e278250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an out_of_range exception with a consistently formatted message.  <a href="#a34583d3983ee4d61d09004ce3e278250">More...</a><br/></td></tr>
<tr class="separator:a34583d3983ee4d61d09004ce3e278250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4764556637084eee528b45d8eaa767"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeb4764556637084eee528b45d8eaa767">abs</a> (double x)</td></tr>
<tr class="memdesc:aeb4764556637084eee528b45d8eaa767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return floating-point absolute value.  <a href="#aeb4764556637084eee528b45d8eaa767">More...</a><br/></td></tr>
<tr class="separator:aeb4764556637084eee528b45d8eaa767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec93b560b654740be65de81d6f348cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ec93b560b654740be65de81d6f348cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ec93b560b654740be65de81d6f348cc">as_bool</a> (const T x)</td></tr>
<tr class="memdesc:a3ec93b560b654740be65de81d6f348cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the argument is unequal to zero and 0 otherwise.  <a href="#a3ec93b560b654740be65de81d6f348cc">More...</a><br/></td></tr>
<tr class="separator:a3ec93b560b654740be65de81d6f348cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb3835848bd8550192cd5e090d3b5a"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:aebfb3835848bd8550192cd5e090d3b5a"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aebfb3835848bd8550192cd5e090d3b5a">bessel_first_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:aebfb3835848bd8550192cd5e090d3b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_first\_kind}(v, x) = \begin{cases} J_v(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_26.png"/>
</p>
  <a href="#aebfb3835848bd8550192cd5e090d3b5a">More...</a><br/></td></tr>
<tr class="separator:aebfb3835848bd8550192cd5e090d3b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ce13c6454913ec39be807751604dc"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a645ce13c6454913ec39be807751604dc"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a645ce13c6454913ec39be807751604dc">bessel_second_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:a645ce13c6454913ec39be807751604dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_second\_kind}(v, x) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0 \\ Y_v(x) &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_30.png"/>
</p>
  <a href="#a645ce13c6454913ec39be807751604dc">More...</a><br/></td></tr>
<tr class="separator:a645ce13c6454913ec39be807751604dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a043f562537b8cc57bb35780ac5b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add2a043f562537b8cc57bb35780ac5b5"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add2a043f562537b8cc57bb35780ac5b5">binary_log_loss</a> (const int y, const T y_hat)</td></tr>
<tr class="memdesc:add2a043f562537b8cc57bb35780ac5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log loss function for binary classification with specified reference and response values.  <a href="#add2a043f562537b8cc57bb35780ac5b5">More...</a><br/></td></tr>
<tr class="separator:add2a043f562537b8cc57bb35780ac5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dad23d38c6d5e74c65e7571c70272e"><td class="memTemplParams" colspan="2">template&lt;typename T_N , typename T_n &gt; </td></tr>
<tr class="memitem:a27dad23d38c6d5e74c65e7571c70272e"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_N, T_n &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a27dad23d38c6d5e74c65e7571c70272e">binomial_coefficient_log</a> (const T_N N, const T_n n)</td></tr>
<tr class="memdesc:a27dad23d38c6d5e74c65e7571c70272e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the binomial coefficient for the specified arguments.  <a href="#a27dad23d38c6d5e74c65e7571c70272e">More...</a><br/></td></tr>
<tr class="separator:a27dad23d38c6d5e74c65e7571c70272e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffd66726e0532160e16e6b48d6f428"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa2ffd66726e0532160e16e6b48d6f428">pi</a> ()</td></tr>
<tr class="memdesc:aa2ffd66726e0532160e16e6b48d6f428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of pi.  <a href="#aa2ffd66726e0532160e16e6b48d6f428">More...</a><br/></td></tr>
<tr class="separator:aa2ffd66726e0532160e16e6b48d6f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b650a0131d41167ef4837ecc7d02be5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a> ()</td></tr>
<tr class="memdesc:a3b650a0131d41167ef4837ecc7d02be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base of the natural logarithm.  <a href="#a3b650a0131d41167ef4837ecc7d02be5">More...</a><br/></td></tr>
<tr class="separator:a3b650a0131d41167ef4837ecc7d02be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1369f60a09e3af4933096de3a54ac28c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1369f60a09e3af4933096de3a54ac28c">sqrt2</a> ()</td></tr>
<tr class="memdesc:a1369f60a09e3af4933096de3a54ac28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of two.  <a href="#a1369f60a09e3af4933096de3a54ac28c">More...</a><br/></td></tr>
<tr class="separator:a1369f60a09e3af4933096de3a54ac28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4f7c092e2bc9a089885628b86c004"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a21f4f7c092e2bc9a089885628b86c004">log10</a> ()</td></tr>
<tr class="memdesc:a21f4f7c092e2bc9a089885628b86c004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of ten.  <a href="#a21f4f7c092e2bc9a089885628b86c004">More...</a><br/></td></tr>
<tr class="separator:a21f4f7c092e2bc9a089885628b86c004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34675a70d3df614d88d33ddbdd49b49a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34675a70d3df614d88d33ddbdd49b49a">positive_infinity</a> ()</td></tr>
<tr class="memdesc:a34675a70d3df614d88d33ddbdd49b49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity.  <a href="#a34675a70d3df614d88d33ddbdd49b49a">More...</a><br/></td></tr>
<tr class="separator:a34675a70d3df614d88d33ddbdd49b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bffe91b7a24cb29bd69cb60814c39e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34bffe91b7a24cb29bd69cb60814c39e">negative_infinity</a> ()</td></tr>
<tr class="memdesc:a34bffe91b7a24cb29bd69cb60814c39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return negative infinity.  <a href="#a34bffe91b7a24cb29bd69cb60814c39e">More...</a><br/></td></tr>
<tr class="separator:a34bffe91b7a24cb29bd69cb60814c39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381493bccc58bd993d797a2a5458c486"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a381493bccc58bd993d797a2a5458c486">not_a_number</a> ()</td></tr>
<tr class="memdesc:a381493bccc58bd993d797a2a5458c486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (quiet) not-a-number.  <a href="#a381493bccc58bd993d797a2a5458c486">More...</a><br/></td></tr>
<tr class="separator:a381493bccc58bd993d797a2a5458c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173839dddd0a8ac8afa710b9e3d5008a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a173839dddd0a8ac8afa710b9e3d5008a">machine_precision</a> ()</td></tr>
<tr class="memdesc:a173839dddd0a8ac8afa710b9e3d5008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference between 1.0 and the next value representable.  <a href="#a173839dddd0a8ac8afa710b9e3d5008a">More...</a><br/></td></tr>
<tr class="separator:a173839dddd0a8ac8afa710b9e3d5008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3c8aa139b956593524b01f21c971a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a3c8aa139b956593524b01f21c971a1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6a3c8aa139b956593524b01f21c971a1">corr_constrain</a> (const T x)</td></tr>
<tr class="memdesc:a6a3c8aa139b956593524b01f21c971a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar to have a valid correlation value between -1 and 1 (inclusive).  <a href="#a6a3c8aa139b956593524b01f21c971a1">More...</a><br/></td></tr>
<tr class="separator:a6a3c8aa139b956593524b01f21c971a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c9589bc6f6d15d7455de5ad453c8e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c9589bc6f6d15d7455de5ad453c8e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a40c9589bc6f6d15d7455de5ad453c8e6">corr_constrain</a> (const T x, T &amp;lp)</td></tr>
<tr class="memdesc:a40c9589bc6f6d15d7455de5ad453c8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar to have a valid correlation value between -1 and 1 (inclusive).  <a href="#a40c9589bc6f6d15d7455de5ad453c8e6">More...</a><br/></td></tr>
<tr class="separator:a40c9589bc6f6d15d7455de5ad453c8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9322e1f1baeb5a192c4972dbec311b4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9322e1f1baeb5a192c4972dbec311b4e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9322e1f1baeb5a192c4972dbec311b4e">corr_free</a> (const T y)</td></tr>
<tr class="memdesc:a9322e1f1baeb5a192c4972dbec311b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained scalar that when transformed to a valid correlation produces the specified value.  <a href="#a9322e1f1baeb5a192c4972dbec311b4e">More...</a><br/></td></tr>
<tr class="separator:a9322e1f1baeb5a192c4972dbec311b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb54ce92709046c6d168e851d2481c7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5eb54ce92709046c6d168e851d2481c7">digamma</a> (double x)</td></tr>
<tr class="memdesc:a5eb54ce92709046c6d168e851d2481c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{digamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \Psi(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_54.png"/>
</p>
  <a href="#a5eb54ce92709046c6d168e851d2481c7">More...</a><br/></td></tr>
<tr class="separator:a5eb54ce92709046c6d168e851d2481c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf04cebee51d38a543e0ec689ae1399c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aaf04cebee51d38a543e0ec689ae1399c">divide</a> (const int x, const int y)</td></tr>
<tr class="separator:aaf04cebee51d38a543e0ec689ae1399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef734d7c3b8ebd689012295bf826e94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ef734d7c3b8ebd689012295bf826e94"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0ef734d7c3b8ebd689012295bf826e94">exp2</a> (const T y)</td></tr>
<tr class="memdesc:a0ef734d7c3b8ebd689012295bf826e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponent base 2 of the specified argument (C99).  <a href="#a0ef734d7c3b8ebd689012295bf826e94">More...</a><br/></td></tr>
<tr class="separator:a0ef734d7c3b8ebd689012295bf826e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2421cf831c518a6260f60d19eb5c32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada2421cf831c518a6260f60d19eb5c32"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ada2421cf831c518a6260f60d19eb5c32">F32</a> (T a, T b, T c, T d, T <a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, T z, T precision=1e-6)</td></tr>
<tr class="separator:ada2421cf831c518a6260f60d19eb5c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65933117ab43cb486fb65023d8e5f3c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad65933117ab43cb486fb65023d8e5f3c"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad65933117ab43cb486fb65023d8e5f3c">falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:ad65933117ab43cb486fb65023d8e5f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{falling\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_58.png"/>
</p>
  <a href="#ad65933117ab43cb486fb65023d8e5f3c">More...</a><br/></td></tr>
<tr class="separator:ad65933117ab43cb486fb65023d8e5f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7d2db622c0f83134b7f3ebd1eec3c1d6">fdim</a> (T1 a, T2 b)</td></tr>
<tr class="memdesc:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The positive difference function (C99).  <a href="#a7d2db622c0f83134b7f3ebd1eec3c1d6">More...</a><br/></td></tr>
<tr class="separator:a7d2db622c0f83134b7f3ebd1eec3c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed411d626d4ae01a76584c454a83673f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aed411d626d4ae01a76584c454a83673f">gamma_p</a> (double x, double a)</td></tr>
<tr class="memdesc:aed411d626d4ae01a76584c454a83673f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_p}(a, z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ P(a, z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_64.png"/>
</p>
  <a href="#aed411d626d4ae01a76584c454a83673f">More...</a><br/></td></tr>
<tr class="separator:aed411d626d4ae01a76584c454a83673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0830ba049b81bc98ea9fbcf1eb7b4bd6">gamma_q</a> (double x, double a)</td></tr>
<tr class="memdesc:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_q}(a, z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ Q(a, z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_70.png"/>
</p>
  <a href="#a0830ba049b81bc98ea9fbcf1eb7b4bd6">More...</a><br/></td></tr>
<tr class="separator:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43226a00b6c2d3f3a2ab5906490f3136"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43226a00b6c2d3f3a2ab5906490f3136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a43226a00b6c2d3f3a2ab5906490f3136">grad_2F1</a> (T &amp;gradA, T &amp;gradC, T a, T b, T c, T z, T precision=1e-6)</td></tr>
<tr class="separator:a43226a00b6c2d3f3a2ab5906490f3136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd0b6c85425c2005e265d8e66852a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02dd0b6c85425c2005e265d8e66852a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a02dd0b6c85425c2005e265d8e66852a8">grad_F32</a> (T *g, T a, T b, T c, T d, T <a class="el" href="namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, T z, T precision=1e-6)</td></tr>
<tr class="separator:a02dd0b6c85425c2005e265d8e66852a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cb272bd839945c13d7b41058c35c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a33cb272bd839945c13d7b41058c35c51">grad_inc_beta</a> (double &amp;g1, double &amp;g2, double a, double b, double z)</td></tr>
<tr class="separator:a33cb272bd839945c13d7b41058c35c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eeb59eb3ae4f0710a7e417478c1212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11eeb59eb3ae4f0710a7e417478c1212"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a11eeb59eb3ae4f0710a7e417478c1212">grad_reg_inc_beta</a> (T &amp;g1, T &amp;g2, T a, T b, T z, T digammaA, T digammaB, T digammaSum, T betaAB)</td></tr>
<tr class="separator:a11eeb59eb3ae4f0710a7e417478c1212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6336e9873f3029f5abe54c4914c71cb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6336e9873f3029f5abe54c4914c71cb2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6336e9873f3029f5abe54c4914c71cb2">grad_reg_inc_gamma</a> (T a, T z, T g, T dig, T precision=1e-6)</td></tr>
<tr class="separator:a6336e9873f3029f5abe54c4914c71cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b430ac57e75ba2d55843cd868506e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af7b430ac57e75ba2d55843cd868506e1">ibeta</a> (const double a, const double b, const double x)</td></tr>
<tr class="memdesc:af7b430ac57e75ba2d55843cd868506e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normalized incomplete beta function of a, b, and x.  <a href="#af7b430ac57e75ba2d55843cd868506e1">More...</a><br/></td></tr>
<tr class="separator:af7b430ac57e75ba2d55843cd868506e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7ea9a437cf38e48ec72cec173d7465"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa7ea9a437cf38e48ec72cec173d7465"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afa7ea9a437cf38e48ec72cec173d7465">identity_constrain</a> (T x)</td></tr>
<tr class="memdesc:afa7ea9a437cf38e48ec72cec173d7465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the identity constraint transform to the input.  <a href="#afa7ea9a437cf38e48ec72cec173d7465">More...</a><br/></td></tr>
<tr class="separator:afa7ea9a437cf38e48ec72cec173d7465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7925ed2737df76a38ae17c13f85e9141"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7925ed2737df76a38ae17c13f85e9141"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7925ed2737df76a38ae17c13f85e9141">identity_constrain</a> (const T x, T &amp;)</td></tr>
<tr class="memdesc:a7925ed2737df76a38ae17c13f85e9141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the identity constraint transform to the input and increments the log probability reference with the log absolute Jacobian determinant.  <a href="#a7925ed2737df76a38ae17c13f85e9141">More...</a><br/></td></tr>
<tr class="separator:a7925ed2737df76a38ae17c13f85e9141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50a1ae328bd1f7195b0c77a16a684ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac50a1ae328bd1f7195b0c77a16a684ab"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac50a1ae328bd1f7195b0c77a16a684ab">identity_free</a> (const T y)</td></tr>
<tr class="memdesc:ac50a1ae328bd1f7195b0c77a16a684ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the inverse of the identity constraint transform to the input.  <a href="#ac50a1ae328bd1f7195b0c77a16a684ab">More...</a><br/></td></tr>
<tr class="separator:ac50a1ae328bd1f7195b0c77a16a684ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e2d3e3ab44f347f3ebaacb67845015"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false &gt; </td></tr>
<tr class="memitem:a65e2d3e3ab44f347f3ebaacb67845015"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_true, T_false &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a65e2d3e3ab44f347f3ebaacb67845015">if_else</a> (const bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:a65e2d3e3ab44f347f3ebaacb67845015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second argument if the first argument is true and otherwise return the second argument.  <a href="#a65e2d3e3ab44f347f3ebaacb67845015">More...</a><br/></td></tr>
<tr class="separator:a65e2d3e3ab44f347f3ebaacb67845015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01192e5a2e1c208f78818b57b4d6aa78"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a01192e5a2e1c208f78818b57b4d6aa78">inc_beta</a> (const double &amp;a, const double &amp;b, const double &amp;x)</td></tr>
<tr class="separator:a01192e5a2e1c208f78818b57b4d6aa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afc99a6a1e74fd1daeab96f7eeb3b05a8">inc_beta_ddb</a> (T a, T b, T z, T digamma_b, T digamma_ab)</td></tr>
<tr class="memdesc:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to b.  <a href="#afc99a6a1e74fd1daeab96f7eeb3b05a8">More...</a><br/></td></tr>
<tr class="separator:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c265eb14e915edc9bd457e93aaaf166"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c265eb14e915edc9bd457e93aaaf166"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9c265eb14e915edc9bd457e93aaaf166">inc_beta_dda</a> (T a, T b, T z, T digamma_a, T digamma_ab)</td></tr>
<tr class="memdesc:a9c265eb14e915edc9bd457e93aaaf166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to a.  <a href="#a9c265eb14e915edc9bd457e93aaaf166">More...</a><br/></td></tr>
<tr class="separator:a9c265eb14e915edc9bd457e93aaaf166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2412f96d2114b4c15efb1ddbddaef35b">inc_beta_ddz</a> (T a, T b, T z)</td></tr>
<tr class="memdesc:a2412f96d2114b4c15efb1ddbddaef35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to z.  <a href="#a2412f96d2114b4c15efb1ddbddaef35b">More...</a><br/></td></tr>
<tr class="separator:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3e5957e2cb19140e6c7bacf5c68320b7">inc_beta_ddz</a> (double a, double b, double z)</td></tr>
<tr class="separator:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c507cff4b7b473cd86e1d428fb03136"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c507cff4b7b473cd86e1d428fb03136"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8c507cff4b7b473cd86e1d428fb03136">int_step</a> (const T y)</td></tr>
<tr class="memdesc:a8c507cff4b7b473cd86e1d428fb03136"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer step, or Heaviside, function.  <a href="#a8c507cff4b7b473cd86e1d428fb03136">More...</a><br/></td></tr>
<tr class="separator:a8c507cff4b7b473cd86e1d428fb03136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64935e0bdac8227bfd9608285d4e699"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab64935e0bdac8227bfd9608285d4e699"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab64935e0bdac8227bfd9608285d4e699">inv</a> (const T x)</td></tr>
<tr class="separator:ab64935e0bdac8227bfd9608285d4e699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a008bf0b6c2ab38d088b0aba5d7b10c8d">inv_cloglog</a> (T x)</td></tr>
<tr class="memdesc:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <a href="#a008bf0b6c2ab38d088b0aba5d7b10c8d">More...</a><br/></td></tr>
<tr class="separator:a008bf0b6c2ab38d088b0aba5d7b10c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad2c4834fc581f55acf8491ec3f80ecb7">inv_logit</a> (const T a)</td></tr>
<tr class="memdesc:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse logit function applied to the argument.  <a href="#ad2c4834fc581f55acf8491ec3f80ecb7">More...</a><br/></td></tr>
<tr class="separator:ad2c4834fc581f55acf8491ec3f80ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4b4db5e98585c71cc7c14319f96e0c04">inv_sqrt</a> (const T x)</td></tr>
<tr class="separator:a4b4db5e98585c71cc7c14319f96e0c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3d2e922aa13e2dfae510fc13d86eaea3">inv_square</a> (const T x)</td></tr>
<tr class="separator:a3d2e922aa13e2dfae510fc13d86eaea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edc35cc581dda178263f6a4a4fd1158"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a1edc35cc581dda178263f6a4a4fd1158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1edc35cc581dda178263f6a4a4fd1158">inverse_softmax</a> (const Vector &amp;simplex, Vector &amp;y)</td></tr>
<tr class="memdesc:a1edc35cc581dda178263f6a4a4fd1158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the inverse softmax of the simplex argument into the second argument.  <a href="#a1edc35cc581dda178263f6a4a4fd1158">More...</a><br/></td></tr>
<tr class="separator:a1edc35cc581dda178263f6a4a4fd1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0020ce04cad9a5eb9b55abb690863fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae0020ce04cad9a5eb9b55abb690863fa">is_inf</a> (const double x)</td></tr>
<tr class="memdesc:ae0020ce04cad9a5eb9b55abb690863fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input is infinite and 0 otherwise.  <a href="#ae0020ce04cad9a5eb9b55abb690863fa">More...</a><br/></td></tr>
<tr class="separator:ae0020ce04cad9a5eb9b55abb690863fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01488df30a81c36b1a00391b9541e1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae01488df30a81c36b1a00391b9541e1d">is_nan</a> (double x)</td></tr>
<tr class="memdesc:ae01488df30a81c36b1a00391b9541e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input is NaN and 0 otherwise.  <a href="#ae01488df30a81c36b1a00391b9541e1d">More...</a><br/></td></tr>
<tr class="separator:ae01488df30a81c36b1a00391b9541e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a40c14c26dc55a985e05695b3ff1eeef2">is_uninitialized</a> (T x)</td></tr>
<tr class="memdesc:a40c14c26dc55a985e05695b3ff1eeef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <a href="#a40c14c26dc55a985e05695b3ff1eeef2">More...</a><br/></td></tr>
<tr class="separator:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02477dd575f3d242826df72489faac4c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TL &gt; </td></tr>
<tr class="memitem:a02477dd575f3d242826df72489faac4c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a02477dd575f3d242826df72489faac4c">lb_constrain</a> (const T x, const TL lb)</td></tr>
<tr class="memdesc:a02477dd575f3d242826df72489faac4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <a href="#a02477dd575f3d242826df72489faac4c">More...</a><br/></td></tr>
<tr class="separator:a02477dd575f3d242826df72489faac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8344b3154a81f8601776582238bac99f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TL &gt; </td></tr>
<tr class="memitem:a8344b3154a81f8601776582238bac99f"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TL &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8344b3154a81f8601776582238bac99f">lb_constrain</a> (const T x, const TL lb, T &amp;lp)</td></tr>
<tr class="memdesc:a8344b3154a81f8601776582238bac99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the speicifed unconstrained input and specified lower bound, incrementing the specified reference with the log absolute Jacobian determinant of the transform.  <a href="#a8344b3154a81f8601776582238bac99f">More...</a><br/></td></tr>
<tr class="separator:a8344b3154a81f8601776582238bac99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e416b7c30dd2ea4fc78254732fa8a52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TL &gt; </td></tr>
<tr class="memitem:a0e416b7c30dd2ea4fc78254732fa8a52"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TL &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0e416b7c30dd2ea4fc78254732fa8a52">lb_free</a> (const T y, const TL lb)</td></tr>
<tr class="memdesc:a0e416b7c30dd2ea4fc78254732fa8a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained value that produces the specified lower-bound constrained value.  <a href="#a0e416b7c30dd2ea4fc78254732fa8a52">More...</a><br/></td></tr>
<tr class="separator:a0e416b7c30dd2ea4fc78254732fa8a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37c166c79a3e66d101d682b3474f6ab"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af37c166c79a3e66d101d682b3474f6ab"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af37c166c79a3e66d101d682b3474f6ab">lbeta</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:af37c166c79a3e66d101d682b3474f6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the beta function applied to the specified arguments.  <a href="#af37c166c79a3e66d101d682b3474f6ab">More...</a><br/></td></tr>
<tr class="separator:af37c166c79a3e66d101d682b3474f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836f46d7f63f5118a32cad11382c0551"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a836f46d7f63f5118a32cad11382c0551">lgamma</a> (double x)</td></tr>
<tr class="memdesc:a836f46d7f63f5118a32cad11382c0551"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lgamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \ln\Gamma(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_95.png"/>
</p>
  <a href="#a836f46d7f63f5118a32cad11382c0551">More...</a><br/></td></tr>
<tr class="separator:a836f46d7f63f5118a32cad11382c0551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0ee0706b2cb6d2e1da2c3b6041c06a56">lmgamma</a> (const int k, T x)</td></tr>
<tr class="memdesc:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the multivariate gamma function with the speciifed dimensions and argument.  <a href="#a0ee0706b2cb6d2e1da2c3b6041c06a56">More...</a><br/></td></tr>
<tr class="separator:a0ee0706b2cb6d2e1da2c3b6041c06a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f92092fb8a70b31d00898bbbe769612"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f92092fb8a70b31d00898bbbe769612"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4f92092fb8a70b31d00898bbbe769612">log1m</a> (T x)</td></tr>
<tr class="memdesc:a4f92092fb8a70b31d00898bbbe769612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the specified value.  <a href="#a4f92092fb8a70b31d00898bbbe769612">More...</a><br/></td></tr>
<tr class="separator:a4f92092fb8a70b31d00898bbbe769612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce261caf05bd371c430e82a0e6389a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ce261caf05bd371c430e82a0e6389a5"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ce261caf05bd371c430e82a0e6389a5">log1m_exp</a> (const T a)</td></tr>
<tr class="memdesc:a3ce261caf05bd371c430e82a0e6389a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 minus the exponential of the specified value without overflow log1m_exp(x) = log(1-exp(x)).  <a href="#a3ce261caf05bd371c430e82a0e6389a5">More...</a><br/></td></tr>
<tr class="separator:a3ce261caf05bd371c430e82a0e6389a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f71c696a5e0da4daab30e5f3704842"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7f71c696a5e0da4daab30e5f3704842"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac7f71c696a5e0da4daab30e5f3704842">log1m_inv_logit</a> (const T u)</td></tr>
<tr class="memdesc:ac7f71c696a5e0da4daab30e5f3704842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of 1 minus the inverse logit of the specified argument.  <a href="#ac7f71c696a5e0da4daab30e5f3704842">More...</a><br/></td></tr>
<tr class="separator:ac7f71c696a5e0da4daab30e5f3704842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5166d3c58ad8ce0aedbf104179888b69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5166d3c58ad8ce0aedbf104179888b69"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5166d3c58ad8ce0aedbf104179888b69">log1p</a> (const T x)</td></tr>
<tr class="memdesc:a5166d3c58ad8ce0aedbf104179888b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one plus the specified value.  <a href="#a5166d3c58ad8ce0aedbf104179888b69">More...</a><br/></td></tr>
<tr class="separator:a5166d3c58ad8ce0aedbf104179888b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88151def26813dec3e04c4a8b9674091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88151def26813dec3e04c4a8b9674091"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88151def26813dec3e04c4a8b9674091">log1p_exp</a> (const T a)</td></tr>
<tr class="memdesc:a88151def26813dec3e04c4a8b9674091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 plus the exponential of the specified value without overflow.  <a href="#a88151def26813dec3e04c4a8b9674091">More...</a><br/></td></tr>
<tr class="separator:a88151def26813dec3e04c4a8b9674091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa25e1572bf46e3a6b9ee270f0c7e2c4d">log2</a> (const T a)</td></tr>
<tr class="memdesc:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 2 logarithm of the argument (C99).  <a href="#aa25e1572bf46e3a6b9ee270f0c7e2c4d">More...</a><br/></td></tr>
<tr class="separator:aa25e1572bf46e3a6b9ee270f0c7e2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947ba3fe3c87293f7c57395007100c79"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a947ba3fe3c87293f7c57395007100c79">log2</a> ()</td></tr>
<tr class="memdesc:a947ba3fe3c87293f7c57395007100c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of two.  <a href="#a947ba3fe3c87293f7c57395007100c79">More...</a><br/></td></tr>
<tr class="separator:a947ba3fe3c87293f7c57395007100c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685dbad032c2794fbc8bca7f44119eab"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a685dbad032c2794fbc8bca7f44119eab"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a685dbad032c2794fbc8bca7f44119eab">log_diff_exp</a> (const T1 x, const T2 y)</td></tr>
<tr class="memdesc:a685dbad032c2794fbc8bca7f44119eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the difference of the natural exponentiation of x1 and the natural exponentiation of x2.  <a href="#a685dbad032c2794fbc8bca7f44119eab">More...</a><br/></td></tr>
<tr class="separator:a685dbad032c2794fbc8bca7f44119eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd407ae0bf698d58b8e59e580749e705"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:afd407ae0bf698d58b8e59e580749e705"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd407ae0bf698d58b8e59e580749e705">log_falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:afd407ae0bf698d58b8e59e580749e705"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_falling\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_118.png"/>
</p>
  <a href="#afd407ae0bf698d58b8e59e580749e705">More...</a><br/></td></tr>
<tr class="separator:afd407ae0bf698d58b8e59e580749e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5be889d1ef4284654a04e400f5371a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5be889d1ef4284654a04e400f5371a7"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad5be889d1ef4284654a04e400f5371a7">log_inv_logit</a> (const T &amp;u)</td></tr>
<tr class="memdesc:ad5be889d1ef4284654a04e400f5371a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the inverse logit of the specified argument.  <a href="#ad5be889d1ef4284654a04e400f5371a7">More...</a><br/></td></tr>
<tr class="separator:ad5be889d1ef4284654a04e400f5371a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7b9cda7f1b3234cc4b3fc20e595482"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1b7b9cda7f1b3234cc4b3fc20e595482">log_mix</a> (double theta, double lambda1, double lambda2)</td></tr>
<tr class="memdesc:a1b7b9cda7f1b3234cc4b3fc20e595482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities.  <a href="#a1b7b9cda7f1b3234cc4b3fc20e595482">More...</a><br/></td></tr>
<tr class="separator:a1b7b9cda7f1b3234cc4b3fc20e595482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05002f0d4de2c84705dc2bbadfce6b6c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a05002f0d4de2c84705dc2bbadfce6b6c"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a05002f0d4de2c84705dc2bbadfce6b6c">log_rising_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:a05002f0d4de2c84705dc2bbadfce6b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_rising\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_127.png"/>
</p>
  <a href="#a05002f0d4de2c84705dc2bbadfce6b6c">More...</a><br/></td></tr>
<tr class="separator:a05002f0d4de2c84705dc2bbadfce6b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554e6f04e24049b7fe6e56f60abbc560"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a554e6f04e24049b7fe6e56f60abbc560"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a554e6f04e24049b7fe6e56f60abbc560">log_sum_exp</a> (const T2 &amp;a, const T1 &amp;b)</td></tr>
<tr class="memdesc:a554e6f04e24049b7fe6e56f60abbc560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log sum of exponetials without overflow.  <a href="#a554e6f04e24049b7fe6e56f60abbc560">More...</a><br/></td></tr>
<tr class="separator:a554e6f04e24049b7fe6e56f60abbc560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adc35bab2db89b3ceda66f11e1fa53ec8">logical_and</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise.  <a href="#adc35bab2db89b3ceda66f11e1fa53ec8">More...</a><br/></td></tr>
<tr class="separator:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab2213736b55fd6696fa0120fd3fe72e4">logical_eq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ab2213736b55fd6696fa0120fd3fe72e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is equal to the second.  <a href="#ab2213736b55fd6696fa0120fd3fe72e4">More...</a><br/></td></tr>
<tr class="separator:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86bfd994302061a0260e1202fca777"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aba86bfd994302061a0260e1202fca777"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aba86bfd994302061a0260e1202fca777">logical_gt</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:aba86bfd994302061a0260e1202fca777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly greater than the second.  <a href="#aba86bfd994302061a0260e1202fca777">More...</a><br/></td></tr>
<tr class="separator:aba86bfd994302061a0260e1202fca777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb0b8623192207d35e207ea312d8be"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac6bb0b8623192207d35e207ea312d8be"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac6bb0b8623192207d35e207ea312d8be">logical_gte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ac6bb0b8623192207d35e207ea312d8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is greater than or equal to the second.  <a href="#ac6bb0b8623192207d35e207ea312d8be">More...</a><br/></td></tr>
<tr class="separator:ac6bb0b8623192207d35e207ea312d8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5bd91412749e10933f304b54aef88f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a0b5bd91412749e10933f304b54aef88f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0b5bd91412749e10933f304b54aef88f">logical_lt</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:a0b5bd91412749e10933f304b54aef88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly less than the second.  <a href="#a0b5bd91412749e10933f304b54aef88f">More...</a><br/></td></tr>
<tr class="separator:a0b5bd91412749e10933f304b54aef88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3649d4c704962c4502cd6220a5e2230"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af3649d4c704962c4502cd6220a5e2230"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af3649d4c704962c4502cd6220a5e2230">logical_lte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:af3649d4c704962c4502cd6220a5e2230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is less than or equal to the second.  <a href="#af3649d4c704962c4502cd6220a5e2230">More...</a><br/></td></tr>
<tr class="separator:af3649d4c704962c4502cd6220a5e2230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aad2fc9ce55dfac079d930335beb7e4a8">logical_negation</a> (const T x)</td></tr>
<tr class="memdesc:aad2fc9ce55dfac079d930335beb7e4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical negation function which returns 1 if the input is equal to zero and 0 otherwise.  <a href="#aad2fc9ce55dfac079d930335beb7e4a8">More...</a><br/></td></tr>
<tr class="separator:aad2fc9ce55dfac079d930335beb7e4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a206eb210d8e7e2c718af25c40de8f9d1">logical_neq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:a206eb210d8e7e2c718af25c40de8f9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is unequal to the second.  <a href="#a206eb210d8e7e2c718af25c40de8f9d1">More...</a><br/></td></tr>
<tr class="separator:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac74007e2d5f55d5ae4a308f535869aee">logical_or</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:ac74007e2d5f55d5ae4a308f535869aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise.  <a href="#ac74007e2d5f55d5ae4a308f535869aee">More...</a><br/></td></tr>
<tr class="separator:ac74007e2d5f55d5ae4a308f535869aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53342d0c2cd3a6e440c533070054aca3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53342d0c2cd3a6e440c533070054aca3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a53342d0c2cd3a6e440c533070054aca3">logit</a> (const T a)</td></tr>
<tr class="memdesc:a53342d0c2cd3a6e440c533070054aca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logit function applied to the argument.  <a href="#a53342d0c2cd3a6e440c533070054aca3">More...</a><br/></td></tr>
<tr class="separator:a53342d0c2cd3a6e440c533070054aca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc0ef5cf22dda83988c062b529dc3a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TL , typename TU &gt; </td></tr>
<tr class="memitem:a5cc0ef5cf22dda83988c062b529dc3a6"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TL, TU &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5cc0ef5cf22dda83988c062b529dc3a6">lub_constrain</a> (const T x, TL lb, TU ub)</td></tr>
<tr class="memdesc:a5cc0ef5cf22dda83988c062b529dc3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower- and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds.  <a href="#a5cc0ef5cf22dda83988c062b529dc3a6">More...</a><br/></td></tr>
<tr class="separator:a5cc0ef5cf22dda83988c062b529dc3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51cc5fe98ac938435e614765e30655a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TL , typename TU &gt; </td></tr>
<tr class="memitem:ab51cc5fe98ac938435e614765e30655a"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TL, TU &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab51cc5fe98ac938435e614765e30655a">lub_constrain</a> (const T x, const TL lb, const TU ub, T &amp;lp)</td></tr>
<tr class="memdesc:ab51cc5fe98ac938435e614765e30655a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower- and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds and increment the specified log probability with the log absolute Jacobian determinant.  <a href="#ab51cc5fe98ac938435e614765e30655a">More...</a><br/></td></tr>
<tr class="separator:ab51cc5fe98ac938435e614765e30655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fa09fdc448652a57d364d70d6e88e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TL , typename TU &gt; </td></tr>
<tr class="memitem:ab9fa09fdc448652a57d364d70d6e88e3"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TL, TU &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab9fa09fdc448652a57d364d70d6e88e3">lub_free</a> (const T y, TL lb, TU ub)</td></tr>
<tr class="memdesc:ab9fa09fdc448652a57d364d70d6e88e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained scalar that transforms to the specified lower- and upper-bounded scalar given the specified bounds.  <a href="#ab9fa09fdc448652a57d364d70d6e88e3">More...</a><br/></td></tr>
<tr class="separator:ab9fa09fdc448652a57d364d70d6e88e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafecf14b103c7c17da33368d07b1565"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:acafecf14b103c7c17da33368d07b1565"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acafecf14b103c7c17da33368d07b1565">modified_bessel_first_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:acafecf14b103c7c17da33368d07b1565"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_first\_kind}(v, z) = \begin{cases} I_v(z) &amp; \mbox{if } -\infty\leq z \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_147.png"/>
</p>
  <a href="#acafecf14b103c7c17da33368d07b1565">More...</a><br/></td></tr>
<tr class="separator:acafecf14b103c7c17da33368d07b1565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a72ce86f3db5478cad4666c9cf1d05a6e">modified_bessel_second_kind</a> (const int v, const T2 z)</td></tr>
<tr class="memdesc:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_second\_kind}(v, z) = \begin{cases} \textrm{error} &amp; \mbox{if } z \leq 0 \\ K_v(z) &amp; \mbox{if } z > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_151.png"/>
</p>
  <a href="#a72ce86f3db5478cad4666c9cf1d05a6e">More...</a><br/></td></tr>
<tr class="separator:a72ce86f3db5478cad4666c9cf1d05a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf62df7cae63f67b1c5c67651bc8dcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afcf62df7cae63f67b1c5c67651bc8dcf">modulus</a> (const int x, const int y)</td></tr>
<tr class="separator:afcf62df7cae63f67b1c5c67651bc8dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f15d9bf40cdab5e3ef75cea2595244c"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:a0f15d9bf40cdab5e3ef75cea2595244c"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T_a, T_b &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0f15d9bf40cdab5e3ef75cea2595244c">multiply_log</a> (const T_a a, const T_b b)</td></tr>
<tr class="memdesc:a0f15d9bf40cdab5e3ef75cea2595244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculated the value of the first argument times log of the second argument while behaving properly with 0 inputs.  <a href="#a0f15d9bf40cdab5e3ef75cea2595244c">More...</a><br/></td></tr>
<tr class="separator:a0f15d9bf40cdab5e3ef75cea2595244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af099f2a72adf07f89f5f27f405d7afab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af099f2a72adf07f89f5f27f405d7afab">owens_t</a> (const double h, const double a)</td></tr>
<tr class="memdesc:af099f2a72adf07f89f5f27f405d7afab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="#af099f2a72adf07f89f5f27f405d7afab">More...</a><br/></td></tr>
<tr class="separator:af099f2a72adf07f89f5f27f405d7afab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85644bbd92359d699f374adea62c643"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac85644bbd92359d699f374adea62c643"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac85644bbd92359d699f374adea62c643">Phi</a> (const T x)</td></tr>
<tr class="memdesc:ac85644bbd92359d699f374adea62c643"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative distribution function.  <a href="#ac85644bbd92359d699f374adea62c643">More...</a><br/></td></tr>
<tr class="separator:ac85644bbd92359d699f374adea62c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cf4bf2074175fd7bcde43f9f94e4d16">Phi_approx</a> (T x)</td></tr>
<tr class="memdesc:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation of the unit normal CDF.  <a href="#a6cf4bf2074175fd7bcde43f9f94e4d16">More...</a><br/></td></tr>
<tr class="separator:a6cf4bf2074175fd7bcde43f9f94e4d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf6708d0fb577e217e81463282cae71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cf6708d0fb577e217e81463282cae71"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cf6708d0fb577e217e81463282cae71">positive_constrain</a> (const T x)</td></tr>
<tr class="memdesc:a6cf6708d0fb577e217e81463282cae71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input.  <a href="#a6cf6708d0fb577e217e81463282cae71">More...</a><br/></td></tr>
<tr class="separator:a6cf6708d0fb577e217e81463282cae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9c43fc857272a76bb4030122ac91ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f9c43fc857272a76bb4030122ac91ed"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9f9c43fc857272a76bb4030122ac91ed">positive_constrain</a> (const T x, T &amp;lp)</td></tr>
<tr class="memdesc:a9f9c43fc857272a76bb4030122ac91ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input, incrementing the scalar reference with the log absolute Jacobian determinant.  <a href="#a9f9c43fc857272a76bb4030122ac91ed">More...</a><br/></td></tr>
<tr class="separator:a9f9c43fc857272a76bb4030122ac91ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a20798b12abb29d73f7391168f836f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a20798b12abb29d73f7391168f836f9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6a20798b12abb29d73f7391168f836f9">positive_free</a> (const T y)</td></tr>
<tr class="memdesc:a6a20798b12abb29d73f7391168f836f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained value corresponding to the specified positive-constrained value.  <a href="#a6a20798b12abb29d73f7391168f836f9">More...</a><br/></td></tr>
<tr class="separator:a6a20798b12abb29d73f7391168f836f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cbc3a490edf340544fb12df544269e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8cbc3a490edf340544fb12df544269e"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;, T &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af8cbc3a490edf340544fb12df544269e">primitive_value</a> (T x)</td></tr>
<tr class="memdesc:af8cbc3a490edf340544fb12df544269e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified arithmetic argument unmodified with its own declared type.  <a href="#af8cbc3a490edf340544fb12df544269e">More...</a><br/></td></tr>
<tr class="separator:af8cbc3a490edf340544fb12df544269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0491e419195548cdede51a384547aef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0491e419195548cdede51a384547aef2"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if<br class="typebreak"/>
&lt; boost::is_arithmetic&lt; T &gt;<br class="typebreak"/>
, double &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0491e419195548cdede51a384547aef2">primitive_value</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a0491e419195548cdede51a384547aef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive value of the specified argument.  <a href="#a0491e419195548cdede51a384547aef2">More...</a><br/></td></tr>
<tr class="separator:a0491e419195548cdede51a384547aef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0b9c35bc619ea5fbac226e985bbc1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a0b9c35bc619ea5fbac226e985bbc1d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7a0b9c35bc619ea5fbac226e985bbc1d">prob_constrain</a> (const T x)</td></tr>
<tr class="memdesc:a7a0b9c35bc619ea5fbac226e985bbc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar.  <a href="#a7a0b9c35bc619ea5fbac226e985bbc1d">More...</a><br/></td></tr>
<tr class="separator:a7a0b9c35bc619ea5fbac226e985bbc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5c8822124337e5d000cfa60046c5fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b5c8822124337e5d000cfa60046c5fa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3b5c8822124337e5d000cfa60046c5fa">prob_constrain</a> (const T x, T &amp;lp)</td></tr>
<tr class="memdesc:a3b5c8822124337e5d000cfa60046c5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="#a3b5c8822124337e5d000cfa60046c5fa">More...</a><br/></td></tr>
<tr class="separator:a3b5c8822124337e5d000cfa60046c5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533afff719fe3e21bf53d2fa53d2fbe3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a533afff719fe3e21bf53d2fa53d2fbe3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a533afff719fe3e21bf53d2fa53d2fbe3">prob_free</a> (const T y)</td></tr>
<tr class="memdesc:a533afff719fe3e21bf53d2fa53d2fbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free scalar that when transformed to a probability produces the specified scalar.  <a href="#a533afff719fe3e21bf53d2fa53d2fbe3">More...</a><br/></td></tr>
<tr class="separator:a533afff719fe3e21bf53d2fa53d2fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4815c45c3f87ea98453880863e3a0b94"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a4815c45c3f87ea98453880863e3a0b94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a>&lt; T, S &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4815c45c3f87ea98453880863e3a0b94">promote_scalar</a> (const S &amp;x)</td></tr>
<tr class="memdesc:a4815c45c3f87ea98453880863e3a0b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the top-level function to call to promote the scalar types of an input of type S to type T.  <a href="#a4815c45c3f87ea98453880863e3a0b94">More...</a><br/></td></tr>
<tr class="separator:a4815c45c3f87ea98453880863e3a0b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db558a6d0b54bf4ea23d9f247c6fbdb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6db558a6d0b54bf4ea23d9f247c6fbdb"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6db558a6d0b54bf4ea23d9f247c6fbdb">rising_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:a6db558a6d0b54bf4ea23d9f247c6fbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{rising\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_175.png"/>
</p>
  <a href="#a6db558a6d0b54bf4ea23d9f247c6fbdb">More...</a><br/></td></tr>
<tr class="separator:a6db558a6d0b54bf4ea23d9f247c6fbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad825f81b97ddf0b2e1217f30913559a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad825f81b97ddf0b2e1217f30913559a3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad825f81b97ddf0b2e1217f30913559a3">sign</a> (const T &amp;z)</td></tr>
<tr class="separator:ad825f81b97ddf0b2e1217f30913559a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b82f11f784f321bce2c5677089e24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a056b82f11f784f321bce2c5677089e24"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a056b82f11f784f321bce2c5677089e24">square</a> (const T x)</td></tr>
<tr class="memdesc:a056b82f11f784f321bce2c5677089e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the specified argument.  <a href="#a056b82f11f784f321bce2c5677089e24">More...</a><br/></td></tr>
<tr class="separator:a056b82f11f784f321bce2c5677089e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8fdc5e5ba8e306c2a594e928bfd62ea2">step</a> (const T y)</td></tr>
<tr class="memdesc:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The step, or Heaviside, function.  <a href="#a8fdc5e5ba8e306c2a594e928bfd62ea2">More...</a><br/></td></tr>
<tr class="separator:a8fdc5e5ba8e306c2a594e928bfd62ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18c21bad37c9af26424d0922936355e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab18c21bad37c9af26424d0922936355e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab18c21bad37c9af26424d0922936355e">trigamma</a> (T x)</td></tr>
<tr class="memdesc:ab18c21bad37c9af26424d0922936355e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{trigamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \Psi_1(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_183.png"/>
</p>
  <a href="#ab18c21bad37c9af26424d0922936355e">More...</a><br/></td></tr>
<tr class="separator:ab18c21bad37c9af26424d0922936355e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9440f04c389ecf55094919dd4a29561"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TU &gt; </td></tr>
<tr class="memitem:ad9440f04c389ecf55094919dd4a29561"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TU &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad9440f04c389ecf55094919dd4a29561">ub_constrain</a> (const T x, const TU ub)</td></tr>
<tr class="memdesc:ad9440f04c389ecf55094919dd4a29561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained scalar and upper bound.  <a href="#ad9440f04c389ecf55094919dd4a29561">More...</a><br/></td></tr>
<tr class="separator:ad9440f04c389ecf55094919dd4a29561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e07e6f25d9cc21ce1467d0d74913a74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TU &gt; </td></tr>
<tr class="memitem:a0e07e6f25d9cc21ce1467d0d74913a74"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TU &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0e07e6f25d9cc21ce1467d0d74913a74">ub_constrain</a> (const T x, const TU ub, T &amp;lp)</td></tr>
<tr class="memdesc:a0e07e6f25d9cc21ce1467d0d74913a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained scalar and upper bound and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="#a0e07e6f25d9cc21ce1467d0d74913a74">More...</a><br/></td></tr>
<tr class="separator:a0e07e6f25d9cc21ce1467d0d74913a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11bdd8c7f6eed39bbac5a663c8a81bc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TU &gt; </td></tr>
<tr class="memitem:ac11bdd8c7f6eed39bbac5a663c8a81bc"><td class="memTemplItemLeft" align="right" valign="top">boost::math::tools::promote_args<br class="typebreak"/>
&lt; T, TU &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac11bdd8c7f6eed39bbac5a663c8a81bc">ub_free</a> (const T y, const TU ub)</td></tr>
<tr class="memdesc:ac11bdd8c7f6eed39bbac5a663c8a81bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free scalar that corresponds to the specified upper-bounded value with respect to the specified upper bound.  <a href="#ac11bdd8c7f6eed39bbac5a663c8a81bc">More...</a><br/></td></tr>
<tr class="separator:ac11bdd8c7f6eed39bbac5a663c8a81bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73087d72fd937f4be66684bd2613ae6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73087d72fd937f4be66684bd2613ae6e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e">value_of</a> (const T x)</td></tr>
<tr class="memdesc:a73087d72fd937f4be66684bd2613ae6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified scalar argument converted to a double value.  <a href="#a73087d72fd937f4be66684bd2613ae6e">More...</a><br/></td></tr>
<tr class="separator:a73087d72fd937f4be66684bd2613ae6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7774df98215b7d113075019d74ebbf"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2d7774df98215b7d113075019d74ebbf"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2d7774df98215b7d113075019d74ebbf">value_of&lt; double &gt;</a> (const double x)</td></tr>
<tr class="memdesc:a2d7774df98215b7d113075019d74ebbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <a href="#a2d7774df98215b7d113075019d74ebbf">More...</a><br/></td></tr>
<tr class="separator:a2d7774df98215b7d113075019d74ebbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a99d6e8d6986fffb421e859770560bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a99d6e8d6986fffb421e859770560bc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7a99d6e8d6986fffb421e859770560bc">value_of_rec</a> (const T x)</td></tr>
<tr class="memdesc:a7a99d6e8d6986fffb421e859770560bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified scalar argument converted to a double value.  <a href="#a7a99d6e8d6986fffb421e859770560bc">More...</a><br/></td></tr>
<tr class="separator:a7a99d6e8d6986fffb421e859770560bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7bb47fffd6ec0b1864d5e8bf0b99cf55">value_of_rec&lt; double &gt;</a> (const double x)</td></tr>
<tr class="memdesc:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <a href="#a7bb47fffd6ec0b1864d5e8bf0b99cf55">More...</a><br/></td></tr>
<tr class="separator:a7bb47fffd6ec0b1864d5e8bf0b99cf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8811804a3bb9a9cd943422ce3938db"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:a9d8811804a3bb9a9cd943422ce3938db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9d8811804a3bb9a9cd943422ce3938db">bernoulli_ccdf_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a9d8811804a3bb9a9cd943422ce3938db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b80aeaa1cc10d315d915aba2ddc6180"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:a0b80aeaa1cc10d315d915aba2ddc6180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0b80aeaa1cc10d315d915aba2ddc6180">bernoulli_cdf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a0b80aeaa1cc10d315d915aba2ddc6180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac569e9e067f4d61280974e9a54ac6476"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ac569e9e067f4d61280974e9a54ac6476"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac569e9e067f4d61280974e9a54ac6476">bernoulli_cdf_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ac569e9e067f4d61280974e9a54ac6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e360bb277db7a3318c1c368dbccdda8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:a3e360bb277db7a3318c1c368dbccdda8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3e360bb277db7a3318c1c368dbccdda8">bernoulli_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a3e360bb277db7a3318c1c368dbccdda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075f08b1d99b150b64d851139be35894"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_prob &gt; </td></tr>
<tr class="memitem:a075f08b1d99b150b64d851139be35894"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a075f08b1d99b150b64d851139be35894">bernoulli_log</a> (const T_y &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a075f08b1d99b150b64d851139be35894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9048a0a4bd452c7e797cb5a496b0b97"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:aa9048a0a4bd452c7e797cb5a496b0b97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa9048a0a4bd452c7e797cb5a496b0b97">bernoulli_logit_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:aa9048a0a4bd452c7e797cb5a496b0b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193781437c0aa1a48fe48b24d9ae8130"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:a193781437c0aa1a48fe48b24d9ae8130"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a193781437c0aa1a48fe48b24d9ae8130">bernoulli_logit_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a193781437c0aa1a48fe48b24d9ae8130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46d3934578fb7346a900677a3e8c377"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ac46d3934578fb7346a900677a3e8c377"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac46d3934578fb7346a900677a3e8c377">bernoulli_rng</a> (const double theta, RNG &amp;rng)</td></tr>
<tr class="separator:ac46d3934578fb7346a900677a3e8c377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab380fecf1c6c99b602f212cbccc28a83"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ab380fecf1c6c99b602f212cbccc28a83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_size1, T_size2 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab380fecf1c6c99b602f212cbccc28a83">beta_binomial_ccdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;beta)</td></tr>
<tr class="separator:ab380fecf1c6c99b602f212cbccc28a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abc35510e01a52b5138a19bfedb2a3e"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a6abc35510e01a52b5138a19bfedb2a3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_size1, T_size2 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6abc35510e01a52b5138a19bfedb2a3e">beta_binomial_cdf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;beta)</td></tr>
<tr class="separator:a6abc35510e01a52b5138a19bfedb2a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2c63ba04c87c46bcb0db999d955e9b"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:adf2c63ba04c87c46bcb0db999d955e9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_size1, T_size2 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adf2c63ba04c87c46bcb0db999d955e9b">beta_binomial_cdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;beta)</td></tr>
<tr class="separator:adf2c63ba04c87c46bcb0db999d955e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2462b112bf6512c4db7c6abea6478c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a5c2462b112bf6512c4db7c6abea6478c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_size1, T_size2 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5c2462b112bf6512c4db7c6abea6478c">beta_binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;beta)</td></tr>
<tr class="separator:a5c2462b112bf6512c4db7c6abea6478c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a71d6f54236310fba1a94b445272f3"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a48a71d6f54236310fba1a94b445272f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_size1, T_size2 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a48a71d6f54236310fba1a94b445272f3">beta_binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;beta)</td></tr>
<tr class="separator:a48a71d6f54236310fba1a94b445272f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0443ac7dbd959b40b1a958767857f5e"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ac0443ac7dbd959b40b1a958767857f5e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0443ac7dbd959b40b1a958767857f5e">beta_binomial_rng</a> (const int N, const double alpha, const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:ac0443ac7dbd959b40b1a958767857f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625d31cf8da1c8cd2ea99af113ed6fe6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:a625d31cf8da1c8cd2ea99af113ed6fe6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale_succ, <br class="typebreak"/>
T_scale_fail &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a625d31cf8da1c8cd2ea99af113ed6fe6">beta_ccdf_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta)</td></tr>
<tr class="separator:a625d31cf8da1c8cd2ea99af113ed6fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84beaaff122d602406a515a9dd97bb90"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:a84beaaff122d602406a515a9dd97bb90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale_succ, <br class="typebreak"/>
T_scale_fail &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a84beaaff122d602406a515a9dd97bb90">beta_cdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta)</td></tr>
<tr class="memdesc:a84beaaff122d602406a515a9dd97bb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the beta cumulative distribution function for the given variate and scale variables.  <a href="#a84beaaff122d602406a515a9dd97bb90">More...</a><br/></td></tr>
<tr class="separator:a84beaaff122d602406a515a9dd97bb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa87400b4ecd4bba0d10158cad4f3a8b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:afa87400b4ecd4bba0d10158cad4f3a8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale_succ, <br class="typebreak"/>
T_scale_fail &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afa87400b4ecd4bba0d10158cad4f3a8b">beta_cdf_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta)</td></tr>
<tr class="separator:afa87400b4ecd4bba0d10158cad4f3a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0246a55c1c14d2c7ec35a0070af63299"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:a0246a55c1c14d2c7ec35a0070af63299"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale_succ, <br class="typebreak"/>
T_scale_fail &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0246a55c1c14d2c7ec35a0070af63299">beta_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta)</td></tr>
<tr class="memdesc:a0246a55c1c14d2c7ec35a0070af63299"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for the specified scalar(s) given the specified sample size(s).  <a href="#a0246a55c1c14d2c7ec35a0070af63299">More...</a><br/></td></tr>
<tr class="separator:a0246a55c1c14d2c7ec35a0070af63299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5818c82697944b91b483674b14ad22"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:a7e5818c82697944b91b483674b14ad22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale_succ, <br class="typebreak"/>
T_scale_fail &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7e5818c82697944b91b483674b14ad22">beta_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta)</td></tr>
<tr class="separator:a7e5818c82697944b91b483674b14ad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa2015614535f45c2cb6d5f544643d0"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a7fa2015614535f45c2cb6d5f544643d0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7fa2015614535f45c2cb6d5f544643d0">beta_rng</a> (const double alpha, const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:a7fa2015614535f45c2cb6d5f544643d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92586706a7afc2c968e0c11a9a021f8a"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a92586706a7afc2c968e0c11a9a021f8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a92586706a7afc2c968e0c11a9a021f8a">binomial_ccdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:a92586706a7afc2c968e0c11a9a021f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ca53e4f20460de16af84337acba3f0"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a25ca53e4f20460de16af84337acba3f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a25ca53e4f20460de16af84337acba3f0">binomial_cdf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:a25ca53e4f20460de16af84337acba3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b0617f8ad60887c84b0cd91ebe202e"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a96b0617f8ad60887c84b0cd91ebe202e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a96b0617f8ad60887c84b0cd91ebe202e">binomial_cdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:a96b0617f8ad60887c84b0cd91ebe202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de035dd17c118b3144a9ed9c867378f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a9de035dd17c118b3144a9ed9c867378f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9de035dd17c118b3144a9ed9c867378f">binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:a9de035dd17c118b3144a9ed9c867378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3409628d97b7ff020f2c0c694d8d40"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a8b3409628d97b7ff020f2c0c694d8d40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8b3409628d97b7ff020f2c0c694d8d40">binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:a8b3409628d97b7ff020f2c0c694d8d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5a9e223a39b11f58fe044dcb2bc7ca"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a8f5a9e223a39b11f58fe044dcb2bc7ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8f5a9e223a39b11f58fe044dcb2bc7ca">binomial_logit_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="separator:a8f5a9e223a39b11f58fe044dcb2bc7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5378254419361dd7a0bfacf139b49401"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a5378254419361dd7a0bfacf139b49401"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_prob &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5378254419361dd7a0bfacf139b49401">binomial_logit_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="separator:a5378254419361dd7a0bfacf139b49401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41d355d768c2258bf999bc765382f27"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aa41d355d768c2258bf999bc765382f27"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa41d355d768c2258bf999bc765382f27">binomial_rng</a> (const int N, const double theta, RNG &amp;rng)</td></tr>
<tr class="separator:aa41d355d768c2258bf999bc765382f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa932af729313abe32571d8a3742385ed"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:aa932af729313abe32571d8a3742385ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa932af729313abe32571d8a3742385ed">cauchy_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa932af729313abe32571d8a3742385ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ecad949e8b175b4b60f6f5cb16319b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ab7ecad949e8b175b4b60f6f5cb16319b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab7ecad949e8b175b4b60f6f5cb16319b">cauchy_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ab7ecad949e8b175b4b60f6f5cb16319b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cauchy cumulative distribution function for the given variate, location, and scale.  <a href="#ab7ecad949e8b175b4b60f6f5cb16319b">More...</a><br/></td></tr>
<tr class="separator:ab7ecad949e8b175b4b60f6f5cb16319b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689566206e25e90e590c2655d3b49032"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a689566206e25e90e590c2655d3b49032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a689566206e25e90e590c2655d3b49032">cauchy_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a689566206e25e90e590c2655d3b49032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b702de583e1883c8abd5b2fbba4b0d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a57b702de583e1883c8abd5b2fbba4b0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a57b702de583e1883c8abd5b2fbba4b0d">cauchy_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:a57b702de583e1883c8abd5b2fbba4b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <a href="#a57b702de583e1883c8abd5b2fbba4b0d">More...</a><br/></td></tr>
<tr class="separator:a57b702de583e1883c8abd5b2fbba4b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffc7f40b61588318f20c738202fc5fc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a6ffc7f40b61588318f20c738202fc5fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6ffc7f40b61588318f20c738202fc5fc">cauchy_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a6ffc7f40b61588318f20c738202fc5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ddbccee3c214e6fc88f297b6524d0b"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ab9ddbccee3c214e6fc88f297b6524d0b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab9ddbccee3c214e6fc88f297b6524d0b">cauchy_rng</a> (const double mu, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ab9ddbccee3c214e6fc88f297b6524d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af270a4206e4a52396b386b54c9a58ae9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:af270a4206e4a52396b386b54c9a58ae9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af270a4206e4a52396b386b54c9a58ae9">chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:af270a4206e4a52396b386b54c9a58ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa196f552535f61f4b2bd088da74cc142"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:aa196f552535f61f4b2bd088da74cc142"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa196f552535f61f4b2bd088da74cc142">chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:aa196f552535f61f4b2bd088da74cc142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the chi square cumulative distribution function for the given variate and degrees of freedom.  <a href="#aa196f552535f61f4b2bd088da74cc142">More...</a><br/></td></tr>
<tr class="separator:aa196f552535f61f4b2bd088da74cc142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf0413c908e37c44c24ad81f99aa77f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:acbf0413c908e37c44c24ad81f99aa77f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acbf0413c908e37c44c24ad81f99aa77f">chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:acbf0413c908e37c44c24ad81f99aa77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1c945dce01a8a4b4485b7c5bb258ba"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:a8a1c945dce01a8a4b4485b7c5bb258ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a1c945dce01a8a4b4485b7c5bb258ba">chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:a8a1c945dce01a8a4b4485b7c5bb258ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a chi-squared density for y with the specified degrees of freedom parameter.  <a href="#a8a1c945dce01a8a4b4485b7c5bb258ba">More...</a><br/></td></tr>
<tr class="separator:a8a1c945dce01a8a4b4485b7c5bb258ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78965d5578823b4bae1dde58e42012c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:a78965d5578823b4bae1dde58e42012c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a78965d5578823b4bae1dde58e42012c1">chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:a78965d5578823b4bae1dde58e42012c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1653e58694ea92bc1781e5d332c31e8"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ac1653e58694ea92bc1781e5d332c31e8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac1653e58694ea92bc1781e5d332c31e8">chi_square_rng</a> (const double nu, RNG &amp;rng)</td></tr>
<tr class="separator:ac1653e58694ea92bc1781e5d332c31e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab670b33f7d9f8cd15406cce67ffbe2c9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ab670b33f7d9f8cd15406cce67ffbe2c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab670b33f7d9f8cd15406cce67ffbe2c9">double_exponential_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ab670b33f7d9f8cd15406cce67ffbe2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658493a49a4e83ac55393a5d43c47ba7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a658493a49a4e83ac55393a5d43c47ba7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a658493a49a4e83ac55393a5d43c47ba7">double_exponential_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:a658493a49a4e83ac55393a5d43c47ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the double exponential cumulative density function.  <a href="#a658493a49a4e83ac55393a5d43c47ba7">More...</a><br/></td></tr>
<tr class="separator:a658493a49a4e83ac55393a5d43c47ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71f7d99df6f1817ad1badc771e30a5e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:aa71f7d99df6f1817ad1badc771e30a5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa71f7d99df6f1817ad1badc771e30a5e">double_exponential_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa71f7d99df6f1817ad1badc771e30a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465bb5ed0b5bb209aa43f2ac71fc3597"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a465bb5ed0b5bb209aa43f2ac71fc3597"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a465bb5ed0b5bb209aa43f2ac71fc3597">double_exponential_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a465bb5ed0b5bb209aa43f2ac71fc3597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96b2758687c3d1eab564e67d18f8922"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ac96b2758687c3d1eab564e67d18f8922"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac96b2758687c3d1eab564e67d18f8922">double_exponential_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ac96b2758687c3d1eab564e67d18f8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ebff3092eb40851fa1f63b7b7196f8"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aa6ebff3092eb40851fa1f63b7b7196f8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa6ebff3092eb40851fa1f63b7b7196f8">double_exponential_rng</a> (const double mu, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:aa6ebff3092eb40851fa1f63b7b7196f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497ff815eeadaffe3204d33359c4be82"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a497ff815eeadaffe3204d33359c4be82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a497ff815eeadaffe3204d33359c4be82">exp_mod_normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:a497ff815eeadaffe3204d33359c4be82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b29301645f48dedc57b97409062250c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a2b29301645f48dedc57b97409062250c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2b29301645f48dedc57b97409062250c">exp_mod_normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:a2b29301645f48dedc57b97409062250c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e32ac964461952d77df48cd30c6f1d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ad0e32ac964461952d77df48cd30c6f1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad0e32ac964461952d77df48cd30c6f1d">exp_mod_normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:ad0e32ac964461952d77df48cd30c6f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27bb81f9220a9ba9082903fd55dff66"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:af27bb81f9220a9ba9082903fd55dff66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af27bb81f9220a9ba9082903fd55dff66">exp_mod_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:af27bb81f9220a9ba9082903fd55dff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3cd94db2760437551ea466247cf8e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a50a3cd94db2760437551ea466247cf8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a50a3cd94db2760437551ea466247cf8e">exp_mod_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:a50a3cd94db2760437551ea466247cf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d3c6fbf610e2c0e997a039f2ed98e8"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a40d3c6fbf610e2c0e997a039f2ed98e8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a40d3c6fbf610e2c0e997a039f2ed98e8">exp_mod_normal_rng</a> (const double mu, const double sigma, const double lambda, RNG &amp;rng)</td></tr>
<tr class="separator:a40d3c6fbf610e2c0e997a039f2ed98e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c92f31b24600c6ce05b4f21f54fb00"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a42c92f31b24600c6ce05b4f21f54fb00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_inv_scale &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a42c92f31b24600c6ce05b4f21f54fb00">exponential_ccdf_log</a> (const T_y &amp;y, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a42c92f31b24600c6ce05b4f21f54fb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac753dcf58b69f0bbf7b001bfe19a3e44"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ac753dcf58b69f0bbf7b001bfe19a3e44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_inv_scale &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac753dcf58b69f0bbf7b001bfe19a3e44">exponential_cdf</a> (const T_y &amp;y, const T_inv_scale &amp;beta)</td></tr>
<tr class="memdesc:ac753dcf58b69f0bbf7b001bfe19a3e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the exponential cumulative distribution function for the given y and beta.  <a href="#ac753dcf58b69f0bbf7b001bfe19a3e44">More...</a><br/></td></tr>
<tr class="separator:ac753dcf58b69f0bbf7b001bfe19a3e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbf986074ea063853c8d244c3c17e0f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a8fbf986074ea063853c8d244c3c17e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_inv_scale &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8fbf986074ea063853c8d244c3c17e0f">exponential_cdf_log</a> (const T_y &amp;y, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a8fbf986074ea063853c8d244c3c17e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcdf998d9f336fd9e4118acc6c7a129"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:addcdf998d9f336fd9e4118acc6c7a129"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_inv_scale &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#addcdf998d9f336fd9e4118acc6c7a129">exponential_log</a> (const T_y &amp;y, const T_inv_scale &amp;beta)</td></tr>
<tr class="memdesc:addcdf998d9f336fd9e4118acc6c7a129"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an exponential density for y with the specified inverse scale parameter.  <a href="#addcdf998d9f336fd9e4118acc6c7a129">More...</a><br/></td></tr>
<tr class="separator:addcdf998d9f336fd9e4118acc6c7a129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3653c4e36237f4d7403af9f64abbcd2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:af3653c4e36237f4d7403af9f64abbcd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_inv_scale &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af3653c4e36237f4d7403af9f64abbcd2">exponential_log</a> (const T_y &amp;y, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:af3653c4e36237f4d7403af9f64abbcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfcce609912c9a6e1b2fad1e5055a1d"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a6cfcce609912c9a6e1b2fad1e5055a1d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6cfcce609912c9a6e1b2fad1e5055a1d">exponential_rng</a> (const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:a6cfcce609912c9a6e1b2fad1e5055a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34680a4c6abd1d998326e44a212aa6d8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a34680a4c6abd1d998326e44a212aa6d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34680a4c6abd1d998326e44a212aa6d8">frechet_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a34680a4c6abd1d998326e44a212aa6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252058aec5645d61efd61e155b788be7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a252058aec5645d61efd61e155b788be7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a252058aec5645d61efd61e155b788be7">frechet_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a252058aec5645d61efd61e155b788be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1ba53b1f236710eed4f8377dc06471"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:aad1ba53b1f236710eed4f8377dc06471"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aad1ba53b1f236710eed4f8377dc06471">frechet_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aad1ba53b1f236710eed4f8377dc06471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f910a5107250d4b47468fe1e7487cc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a17f910a5107250d4b47468fe1e7487cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a17f910a5107250d4b47468fe1e7487cc">frechet_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a17f910a5107250d4b47468fe1e7487cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f05e7ee3898b2f48b4b2658dad51c5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a63f05e7ee3898b2f48b4b2658dad51c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a63f05e7ee3898b2f48b4b2658dad51c5">frechet_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a63f05e7ee3898b2f48b4b2658dad51c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bd113906fdeaf57e662a598ad99689"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a85bd113906fdeaf57e662a598ad99689"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a85bd113906fdeaf57e662a598ad99689">frechet_rng</a> (const double alpha, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:a85bd113906fdeaf57e662a598ad99689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f6f9efb0e1bacdc6415b6e0d6d6f00"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ae2f6f9efb0e1bacdc6415b6e0d6d6f00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae2f6f9efb0e1bacdc6415b6e0d6d6f00">gamma_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:ae2f6f9efb0e1bacdc6415b6e0d6d6f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad927dbc83dc93b41cfb7a1ab6dccbd9e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ad927dbc83dc93b41cfb7a1ab6dccbd9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad927dbc83dc93b41cfb7a1ab6dccbd9e">gamma_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="memdesc:ad927dbc83dc93b41cfb7a1ab6dccbd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cumulative density function for a gamma distribution for y with the specified shape and inverse scale parameters.  <a href="#ad927dbc83dc93b41cfb7a1ab6dccbd9e">More...</a><br/></td></tr>
<tr class="separator:ad927dbc83dc93b41cfb7a1ab6dccbd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af878fa8fc2eaeec210aff65ec83f5323"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:af878fa8fc2eaeec210aff65ec83f5323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af878fa8fc2eaeec210aff65ec83f5323">gamma_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:af878fa8fc2eaeec210aff65ec83f5323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab77693b33e10406f7ca5d85ce97107f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:aab77693b33e10406f7ca5d85ce97107f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab77693b33e10406f7ca5d85ce97107f">gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="memdesc:aab77693b33e10406f7ca5d85ce97107f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a gamma density for y with the specified shape and inverse scale parameters.  <a href="#aab77693b33e10406f7ca5d85ce97107f">More...</a><br/></td></tr>
<tr class="separator:aab77693b33e10406f7ca5d85ce97107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03197f2fe5c3a96f77a9727f2db29d38"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a03197f2fe5c3a96f77a9727f2db29d38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a03197f2fe5c3a96f77a9727f2db29d38">gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a03197f2fe5c3a96f77a9727f2db29d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf6ec5f55f56b5756804a1771259a58"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aacf6ec5f55f56b5756804a1771259a58"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aacf6ec5f55f56b5756804a1771259a58">gamma_rng</a> (const double alpha, const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:aacf6ec5f55f56b5756804a1771259a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da900adc6bb1216e99f604001cd4caa"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a9da900adc6bb1216e99f604001cd4caa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9da900adc6bb1216e99f604001cd4caa">gumbel_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;beta)</td></tr>
<tr class="separator:a9da900adc6bb1216e99f604001cd4caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ac5bc9a01ebadccc004463b054697c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a52ac5bc9a01ebadccc004463b054697c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a52ac5bc9a01ebadccc004463b054697c">gumbel_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;beta)</td></tr>
<tr class="separator:a52ac5bc9a01ebadccc004463b054697c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f4009f162e58a62a583b84f2d5ccf9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a06f4009f162e58a62a583b84f2d5ccf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a06f4009f162e58a62a583b84f2d5ccf9">gumbel_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;beta)</td></tr>
<tr class="separator:a06f4009f162e58a62a583b84f2d5ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fda97c2d23cb9fd2091e5bd1002e5d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:aa5fda97c2d23cb9fd2091e5bd1002e5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa5fda97c2d23cb9fd2091e5bd1002e5d">gumbel_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;beta)</td></tr>
<tr class="separator:aa5fda97c2d23cb9fd2091e5bd1002e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166ad02fac07d4a084655f8fde1ec2ec"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a166ad02fac07d4a084655f8fde1ec2ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a166ad02fac07d4a084655f8fde1ec2ec">gumbel_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;beta)</td></tr>
<tr class="separator:a166ad02fac07d4a084655f8fde1ec2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7ad70ee185c1e0720086617431f71a"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:afb7ad70ee185c1e0720086617431f71a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afb7ad70ee185c1e0720086617431f71a">gumbel_rng</a> (const double mu, const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:afb7ad70ee185c1e0720086617431f71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf091835ddc913687ab4d34c3eee662e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:acf091835ddc913687ab4d34c3eee662e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acf091835ddc913687ab4d34c3eee662e">hypergeometric_log</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:acf091835ddc913687ab4d34c3eee662e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d194254677d4503c2f5d7c6c4f6224"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:a28d194254677d4503c2f5d7c6c4f6224"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a28d194254677d4503c2f5d7c6c4f6224">hypergeometric_log</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a28d194254677d4503c2f5d7c6c4f6224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3878889879be4781cc8d560f534ab123"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a3878889879be4781cc8d560f534ab123"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3878889879be4781cc8d560f534ab123">hypergeometric_rng</a> (int N, int a, int b, RNG &amp;rng)</td></tr>
<tr class="separator:a3878889879be4781cc8d560f534ab123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a32a9537cf8218b73109b93379b5b1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:a24a32a9537cf8218b73109b93379b5b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a24a32a9537cf8218b73109b93379b5b1">inv_chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:a24a32a9537cf8218b73109b93379b5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372e143655badb8f25e542697f689f39"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:a372e143655badb8f25e542697f689f39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a372e143655badb8f25e542697f689f39">inv_chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:a372e143655badb8f25e542697f689f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae005376416b29d9118470b9c2d18133"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:aae005376416b29d9118470b9c2d18133"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aae005376416b29d9118470b9c2d18133">inv_chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:aae005376416b29d9118470b9c2d18133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae83a74c666a703da52db606eb478f50"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:aae83a74c666a703da52db606eb478f50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aae83a74c666a703da52db606eb478f50">inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:aae83a74c666a703da52db606eb478f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse chi-squared density for y with the specified degrees of freedom parameter.  <a href="#aae83a74c666a703da52db606eb478f50">More...</a><br/></td></tr>
<tr class="separator:aae83a74c666a703da52db606eb478f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b9a4f2fd21b540a7d50a37d23f0869"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:a19b9a4f2fd21b540a7d50a37d23f0869"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a19b9a4f2fd21b540a7d50a37d23f0869">inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:a19b9a4f2fd21b540a7d50a37d23f0869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8159125045ed1c5ee551537c9983921f"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a8159125045ed1c5ee551537c9983921f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8159125045ed1c5ee551537c9983921f">inv_chi_square_rng</a> (const double nu, RNG &amp;rng)</td></tr>
<tr class="separator:a8159125045ed1c5ee551537c9983921f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b35d989d0d1a9cb6ea163bbbd14ed3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:af2b35d989d0d1a9cb6ea163bbbd14ed3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af2b35d989d0d1a9cb6ea163bbbd14ed3">inv_gamma_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;beta)</td></tr>
<tr class="separator:af2b35d989d0d1a9cb6ea163bbbd14ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195c84d2f45abc7bcf28c1d9e3fd8cf8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a195c84d2f45abc7bcf28c1d9e3fd8cf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a195c84d2f45abc7bcf28c1d9e3fd8cf8">inv_gamma_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;beta)</td></tr>
<tr class="memdesc:a195c84d2f45abc7bcf28c1d9e3fd8cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CDF of an inverse gamma density for y with the specified shape and scale parameters.  <a href="#a195c84d2f45abc7bcf28c1d9e3fd8cf8">More...</a><br/></td></tr>
<tr class="separator:a195c84d2f45abc7bcf28c1d9e3fd8cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e622170c7270f1a441235f98248d3a3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a0e622170c7270f1a441235f98248d3a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0e622170c7270f1a441235f98248d3a3">inv_gamma_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;beta)</td></tr>
<tr class="separator:a0e622170c7270f1a441235f98248d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34fa642137e07f723c995d42e78df2c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ad34fa642137e07f723c995d42e78df2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad34fa642137e07f723c995d42e78df2c">inv_gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;beta)</td></tr>
<tr class="memdesc:ad34fa642137e07f723c995d42e78df2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse gamma density for y with the specified shape and scale parameters.  <a href="#ad34fa642137e07f723c995d42e78df2c">More...</a><br/></td></tr>
<tr class="separator:ad34fa642137e07f723c995d42e78df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6c6fb67d4de25708140e5fce64e4f4"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a2a6c6fb67d4de25708140e5fce64e4f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2a6c6fb67d4de25708140e5fce64e4f4">inv_gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;beta)</td></tr>
<tr class="separator:a2a6c6fb67d4de25708140e5fce64e4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3222e632ba4aaeb90753a96520799867"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a3222e632ba4aaeb90753a96520799867"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3222e632ba4aaeb90753a96520799867">inv_gamma_rng</a> (const double alpha, const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:a3222e632ba4aaeb90753a96520799867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd36ac96595c375db7fddc885c30794"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a2fd36ac96595c375db7fddc885c30794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2fd36ac96595c375db7fddc885c30794">logistic_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a2fd36ac96595c375db7fddc885c30794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1ca40295978d785324b33f3a78c96b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a1e1ca40295978d785324b33f3a78c96b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1e1ca40295978d785324b33f3a78c96b">logistic_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a1e1ca40295978d785324b33f3a78c96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d9fcb73b6a1d04896031edc0d8e510"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a88d9fcb73b6a1d04896031edc0d8e510"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a88d9fcb73b6a1d04896031edc0d8e510">logistic_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a88d9fcb73b6a1d04896031edc0d8e510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431d5fcf935535cbe08981286652d57b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a431d5fcf935535cbe08981286652d57b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a431d5fcf935535cbe08981286652d57b">logistic_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a431d5fcf935535cbe08981286652d57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fdf5c03ed2e39d081df54372622eec"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a35fdf5c03ed2e39d081df54372622eec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a35fdf5c03ed2e39d081df54372622eec">logistic_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a35fdf5c03ed2e39d081df54372622eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fc8e75fbb17cb5f22079e90fac128b"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ac9fc8e75fbb17cb5f22079e90fac128b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac9fc8e75fbb17cb5f22079e90fac128b">logistic_rng</a> (const double mu, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ac9fc8e75fbb17cb5f22079e90fac128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb0f2c6b58bc55e506f3bfcf9ba829"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:afacb0f2c6b58bc55e506f3bfcf9ba829"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afacb0f2c6b58bc55e506f3bfcf9ba829">lognormal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:afacb0f2c6b58bc55e506f3bfcf9ba829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9536cc20905aca8f393138adbe71bb73"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a9536cc20905aca8f393138adbe71bb73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9536cc20905aca8f393138adbe71bb73">lognormal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a9536cc20905aca8f393138adbe71bb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a771406ab16c52532e52bebc21c31f6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a1a771406ab16c52532e52bebc21c31f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1a771406ab16c52532e52bebc21c31f6">lognormal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a1a771406ab16c52532e52bebc21c31f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623bb0aad5e3d872d52d0443a46ad270"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a623bb0aad5e3d872d52d0443a46ad270"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a623bb0aad5e3d872d52d0443a46ad270">lognormal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a623bb0aad5e3d872d52d0443a46ad270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfc3796274f4ccd677f96792551c127"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a2bfc3796274f4ccd677f96792551c127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2bfc3796274f4ccd677f96792551c127">lognormal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a2bfc3796274f4ccd677f96792551c127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a619e160ca64fff9f2d69b32bf69b6"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:af5a619e160ca64fff9f2d69b32bf69b6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af5a619e160ca64fff9f2d69b32bf69b6">lognormal_rng</a> (const double mu, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:af5a619e160ca64fff9f2d69b32bf69b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d35a349ee49712178c19dde27fcc5d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:a63d35a349ee49712178c19dde27fcc5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_location, <br class="typebreak"/>
T_precision &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a63d35a349ee49712178c19dde27fcc5d">neg_binomial_2_ccdf_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a63d35a349ee49712178c19dde27fcc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc7b5ee1f4534f7c6eb509f08c1dd8b"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:a6bc7b5ee1f4534f7c6eb509f08c1dd8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_location, <br class="typebreak"/>
T_precision &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6bc7b5ee1f4534f7c6eb509f08c1dd8b">neg_binomial_2_cdf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a6bc7b5ee1f4534f7c6eb509f08c1dd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0a4ada20d2611ea7b7c717bcfd42ad"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ade0a4ada20d2611ea7b7c717bcfd42ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_location, <br class="typebreak"/>
T_precision &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ade0a4ada20d2611ea7b7c717bcfd42ad">neg_binomial_2_cdf_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ade0a4ada20d2611ea7b7c717bcfd42ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72735047f883b88395f4e50e515140d2"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:a72735047f883b88395f4e50e515140d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_location, <br class="typebreak"/>
T_precision &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a72735047f883b88395f4e50e515140d2">neg_binomial_2_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a72735047f883b88395f4e50e515140d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf533af613ce70cc7b53fd678c2363b7"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:abf533af613ce70cc7b53fd678c2363b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_location, <br class="typebreak"/>
T_precision &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abf533af613ce70cc7b53fd678c2363b7">neg_binomial_2_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:abf533af613ce70cc7b53fd678c2363b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f9603fcb9767d59c7aa75cfbd489e9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_location , typename T_precision &gt; </td></tr>
<tr class="memitem:a07f9603fcb9767d59c7aa75cfbd489e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_log_location, <br class="typebreak"/>
T_precision &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a07f9603fcb9767d59c7aa75cfbd489e9">neg_binomial_2_log_log</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:a07f9603fcb9767d59c7aa75cfbd489e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef63f32976322da20fcea2a0c15fb888"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_location , typename T_precision &gt; </td></tr>
<tr class="memitem:aef63f32976322da20fcea2a0c15fb888"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_log_location, <br class="typebreak"/>
T_precision &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aef63f32976322da20fcea2a0c15fb888">neg_binomial_2_log_log</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:aef63f32976322da20fcea2a0c15fb888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626a27ed755b59249175c99dd2548ea3"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a626a27ed755b59249175c99dd2548ea3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a626a27ed755b59249175c99dd2548ea3">neg_binomial_2_log_rng</a> (const double eta, const double phi, RNG &amp;rng)</td></tr>
<tr class="separator:a626a27ed755b59249175c99dd2548ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1088da4c2c0c2b157862fbad43c75d0a"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a1088da4c2c0c2b157862fbad43c75d0a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1088da4c2c0c2b157862fbad43c75d0a">neg_binomial_2_rng</a> (const double mu, const double phi, RNG &amp;rng)</td></tr>
<tr class="separator:a1088da4c2c0c2b157862fbad43c75d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176323fd45f7f70cf9fa801310c3c614"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a176323fd45f7f70cf9fa801310c3c614"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a176323fd45f7f70cf9fa801310c3c614">neg_binomial_ccdf_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a176323fd45f7f70cf9fa801310c3c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e90bd5f65cafdcd66b41617bf31718"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a31e90bd5f65cafdcd66b41617bf31718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a31e90bd5f65cafdcd66b41617bf31718">neg_binomial_cdf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a31e90bd5f65cafdcd66b41617bf31718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e5ebf37ccf49350280631039a23017"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a51e5ebf37ccf49350280631039a23017"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a51e5ebf37ccf49350280631039a23017">neg_binomial_cdf_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a51e5ebf37ccf49350280631039a23017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3f283f0d71f78bb437e1e1c4fdb805"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a5b3f283f0d71f78bb437e1e1c4fdb805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5b3f283f0d71f78bb437e1e1c4fdb805">neg_binomial_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a5b3f283f0d71f78bb437e1e1c4fdb805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24147a6471d65586101de3a5dfa4a53c"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a24147a6471d65586101de3a5dfa4a53c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_shape, <br class="typebreak"/>
T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a24147a6471d65586101de3a5dfa4a53c">neg_binomial_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta)</td></tr>
<tr class="separator:a24147a6471d65586101de3a5dfa4a53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898e2ab003c78229367378b150c78aca"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a898e2ab003c78229367378b150c78aca"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a898e2ab003c78229367378b150c78aca">neg_binomial_rng</a> (const double alpha, const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:a898e2ab003c78229367378b150c78aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2214490cfe7d81bdc51318028cd7df94"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a2214490cfe7d81bdc51318028cd7df94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2214490cfe7d81bdc51318028cd7df94">normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a2214490cfe7d81bdc51318028cd7df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b9ee666af5f1741dc9f75108176386"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:aa2b9ee666af5f1741dc9f75108176386"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa2b9ee666af5f1741dc9f75108176386">normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:aa2b9ee666af5f1741dc9f75108176386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normal cumulative distribution function for the given variate, location, and scale.  <a href="#aa2b9ee666af5f1741dc9f75108176386">More...</a><br/></td></tr>
<tr class="separator:aa2b9ee666af5f1741dc9f75108176386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0b3b3339016b3282cf360feb7cd0f9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a6d0b3b3339016b3282cf360feb7cd0f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d0b3b3339016b3282cf360feb7cd0f9">normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a6d0b3b3339016b3282cf360feb7cd0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d387734f07e63bf2713b610f73a2d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a1b7d387734f07e63bf2713b610f73a2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1b7d387734f07e63bf2713b610f73a2d">normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:a1b7d387734f07e63bf2713b610f73a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s).  <a href="#a1b7d387734f07e63bf2713b610f73a2d">More...</a><br/></td></tr>
<tr class="separator:a1b7d387734f07e63bf2713b610f73a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2fd29076680ce830285130b5fd6f81"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:afc2fd29076680ce830285130b5fd6f81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afc2fd29076680ce830285130b5fd6f81">normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:afc2fd29076680ce830285130b5fd6f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70652885c9903a1122575590075bc78"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ac70652885c9903a1122575590075bc78"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac70652885c9903a1122575590075bc78">normal_rng</a> (const double mu, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ac70652885c9903a1122575590075bc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae265a3d80fc60a58c6642e3cb32e5a3e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ae265a3d80fc60a58c6642e3cb32e5a3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale, <br class="typebreak"/>
T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae265a3d80fc60a58c6642e3cb32e5a3e">pareto_ccdf_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ae265a3d80fc60a58c6642e3cb32e5a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04334b6b9aefbc902c156c6ebabd1b7f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a04334b6b9aefbc902c156c6ebabd1b7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale, <br class="typebreak"/>
T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a04334b6b9aefbc902c156c6ebabd1b7f">pareto_cdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a04334b6b9aefbc902c156c6ebabd1b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b395deb308bc16b82587a97bfb1eba"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a32b395deb308bc16b82587a97bfb1eba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale, <br class="typebreak"/>
T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a32b395deb308bc16b82587a97bfb1eba">pareto_cdf_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a32b395deb308bc16b82587a97bfb1eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eefb96c196d0c61694de1fda5d9a8c6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a4eefb96c196d0c61694de1fda5d9a8c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale, <br class="typebreak"/>
T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4eefb96c196d0c61694de1fda5d9a8c6">pareto_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a4eefb96c196d0c61694de1fda5d9a8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f851b988a9325dc6ea8398d45ff1601"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a3f851b988a9325dc6ea8398d45ff1601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale, <br class="typebreak"/>
T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f851b988a9325dc6ea8398d45ff1601">pareto_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a3f851b988a9325dc6ea8398d45ff1601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624fd25c2bd925d2b96971c70b695245"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a624fd25c2bd925d2b96971c70b695245"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a624fd25c2bd925d2b96971c70b695245">pareto_rng</a> (const double y_min, const double alpha, RNG &amp;rng)</td></tr>
<tr class="separator:a624fd25c2bd925d2b96971c70b695245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f7adad4637fb745bceb3be2db2c6d2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ab4f7adad4637fb745bceb3be2db2c6d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab4f7adad4637fb745bceb3be2db2c6d2">pareto_type_2_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ab4f7adad4637fb745bceb3be2db2c6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa9090877913c41608ec9edc7644718"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a6aa9090877913c41608ec9edc7644718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6aa9090877913c41608ec9edc7644718">pareto_type_2_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a6aa9090877913c41608ec9edc7644718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc69970c0086687e5c19c7c3d4fe5108"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:acc69970c0086687e5c19c7c3d4fe5108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acc69970c0086687e5c19c7c3d4fe5108">pareto_type_2_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:acc69970c0086687e5c19c7c3d4fe5108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078e211e38ac272092603cdf728f3f02"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a078e211e38ac272092603cdf728f3f02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a078e211e38ac272092603cdf728f3f02">pareto_type_2_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a078e211e38ac272092603cdf728f3f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3253943ad32c19d36887e748a4aa6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a5bd3253943ad32c19d36887e748a4aa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5bd3253943ad32c19d36887e748a4aa6">pareto_type_2_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a5bd3253943ad32c19d36887e748a4aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55974320ebae90f0e36341934d8a57b"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:af55974320ebae90f0e36341934d8a57b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af55974320ebae90f0e36341934d8a57b">pareto_type_2_rng</a> (const double mu, const double lambda, const double alpha, RNG &amp;rng)</td></tr>
<tr class="separator:af55974320ebae90f0e36341934d8a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad069a055750c038c054eb7ecabfb53bf"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ad069a055750c038c054eb7ecabfb53bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad069a055750c038c054eb7ecabfb53bf">poisson_ccdf_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ad069a055750c038c054eb7ecabfb53bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84009ffe822acedc6362015fd08107be"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:a84009ffe822acedc6362015fd08107be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a84009ffe822acedc6362015fd08107be">poisson_cdf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:a84009ffe822acedc6362015fd08107be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9138a37ffe00ff85c6824447e85db1"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:acc9138a37ffe00ff85c6824447e85db1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acc9138a37ffe00ff85c6824447e85db1">poisson_cdf_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:acc9138a37ffe00ff85c6824447e85db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a95ee36796c1a077510303bb2535c2"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ae7a95ee36796c1a077510303bb2535c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae7a95ee36796c1a077510303bb2535c2">poisson_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ae7a95ee36796c1a077510303bb2535c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d918359198306069f71f1477a046f"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:a202d918359198306069f71f1477a046f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a202d918359198306069f71f1477a046f">poisson_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:a202d918359198306069f71f1477a046f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a06118d9d96bde7ee5d8c28eb08e5ec"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_rate &gt; </td></tr>
<tr class="memitem:a4a06118d9d96bde7ee5d8c28eb08e5ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_log_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4a06118d9d96bde7ee5d8c28eb08e5ec">poisson_log_log</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:a4a06118d9d96bde7ee5d8c28eb08e5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d441b4aee12ece4fc2d1b4d8027c7a0"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_rate &gt; </td></tr>
<tr class="memitem:a5d441b4aee12ece4fc2d1b4d8027c7a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_log_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5d441b4aee12ece4fc2d1b4d8027c7a0">poisson_log_log</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:a5d441b4aee12ece4fc2d1b4d8027c7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cdc8d2997b25f9ed799555ecf37106"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ac3cdc8d2997b25f9ed799555ecf37106"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac3cdc8d2997b25f9ed799555ecf37106">poisson_log_rng</a> (const double alpha, RNG &amp;rng)</td></tr>
<tr class="separator:ac3cdc8d2997b25f9ed799555ecf37106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7aaf7ee5cf0eb93778d7f30db23834"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a8f7aaf7ee5cf0eb93778d7f30db23834"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8f7aaf7ee5cf0eb93778d7f30db23834">poisson_rng</a> (const double lambda, RNG &amp;rng)</td></tr>
<tr class="separator:a8f7aaf7ee5cf0eb93778d7f30db23834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca6e149995234eee4801ea4090b34cd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:a3ca6e149995234eee4801ea4090b34cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ca6e149995234eee4801ea4090b34cd">rayleigh_ccdf_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a3ca6e149995234eee4801ea4090b34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca0bc173ef3459a1eac46296bcd83bc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:abca0bc173ef3459a1eac46296bcd83bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abca0bc173ef3459a1eac46296bcd83bc">rayleigh_cdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:abca0bc173ef3459a1eac46296bcd83bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae588257225777f6a33cffb2139f8a4d9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:ae588257225777f6a33cffb2139f8a4d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae588257225777f6a33cffb2139f8a4d9">rayleigh_cdf_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ae588257225777f6a33cffb2139f8a4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60039dc0a79268bbb0da0a715b309af9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:a60039dc0a79268bbb0da0a715b309af9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a60039dc0a79268bbb0da0a715b309af9">rayleigh_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a60039dc0a79268bbb0da0a715b309af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87968a836e36d11622dbe52db277f36e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:a87968a836e36d11622dbe52db277f36e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87968a836e36d11622dbe52db277f36e">rayleigh_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a87968a836e36d11622dbe52db277f36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab42ace2560fde585011d2f3c5459139"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aab42ace2560fde585011d2f3c5459139"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab42ace2560fde585011d2f3c5459139">rayleigh_rng</a> (const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:aab42ace2560fde585011d2f3c5459139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fefbbf10f04d62902c383f26d98eaee"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a4fefbbf10f04d62902c383f26d98eaee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4fefbbf10f04d62902c383f26d98eaee">scaled_inv_chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:a4fefbbf10f04d62902c383f26d98eaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5ccd3b4bbd2f80b59a6cfaa2a7ebcb"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:aac5ccd3b4bbd2f80b59a6cfaa2a7ebcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aac5ccd3b4bbd2f80b59a6cfaa2a7ebcb">scaled_inv_chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="memdesc:aac5ccd3b4bbd2f80b59a6cfaa2a7ebcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CDF of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.  <a href="#aac5ccd3b4bbd2f80b59a6cfaa2a7ebcb">More...</a><br/></td></tr>
<tr class="separator:aac5ccd3b4bbd2f80b59a6cfaa2a7ebcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d0c1c0ea0a346e972a2b461fb2b51"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a6f8d0c1c0ea0a346e972a2b461fb2b51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f8d0c1c0ea0a346e972a2b461fb2b51">scaled_inv_chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:a6f8d0c1c0ea0a346e972a2b461fb2b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa760eab5a913100acb5ad73851ec520f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:aa760eab5a913100acb5ad73851ec520f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa760eab5a913100acb5ad73851ec520f">scaled_inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="memdesc:aa760eab5a913100acb5ad73851ec520f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.  <a href="#aa760eab5a913100acb5ad73851ec520f">More...</a><br/></td></tr>
<tr class="separator:aa760eab5a913100acb5ad73851ec520f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469a0510198f66cfb4a23d9f0d185541"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a469a0510198f66cfb4a23d9f0d185541"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a469a0510198f66cfb4a23d9f0d185541">scaled_inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:a469a0510198f66cfb4a23d9f0d185541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb144e1487af0dcab52c5f47fcbc93f"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aefb144e1487af0dcab52c5f47fcbc93f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aefb144e1487af0dcab52c5f47fcbc93f">scaled_inv_chi_square_rng</a> (const double nu, const double s, RNG &amp;rng)</td></tr>
<tr class="separator:aefb144e1487af0dcab52c5f47fcbc93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764774344adc0fc192a79bb25cab62ea"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a764774344adc0fc192a79bb25cab62ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a764774344adc0fc192a79bb25cab62ea">skew_normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a764774344adc0fc192a79bb25cab62ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4619194e1d367590916fb133f99385a7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a4619194e1d367590916fb133f99385a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4619194e1d367590916fb133f99385a7">skew_normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a4619194e1d367590916fb133f99385a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244e671c45143752fe0d8e50dd8d64dd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a244e671c45143752fe0d8e50dd8d64dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a244e671c45143752fe0d8e50dd8d64dd">skew_normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a244e671c45143752fe0d8e50dd8d64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063fa4970b1aced1fe47505e950c5ff9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a063fa4970b1aced1fe47505e950c5ff9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a063fa4970b1aced1fe47505e950c5ff9">skew_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a063fa4970b1aced1fe47505e950c5ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3802cc8e1abfde6592284133457854"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a9f3802cc8e1abfde6592284133457854"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9f3802cc8e1abfde6592284133457854">skew_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a9f3802cc8e1abfde6592284133457854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20ce3e4d117da5792ace24dfc92b1ea"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ae20ce3e4d117da5792ace24dfc92b1ea"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae20ce3e4d117da5792ace24dfc92b1ea">skew_normal_rng</a> (const double mu, const double sigma, const double alpha, RNG &amp;rng)</td></tr>
<tr class="separator:ae20ce3e4d117da5792ace24dfc92b1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7330bcb373ce5df4f6cedb70d4ba571"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:aa7330bcb373ce5df4f6cedb70d4ba571"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa7330bcb373ce5df4f6cedb70d4ba571">student_t_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa7330bcb373ce5df4f6cedb70d4ba571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3707b197842a840217b04e3cc1b0da"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a6c3707b197842a840217b04e3cc1b0da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6c3707b197842a840217b04e3cc1b0da">student_t_cdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a6c3707b197842a840217b04e3cc1b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf7b73942cfee4fec76599b966796d1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a0cf7b73942cfee4fec76599b966796d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0cf7b73942cfee4fec76599b966796d1">student_t_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a0cf7b73942cfee4fec76599b966796d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20962dd5b3da2477c4c2a9170904fb27"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a20962dd5b3da2477c4c2a9170904fb27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a20962dd5b3da2477c4c2a9170904fb27">student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:a20962dd5b3da2477c4c2a9170904fb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Student-t density for the given y, nu, mean, and scale parameter.  <a href="#a20962dd5b3da2477c4c2a9170904fb27">More...</a><br/></td></tr>
<tr class="separator:a20962dd5b3da2477c4c2a9170904fb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25a0e28b3bd50cfc9fb14e9f410bd3b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ab25a0e28b3bd50cfc9fb14e9f410bd3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_dof, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab25a0e28b3bd50cfc9fb14e9f410bd3b">student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ab25a0e28b3bd50cfc9fb14e9f410bd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d151fedbd83f49080ef17c148ef1dad"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a4d151fedbd83f49080ef17c148ef1dad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4d151fedbd83f49080ef17c148ef1dad">student_t_rng</a> (const double nu, const double mu, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:a4d151fedbd83f49080ef17c148ef1dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2b8fa3c8f27cf5fe06e35971810d52"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a5e2b8fa3c8f27cf5fe06e35971810d52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_low, <br class="typebreak"/>
T_high &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e2b8fa3c8f27cf5fe06e35971810d52">uniform_ccdf_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;beta)</td></tr>
<tr class="separator:a5e2b8fa3c8f27cf5fe06e35971810d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15c5027f6cc08a719ce42c82f42e8ab"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:aa15c5027f6cc08a719ce42c82f42e8ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_low, <br class="typebreak"/>
T_high &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa15c5027f6cc08a719ce42c82f42e8ab">uniform_cdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;beta)</td></tr>
<tr class="separator:aa15c5027f6cc08a719ce42c82f42e8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f377bbfcb2c65d7c9b22f2a007cdc71"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a8f377bbfcb2c65d7c9b22f2a007cdc71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_low, <br class="typebreak"/>
T_high &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8f377bbfcb2c65d7c9b22f2a007cdc71">uniform_cdf_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;beta)</td></tr>
<tr class="separator:a8f377bbfcb2c65d7c9b22f2a007cdc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39a215713172d13a104cf33d6186c65"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:ae39a215713172d13a104cf33d6186c65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_low, <br class="typebreak"/>
T_high &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae39a215713172d13a104cf33d6186c65">uniform_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;beta)</td></tr>
<tr class="memdesc:ae39a215713172d13a104cf33d6186c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a uniform density for the given y, lower, and upper bound.  <a href="#ae39a215713172d13a104cf33d6186c65">More...</a><br/></td></tr>
<tr class="separator:ae39a215713172d13a104cf33d6186c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c32b2aba8ca5e5eb4ebe76fd1f9a832"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a9c32b2aba8ca5e5eb4ebe76fd1f9a832"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_low, <br class="typebreak"/>
T_high &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9c32b2aba8ca5e5eb4ebe76fd1f9a832">uniform_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;beta)</td></tr>
<tr class="separator:a9c32b2aba8ca5e5eb4ebe76fd1f9a832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10447d2a77f0fdf32e0adce2546cd3cd"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a10447d2a77f0fdf32e0adce2546cd3cd"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a10447d2a77f0fdf32e0adce2546cd3cd">uniform_rng</a> (const double alpha, const double beta, RNG &amp;rng)</td></tr>
<tr class="separator:a10447d2a77f0fdf32e0adce2546cd3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7a36cd810a693a04ef145882894754"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a3e7a36cd810a693a04ef145882894754"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3e7a36cd810a693a04ef145882894754">von_mises_log</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:a3e7a36cd810a693a04ef145882894754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06353ba5a996ebfc43ec69decf9fb9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a8a06353ba5a996ebfc43ec69decf9fb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_loc, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a06353ba5a996ebfc43ec69decf9fb9">von_mises_log</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:a8a06353ba5a996ebfc43ec69decf9fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71998db3e6cfebf31463452f99878b99"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a71998db3e6cfebf31463452f99878b99"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a71998db3e6cfebf31463452f99878b99">von_mises_rng</a> (const double mu, const double kappa, RNG &amp;rng)</td></tr>
<tr class="separator:a71998db3e6cfebf31463452f99878b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0033ce06f5f7b1109a42eee2579955a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:aa0033ce06f5f7b1109a42eee2579955a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa0033ce06f5f7b1109a42eee2579955a">weibull_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa0033ce06f5f7b1109a42eee2579955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae943a8f5c87e946a45a4f3b62f99b187"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ae943a8f5c87e946a45a4f3b62f99b187"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae943a8f5c87e946a45a4f3b62f99b187">weibull_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ae943a8f5c87e946a45a4f3b62f99b187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94334459868c125f2a6504b69f46158"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ae94334459868c125f2a6504b69f46158"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae94334459868c125f2a6504b69f46158">weibull_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ae94334459868c125f2a6504b69f46158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3a52747636627895374aa555279a92"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a4f3a52747636627895374aa555279a92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4f3a52747636627895374aa555279a92">weibull_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a4f3a52747636627895374aa555279a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76561164f1ff9ed6e70bf4a75e6f8ae2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a76561164f1ff9ed6e70bf4a75e6f8ae2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_shape, <br class="typebreak"/>
T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a76561164f1ff9ed6e70bf4a75e6f8ae2">weibull_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a76561164f1ff9ed6e70bf4a75e6f8ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd376b3fe82077f0565de1fbef6b4202"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:afd376b3fe82077f0565de1fbef6b4202"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afd376b3fe82077f0565de1fbef6b4202">weibull_rng</a> (const double alpha, const double sigma, RNG &amp;rng)</td></tr>
<tr class="separator:afd376b3fe82077f0565de1fbef6b4202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a28135e8fe64782357d52062380796"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:ae7a28135e8fe64782357d52062380796"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_alpha, <br class="typebreak"/>
T_tau, T_beta, T_delta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae7a28135e8fe64782357d52062380796">wiener_log</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;beta, const T_delta &amp;delta)</td></tr>
<tr class="memdesc:ae7a28135e8fe64782357d52062380796"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the first passage time density function for a (Wiener) drift diffusion model for the given <img class="formulaInl" alt="$y$" src="form_200.png"/>, boundary separation <img class="formulaInl" alt="$\alpha$" src="form_201.png"/>, nondecision time <img class="formulaInl" alt="$\tau$" src="form_202.png"/>, relative bias <img class="formulaInl" alt="$\beta$" src="form_203.png"/>, and drift rate <img class="formulaInl" alt="$\delta$" src="form_204.png"/>.  <a href="#ae7a28135e8fe64782357d52062380796">More...</a><br/></td></tr>
<tr class="separator:ae7a28135e8fe64782357d52062380796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ee0070ef7fdeac83b11eae40b1646a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:a51ee0070ef7fdeac83b11eae40b1646a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, T_alpha, <br class="typebreak"/>
T_tau, T_beta, T_delta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a51ee0070ef7fdeac83b11eae40b1646a">wiener_log</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;beta, const T_delta &amp;delta)</td></tr>
<tr class="separator:a51ee0070ef7fdeac83b11eae40b1646a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3072490832a96e50ca3143e4226e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add3072490832a96e50ca3143e4226e67">log_sum_exp</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:add3072490832a96e50ca3143e4226e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#add3072490832a96e50ca3143e4226e67">More...</a><br/></td></tr>
<tr class="separator:add3072490832a96e50ca3143e4226e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2538f04d0c683772fb3f46197d8c0059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2538f04d0c683772fb3f46197d8c0059">sum</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt; &amp;m)</td></tr>
<tr class="memdesc:a2538f04d0c683772fb3f46197d8c0059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the entries of the specified vector.  <a href="#a2538f04d0c683772fb3f46197d8c0059">More...</a><br/></td></tr>
<tr class="separator:a2538f04d0c683772fb3f46197d8c0059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a238bf34fdfe67aa84300d9822f34be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1a238bf34fdfe67aa84300d9822f34be">add_initial_values</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &gt; &amp;y0, std::vector&lt; std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &gt; &gt; &amp;y)</td></tr>
<tr class="memdesc:a1a238bf34fdfe67aa84300d9822f34be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the state derived from the coupled system in the with the original initial state.  <a href="#a1a238bf34fdfe67aa84300d9822f34be">More...</a><br/></td></tr>
<tr class="separator:a1a238bf34fdfe67aa84300d9822f34be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430f171295b91277dc60dfa2177c7c0b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a430f171295b91277dc60dfa2177c7c0b">empty_nested</a> ()</td></tr>
<tr class="memdesc:a430f171295b91277dc60dfa2177c7c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there is no nested autodiff being executed.  <a href="#a430f171295b91277dc60dfa2177c7c0b">More...</a><br/></td></tr>
<tr class="separator:a430f171295b91277dc60dfa2177c7c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c32f9b52bef3a296432df037f96af3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae6c32f9b52bef3a296432df037f96af3">grad</a> (<a class="el" href="classstan_1_1math_1_1chainable.html">chainable</a> *vi)</td></tr>
<tr class="memdesc:ae6c32f9b52bef3a296432df037f96af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for all variables starting from the specified root variable implementation.  <a href="#ae6c32f9b52bef3a296432df037f96af3">More...</a><br/></td></tr>
<tr class="separator:ae6c32f9b52bef3a296432df037f96af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f68ac575a2b8dff3a7a2359962c607"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0f68ac575a2b8dff3a7a2359962c607">nested_size</a> ()</td></tr>
<tr class="separator:ac0f68ac575a2b8dff3a7a2359962c607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb4c7bced043de79d94676dac3cfc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afcb4c7bced043de79d94676dac3cfc4b">operator+</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:afcb4c7bced043de79d94676dac3cfc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for variables (C++).  <a href="#afcb4c7bced043de79d94676dac3cfc4b">More...</a><br/></td></tr>
<tr class="separator:afcb4c7bced043de79d94676dac3cfc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ec1a6c24e3a21e00c42142d582d944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab7ec1a6c24e3a21e00c42142d582d944">operator+</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:ab7ec1a6c24e3a21e00c42142d582d944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for variable and scalar (C++).  <a href="#ab7ec1a6c24e3a21e00c42142d582d944">More...</a><br/></td></tr>
<tr class="separator:ab7ec1a6c24e3a21e00c42142d582d944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2a79efe1e8415fb532a27b26406798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abe2a79efe1e8415fb532a27b26406798">operator+</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:abe2a79efe1e8415fb532a27b26406798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar and variable (C++).  <a href="#abe2a79efe1e8415fb532a27b26406798">More...</a><br/></td></tr>
<tr class="separator:abe2a79efe1e8415fb532a27b26406798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15f9adeb9753deea83b30e18aaf8e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac15f9adeb9753deea83b30e18aaf8e98">operator/</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:ac15f9adeb9753deea83b30e18aaf8e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for two variables (C++).  <a href="#ac15f9adeb9753deea83b30e18aaf8e98">More...</a><br/></td></tr>
<tr class="separator:ac15f9adeb9753deea83b30e18aaf8e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12be933cc2e01e203a6ffa09508d319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa12be933cc2e01e203a6ffa09508d319">operator/</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:aa12be933cc2e01e203a6ffa09508d319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for dividing a variable by a scalar (C++).  <a href="#aa12be933cc2e01e203a6ffa09508d319">More...</a><br/></td></tr>
<tr class="separator:aa12be933cc2e01e203a6ffa09508d319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad2fbfb99eb063eda9ef0b466b2014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a81ad2fbfb99eb063eda9ef0b466b2014">operator/</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a81ad2fbfb99eb063eda9ef0b466b2014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for dividing a scalar by a variable (C++).  <a href="#a81ad2fbfb99eb063eda9ef0b466b2014">More...</a><br/></td></tr>
<tr class="separator:a81ad2fbfb99eb063eda9ef0b466b2014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e8c00dc01b2df161d0d242c124b046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a62e8c00dc01b2df161d0d242c124b046">operator==</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a62e8c00dc01b2df161d0d242c124b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing two variables' values (C++).  <a href="#a62e8c00dc01b2df161d0d242c124b046">More...</a><br/></td></tr>
<tr class="separator:a62e8c00dc01b2df161d0d242c124b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad239b56697788a42a944361e26b56e56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad239b56697788a42a944361e26b56e56">operator==</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:ad239b56697788a42a944361e26b56e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing a variable's value and a double (C++).  <a href="#ad239b56697788a42a944361e26b56e56">More...</a><br/></td></tr>
<tr class="separator:ad239b56697788a42a944361e26b56e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add97c0c3a895203b8ab3205aca59d088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add97c0c3a895203b8ab3205aca59d088">operator==</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:add97c0c3a895203b8ab3205aca59d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing a scalar and a variable's value (C++).  <a href="#add97c0c3a895203b8ab3205aca59d088">More...</a><br/></td></tr>
<tr class="separator:add97c0c3a895203b8ab3205aca59d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465afbe6fb2692b02b60d9760e5cbda9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a465afbe6fb2692b02b60d9760e5cbda9">operator&gt;</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a465afbe6fb2692b02b60d9760e5cbda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing variables' values (C++).  <a href="#a465afbe6fb2692b02b60d9760e5cbda9">More...</a><br/></td></tr>
<tr class="separator:a465afbe6fb2692b02b60d9760e5cbda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361d2b2ac2c39919dc71183312855c92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a361d2b2ac2c39919dc71183312855c92">operator&gt;</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:a361d2b2ac2c39919dc71183312855c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing variable's value and double (C++).  <a href="#a361d2b2ac2c39919dc71183312855c92">More...</a><br/></td></tr>
<tr class="separator:a361d2b2ac2c39919dc71183312855c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b9438d0ef1f58b41a228a1154308aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a34b9438d0ef1f58b41a228a1154308aa">operator&gt;</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a34b9438d0ef1f58b41a228a1154308aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing a double and a variable's value (C++).  <a href="#a34b9438d0ef1f58b41a228a1154308aa">More...</a><br/></td></tr>
<tr class="separator:a34b9438d0ef1f58b41a228a1154308aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938fb84cef113596828ad131e513fa1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a938fb84cef113596828ad131e513fa1e">operator&gt;=</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a938fb84cef113596828ad131e513fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing two variables' values (C++).  <a href="#a938fb84cef113596828ad131e513fa1e">More...</a><br/></td></tr>
<tr class="separator:a938fb84cef113596828ad131e513fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055bb2d4f3560761f3383b0f499e7fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a055bb2d4f3560761f3383b0f499e7fe7">operator&gt;=</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:a055bb2d4f3560761f3383b0f499e7fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing variable's value and double (C++).  <a href="#a055bb2d4f3560761f3383b0f499e7fe7">More...</a><br/></td></tr>
<tr class="separator:a055bb2d4f3560761f3383b0f499e7fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4492a18f751e82a980740f7beac0e025"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4492a18f751e82a980740f7beac0e025">operator&gt;=</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a4492a18f751e82a980740f7beac0e025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing double and variable's value (C++).  <a href="#a4492a18f751e82a980740f7beac0e025">More...</a><br/></td></tr>
<tr class="separator:a4492a18f751e82a980740f7beac0e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe39e7c1b0831663418188ab23b98965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afe39e7c1b0831663418188ab23b98965">operator&lt;</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:afe39e7c1b0831663418188ab23b98965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing variables' values (C++).  <a href="#afe39e7c1b0831663418188ab23b98965">More...</a><br/></td></tr>
<tr class="separator:afe39e7c1b0831663418188ab23b98965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021f473185983f63d23ee362605249d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a021f473185983f63d23ee362605249d8">operator&lt;</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:a021f473185983f63d23ee362605249d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing variable's value and a double (C++).  <a href="#a021f473185983f63d23ee362605249d8">More...</a><br/></td></tr>
<tr class="separator:a021f473185983f63d23ee362605249d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5a959d8186caa585d5922a4facf649"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aec5a959d8186caa585d5922a4facf649">operator&lt;</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:aec5a959d8186caa585d5922a4facf649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing a double and variable's value (C++).  <a href="#aec5a959d8186caa585d5922a4facf649">More...</a><br/></td></tr>
<tr class="separator:aec5a959d8186caa585d5922a4facf649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee09427479a707c4e715677d5036307b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aee09427479a707c4e715677d5036307b">operator&lt;=</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:aee09427479a707c4e715677d5036307b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing two variables' values (C++).  <a href="#aee09427479a707c4e715677d5036307b">More...</a><br/></td></tr>
<tr class="separator:aee09427479a707c4e715677d5036307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f46c552a80c056955c460a1796d724d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f46c552a80c056955c460a1796d724d">operator&lt;=</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:a1f46c552a80c056955c460a1796d724d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing a variable's value and a scalar (C++).  <a href="#a1f46c552a80c056955c460a1796d724d">More...</a><br/></td></tr>
<tr class="separator:a1f46c552a80c056955c460a1796d724d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e6962678ac8407d6d004c48988c1a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a79e6962678ac8407d6d004c48988c1a2">operator&lt;=</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a79e6962678ac8407d6d004c48988c1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing a double and variable's value (C++).  <a href="#a79e6962678ac8407d6d004c48988c1a2">More...</a><br/></td></tr>
<tr class="separator:a79e6962678ac8407d6d004c48988c1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436203414c825bb8765ea82786313909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a436203414c825bb8765ea82786313909">operator*</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a436203414c825bb8765ea82786313909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for two variables (C++).  <a href="#a436203414c825bb8765ea82786313909">More...</a><br/></td></tr>
<tr class="separator:a436203414c825bb8765ea82786313909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63dc18994ab79b22ff3f6a37fe784db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae63dc18994ab79b22ff3f6a37fe784db">operator*</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:ae63dc18994ab79b22ff3f6a37fe784db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for a variable and a scalar (C++).  <a href="#ae63dc18994ab79b22ff3f6a37fe784db">More...</a><br/></td></tr>
<tr class="separator:ae63dc18994ab79b22ff3f6a37fe784db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6de4291925b8d2f8a7060617e276c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa6de4291925b8d2f8a7060617e276c5e">operator*</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa6de4291925b8d2f8a7060617e276c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for a scalar and a variable (C++).  <a href="#aa6de4291925b8d2f8a7060617e276c5e">More...</a><br/></td></tr>
<tr class="separator:aa6de4291925b8d2f8a7060617e276c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23eb5d64637b32c92292456aa006ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae23eb5d64637b32c92292456aa006ff0">operator!=</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:ae23eb5d64637b32c92292456aa006ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing two variables' values (C++).  <a href="#ae23eb5d64637b32c92292456aa006ff0">More...</a><br/></td></tr>
<tr class="separator:ae23eb5d64637b32c92292456aa006ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570111dc15835a88afcfb8130b4746fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a570111dc15835a88afcfb8130b4746fd">operator!=</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:a570111dc15835a88afcfb8130b4746fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing a variable's value and a double (C++).  <a href="#a570111dc15835a88afcfb8130b4746fd">More...</a><br/></td></tr>
<tr class="separator:a570111dc15835a88afcfb8130b4746fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6464b66683b8cf12702e71c155853b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa6464b66683b8cf12702e71c155853b7">operator!=</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa6464b66683b8cf12702e71c155853b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing a double and a variable's value (C++).  <a href="#aa6464b66683b8cf12702e71c155853b7">More...</a><br/></td></tr>
<tr class="separator:aa6464b66683b8cf12702e71c155853b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971b741313ecc65a639076acc188614a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a971b741313ecc65a639076acc188614a">operator-</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a971b741313ecc65a639076acc188614a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for variables (C++).  <a href="#a971b741313ecc65a639076acc188614a">More...</a><br/></td></tr>
<tr class="separator:a971b741313ecc65a639076acc188614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec4b5043616cea0be01ee41fd899198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abec4b5043616cea0be01ee41fd899198">operator-</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:abec4b5043616cea0be01ee41fd899198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for variable and scalar (C++).  <a href="#abec4b5043616cea0be01ee41fd899198">More...</a><br/></td></tr>
<tr class="separator:abec4b5043616cea0be01ee41fd899198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9586c6690c5088deedcbac089158960a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9586c6690c5088deedcbac089158960a">operator-</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a9586c6690c5088deedcbac089158960a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar and variable (C++).  <a href="#a9586c6690c5088deedcbac089158960a">More...</a><br/></td></tr>
<tr class="separator:a9586c6690c5088deedcbac089158960a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e496e6e1fd02a0378a729ada4f39df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a10e496e6e1fd02a0378a729ada4f39df">operator--</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a10e496e6e1fd02a0378a729ada4f39df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator for variables (C++).  <a href="#a10e496e6e1fd02a0378a729ada4f39df">More...</a><br/></td></tr>
<tr class="separator:a10e496e6e1fd02a0378a729ada4f39df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcadc96f506e9f1408647cdce4d09092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abcadc96f506e9f1408647cdce4d09092">operator--</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, int)</td></tr>
<tr class="memdesc:abcadc96f506e9f1408647cdce4d09092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator for variables (C++).  <a href="#abcadc96f506e9f1408647cdce4d09092">More...</a><br/></td></tr>
<tr class="separator:abcadc96f506e9f1408647cdce4d09092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab33c64042765d924f07e7490788e6d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab33c64042765d924f07e7490788e6d4">operator++</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:aab33c64042765d924f07e7490788e6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator for variables (C++).  <a href="#aab33c64042765d924f07e7490788e6d4">More...</a><br/></td></tr>
<tr class="separator:aab33c64042765d924f07e7490788e6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3597f71f364d94814268d4911f111674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3597f71f364d94814268d4911f111674">operator++</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, int)</td></tr>
<tr class="memdesc:a3597f71f364d94814268d4911f111674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator for variables (C++).  <a href="#a3597f71f364d94814268d4911f111674">More...</a><br/></td></tr>
<tr class="separator:a3597f71f364d94814268d4911f111674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8564365599db5cea0b51b635ea482a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2f8564365599db5cea0b51b635ea482a">operator-</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2f8564365599db5cea0b51b635ea482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation operator for variables (C++).  <a href="#a2f8564365599db5cea0b51b635ea482a">More...</a><br/></td></tr>
<tr class="separator:a2f8564365599db5cea0b51b635ea482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee31e071296bea410dd943347b9a65d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeee31e071296bea410dd943347b9a65d">operator!</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:aeee31e071296bea410dd943347b9a65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix logical negation for the value of variables (C++).  <a href="#aeee31e071296bea410dd943347b9a65d">More...</a><br/></td></tr>
<tr class="separator:aeee31e071296bea410dd943347b9a65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f17a8253887d3b573fd59c5a4c6769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a28f17a8253887d3b573fd59c5a4c6769">operator+</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a28f17a8253887d3b573fd59c5a4c6769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus operator for variables (C++).  <a href="#a28f17a8253887d3b573fd59c5a4c6769">More...</a><br/></td></tr>
<tr class="separator:a28f17a8253887d3b573fd59c5a4c6769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae0c4c9c64db8bb166f67caf352b35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2ae0c4c9c64db8bb166f67caf352b35f">precomputed_gradients</a> (const double value, const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt; &amp;operands, const std::vector&lt; double &gt; &amp;gradients)</td></tr>
<tr class="memdesc:a2ae0c4c9c64db8bb166f67caf352b35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a var for an expression that has the specified value, vector of operands, and vector of partial derivatives of value with respect to the operands.  <a href="#a2ae0c4c9c64db8bb166f67caf352b35f">More...</a><br/></td></tr>
<tr class="separator:a2ae0c4c9c64db8bb166f67caf352b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0611cecb5356e187818c1901134c7665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0611cecb5356e187818c1901134c7665">print_stack</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a0611cecb5356e187818c1901134c7665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the auto-dif variable stack.  <a href="#a0611cecb5356e187818c1901134c7665">More...</a><br/></td></tr>
<tr class="separator:a0611cecb5356e187818c1901134c7665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2cbb83ac9ef52296755690e61f4298"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afe2cbb83ac9ef52296755690e61f4298">recover_memory</a> ()</td></tr>
<tr class="memdesc:afe2cbb83ac9ef52296755690e61f4298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover memory used for all variables for reuse.  <a href="#afe2cbb83ac9ef52296755690e61f4298">More...</a><br/></td></tr>
<tr class="separator:afe2cbb83ac9ef52296755690e61f4298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8ebf2b2bc0f63dcb46a176b43e8b369a">recover_memory_nested</a> ()</td></tr>
<tr class="memdesc:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover only the memory used for the top nested call.  <a href="#a8ebf2b2bc0f63dcb46a176b43e8b369a">More...</a><br/></td></tr>
<tr class="separator:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9614efc6fd66533b74b43ddb69f21d3b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9614efc6fd66533b74b43ddb69f21d3b">set_zero_all_adjoints</a> ()</td></tr>
<tr class="memdesc:a9614efc6fd66533b74b43ddb69f21d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all adjoint values in the stack to zero.  <a href="#a9614efc6fd66533b74b43ddb69f21d3b">More...</a><br/></td></tr>
<tr class="separator:a9614efc6fd66533b74b43ddb69f21d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad4a72c89ed9143a7760cc3611e8a0df0">start_nested</a> ()</td></tr>
<tr class="memdesc:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the current position so that <code><a class="el" href="namespacestan_1_1math.html#a8ebf2b2bc0f63dcb46a176b43e8b369a" title="Recover only the memory used for the top nested call. ">recover_memory_nested()</a></code> can find it.  <a href="#ad4a72c89ed9143a7760cc3611e8a0df0">More...</a><br/></td></tr>
<tr class="separator:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c32f9b52bef3a296432df037f96af3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae6c32f9b52bef3a296432df037f96af3">grad</a> (<a class="el" href="classstan_1_1math_1_1chainable.html">chainable</a> *vi)</td></tr>
<tr class="separator:ae6c32f9b52bef3a296432df037f96af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f7ba0991c234a715af5b4968a28014"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a09f7ba0991c234a715af5b4968a28014"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T2, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, Eigen::Matrix<br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, 1, C1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09f7ba0991c234a715af5b4968a28014">columns_dot_product</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a09f7ba0991c234a715af5b4968a28014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1e866e49a056dc81b8b6b673dda0f8"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a5f1e866e49a056dc81b8b6b673dda0f8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, 1, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5f1e866e49a056dc81b8b6b673dda0f8">columns_dot_self</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a5f1e866e49a056dc81b8b6b673dda0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="#a5f1e866e49a056dc81b8b6b673dda0f8">More...</a><br/></td></tr>
<tr class="separator:a5f1e866e49a056dc81b8b6b673dda0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8605c80796abfc9c7082d001e8fd4501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8605c80796abfc9c7082d001e8fd4501">crossprod</a> (const <a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> &amp;M)</td></tr>
<tr class="memdesc:a8605c80796abfc9c7082d001e8fd4501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <a href="#a8605c80796abfc9c7082d001e8fd4501">More...</a><br/></td></tr>
<tr class="separator:a8605c80796abfc9c7082d001e8fd4501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cf09ca9596a572e5040deaecfba87f"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a25cf09ca9596a572e5040deaecfba87f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a25cf09ca9596a572e5040deaecfba87f">determinant</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a25cf09ca9596a572e5040deaecfba87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66343caaf5970081f4eedc8b178bc4d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66343caaf5970081f4eedc8b178bc4d0">divide</a> (double x, double y)</td></tr>
<tr class="memdesc:a66343caaf5970081f4eedc8b178bc4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the division of the first scalar by the second scalar.  <a href="#a66343caaf5970081f4eedc8b178bc4d0">More...</a><br/></td></tr>
<tr class="separator:a66343caaf5970081f4eedc8b178bc4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aad4b9e552bacdbcac3b0bbd783d31"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae0aad4b9e552bacdbcac3b0bbd783d31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae0aad4b9e552bacdbcac3b0bbd783d31">divide</a> (const T1 &amp;v, const T2 &amp;c)</td></tr>
<tr class="separator:ae0aad4b9e552bacdbcac3b0bbd783d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818fcac13304ea5c8679b3fc38e51ac1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R, int C&gt; </td></tr>
<tr class="memitem:a818fcac13304ea5c8679b3fc38e51ac1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a818fcac13304ea5c8679b3fc38e51ac1">divide</a> (const Eigen::Matrix&lt; T1, R, C &gt; &amp;v, const T2 &amp;c)</td></tr>
<tr class="memdesc:a818fcac13304ea5c8679b3fc38e51ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the division of the specified column vector by the specified scalar.  <a href="#a818fcac13304ea5c8679b3fc38e51ac1">More...</a><br/></td></tr>
<tr class="separator:a818fcac13304ea5c8679b3fc38e51ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70b6ae039b48ca04b071daf5e265363"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:ad70b6ae039b48ca04b071daf5e265363"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T2, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad70b6ae039b48ca04b071daf5e265363">dot_product</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad70b6ae039b48ca04b071daf5e265363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product.  <a href="#ad70b6ae039b48ca04b071daf5e265363">More...</a><br/></td></tr>
<tr class="separator:ad70b6ae039b48ca04b071daf5e265363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc208771c9df3e3e96901fb27a05dde0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:afc208771c9df3e3e96901fb27a05dde0"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T2, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afc208771c9df3e3e96901fb27a05dde0">dot_product</a> (const T1 *v1, const T2 *v2, size_t <a class="el" href="namespacestan.html#adb2e0700b1ec87a5e080cd50026b0182">length</a>)</td></tr>
<tr class="memdesc:afc208771c9df3e3e96901fb27a05dde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product.  <a href="#afc208771c9df3e3e96901fb27a05dde0">More...</a><br/></td></tr>
<tr class="separator:afc208771c9df3e3e96901fb27a05dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07462a84486826d0b7fe3cfebb51d386"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a07462a84486826d0b7fe3cfebb51d386"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T2, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a07462a84486826d0b7fe3cfebb51d386">dot_product</a> (const std::vector&lt; T1 &gt; &amp;v1, const std::vector&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a07462a84486826d0b7fe3cfebb51d386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product.  <a href="#a07462a84486826d0b7fe3cfebb51d386">More...</a><br/></td></tr>
<tr class="separator:a07462a84486826d0b7fe3cfebb51d386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9f13b58d14d7b7b8cc43ab30a434d0"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:add9f13b58d14d7b7b8cc43ab30a434d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add9f13b58d14d7b7b8cc43ab30a434d0">dot_self</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;v)</td></tr>
<tr class="memdesc:add9f13b58d14d7b7b8cc43ab30a434d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of a vector with itself.  <a href="#add9f13b58d14d7b7b8cc43ab30a434d0">More...</a><br/></td></tr>
<tr class="separator:add9f13b58d14d7b7b8cc43ab30a434d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c351f7c1ef5ea39c047fe102f70da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a78c351f7c1ef5ea39c047fe102f70da3">grad</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;v, Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, Eigen::Dynamic, 1 &gt; &amp;x, Eigen::VectorXd &amp;g)</td></tr>
<tr class="memdesc:a78c351f7c1ef5ea39c047fe102f70da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate chain rule to calculate gradients starting from the specified variable.  <a href="#a78c351f7c1ef5ea39c047fe102f70da3">More...</a><br/></td></tr>
<tr class="separator:a78c351f7c1ef5ea39c047fe102f70da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf0a5cd40134110da3230d6fdea989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aebdf0a5cd40134110da3230d6fdea989">initialize_variable</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;variable, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;value)</td></tr>
<tr class="memdesc:aebdf0a5cd40134110da3230d6fdea989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize variable to value.  <a href="#aebdf0a5cd40134110da3230d6fdea989">More...</a><br/></td></tr>
<tr class="separator:aebdf0a5cd40134110da3230d6fdea989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bb474a393fa5277ff69c9498cb3809"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ad1bb474a393fa5277ff69c9498cb3809"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad1bb474a393fa5277ff69c9498cb3809">initialize_variable</a> (Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;matrix, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;value)</td></tr>
<tr class="memdesc:ad1bb474a393fa5277ff69c9498cb3809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize every cell in the matrix to the specified value.  <a href="#ad1bb474a393fa5277ff69c9498cb3809">More...</a><br/></td></tr>
<tr class="separator:ad1bb474a393fa5277ff69c9498cb3809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ada62635d3e2320c9e36ac59a1c4bbdb0">initialize_variable</a> (std::vector&lt; T &gt; &amp;variables, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;value)</td></tr>
<tr class="memdesc:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the variables in the standard vector recursively.  <a href="#ada62635d3e2320c9e36ac59a1c4bbdb0">More...</a><br/></td></tr>
<tr class="separator:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83dcd77f80cb38f31af8c5284370112"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ae83dcd77f80cb38f31af8c5284370112"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae83dcd77f80cb38f31af8c5284370112">log_determinant</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;m)</td></tr>
<tr class="separator:ae83dcd77f80cb38f31af8c5284370112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc785decbbbee8de2a2b8f2df9715d48"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:acc785decbbbee8de2a2b8f2df9715d48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acc785decbbbee8de2a2b8f2df9715d48">log_determinant_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;A)</td></tr>
<tr class="separator:acc785decbbbee8de2a2b8f2df9715d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ff74da7a827b5e433fc8d65d8b73e9"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a18ff74da7a827b5e433fc8d65d8b73e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a18ff74da7a827b5e433fc8d65d8b73e9">log_determinant_spd</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a18ff74da7a827b5e433fc8d65d8b73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443bda462051b08fcd0274c3ae1c73aa"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a443bda462051b08fcd0274c3ae1c73aa">log_softmax</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, Eigen::Dynamic, 1 &gt; &amp;alpha)</td></tr>
<tr class="memdesc:a443bda462051b08fcd0274c3ae1c73aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector.  <a href="#a443bda462051b08fcd0274c3ae1c73aa">More...</a><br/></td></tr>
<tr class="separator:a443bda462051b08fcd0274c3ae1c73aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99a093a231daf213b589a2c96644fd7"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:aa99a093a231daf213b589a2c96644fd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa99a093a231daf213b589a2c96644fd7">log_sum_exp</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:aa99a093a231daf213b589a2c96644fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#aa99a093a231daf213b589a2c96644fd7">More...</a><br/></td></tr>
<tr class="separator:aa99a093a231daf213b589a2c96644fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0d163d45e4ee75444257dea341b731"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aef0d163d45e4ee75444257dea341b731"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aef0d163d45e4ee75444257dea341b731">mdivide_left</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:aef0d163d45e4ee75444257dea341b731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f9550fa3c3a000d8fb1657681d7ecb"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ad6f9550fa3c3a000d8fb1657681d7ecb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad6f9550fa3c3a000d8fb1657681d7ecb">mdivide_left</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:ad6f9550fa3c3a000d8fb1657681d7ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0203466ed040dd643c8b6d4a78d7f53"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ad0203466ed040dd643c8b6d4a78d7f53"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad0203466ed040dd643c8b6d4a78d7f53">mdivide_left</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:ad0203466ed040dd643c8b6d4a78d7f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f1163f092f8ce7053a67d3d46302ef"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a84f1163f092f8ce7053a67d3d46302ef"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a84f1163f092f8ce7053a67d3d46302ef">mdivide_left_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a84f1163f092f8ce7053a67d3d46302ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#a84f1163f092f8ce7053a67d3d46302ef">More...</a><br/></td></tr>
<tr class="separator:a84f1163f092f8ce7053a67d3d46302ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4be1cd5b51a7d2758a75e9541ad042"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a6a4be1cd5b51a7d2758a75e9541ad042"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6a4be1cd5b51a7d2758a75e9541ad042">mdivide_left_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a6a4be1cd5b51a7d2758a75e9541ad042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#a6a4be1cd5b51a7d2758a75e9541ad042">More...</a><br/></td></tr>
<tr class="separator:a6a4be1cd5b51a7d2758a75e9541ad042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed166703ba12f63c6cad94e0cc5a6f8f"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aed166703ba12f63c6cad94e0cc5a6f8f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aed166703ba12f63c6cad94e0cc5a6f8f">mdivide_left_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="memdesc:aed166703ba12f63c6cad94e0cc5a6f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A.  <a href="#aed166703ba12f63c6cad94e0cc5a6f8f">More...</a><br/></td></tr>
<tr class="separator:aed166703ba12f63c6cad94e0cc5a6f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba7ed90b8091cf3dee35b9d4688cbc0"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a1ba7ed90b8091cf3dee35b9d4688cbc0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1ba7ed90b8091cf3dee35b9d4688cbc0">mdivide_left_spd</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a1ba7ed90b8091cf3dee35b9d4688cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3487ef4bdd1b20d8d5e5f7d5ff57738"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:ae3487ef4bdd1b20d8d5e5f7d5ff57738"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae3487ef4bdd1b20d8d5e5f7d5ff57738">mdivide_left_spd</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:ae3487ef4bdd1b20d8d5e5f7d5ff57738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8412be81e5c41c2b59e761476ac82a"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a4b8412be81e5c41c2b59e761476ac82a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4b8412be81e5c41c2b59e761476ac82a">mdivide_left_spd</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a4b8412be81e5c41c2b59e761476ac82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2622a3a81c3faba8fa3c3dfc5f848b48"><td class="memTemplParams" colspan="2">template&lt;int TriView, int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a2622a3a81c3faba8fa3c3dfc5f848b48"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2622a3a81c3faba8fa3c3dfc5f848b48">mdivide_left_tri</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a2622a3a81c3faba8fa3c3dfc5f848b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f2d1a3336eefc43a12affb5862e663"><td class="memTemplParams" colspan="2">template&lt;int TriView, int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aa1f2d1a3336eefc43a12affb5862e663"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1f2d1a3336eefc43a12affb5862e663">mdivide_left_tri</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:aa1f2d1a3336eefc43a12affb5862e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318338a3886f5b653a5e5d284db4ce50"><td class="memTemplParams" colspan="2">template&lt;int TriView, int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a318338a3886f5b653a5e5d284db4ce50"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a318338a3886f5b653a5e5d284db4ce50">mdivide_left_tri</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;A, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;b)</td></tr>
<tr class="separator:a318338a3886f5b653a5e5d284db4ce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064999d72ccfe825466a8d35221270c6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a064999d72ccfe825466a8d35221270c6"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; (boost::is_scalar&lt; T1 &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T1, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value)&amp;&amp;(boost::is_scalar<br class="typebreak"/>
&lt; T2 &gt;::value||boost::is_same<br class="typebreak"/>
&lt; T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value), typename <br class="typebreak"/>
boost::math::tools::promote_args<br class="typebreak"/>
&lt; T1, T2 &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a064999d72ccfe825466a8d35221270c6">multiply</a> (const T1 &amp;v, const T2 &amp;c)</td></tr>
<tr class="memdesc:a064999d72ccfe825466a8d35221270c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two scalars.  <a href="#a064999d72ccfe825466a8d35221270c6">More...</a><br/></td></tr>
<tr class="separator:a064999d72ccfe825466a8d35221270c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2287bd9466a58f7df6ca88bf3374c7e9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a2287bd9466a58f7df6ca88bf3374c7e9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2287bd9466a58f7df6ca88bf3374c7e9">multiply</a> (const T1 &amp;c, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a2287bd9466a58f7df6ca88bf3374c7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of scalar and matrix.  <a href="#a2287bd9466a58f7df6ca88bf3374c7e9">More...</a><br/></td></tr>
<tr class="separator:a2287bd9466a58f7df6ca88bf3374c7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0671954ee3596b7ca59ec1e3bf832c63"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 &gt; </td></tr>
<tr class="memitem:a0671954ee3596b7ca59ec1e3bf832c63"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0671954ee3596b7ca59ec1e3bf832c63">multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m, const T2 &amp;c)</td></tr>
<tr class="memdesc:a0671954ee3596b7ca59ec1e3bf832c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of scalar and matrix.  <a href="#a0671954ee3596b7ca59ec1e3bf832c63">More...</a><br/></td></tr>
<tr class="separator:a0671954ee3596b7ca59ec1e3bf832c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba7d9d70a0b0c4515d767bcde7d2f66"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a6ba7d9d70a0b0c4515d767bcde7d2f66"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T2, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, Eigen::Matrix<br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6ba7d9d70a0b0c4515d767bcde7d2f66">multiply</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;m1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:a6ba7d9d70a0b0c4515d767bcde7d2f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <a href="#a6ba7d9d70a0b0c4515d767bcde7d2f66">More...</a><br/></td></tr>
<tr class="separator:a6ba7d9d70a0b0c4515d767bcde7d2f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaecf22fee1b8944975a8124cd294bf0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int C1, typename T2 , int R2&gt; </td></tr>
<tr class="memitem:aeaecf22fee1b8944975a8124cd294bf0"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T2, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aeaecf22fee1b8944975a8124cd294bf0">multiply</a> (const Eigen::Matrix&lt; T1, 1, C1 &gt; &amp;rv, const Eigen::Matrix&lt; T2, R2, 1 &gt; &amp;v)</td></tr>
<tr class="memdesc:aeaecf22fee1b8944975a8124cd294bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scalar product of the specified row vector and specified column vector.  <a href="#aeaecf22fee1b8944975a8124cd294bf0">More...</a><br/></td></tr>
<tr class="separator:aeaecf22fee1b8944975a8124cd294bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4d12daa275a9a471974f6447396266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f4d12daa275a9a471974f6447396266">multiply_lower_tri_self_transpose</a> (const <a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> &amp;L)</td></tr>
<tr class="separator:a6f4d12daa275a9a471974f6447396266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29c95a66e3c89b411b47a9613f7d00c"><td class="memTemplParams" colspan="2">template&lt;typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </td></tr>
<tr class="memitem:ae29c95a66e3c89b411b47a9613f7d00c"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; TB, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, Eigen::Matrix<br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, CB, CB &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae29c95a66e3c89b411b47a9613f7d00c">quad_form</a> (const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:ae29c95a66e3c89b411b47a9613f7d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78760f17a4a1aa70975f3c4abbc1d03d"><td class="memTemplParams" colspan="2">template&lt;typename TA , int RA, int CA, typename TB , int RB&gt; </td></tr>
<tr class="memitem:a78760f17a4a1aa70975f3c4abbc1d03d"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; TB, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a78760f17a4a1aa70975f3c4abbc1d03d">quad_form</a> (const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; TB, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a78760f17a4a1aa70975f3c4abbc1d03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0e772a20247cedc2da98a9c8946c89"><td class="memTemplParams" colspan="2">template&lt;typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </td></tr>
<tr class="memitem:a0e0e772a20247cedc2da98a9c8946c89"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; TB, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, Eigen::Matrix<br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, CB, CB &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0e0e772a20247cedc2da98a9c8946c89">quad_form_sym</a> (const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:a0e0e772a20247cedc2da98a9c8946c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e79db5761062cc2b5eebe9edca4127e"><td class="memTemplParams" colspan="2">template&lt;typename TA , int RA, int CA, typename TB , int RB&gt; </td></tr>
<tr class="memitem:a8e79db5761062cc2b5eebe9edca4127e"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; TB, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8e79db5761062cc2b5eebe9edca4127e">quad_form_sym</a> (const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; TB, RB, 1 &gt; &amp;B)</td></tr>
<tr class="separator:a8e79db5761062cc2b5eebe9edca4127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719a9c5d9d748a503b52d44ed4802193"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </td></tr>
<tr class="memitem:a719a9c5d9d748a503b52d44ed4802193"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; T2, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, Eigen::Matrix<br class="typebreak"/>
&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, 1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a719a9c5d9d748a503b52d44ed4802193">rows_dot_product</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a719a9c5d9d748a503b52d44ed4802193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a5f3ceef72929ae7b80e83338d33f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa6a5f3ceef72929ae7b80e83338d33f3">sd</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:aa6a5f3ceef72929ae7b80e83338d33f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample standard deviation of the specified standard vector.  <a href="#aa6a5f3ceef72929ae7b80e83338d33f3">More...</a><br/></td></tr>
<tr class="separator:aa6a5f3ceef72929ae7b80e83338d33f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706c4baf534be70bbaa1cceae41da186"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a706c4baf534be70bbaa1cceae41da186"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a706c4baf534be70bbaa1cceae41da186">sd</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a706c4baf534be70bbaa1cceae41da186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc994b4977baae2d53f2d0a60c77522"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, <br class="typebreak"/>
Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9fc994b4977baae2d53f2d0a60c77522">softmax</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, Eigen::Dynamic, 1 &gt; &amp;alpha)</td></tr>
<tr class="memdesc:a9fc994b4977baae2d53f2d0a60c77522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector.  <a href="#a9fc994b4977baae2d53f2d0a60c77522">More...</a><br/></td></tr>
<tr class="separator:a9fc994b4977baae2d53f2d0a60c77522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8583739553a742829c5e0b39879af0dd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8583739553a742829c5e0b39879af0dd">sort_asc</a> (std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt; xs)</td></tr>
<tr class="memdesc:a8583739553a742829c5e0b39879af0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in ascending order with gradients kept.  <a href="#a8583739553a742829c5e0b39879af0dd">More...</a><br/></td></tr>
<tr class="separator:a8583739553a742829c5e0b39879af0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0391669326527e057a3f0865703b13d"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ac0391669326527e057a3f0865703b13d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0391669326527e057a3f0865703b13d">sort_asc</a> (Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; xs)</td></tr>
<tr class="memdesc:ac0391669326527e057a3f0865703b13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in ascending order with gradients kept.  <a href="#ac0391669326527e057a3f0865703b13d">More...</a><br/></td></tr>
<tr class="separator:ac0391669326527e057a3f0865703b13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cefcb10a8af1224993d04e812f74e5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8cefcb10a8af1224993d04e812f74e5e">sort_desc</a> (std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt; xs)</td></tr>
<tr class="memdesc:a8cefcb10a8af1224993d04e812f74e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in descending order with gradients kept.  <a href="#a8cefcb10a8af1224993d04e812f74e5e">More...</a><br/></td></tr>
<tr class="separator:a8cefcb10a8af1224993d04e812f74e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8d83ef27eeacd30d11964ce32f4186"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a5d8d83ef27eeacd30d11964ce32f4186"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5d8d83ef27eeacd30d11964ce32f4186">sort_desc</a> (Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; xs)</td></tr>
<tr class="memdesc:a5d8d83ef27eeacd30d11964ce32f4186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified eigen vector in descending order with gradients kept.  <a href="#a5d8d83ef27eeacd30d11964ce32f4186">More...</a><br/></td></tr>
<tr class="separator:a5d8d83ef27eeacd30d11964ce32f4186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2e9c8de72e19836336f70e6c03341c"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a2d2e9c8de72e19836336f70e6c03341c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2d2e9c8de72e19836336f70e6c03341c">squared_distance</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a2d2e9c8de72e19836336f70e6c03341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b6cfbac0ae13e4217fba5ff20ac9e4"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:a57b6cfbac0ae13e4217fba5ff20ac9e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a57b6cfbac0ae13e4217fba5ff20ac9e4">squared_distance</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:a57b6cfbac0ae13e4217fba5ff20ac9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5483c9ea2644a3b127b36f32668bbec"><td class="memTemplParams" colspan="2">template&lt;int R1, int C1, int R2, int C2&gt; </td></tr>
<tr class="memitem:aa5483c9ea2644a3b127b36f32668bbec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa5483c9ea2644a3b127b36f32668bbec">squared_distance</a> (const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;v1, const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2 &gt; &amp;v2)</td></tr>
<tr class="separator:aa5483c9ea2644a3b127b36f32668bbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45f57a15327ae4f94a1aef0bcd869f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab45f57a15327ae4f94a1aef0bcd869f">stan_print</a> (std::ostream *o, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;x)</td></tr>
<tr class="separator:aab45f57a15327ae4f94a1aef0bcd869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec64f77d2621d9f1aada5a8d2e90c2b"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a1ec64f77d2621d9f1aada5a8d2e90c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1ec64f77d2621d9f1aada5a8d2e90c2b">sum</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;m)</td></tr>
<tr class="memdesc:a1ec64f77d2621d9f1aada5a8d2e90c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified matrix, column vector or row vector.  <a href="#a1ec64f77d2621d9f1aada5a8d2e90c2b">More...</a><br/></td></tr>
<tr class="separator:a1ec64f77d2621d9f1aada5a8d2e90c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ab719a94e19bfcf26e208ffcf5ff9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a03ab719a94e19bfcf26e208ffcf5ff9a">tcrossprod</a> (const <a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> &amp;M)</td></tr>
<tr class="memdesc:a03ab719a94e19bfcf26e208ffcf5ff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="#a03ab719a94e19bfcf26e208ffcf5ff9a">More...</a><br/></td></tr>
<tr class="separator:a03ab719a94e19bfcf26e208ffcf5ff9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ea285d4408c28e9ec6dc2ca1b571b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a06ea285d4408c28e9ec6dc2ca1b571b5">to_var</a> (const double &amp;x)</td></tr>
<tr class="memdesc:a06ea285d4408c28e9ec6dc2ca1b571b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#a06ea285d4408c28e9ec6dc2ca1b571b5">More...</a><br/></td></tr>
<tr class="separator:a06ea285d4408c28e9ec6dc2ca1b571b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad5c0d61bde25dc78e090509b4b3149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adad5c0d61bde25dc78e090509b4b3149">to_var</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;x)</td></tr>
<tr class="memdesc:adad5c0d61bde25dc78e090509b4b3149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#adad5c0d61bde25dc78e090509b4b3149">More...</a><br/></td></tr>
<tr class="separator:adad5c0d61bde25dc78e090509b4b3149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae9f601dd5faa6dcfa6e4edd7e84be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adae9f601dd5faa6dcfa6e4edd7e84be9">to_var</a> (const <a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">stan::math::matrix_d</a> &amp;m)</td></tr>
<tr class="memdesc:adae9f601dd5faa6dcfa6e4edd7e84be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#adae9f601dd5faa6dcfa6e4edd7e84be9">More...</a><br/></td></tr>
<tr class="separator:adae9f601dd5faa6dcfa6e4edd7e84be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40674afd6b5163ad3e859fc7da721faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a40674afd6b5163ad3e859fc7da721faf">to_var</a> (const <a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> &amp;m)</td></tr>
<tr class="memdesc:a40674afd6b5163ad3e859fc7da721faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#a40674afd6b5163ad3e859fc7da721faf">More...</a><br/></td></tr>
<tr class="separator:a40674afd6b5163ad3e859fc7da721faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345ee377fd33a8f5101a87482e098247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#aa7d3137027b10bc7758d4c1763b58a8e">vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a345ee377fd33a8f5101a87482e098247">to_var</a> (const <a class="el" href="namespacestan_1_1math.html#ac9e96c15b87fbd704ab9bcf77e7597db">stan::math::vector_d</a> &amp;v)</td></tr>
<tr class="memdesc:a345ee377fd33a8f5101a87482e098247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#a345ee377fd33a8f5101a87482e098247">More...</a><br/></td></tr>
<tr class="separator:a345ee377fd33a8f5101a87482e098247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd6f29816f4c58601da47f272848187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#aa7d3137027b10bc7758d4c1763b58a8e">vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abdd6f29816f4c58601da47f272848187">to_var</a> (const <a class="el" href="namespacestan_1_1math.html#aa7d3137027b10bc7758d4c1763b58a8e">vector_v</a> &amp;v)</td></tr>
<tr class="memdesc:abdd6f29816f4c58601da47f272848187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#abdd6f29816f4c58601da47f272848187">More...</a><br/></td></tr>
<tr class="separator:abdd6f29816f4c58601da47f272848187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98e7e17d969cb7ee4b36dce58137cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a05401bf8bb7f886d11b1ee90495fe153">row_vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac98e7e17d969cb7ee4b36dce58137cba">to_var</a> (const <a class="el" href="namespacestan_1_1math.html#ac61a9b8f4000b9e69bf2d1dcfb34c984">stan::math::row_vector_d</a> &amp;rv)</td></tr>
<tr class="memdesc:ac98e7e17d969cb7ee4b36dce58137cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#ac98e7e17d969cb7ee4b36dce58137cba">More...</a><br/></td></tr>
<tr class="separator:ac98e7e17d969cb7ee4b36dce58137cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28a0e06bb7bd6be39ef50f90e529ccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math.html#a05401bf8bb7f886d11b1ee90495fe153">row_vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac28a0e06bb7bd6be39ef50f90e529ccd">to_var</a> (const <a class="el" href="namespacestan_1_1math.html#a05401bf8bb7f886d11b1ee90495fe153">row_vector_v</a> &amp;rv)</td></tr>
<tr class="memdesc:ac28a0e06bb7bd6be39ef50f90e529ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="#ac28a0e06bb7bd6be39ef50f90e529ccd">More...</a><br/></td></tr>
<tr class="separator:ac28a0e06bb7bd6be39ef50f90e529ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dc9df09e11dc3e66438bb5d9aa457f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2, typename T3 , int R3, int C3&gt; </td></tr>
<tr class="memitem:af2dc9df09e11dc3e66438bb5d9aa457f"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T1 &gt;::value||<a class="el" href="structstan_1_1is__var.html">stan::is_var</a><br class="typebreak"/>
&lt; T2 &gt;::value||<a class="el" href="structstan_1_1is__var.html">stan::is_var</a><br class="typebreak"/>
&lt; T3 &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af2dc9df09e11dc3e66438bb5d9aa457f">trace_gen_inv_quad_form_ldlt</a> (const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;D, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;B)</td></tr>
<tr class="memdesc:af2dc9df09e11dc3e66438bb5d9aa457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <a href="#af2dc9df09e11dc3e66438bb5d9aa457f">More...</a><br/></td></tr>
<tr class="separator:af2dc9df09e11dc3e66438bb5d9aa457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0d37f9fa5d50999308a19d8e67714e"><td class="memTemplParams" colspan="2">template&lt;typename TD , int RD, int CD, typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </td></tr>
<tr class="memitem:a2c0d37f9fa5d50999308a19d8e67714e"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; TD, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; TA, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value||boost::is_same<br class="typebreak"/>
&lt; TB, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2c0d37f9fa5d50999308a19d8e67714e">trace_gen_quad_form</a> (const Eigen::Matrix&lt; TD, RD, CD &gt; &amp;D, const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:a2c0d37f9fa5d50999308a19d8e67714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f24e9594341db1cc4ceaf5a69f039b"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int R2, int C2, typename T3 , int R3, int C3&gt; </td></tr>
<tr class="memitem:a04f24e9594341db1cc4ceaf5a69f039b"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; <a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt; T2 &gt;::value||<a class="el" href="structstan_1_1is__var.html">stan::is_var</a><br class="typebreak"/>
&lt; T3 &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a04f24e9594341db1cc4ceaf5a69f039b">trace_inv_quad_form_ldlt</a> (const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;A, const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;B)</td></tr>
<tr class="memdesc:a04f24e9594341db1cc4ceaf5a69f039b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <a href="#a04f24e9594341db1cc4ceaf5a69f039b">More...</a><br/></td></tr>
<tr class="separator:a04f24e9594341db1cc4ceaf5a69f039b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7a80225b1cb62153ba5d47a45870fe"><td class="memTemplParams" colspan="2">template&lt;typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </td></tr>
<tr class="memitem:a5c7a80225b1cb62153ba5d47a45870fe"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c<br class="typebreak"/>
&lt; boost::is_same&lt; TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;<br class="typebreak"/>
::value||boost::is_same&lt; TB, <br class="typebreak"/>
<a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5c7a80225b1cb62153ba5d47a45870fe">trace_quad_form</a> (const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;A, const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;B)</td></tr>
<tr class="separator:a5c7a80225b1cb62153ba5d47a45870fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0400489c86a0f208ed17371ab97254f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac0400489c86a0f208ed17371ab97254f">variance</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ac0400489c86a0f208ed17371ab97254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the specified standard vector.  <a href="#ac0400489c86a0f208ed17371ab97254f">More...</a><br/></td></tr>
<tr class="separator:ac0400489c86a0f208ed17371ab97254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5dc6176d49564ace17029793589421"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a4c5dc6176d49564ace17029793589421"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4c5dc6176d49564ace17029793589421">variance</a> (const Eigen::Matrix&lt; <a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C &gt; &amp;m)</td></tr>
<tr class="separator:a4c5dc6176d49564ace17029793589421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d25361a4bcf7ddb7fdb7edd35b8060"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a42d25361a4bcf7ddb7fdb7edd35b8060"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a42d25361a4bcf7ddb7fdb7edd35b8060">gradient</a> (const F &amp;f, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;grad_fx)</td></tr>
<tr class="memdesc:a42d25361a4bcf7ddb7fdb7edd35b8060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <a href="#a42d25361a4bcf7ddb7fdb7edd35b8060">More...</a><br/></td></tr>
<tr class="separator:a42d25361a4bcf7ddb7fdb7edd35b8060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cb12dbca88db90b1b3f8654ea193a5"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a40cb12dbca88db90b1b3f8654ea193a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a40cb12dbca88db90b1b3f8654ea193a5">jacobian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;x, Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;fx, Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;J)</td></tr>
<tr class="separator:a40cb12dbca88db90b1b3f8654ea193a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971adca9c3989255ca1f9568f8e7dc93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a971adca9c3989255ca1f9568f8e7dc93">abs</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a971adca9c3989255ca1f9568f8e7dc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (std).  <a href="#a971adca9c3989255ca1f9568f8e7dc93">More...</a><br/></td></tr>
<tr class="separator:a971adca9c3989255ca1f9568f8e7dc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b472e155399f39ba2d7e26abb50cd7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5b472e155399f39ba2d7e26abb50cd7b">acos</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a5b472e155399f39ba2d7e26abb50cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc cosine of a variable, in radians (cmath).  <a href="#a5b472e155399f39ba2d7e26abb50cd7b">More...</a><br/></td></tr>
<tr class="separator:a5b472e155399f39ba2d7e26abb50cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d20387e255363750b779b213d734f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9a8d20387e255363750b779b213d734f">acosh</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a9a8d20387e255363750b779b213d734f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic cosine function for variables (C99).  <a href="#a9a8d20387e255363750b779b213d734f">More...</a><br/></td></tr>
<tr class="separator:a9a8d20387e255363750b779b213d734f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab7ad9c5e9f0b2f99b96133ad7a158f64">as_bool</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;v)</td></tr>
<tr class="memdesc:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the argument is unequal to zero and 0 otherwise.  <a href="#ab7ad9c5e9f0b2f99b96133ad7a158f64">More...</a><br/></td></tr>
<tr class="separator:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710bf940838cc452c426597f55f74dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab710bf940838cc452c426597f55f74dc">asin</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab710bf940838cc452c426597f55f74dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc sine, in radians, of the specified variable (cmath).  <a href="#ab710bf940838cc452c426597f55f74dc">More...</a><br/></td></tr>
<tr class="separator:ab710bf940838cc452c426597f55f74dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d7b01cd76067a0fa8d424b4e81a4fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af6d7b01cd76067a0fa8d424b4e81a4fc">asinh</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:af6d7b01cd76067a0fa8d424b4e81a4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic sine function for variables (C99).  <a href="#af6d7b01cd76067a0fa8d424b4e81a4fc">More...</a><br/></td></tr>
<tr class="separator:af6d7b01cd76067a0fa8d424b4e81a4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cb80cff5115679c25d7347ffa89c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a85cb80cff5115679c25d7347ffa89c81">atan</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a85cb80cff5115679c25d7347ffa89c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the specified variable (cmath).  <a href="#a85cb80cff5115679c25d7347ffa89c81">More...</a><br/></td></tr>
<tr class="separator:a85cb80cff5115679c25d7347ffa89c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fe21eb929346e553266ceda0a97f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a32fe21eb929346e553266ceda0a97f23">atan2</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a32fe21eb929346e553266ceda0a97f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first variable divided by the second (cmath).  <a href="#a32fe21eb929346e553266ceda0a97f23">More...</a><br/></td></tr>
<tr class="separator:a32fe21eb929346e553266ceda0a97f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0d4eeedff1e94221e2b719d0227e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acf0d4eeedff1e94221e2b719d0227e25">atan2</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:acf0d4eeedff1e94221e2b719d0227e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first variable divided by the second scalar (cmath).  <a href="#acf0d4eeedff1e94221e2b719d0227e25">More...</a><br/></td></tr>
<tr class="separator:acf0d4eeedff1e94221e2b719d0227e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a3681701397c99fd57d8816869b92f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a02a3681701397c99fd57d8816869b92f">atan2</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a02a3681701397c99fd57d8816869b92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first scalar divided by the second variable (cmath).  <a href="#a02a3681701397c99fd57d8816869b92f">More...</a><br/></td></tr>
<tr class="separator:a02a3681701397c99fd57d8816869b92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf81b5222fb11c01b539fab0434bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9cbf81b5222fb11c01b539fab0434bdd">atanh</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a9cbf81b5222fb11c01b539fab0434bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic tangent function for variables (C99).  <a href="#a9cbf81b5222fb11c01b539fab0434bdd">More...</a><br/></td></tr>
<tr class="separator:a9cbf81b5222fb11c01b539fab0434bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367822396d06842610b32ec1d1010944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a367822396d06842610b32ec1d1010944">bessel_first_kind</a> (const int &amp;v, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="separator:a367822396d06842610b32ec1d1010944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bff905107813b205e8cf81ace301ef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7bff905107813b205e8cf81ace301ef9">bessel_second_kind</a> (const int &amp;v, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="separator:a7bff905107813b205e8cf81ace301ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b93caccb44639dea5c47f78fe6be28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a87b93caccb44639dea5c47f78fe6be28">binary_log_loss</a> (const int y, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;y_hat)</td></tr>
<tr class="memdesc:a87b93caccb44639dea5c47f78fe6be28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log loss function for variables (stan).  <a href="#a87b93caccb44639dea5c47f78fe6be28">More...</a><br/></td></tr>
<tr class="separator:a87b93caccb44639dea5c47f78fe6be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b0e3e51b5cc7ab1da287369ff754d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab9b0e3e51b5cc7ab1da287369ff754d7">calculate_chain</a> (const double &amp;x, const double &amp;val)</td></tr>
<tr class="separator:ab9b0e3e51b5cc7ab1da287369ff754d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a865962fcd8998de077f4a77b0a4ffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2a865962fcd8998de077f4a77b0a4ffa">cbrt</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2a865962fcd8998de077f4a77b0a4ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cube root of the specified variable (C99).  <a href="#a2a865962fcd8998de077f4a77b0a4ffa">More...</a><br/></td></tr>
<tr class="separator:a2a865962fcd8998de077f4a77b0a4ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e924d5a6c94f7593056b5cb1324b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a06e924d5a6c94f7593056b5cb1324b66">ceil</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a06e924d5a6c94f7593056b5cb1324b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ceiling of the specified variable (cmath).  <a href="#a06e924d5a6c94f7593056b5cb1324b66">More...</a><br/></td></tr>
<tr class="separator:a06e924d5a6c94f7593056b5cb1324b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3ac00ed58d998daed7f4d97195e967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0f3ac00ed58d998daed7f4d97195e967">cos</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a0f3ac00ed58d998daed7f4d97195e967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a radian-scaled variable (cmath).  <a href="#a0f3ac00ed58d998daed7f4d97195e967">More...</a><br/></td></tr>
<tr class="separator:a0f3ac00ed58d998daed7f4d97195e967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a43fcaf01cfef4c73074e77390a205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab2a43fcaf01cfef4c73074e77390a205">cosh</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab2a43fcaf01cfef4c73074e77390a205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the specified variable (cmath).  <a href="#ab2a43fcaf01cfef4c73074e77390a205">More...</a><br/></td></tr>
<tr class="separator:ab2a43fcaf01cfef4c73074e77390a205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ba0d22b63d45054e4a022e4ffa994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a366ba0d22b63d45054e4a022e4ffa994">digamma</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="separator:a366ba0d22b63d45054e4a022e4ffa994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a759d52872682fdf0d6a7a6d75b4f1d9e">erf</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error function for variables (C99).  <a href="#a759d52872682fdf0d6a7a6d75b4f1d9e">More...</a><br/></td></tr>
<tr class="separator:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8543e9c729e794bcbdff2ed223eb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a8543e9c729e794bcbdff2ed223eb45">erfc</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a8a8543e9c729e794bcbdff2ed223eb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The complementary error function for variables (C99).  <a href="#a8a8543e9c729e794bcbdff2ed223eb45">More...</a><br/></td></tr>
<tr class="separator:a8a8543e9c729e794bcbdff2ed223eb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43b048d4a5f53f94501773c93689a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae43b048d4a5f53f94501773c93689a65">exp</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:ae43b048d4a5f53f94501773c93689a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponentiation of the specified variable (cmath).  <a href="#ae43b048d4a5f53f94501773c93689a65">More...</a><br/></td></tr>
<tr class="separator:ae43b048d4a5f53f94501773c93689a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd4650bbf246a10ac798c71da8b99d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9fd4650bbf246a10ac798c71da8b99d5">exp2</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a9fd4650bbf246a10ac798c71da8b99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation base 2 function for variables (C99).  <a href="#a9fd4650bbf246a10ac798c71da8b99d5">More...</a><br/></td></tr>
<tr class="separator:a9fd4650bbf246a10ac798c71da8b99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c632ff37556a4989fb351042da3a05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8c632ff37556a4989fb351042da3a05a">expm1</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:a8c632ff37556a4989fb351042da3a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exponentiation of the specified variable minus 1 (C99).  <a href="#a8c632ff37556a4989fb351042da3a05a">More...</a><br/></td></tr>
<tr class="separator:a8c632ff37556a4989fb351042da3a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8428395b18c89bc01669915993b8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aea8428395b18c89bc01669915993b8e7">fabs</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:aea8428395b18c89bc01669915993b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (cmath).  <a href="#aea8428395b18c89bc01669915993b8e7">More...</a><br/></td></tr>
<tr class="separator:aea8428395b18c89bc01669915993b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fdf588b0a37df21c5b67ed7370b003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a96fdf588b0a37df21c5b67ed7370b003">falling_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="separator:a96fdf588b0a37df21c5b67ed7370b003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f5570887f609618c63c727afda46ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a78f5570887f609618c63c727afda46ba">falling_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:a78f5570887f609618c63c727afda46ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6fa4b14f17cc4df149df09224a18b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#add6fa4b14f17cc4df149df09224a18b9">falling_factorial</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:add6fa4b14f17cc4df149df09224a18b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f899b184aa38d3a5f814518611a0666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f899b184aa38d3a5f814518611a0666">fdim</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a6f899b184aa38d3a5f814518611a0666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's the value and the second's (C99).  <a href="#a6f899b184aa38d3a5f814518611a0666">More...</a><br/></td></tr>
<tr class="separator:a6f899b184aa38d3a5f814518611a0666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe00d070fb14766341060f7f0fe2627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6fe00d070fb14766341060f7f0fe2627">fdim</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a6fe00d070fb14766341060f7f0fe2627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first value and the value of the second variable (C99).  <a href="#a6fe00d070fb14766341060f7f0fe2627">More...</a><br/></td></tr>
<tr class="separator:a6fe00d070fb14766341060f7f0fe2627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014a74412301cf66626baa1fe1491d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a014a74412301cf66626baa1fe1491d94">fdim</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="memdesc:a014a74412301cf66626baa1fe1491d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's value and the second value (C99).  <a href="#a014a74412301cf66626baa1fe1491d94">More...</a><br/></td></tr>
<tr class="separator:a014a74412301cf66626baa1fe1491d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66dea6b6d18e39c5b0f38d3204aa04d5">floor</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floor of the specified variable (cmath).  <a href="#a66dea6b6d18e39c5b0f38d3204aa04d5">More...</a><br/></td></tr>
<tr class="separator:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3ab44e4f8a8430bd1fd19e37101555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f3ab44e4f8a8430bd1fd19e37101555">fma</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;c)</td></tr>
<tr class="memdesc:a3f3ab44e4f8a8430bd1fd19e37101555"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for three variables (C99).  <a href="#a3f3ab44e4f8a8430bd1fd19e37101555">More...</a><br/></td></tr>
<tr class="separator:a3f3ab44e4f8a8430bd1fd19e37101555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57371eb5b1cf21e7fa089e89758bdef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab57371eb5b1cf21e7fa089e89758bdef">fma</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b, const double &amp;c)</td></tr>
<tr class="memdesc:ab57371eb5b1cf21e7fa089e89758bdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for two variables and a value (C99).  <a href="#ab57371eb5b1cf21e7fa089e89758bdef">More...</a><br/></td></tr>
<tr class="separator:ab57371eb5b1cf21e7fa089e89758bdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1708d9819f74c9b8663c802a2d1a2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2d1708d9819f74c9b8663c802a2d1a2a">fma</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;c)</td></tr>
<tr class="memdesc:a2d1708d9819f74c9b8663c802a2d1a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a variable, value, and variable (C99).  <a href="#a2d1708d9819f74c9b8663c802a2d1a2a">More...</a><br/></td></tr>
<tr class="separator:a2d1708d9819f74c9b8663c802a2d1a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7340a4f23e33e671e53c2582c63272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6a7340a4f23e33e671e53c2582c63272">fma</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b, const double &amp;c)</td></tr>
<tr class="memdesc:a6a7340a4f23e33e671e53c2582c63272"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a variable and two values (C99).  <a href="#a6a7340a4f23e33e671e53c2582c63272">More...</a><br/></td></tr>
<tr class="separator:a6a7340a4f23e33e671e53c2582c63272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4becb131eda9f3e3f1ca06e373fea66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab4becb131eda9f3e3f1ca06e373fea66">fma</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b, const double &amp;c)</td></tr>
<tr class="memdesc:ab4becb131eda9f3e3f1ca06e373fea66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a value, variable, and value (C99).  <a href="#ab4becb131eda9f3e3f1ca06e373fea66">More...</a><br/></td></tr>
<tr class="separator:ab4becb131eda9f3e3f1ca06e373fea66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6917da974098b0bb02883839f1ae0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad6917da974098b0bb02883839f1ae0e1">fma</a> (const double &amp;a, const double &amp;b, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;c)</td></tr>
<tr class="memdesc:ad6917da974098b0bb02883839f1ae0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for two values and a variable, and value (C99).  <a href="#ad6917da974098b0bb02883839f1ae0e1">More...</a><br/></td></tr>
<tr class="separator:ad6917da974098b0bb02883839f1ae0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f288e71a8a7012ad123ca361f6a739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae9f288e71a8a7012ad123ca361f6a739">fma</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;c)</td></tr>
<tr class="memdesc:ae9f288e71a8a7012ad123ca361f6a739"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a value and two variables (C99).  <a href="#ae9f288e71a8a7012ad123ca361f6a739">More...</a><br/></td></tr>
<tr class="separator:ae9f288e71a8a7012ad123ca361f6a739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57bd2f169eb820c21273293d2cfa01b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab57bd2f169eb820c21273293d2cfa01b">fmax</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:ab57bd2f169eb820c21273293d2cfa01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of the two variable arguments (C99).  <a href="#ab57bd2f169eb820c21273293d2cfa01b">More...</a><br/></td></tr>
<tr class="separator:ab57bd2f169eb820c21273293d2cfa01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e72a34aed1af28919d940399a07c3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5e72a34aed1af28919d940399a07c3d0">fmax</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="memdesc:a5e72a34aed1af28919d940399a07c3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of the variable and scalar, promoting the scalar to a variable if it is larger (C99).  <a href="#a5e72a34aed1af28919d940399a07c3d0">More...</a><br/></td></tr>
<tr class="separator:a5e72a34aed1af28919d940399a07c3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a200e969bd57383ff4f89516c0690b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a200e969bd57383ff4f89516c0690b5">fmax</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a8a200e969bd57383ff4f89516c0690b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of a scalar and variable, promoting the scalar to a variable if it is larger (C99).  <a href="#a8a200e969bd57383ff4f89516c0690b5">More...</a><br/></td></tr>
<tr class="separator:a8a200e969bd57383ff4f89516c0690b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff067261be560b2502178b590a7a068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3ff067261be560b2502178b590a7a068">fmin</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a3ff067261be560b2502178b590a7a068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the two variable arguments (C99).  <a href="#a3ff067261be560b2502178b590a7a068">More...</a><br/></td></tr>
<tr class="separator:a3ff067261be560b2502178b590a7a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9c72371629b0a266acc6795d723aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2e9c72371629b0a266acc6795d723aa6">fmin</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a2e9c72371629b0a266acc6795d723aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the variable and scalar, promoting the scalar to a variable if it is larger (C99).  <a href="#a2e9c72371629b0a266acc6795d723aa6">More...</a><br/></td></tr>
<tr class="separator:a2e9c72371629b0a266acc6795d723aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78692904b139471b470740ce866468e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af78692904b139471b470740ce866468e">fmin</a> (double a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:af78692904b139471b470740ce866468e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of a scalar and variable, promoting the scalar to a variable if it is larger (C99).  <a href="#af78692904b139471b470740ce866468e">More...</a><br/></td></tr>
<tr class="separator:af78692904b139471b470740ce866468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935933626162d429e5a7f06ca0bde103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a935933626162d429e5a7f06ca0bde103">fmod</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a935933626162d429e5a7f06ca0bde103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first variable by the second (cmath).  <a href="#a935933626162d429e5a7f06ca0bde103">More...</a><br/></td></tr>
<tr class="separator:a935933626162d429e5a7f06ca0bde103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ecd1367428932c3515ef3c374e6e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab9ecd1367428932c3515ef3c374e6e9e">fmod</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:ab9ecd1367428932c3515ef3c374e6e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the the first variable by the second scalar (cmath).  <a href="#ab9ecd1367428932c3515ef3c374e6e9e">More...</a><br/></td></tr>
<tr class="separator:ab9ecd1367428932c3515ef3c374e6e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6806c0d68c9e23e905b4ca36119734bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6806c0d68c9e23e905b4ca36119734bd">fmod</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a6806c0d68c9e23e905b4ca36119734bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first scalar by the second variable (cmath).  <a href="#a6806c0d68c9e23e905b4ca36119734bd">More...</a><br/></td></tr>
<tr class="separator:a6806c0d68c9e23e905b4ca36119734bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec26628247b9e474e1b3254aae0b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad9ec26628247b9e474e1b3254aae0b32">gamma_p</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="separator:ad9ec26628247b9e474e1b3254aae0b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad392cbaa9872996da3127a359929cea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad392cbaa9872996da3127a359929cea4">gamma_p</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="separator:ad392cbaa9872996da3127a359929cea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3db0274d59a42798f93e66d0d411dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa3db0274d59a42798f93e66d0d411dd8">gamma_p</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="separator:aa3db0274d59a42798f93e66d0d411dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ed9105d1156ceaca26ab323f1a2648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac8ed9105d1156ceaca26ab323f1a2648">gamma_q</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="separator:ac8ed9105d1156ceaca26ab323f1a2648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97d9968df786f813758bce4a8909f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af97d9968df786f813758bce4a8909f62">gamma_q</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="separator:af97d9968df786f813758bce4a8909f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9a338d5f5fd18bddf0e8225f6cc27d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acb9a338d5f5fd18bddf0e8225f6cc27d">gamma_q</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="separator:acb9a338d5f5fd18bddf0e8225f6cc27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f15a75139ebb4a3b599a1190d39fc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a25f15a75139ebb4a3b599a1190d39fc1">grad_inc_beta</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;g1, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;g2, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;z)</td></tr>
<tr class="separator:a25f15a75139ebb4a3b599a1190d39fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0827e995b465dcb291c3de1a77e2b547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0827e995b465dcb291c3de1a77e2b547">hypot</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a0827e995b465dcb291c3de1a77e2b547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypoteneuse of a right triangle with sides of the specified lengths (C99).  <a href="#a0827e995b465dcb291c3de1a77e2b547">More...</a><br/></td></tr>
<tr class="separator:a0827e995b465dcb291c3de1a77e2b547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb40e789140be0e0b93a44e055a6cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abcb40e789140be0e0b93a44e055a6cfc">hypot</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:abcb40e789140be0e0b93a44e055a6cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypoteneuse of a right triangle with sides of the specified lengths (C99).  <a href="#abcb40e789140be0e0b93a44e055a6cfc">More...</a><br/></td></tr>
<tr class="separator:abcb40e789140be0e0b93a44e055a6cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5c9d2305ce89a46a7d182e6014fd0b3f">hypot</a> (double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypoteneuse of a right triangle with sides of the specified lengths (C99).  <a href="#a5c9d2305ce89a46a7d182e6014fd0b3f">More...</a><br/></td></tr>
<tr class="separator:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7547dffd79bc54378fb3906345500e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8c7547dffd79bc54378fb3906345500e">ibeta</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;x)</td></tr>
<tr class="memdesc:a8c7547dffd79bc54378fb3906345500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normalized incomplete beta function of a, b, and x.  <a href="#a8c7547dffd79bc54378fb3906345500e">More...</a><br/></td></tr>
<tr class="separator:a8c7547dffd79bc54378fb3906345500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abb35d5a60bdc11a5d09eb629c50b5db5">if_else</a> (bool c, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;y_true, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;y_false)</td></tr>
<tr class="memdesc:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return the first variable, otherwise return the second variable.  <a href="#abb35d5a60bdc11a5d09eb629c50b5db5">More...</a><br/></td></tr>
<tr class="separator:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1dc3a479994402ee1959b75fa2c70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abc1dc3a479994402ee1959b75fa2c70f">if_else</a> (bool c, double y_true, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;y_false)</td></tr>
<tr class="memdesc:abc1dc3a479994402ee1959b75fa2c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return a new variable constructed from the first scalar, otherwise return the second variable.  <a href="#abc1dc3a479994402ee1959b75fa2c70f">More...</a><br/></td></tr>
<tr class="separator:abc1dc3a479994402ee1959b75fa2c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09912038470cc9d13d754296b1fe6949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a09912038470cc9d13d754296b1fe6949">if_else</a> (bool c, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;y_true, const double y_false)</td></tr>
<tr class="memdesc:a09912038470cc9d13d754296b1fe6949"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return the first variable, otherwise return a new variable constructed from the second scalar.  <a href="#a09912038470cc9d13d754296b1fe6949">More...</a><br/></td></tr>
<tr class="separator:a09912038470cc9d13d754296b1fe6949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf29f2f025873816925c6786842d0afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abf29f2f025873816925c6786842d0afe">inc_beta</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;c)</td></tr>
<tr class="separator:abf29f2f025873816925c6786842d0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b645189bc4899956bdba20158a0ee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad0b645189bc4899956bdba20158a0ee6">inv</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:ad0b645189bc4899956bdba20158a0ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv}(x) = \begin{cases} \frac{1}{x} &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_382.png"/>
</p>
  <a href="#ad0b645189bc4899956bdba20158a0ee6">More...</a><br/></td></tr>
<tr class="separator:ad0b645189bc4899956bdba20158a0ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab834f530318a33700ba2c66b74ea3bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab834f530318a33700ba2c66b74ea3bf5">inv_cloglog</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:ab834f530318a33700ba2c66b74ea3bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse complementary log-log function applied specified variable (stan).  <a href="#ab834f530318a33700ba2c66b74ea3bf5">More...</a><br/></td></tr>
<tr class="separator:ab834f530318a33700ba2c66b74ea3bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7861511ad7d8a82e17a1e9fa573de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad7d7861511ad7d8a82e17a1e9fa573de">inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:ad7d7861511ad7d8a82e17a1e9fa573de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse logit function for variables (stan).  <a href="#ad7d7861511ad7d8a82e17a1e9fa573de">More...</a><br/></td></tr>
<tr class="separator:ad7d7861511ad7d8a82e17a1e9fa573de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3e1382ec567be20643caef30076869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4f3e1382ec567be20643caef30076869">inv_sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a4f3e1382ec567be20643caef30076869"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_sqrt}(x) = \begin{cases} \frac{1}{\sqrt{x}} &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_386.png"/>
</p>
  <a href="#a4f3e1382ec567be20643caef30076869">More...</a><br/></td></tr>
<tr class="separator:a4f3e1382ec567be20643caef30076869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa347bbaada35746d4fbd644549416ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa347bbaada35746d4fbd644549416ce3">inv_square</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:aa347bbaada35746d4fbd644549416ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_square}(x) = \begin{cases} \frac{1}{x^2} &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_388.png"/>
</p>
  <a href="#aa347bbaada35746d4fbd644549416ce3">More...</a><br/></td></tr>
<tr class="separator:aa347bbaada35746d4fbd644549416ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c050932da2e90902bda668170379545"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2c050932da2e90902bda668170379545">is_inf</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;v)</td></tr>
<tr class="memdesc:a2c050932da2e90902bda668170379545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is infinite and 0 otherwise.  <a href="#a2c050932da2e90902bda668170379545">More...</a><br/></td></tr>
<tr class="separator:a2c050932da2e90902bda668170379545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ef1e06cddc77c4c56311f937cc183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acf8ef1e06cddc77c4c56311f937cc183">is_nan</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;v)</td></tr>
<tr class="memdesc:acf8ef1e06cddc77c4c56311f937cc183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is NaN and 0 otherwise.  <a href="#acf8ef1e06cddc77c4c56311f937cc183">More...</a><br/></td></tr>
<tr class="separator:acf8ef1e06cddc77c4c56311f937cc183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8d228f0969deddaf2c485f07452fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2f8d228f0969deddaf2c485f07452fd5">is_uninitialized</a> (<a class="el" href="classstan_1_1math_1_1var.html">var</a> x)</td></tr>
<tr class="memdesc:a2f8d228f0969deddaf2c485f07452fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <a href="#a2f8d228f0969deddaf2c485f07452fd5">More...</a><br/></td></tr>
<tr class="separator:a2f8d228f0969deddaf2c485f07452fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21018562738b2bf94984bcb7e1c9865b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a21018562738b2bf94984bcb7e1c9865b">lgamma</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:a21018562738b2bf94984bcb7e1c9865b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log gamma function for variables (C99).  <a href="#a21018562738b2bf94984bcb7e1c9865b">More...</a><br/></td></tr>
<tr class="separator:a21018562738b2bf94984bcb7e1c9865b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f77e1a76bdde13d243f68d45c1d392b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3f77e1a76bdde13d243f68d45c1d392b">lmgamma</a> (int a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="separator:a3f77e1a76bdde13d243f68d45c1d392b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a236280de2603e0ead1966468f0ceea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a236280de2603e0ead1966468f0ceea">log</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a8a236280de2603e0ead1966468f0ceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural log of the specified variable (cmath).  <a href="#a8a236280de2603e0ead1966468f0ceea">More...</a><br/></td></tr>
<tr class="separator:a8a236280de2603e0ead1966468f0ceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56e2f9808a531946681d3644307edeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af56e2f9808a531946681d3644307edeb">log10</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:af56e2f9808a531946681d3644307edeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 log of the specified variable (cmath).  <a href="#af56e2f9808a531946681d3644307edeb">More...</a><br/></td></tr>
<tr class="separator:af56e2f9808a531946681d3644307edeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaee0104c1b99038dda2dbb769abae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5aaee0104c1b99038dda2dbb769abae1">log1m</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:a5aaee0104c1b99038dda2dbb769abae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log (1 - x) function for variables.  <a href="#a5aaee0104c1b99038dda2dbb769abae1">More...</a><br/></td></tr>
<tr class="separator:a5aaee0104c1b99038dda2dbb769abae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab62e8d3067ce13dea1b2ee4f38618b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aab62e8d3067ce13dea1b2ee4f38618b1">log1m_exp</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:aab62e8d3067ce13dea1b2ee4f38618b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of 1 minus the exponential of the specified variable.  <a href="#aab62e8d3067ce13dea1b2ee4f38618b1">More...</a><br/></td></tr>
<tr class="separator:aab62e8d3067ce13dea1b2ee4f38618b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9851bec44891899ceacfc17ef6e86b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9851bec44891899ceacfc17ef6e86b21">log1p</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:a9851bec44891899ceacfc17ef6e86b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log (1 + x) function for variables (C99).  <a href="#a9851bec44891899ceacfc17ef6e86b21">More...</a><br/></td></tr>
<tr class="separator:a9851bec44891899ceacfc17ef6e86b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaffb88be27fafab634c74e14508e0f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#abaffb88be27fafab634c74e14508e0f3">log1p_exp</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:abaffb88be27fafab634c74e14508e0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of 1 plus the exponential of the specified variable.  <a href="#abaffb88be27fafab634c74e14508e0f3">More...</a><br/></td></tr>
<tr class="separator:abaffb88be27fafab634c74e14508e0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6322be7704b2efc1e36951b46bb88568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6322be7704b2efc1e36951b46bb88568">log2</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:a6322be7704b2efc1e36951b46bb88568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 2 logarithm of the specified variable (C99).  <a href="#a6322be7704b2efc1e36951b46bb88568">More...</a><br/></td></tr>
<tr class="separator:a6322be7704b2efc1e36951b46bb88568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fccfff5553aa860351a147ab10e301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a43fccfff5553aa860351a147ab10e301">log_diff_exp</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a43fccfff5553aa860351a147ab10e301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#a43fccfff5553aa860351a147ab10e301">More...</a><br/></td></tr>
<tr class="separator:a43fccfff5553aa860351a147ab10e301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a09bd43a4ade10703b6a1fb521d09e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7a09bd43a4ade10703b6a1fb521d09e8">log_diff_exp</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="memdesc:a7a09bd43a4ade10703b6a1fb521d09e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#a7a09bd43a4ade10703b6a1fb521d09e8">More...</a><br/></td></tr>
<tr class="separator:a7a09bd43a4ade10703b6a1fb521d09e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03afe35a61cd6068465799e22d600879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a03afe35a61cd6068465799e22d600879">log_diff_exp</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a03afe35a61cd6068465799e22d600879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#a03afe35a61cd6068465799e22d600879">More...</a><br/></td></tr>
<tr class="separator:a03afe35a61cd6068465799e22d600879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5951b9e0e640a8f2f53348015387c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6f5951b9e0e640a8f2f53348015387c4">log_falling_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="separator:a6f5951b9e0e640a8f2f53348015387c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6fbe2cf74d7dc89d10999d512c3efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1a6fbe2cf74d7dc89d10999d512c3efd">log_falling_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:a1a6fbe2cf74d7dc89d10999d512c3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599bc1031e28ecc3cc192b07bdced6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a599bc1031e28ecc3cc192b07bdced6ed">log_falling_factorial</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:a599bc1031e28ecc3cc192b07bdced6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3e6e5267f60e3537dd8bdd0299a3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8b3e6e5267f60e3537dd8bdd0299a3ee">log_mix_partial_helper</a> (const double &amp;theta_val, const double &amp;lambda1_val, const double &amp;lambda2_val, double &amp;one_m_exp_lam2_m_lam1, double &amp;one_m_t_prod_exp_lam2_m_lam1, double &amp;one_d_t_plus_one_m_t_prod_exp_lam2_m_lam1)</td></tr>
<tr class="separator:a8b3e6e5267f60e3537dd8bdd0299a3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f87ac712232f684f398ff5e5865887"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 &gt; </td></tr>
<tr class="memitem:a91f87ac712232f684f398ff5e5865887"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_theta, <br class="typebreak"/>
T_lambda1, T_lambda2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a91f87ac712232f684f398ff5e5865887">log_mix</a> (const T_theta &amp;theta, const T_lambda1 &amp;lambda1, const T_lambda2 &amp;lambda2)</td></tr>
<tr class="memdesc:a91f87ac712232f684f398ff5e5865887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities and its derivative at each.  <a href="#a91f87ac712232f684f398ff5e5865887">More...</a><br/></td></tr>
<tr class="separator:a91f87ac712232f684f398ff5e5865887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6353b21fe0f6314e677e0c0ec1d27e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6353b21fe0f6314e677e0c0ec1d27e2a">log_rising_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="separator:a6353b21fe0f6314e677e0c0ec1d27e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff05bb4af6475162c98f06f5ccd186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a57ff05bb4af6475162c98f06f5ccd186">log_rising_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:a57ff05bb4af6475162c98f06f5ccd186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4b56e93a461861d24468412ec75a3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5b4b56e93a461861d24468412ec75a3a">log_rising_factorial</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:a5b4b56e93a461861d24468412ec75a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e133913e946710e85efc00306a2610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a50e133913e946710e85efc00306a2610">log_sum_exp</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a50e133913e946710e85efc00306a2610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#a50e133913e946710e85efc00306a2610">More...</a><br/></td></tr>
<tr class="separator:a50e133913e946710e85efc00306a2610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2ea975711d2420728cce2878bca93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c2ea975711d2420728cce2878bca93c">log_sum_exp</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="memdesc:a3c2ea975711d2420728cce2878bca93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#a3c2ea975711d2420728cce2878bca93c">More...</a><br/></td></tr>
<tr class="separator:a3c2ea975711d2420728cce2878bca93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04418b73a6d6efd660a67d9af4546840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a04418b73a6d6efd660a67d9af4546840">log_sum_exp</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;b)</td></tr>
<tr class="memdesc:a04418b73a6d6efd660a67d9af4546840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="#a04418b73a6d6efd660a67d9af4546840">More...</a><br/></td></tr>
<tr class="separator:a04418b73a6d6efd660a67d9af4546840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5625b66e071a9b57af3f0dd9325c79bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5625b66e071a9b57af3f0dd9325c79bd">modified_bessel_first_kind</a> (const int &amp;v, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="separator:a5625b66e071a9b57af3f0dd9325c79bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f39f5d25033d6fb49cf875cc18fa956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1f39f5d25033d6fb49cf875cc18fa956">modified_bessel_second_kind</a> (const int &amp;v, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="separator:a1f39f5d25033d6fb49cf875cc18fa956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da7e77b75bf5f288ddc7c546f941c70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3da7e77b75bf5f288ddc7c546f941c70">multiply_log</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a3da7e77b75bf5f288ddc7c546f941c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="#a3da7e77b75bf5f288ddc7c546f941c70">More...</a><br/></td></tr>
<tr class="separator:a3da7e77b75bf5f288ddc7c546f941c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05bd638024e60440e56c8ee4a0dbab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa05bd638024e60440e56c8ee4a0dbab3">multiply_log</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double b)</td></tr>
<tr class="memdesc:aa05bd638024e60440e56c8ee4a0dbab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="#aa05bd638024e60440e56c8ee4a0dbab3">More...</a><br/></td></tr>
<tr class="separator:aa05bd638024e60440e56c8ee4a0dbab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c980d72501fd340f6148c125c1da018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3c980d72501fd340f6148c125c1da018">multiply_log</a> (const double a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="memdesc:a3c980d72501fd340f6148c125c1da018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="#a3c980d72501fd340f6148c125c1da018">More...</a><br/></td></tr>
<tr class="separator:a3c980d72501fd340f6148c125c1da018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3be132b9586de8773f1489ad485e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3a3be132b9586de8773f1489ad485e0a">owens_t</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;h, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a3a3be132b9586de8773f1489ad485e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="#a3a3be132b9586de8773f1489ad485e0a">More...</a><br/></td></tr>
<tr class="separator:a3a3be132b9586de8773f1489ad485e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa226754d101430c9bdf91ece0a9eb1d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa226754d101430c9bdf91ece0a9eb1d7">owens_t</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;h, double a)</td></tr>
<tr class="memdesc:aa226754d101430c9bdf91ece0a9eb1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="#aa226754d101430c9bdf91ece0a9eb1d7">More...</a><br/></td></tr>
<tr class="separator:aa226754d101430c9bdf91ece0a9eb1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8dab8811eeb8705651daeefc449816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1a8dab8811eeb8705651daeefc449816">owens_t</a> (double h, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a1a8dab8811eeb8705651daeefc449816"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="#a1a8dab8811eeb8705651daeefc449816">More...</a><br/></td></tr>
<tr class="separator:a1a8dab8811eeb8705651daeefc449816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88a365e721ffe6c1da4115e378bebf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad88a365e721ffe6c1da4115e378bebf4">Phi</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:ad88a365e721ffe6c1da4115e378bebf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative density function for variables (stan).  <a href="#ad88a365e721ffe6c1da4115e378bebf4">More...</a><br/></td></tr>
<tr class="separator:ad88a365e721ffe6c1da4115e378bebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0a2a4530d320ca7945a09ae88783f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afa0a2a4530d320ca7945a09ae88783f3">Phi_approx</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:afa0a2a4530d320ca7945a09ae88783f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation of the unit normal CDF for variables (stan).  <a href="#afa0a2a4530d320ca7945a09ae88783f3">More...</a><br/></td></tr>
<tr class="separator:afa0a2a4530d320ca7945a09ae88783f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32adb49018d9fd61d3c568d1edcdb3c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a32adb49018d9fd61d3c568d1edcdb3c0">pow</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;base, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;exponent)</td></tr>
<tr class="memdesc:a32adb49018d9fd61d3c568d1edcdb3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base raised to the power of the exponent (cmath).  <a href="#a32adb49018d9fd61d3c568d1edcdb3c0">More...</a><br/></td></tr>
<tr class="separator:a32adb49018d9fd61d3c568d1edcdb3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1b3f97cd1cf4c7391d160f9a3db4f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aff1b3f97cd1cf4c7391d160f9a3db4f6">pow</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;base, const double exponent)</td></tr>
<tr class="memdesc:aff1b3f97cd1cf4c7391d160f9a3db4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base variable raised to the power of the exponent scalar (cmath).  <a href="#aff1b3f97cd1cf4c7391d160f9a3db4f6">More...</a><br/></td></tr>
<tr class="separator:aff1b3f97cd1cf4c7391d160f9a3db4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dafae271ea06210bf3cbe2545ead16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a52dafae271ea06210bf3cbe2545ead16">pow</a> (const double base, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;exponent)</td></tr>
<tr class="memdesc:a52dafae271ea06210bf3cbe2545ead16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base scalar raised to the power of the exponent variable (cmath).  <a href="#a52dafae271ea06210bf3cbe2545ead16">More...</a><br/></td></tr>
<tr class="separator:a52dafae271ea06210bf3cbe2545ead16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccbe1638f463027973553dec7175dbc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0ccbe1638f463027973553dec7175dbc">primitive_value</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;v)</td></tr>
<tr class="memdesc:a0ccbe1638f463027973553dec7175dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive double value for the specified auto-diff variable.  <a href="#a0ccbe1638f463027973553dec7175dbc">More...</a><br/></td></tr>
<tr class="separator:a0ccbe1638f463027973553dec7175dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317b1161dabe541d3011714f97684ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a317b1161dabe541d3011714f97684ca4">rising_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const double &amp;b)</td></tr>
<tr class="separator:a317b1161dabe541d3011714f97684ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b35a50161c460ac1d885c61bd705d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4b35a50161c460ac1d885c61bd705d5a">rising_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:a4b35a50161c460ac1d885c61bd705d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b13a596449384f742cc4b758c2e3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ac4b13a596449384f742cc4b758c2e3b9">rising_factorial</a> (const double &amp;a, const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;b)</td></tr>
<tr class="separator:ac4b13a596449384f742cc4b758c2e3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab259f70f4c7ebcdf3e032f01efb66c02">round</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rounded form of the specified variable (C99).  <a href="#ab259f70f4c7ebcdf3e032f01efb66c02">More...</a><br/></td></tr>
<tr class="separator:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae306538402ac590b8b84e6ed58989629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ae306538402ac590b8b84e6ed58989629">sin</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:ae306538402ac590b8b84e6ed58989629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a radian-scaled variable (cmath).  <a href="#ae306538402ac590b8b84e6ed58989629">More...</a><br/></td></tr>
<tr class="separator:ae306538402ac590b8b84e6ed58989629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b79300774f40a6e67b7156b494462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a241b79300774f40a6e67b7156b494462">sinh</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a241b79300774f40a6e67b7156b494462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the specified variable (cmath).  <a href="#a241b79300774f40a6e67b7156b494462">More...</a><br/></td></tr>
<tr class="separator:a241b79300774f40a6e67b7156b494462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab438f4b0a11d8551fe5605237f655730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab438f4b0a11d8551fe5605237f655730">sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab438f4b0a11d8551fe5605237f655730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the specified variable (cmath).  <a href="#ab438f4b0a11d8551fe5605237f655730">More...</a><br/></td></tr>
<tr class="separator:ab438f4b0a11d8551fe5605237f655730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b349cd070427c412c2c0a0d32327b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa1b349cd070427c412c2c0a0d32327b5">square</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;x)</td></tr>
<tr class="memdesc:aa1b349cd070427c412c2c0a0d32327b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the input variable.  <a href="#aa1b349cd070427c412c2c0a0d32327b5">More...</a><br/></td></tr>
<tr class="separator:aa1b349cd070427c412c2c0a0d32327b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7c701333f443140d6d4bfdde5b15b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a7c701333f443140d6d4bfdde5b15b3">step</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:a8a7c701333f443140d6d4bfdde5b15b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the step, or heaviside, function applied to the specified variable (stan).  <a href="#a8a7c701333f443140d6d4bfdde5b15b3">More...</a><br/></td></tr>
<tr class="separator:a8a7c701333f443140d6d4bfdde5b15b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#adf8320fd61a3c0c73f2ab8d78d949e58">tan</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a radian-scaled variable (cmath).  <a href="#adf8320fd61a3c0c73f2ab8d78d949e58">More...</a><br/></td></tr>
<tr class="separator:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d342831ec24762b18f71ba4fba54621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a6d342831ec24762b18f71ba4fba54621">tanh</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a6d342831ec24762b18f71ba4fba54621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the specified variable (cmath).  <a href="#a6d342831ec24762b18f71ba4fba54621">More...</a><br/></td></tr>
<tr class="separator:a6d342831ec24762b18f71ba4fba54621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27ba386c3836a69c7d270f89c946268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af27ba386c3836a69c7d270f89c946268">tgamma</a> (const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;a)</td></tr>
<tr class="memdesc:af27ba386c3836a69c7d270f89c946268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Gamma function applied to the specified variable (C99).  <a href="#af27ba386c3836a69c7d270f89c946268">More...</a><br/></td></tr>
<tr class="separator:af27ba386c3836a69c7d270f89c946268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e85e1eba4076438c72cd986fde40e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a80e85e1eba4076438c72cd986fde40e8">trunc</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;a)</td></tr>
<tr class="memdesc:a80e85e1eba4076438c72cd986fde40e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the truncatation of the specified variable (C99).  <a href="#a80e85e1eba4076438c72cd986fde40e8">More...</a><br/></td></tr>
<tr class="separator:a80e85e1eba4076438c72cd986fde40e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a759dd2a7ff07dbf11f60d9e1352bb3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0a759dd2a7ff07dbf11f60d9e1352bb3">value_of</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;v)</td></tr>
<tr class="memdesc:a0a759dd2a7ff07dbf11f60d9e1352bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="#a0a759dd2a7ff07dbf11f60d9e1352bb3">More...</a><br/></td></tr>
<tr class="separator:a0a759dd2a7ff07dbf11f60d9e1352bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab481d22f60e4cb93d629ac5d9f43bb00"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab481d22f60e4cb93d629ac5d9f43bb00">value_of_rec</a> (const <a class="el" href="classstan_1_1math_1_1var.html">var</a> &amp;v)</td></tr>
<tr class="memdesc:ab481d22f60e4cb93d629ac5d9f43bb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="#ab481d22f60e4cb93d629ac5d9f43bb00">More...</a><br/></td></tr>
<tr class="separator:ab481d22f60e4cb93d629ac5d9f43bb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aece739c5a2672028f0c7848045b89f08"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aece739c5a2672028f0c7848045b89f08">CONSTRAINT_TOLERANCE</a> = 1E-8</td></tr>
<tr class="memdesc:aece739c5a2672028f0c7848045b89f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tolerance for checking arithmetic bounds In rank and in simplexes.  <a href="#aece739c5a2672028f0c7848045b89f08">More...</a><br/></td></tr>
<tr class="separator:aece739c5a2672028f0c7848045b89f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f94e47c6dc073bbd3929903b4431fe"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a66f94e47c6dc073bbd3929903b4431fe">E</a> = boost::math::constants::e&lt;double&gt;()</td></tr>
<tr class="memdesc:a66f94e47c6dc073bbd3929903b4431fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base of the natural logarithm, <img class="formulaInl" alt="$ e $" src="form_45.png"/>.  <a href="#a66f94e47c6dc073bbd3929903b4431fe">More...</a><br/></td></tr>
<tr class="separator:a66f94e47c6dc073bbd3929903b4431fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a> = std::sqrt(2.0)</td></tr>
<tr class="memdesc:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of 2, <img class="formulaInl" alt="$ \sqrt{2} $" src="form_46.png"/>.  <a href="#a491d6e40aaa2a3e205ea6708dc3c75dd">More...</a><br/></td></tr>
<tr class="separator:a491d6e40aaa2a3e205ea6708dc3c75dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5491e346d5a812af988f8de4a5948c88"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5491e346d5a812af988f8de4a5948c88">INV_SQRT_2</a> = 1.0 / <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a></td></tr>
<tr class="memdesc:a5491e346d5a812af988f8de4a5948c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of 2, <img class="formulaInl" alt="$ 1 / \sqrt{2} $" src="form_47.png"/>.  <a href="#a5491e346d5a812af988f8de4a5948c88">More...</a><br/></td></tr>
<tr class="separator:a5491e346d5a812af988f8de4a5948c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fb48f0a7f26bc60c1dfb572283b149"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a43fb48f0a7f26bc60c1dfb572283b149">LOG_2</a> = std::log(2.0)</td></tr>
<tr class="memdesc:a43fb48f0a7f26bc60c1dfb572283b149"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2, <img class="formulaInl" alt="$ \log 2 $" src="form_48.png"/>.  <a href="#a43fb48f0a7f26bc60c1dfb572283b149">More...</a><br/></td></tr>
<tr class="separator:a43fb48f0a7f26bc60c1dfb572283b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab773773e2db53015eb48ab1730816fb5"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab773773e2db53015eb48ab1730816fb5">LOG_10</a> = std::log(10.0)</td></tr>
<tr class="memdesc:ab773773e2db53015eb48ab1730816fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10, <img class="formulaInl" alt="$ \log 10 $" src="form_49.png"/>.  <a href="#ab773773e2db53015eb48ab1730816fb5">More...</a><br/></td></tr>
<tr class="separator:ab773773e2db53015eb48ab1730816fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a7f2ac8ebf3095e9934715bb34f0669b3">INFTY</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity.  <a href="#a7f2ac8ebf3095e9934715bb34f0669b3">More...</a><br/></td></tr>
<tr class="separator:a7f2ac8ebf3095e9934715bb34f0669b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa37d0f67f02e0a0b5797ed9f4df56bfb">NEGATIVE_INFTY</a> = - std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity.  <a href="#aa37d0f67f02e0a0b5797ed9f4df56bfb">More...</a><br/></td></tr>
<tr class="separator:aa37d0f67f02e0a0b5797ed9f4df56bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf147700a2e38335abc618b2c913b8a"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9cf147700a2e38335abc618b2c913b8a">NOT_A_NUMBER</a> = std::numeric_limits&lt;double&gt;::quiet_NaN()</td></tr>
<tr class="memdesc:a9cf147700a2e38335abc618b2c913b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Quiet) not-a-number value.  <a href="#a9cf147700a2e38335abc618b2c913b8a">More...</a><br/></td></tr>
<tr class="separator:a9cf147700a2e38335abc618b2c913b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a5ffd625c2083751d7ccabb7dbe39cbe0">EPSILON</a> = std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest positive value.  <a href="#a5ffd625c2083751d7ccabb7dbe39cbe0">More...</a><br/></td></tr>
<tr class="separator:a5ffd625c2083751d7ccabb7dbe39cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcea3a9752d079c9f972040b873b704"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a1dcea3a9752d079c9f972040b873b704">NEGATIVE_EPSILON</a> = - std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a1dcea3a9752d079c9f972040b873b704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest negative value (i.e., smallest absolute value).  <a href="#a1dcea3a9752d079c9f972040b873b704">More...</a><br/></td></tr>
<tr class="separator:a1dcea3a9752d079c9f972040b873b704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea938c86917d89bbd13e4edcbecb1be"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a4ea938c86917d89bbd13e4edcbecb1be">POISSON_MAX_RATE</a> = std::pow(2.0, 30)</td></tr>
<tr class="memdesc:a4ea938c86917d89bbd13e4edcbecb1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest rate parameter allowed in Poisson RNG.  <a href="#a4ea938c86917d89bbd13e4edcbecb1be">More...</a><br/></td></tr>
<tr class="separator:a4ea938c86917d89bbd13e4edcbecb1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177764626d2378e0d7bdfb26aac187b6"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a177764626d2378e0d7bdfb26aac187b6">LOG_PI_OVER_FOUR</a> = std::log(boost::math::constants::pi&lt;double&gt;()) / 4.0</td></tr>
<tr class="memdesc:a177764626d2378e0d7bdfb26aac187b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log pi divided by 4 <img class="formulaInl" alt="$ \log \pi / 4 $" src="form_50.png"/>.  <a href="#a177764626d2378e0d7bdfb26aac187b6">More...</a><br/></td></tr>
<tr class="separator:a177764626d2378e0d7bdfb26aac187b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e31fd76fde6e97d14dfb26c5f4ab8d0"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a3e31fd76fde6e97d14dfb26c5f4ab8d0">SQRT_PI</a> = std::sqrt(boost::math::constants::pi&lt;double&gt;())</td></tr>
<tr class="separator:a3e31fd76fde6e97d14dfb26c5f4ab8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa628c5af5a85d53472f0126fcca44524"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa628c5af5a85d53472f0126fcca44524">SQRT_2_TIMES_SQRT_PI</a> = <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a> * <a class="el" href="namespacestan_1_1math.html#a3e31fd76fde6e97d14dfb26c5f4ab8d0">SQRT_PI</a></td></tr>
<tr class="separator:aa628c5af5a85d53472f0126fcca44524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935530f53a026ebb80fcd9006059e9c8"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a> = 2.0 / <a class="el" href="namespacestan_1_1math.html#a3e31fd76fde6e97d14dfb26c5f4ab8d0">SQRT_PI</a></td></tr>
<tr class="separator:a935530f53a026ebb80fcd9006059e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344504ea0c1f4f956c85ea8027a07ba9"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a344504ea0c1f4f956c85ea8027a07ba9">NEG_TWO_OVER_SQRT_PI</a> = -<a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a></td></tr>
<tr class="separator:a344504ea0c1f4f956c85ea8027a07ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d54686aa26009d0e9101be42afd877"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a44d54686aa26009d0e9101be42afd877">INV_SQRT_TWO_PI</a> = 1.0 / std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;())</td></tr>
<tr class="separator:a44d54686aa26009d0e9101be42afd877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd9cf6abfd8930528d3635890982b1"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a> = std::log(boost::math::constants::pi&lt;double&gt;())</td></tr>
<tr class="separator:af6dd9cf6abfd8930528d3635890982b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab836723c882918b6263042bdefa3c0d7"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ab836723c882918b6263042bdefa3c0d7">LOG_SQRT_PI</a> = std::log(<a class="el" href="namespacestan_1_1math.html#a3e31fd76fde6e97d14dfb26c5f4ab8d0">SQRT_PI</a>)</td></tr>
<tr class="separator:ab836723c882918b6263042bdefa3c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd99e429af3a997976a017d6a580e3f9"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#acd99e429af3a997976a017d6a580e3f9">LOG_ZERO</a> = std::log(0.0)</td></tr>
<tr class="separator:acd99e429af3a997976a017d6a580e3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a5d92de812b4b632801cf8e32dbe7d"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad7a5d92de812b4b632801cf8e32dbe7d">LOG_TWO</a> = std::log(2.0)</td></tr>
<tr class="separator:ad7a5d92de812b4b632801cf8e32dbe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84525339d1870944d63c1cce6caa1af1"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a84525339d1870944d63c1cce6caa1af1">LOG_HALF</a> = std::log(0.5)</td></tr>
<tr class="separator:a84525339d1870944d63c1cce6caa1af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa546788809cd7f0be4a9872bc8009325"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#aa546788809cd7f0be4a9872bc8009325">NEG_LOG_TWO</a> = - <a class="el" href="namespacestan_1_1math.html#ad7a5d92de812b4b632801cf8e32dbe7d">LOG_TWO</a></td></tr>
<tr class="separator:aa546788809cd7f0be4a9872bc8009325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f7f156224f9e60c2fb3e99034212eb"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a59f7f156224f9e60c2fb3e99034212eb">NEG_LOG_SQRT_TWO_PI</a> = - std::log(std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;()))</td></tr>
<tr class="separator:a59f7f156224f9e60c2fb3e99034212eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f964e25c3ad3515549ead08428ff7cf"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a0f964e25c3ad3515549ead08428ff7cf">NEG_LOG_PI</a> = - <a class="el" href="namespacestan_1_1math.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a></td></tr>
<tr class="separator:a0f964e25c3ad3515549ead08428ff7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4a282e2196987e10d2bb65f12ec55a"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#afb4a282e2196987e10d2bb65f12ec55a">NEG_LOG_SQRT_PI</a> = -std::log(std::sqrt(boost::math::constants::pi&lt;double&gt;()))</td></tr>
<tr class="separator:afb4a282e2196987e10d2bb65f12ec55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0bc03717322aa20ea2be9d6e488738"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a9b0bc03717322aa20ea2be9d6e488738">NEG_LOG_TWO_OVER_TWO</a> = - <a class="el" href="namespacestan_1_1math.html#ad7a5d92de812b4b632801cf8e32dbe7d">LOG_TWO</a> / 2.0</td></tr>
<tr class="separator:a9b0bc03717322aa20ea2be9d6e488738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e5d349b0ffdfdae9674f9dd4dbebe"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a938e5d349b0ffdfdae9674f9dd4dbebe">LOG_TWO_PI</a> = <a class="el" href="namespacestan_1_1math.html#ad7a5d92de812b4b632801cf8e32dbe7d">LOG_TWO</a> + <a class="el" href="namespacestan_1_1math.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a></td></tr>
<tr class="separator:a938e5d349b0ffdfdae9674f9dd4dbebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc867325cdad6b9dcc2e7443ddf5956"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a2fc867325cdad6b9dcc2e7443ddf5956">NEG_LOG_TWO_PI</a> = - <a class="el" href="namespacestan_1_1math.html#a938e5d349b0ffdfdae9674f9dd4dbebe">LOG_TWO_PI</a></td></tr>
<tr class="separator:a2fc867325cdad6b9dcc2e7443ddf5956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a063d6b0347cc193b69270211e8aadd"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a8a063d6b0347cc193b69270211e8aadd">MAJOR_VERSION</a> = <a class="el" href="version_8hpp.html#a0c96447c79362b9df7ef76867a44d3be">STAN_STRING</a>(<a class="el" href="version_8hpp.html#a64f03843f4437f40d083b7bc1a1206e1">STAN_MATH_MAJOR</a>)</td></tr>
<tr class="memdesc:a8a063d6b0347cc193b69270211e8aadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major version number for Stan math library.  <a href="#a8a063d6b0347cc193b69270211e8aadd">More...</a><br/></td></tr>
<tr class="separator:a8a063d6b0347cc193b69270211e8aadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60295ca22b8701af9a3ccf3b607231f4"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#a60295ca22b8701af9a3ccf3b607231f4">MINOR_VERSION</a> = <a class="el" href="version_8hpp.html#a0c96447c79362b9df7ef76867a44d3be">STAN_STRING</a>(<a class="el" href="version_8hpp.html#afae12a425638d2799b253d3eb268190c">STAN_MATH_MINOR</a>)</td></tr>
<tr class="memdesc:a60295ca22b8701af9a3ccf3b607231f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minor version number for Stan math library.  <a href="#a60295ca22b8701af9a3ccf3b607231f4">More...</a><br/></td></tr>
<tr class="separator:a60295ca22b8701af9a3ccf3b607231f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html#ad4c620fffa8fa7ddd68ffb46fb64667b">PATCH_VERSION</a> = <a class="el" href="version_8hpp.html#a0c96447c79362b9df7ef76867a44d3be">STAN_STRING</a>(<a class="el" href="version_8hpp.html#aacfcdd8a078a3dc181112e6d04b82f49">STAN_MATH_PATCH</a>)</td></tr>
<tr class="memdesc:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch version for Stan math library.  <a href="#ad4c620fffa8fa7ddd68ffb46fb64667b">More...</a><br/></td></tr>
<tr class="separator:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrices and templated mathematical functions. </p>
<p>Templated probability distributions. All paramaterizations are based on Bayesian Data Analysis. Function gradients via reverse-mode automatic differentiation. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a947fbc8520096439705d2072a18b43c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structstan_1_1math_1_1_autodiff_stack_storage.html">AutodiffStackStorage</a>&lt;<a class="el" href="classstan_1_1math_1_1chainable.html">chainable</a>, <a class="el" href="classstan_1_1math_1_1chainable__alloc.html">chainable_alloc</a>&gt; <a class="el" href="namespacestan_1_1math.html#a947fbc8520096439705d2072a18b43c0">stan::math::ChainableStack</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="chainablestack_8hpp_source.html#l00011">11</a> of file <a class="el" href="chainablestack_8hpp_source.html">chainablestack.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a735db87876a1e603cdfb3c8b3c41aab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">stan::math::matrix_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for matrix of double values. </p>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2typedefs_8hpp_source.html#l00023">23</a> of file <a class="el" href="prim_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12edd55403c6b7a6a7a859aef1990df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;double&gt;, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a12edd55403c6b7a6a7a859aef1990df5">stan::math::matrix_fd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1a8f07814e249e758d3347cbf3ce23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;double&gt; &gt;, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#ac1a8f07814e249e758d3347cbf3ce23f">stan::math::matrix_ffd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7ad1f7cc49caf90a56fe364405e1187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt; &gt;, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#af7ad1f7cc49caf90a56fe364405e1187">stan::math::matrix_ffv</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html#l00018">18</a> of file <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a401abbdecf03e1aaa673aae55ea22fad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a401abbdecf03e1aaa673aae55ea22fad">stan::math::matrix_fv</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html#l00014">14</a> of file <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5eec679edf26abd1fdf8cf56053caf8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">stan::math::matrix_v</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a matrix holding <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code> values. </p>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2typedefs_8hpp_source.html#l00021">21</a> of file <a class="el" href="rev_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac61a9b8f4000b9e69bf2d1dcfb34c984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, 1, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#ac61a9b8f4000b9e69bf2d1dcfb34c984">stan::math::row_vector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for (row) vector of double values. </p>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2typedefs_8hpp_source.html#l00037">37</a> of file <a class="el" href="prim_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93e8ecf4499143a1d39440a4ce690de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;double&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a93e8ecf4499143a1d39440a4ce690de6">stan::math::row_vector_fd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html#l00033">33</a> of file <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae05b8f0a467a66e088270a5707a9f3b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;double&gt; &gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#ae05b8f0a467a66e088270a5707a9f3b7">stan::math::row_vector_ffd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html#l00037">37</a> of file <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0159cba837b1310fe0c68b21ce555d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt; &gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a0159cba837b1310fe0c68b21ce555d5b">stan::math::row_vector_ffv</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html#l00034">34</a> of file <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87031870214da337be0da09913bc9158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a87031870214da337be0da09913bc9158">stan::math::row_vector_fv</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html#l00030">30</a> of file <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05401bf8bb7f886d11b1ee90495fe153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, 1, Eigen::Dynamic&gt; <a class="el" href="namespacestan_1_1math.html#a05401bf8bb7f886d11b1ee90495fe153">stan::math::row_vector_v</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a row vector holding <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code> values. </p>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2typedefs_8hpp_source.html#l00037">37</a> of file <a class="el" href="rev_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98ff1baf06b8c5e2fc241bba99d0a97d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;::Index <a class="el" href="namespacestan_1_1math.html#a98ff1baf06b8c5e2fc241bba99d0a97d">stan::math::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for sizes and indexes in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix with double e. </p>

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9e96c15b87fbd704ab9bcf77e7597db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt; <a class="el" href="namespacestan_1_1math.html#ac9e96c15b87fbd704ab9bcf77e7597db">stan::math::vector_d</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for (column) vector of double values. </p>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2typedefs_8hpp_source.html#l00030">30</a> of file <a class="el" href="prim_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a961a316bf3b39b578ec6382096da3e9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;double&gt;, Eigen::Dynamic, 1&gt; <a class="el" href="namespacestan_1_1math.html#a961a316bf3b39b578ec6382096da3e9a">stan::math::vector_fd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html#l00025">25</a> of file <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a846bbc633c1a4c67cd805bbf61f42be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;double&gt; &gt;, Eigen::Dynamic, 1&gt; <a class="el" href="namespacestan_1_1math.html#a846bbc633c1a4c67cd805bbf61f42be0">stan::math::vector_ffd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html#l00029">29</a> of file <a class="el" href="fwd_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1d0aff99d591327d929ee87054978ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt; &gt;, Eigen::Dynamic, 1&gt; <a class="el" href="namespacestan_1_1math.html#ab1d0aff99d591327d929ee87054978ce">stan::math::vector_ffv</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html#l00026">26</a> of file <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5065cc81264dfe941f8e9a3ecfe5ee85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;, Eigen::Dynamic, 1&gt; <a class="el" href="namespacestan_1_1math.html#a5065cc81264dfe941f8e9a3ecfe5ee85">stan::math::vector_fv</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html#l00022">22</a> of file <a class="el" href="mix_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7d3137027b10bc7758d4c1763b58a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, Eigen::Dynamic, 1&gt; <a class="el" href="namespacestan_1_1math.html#aa7d3137027b10bc7758d4c1763b58a8e">stan::math::vector_v</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a (column) vector holding <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code> values. </p>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2typedefs_8hpp_source.html#l00029">29</a> of file <a class="el" href="rev_2mat_2fun_2typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae560b842e3ed6e5939dc2177bf158265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::abs </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2abs_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2abs_8hpp_source.html">abs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb4764556637084eee528b45d8eaa767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return floating-point absolute value. </p>
<p>Delegates to <code>fabs(double)</code> rather than <code>std::abs(int)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute value of scalar </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2abs_8hpp_source.html#l00019">19</a> of file <a class="el" href="prim_2scal_2fun_2abs_8hpp_source.html">abs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a971adca9c3989255ca1f9568f8e7dc93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::abs </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the absolute value of the variable (std). </p>
<p>Delegates to <code><a class="el" href="namespacestan_1_1math.html#a6c79c9be5c64873b74f3c6924fef6911">fabs()</a></code> (see for doc).</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{abs}(x) = \begin{cases} |x| &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_251.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{abs}(x)}{\partial x} = \begin{cases} -1 &amp; \mbox{if } x < 0 \\ 0 &amp; \mbox{if } x = 0 \\ 1 &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_252.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Absolute value of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2abs_8hpp_source.html#l00035">35</a> of file <a class="el" href="rev_2scal_2fun_2abs_8hpp_source.html">abs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6952d8c23d69dc891dbe78e7d4ea7a80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::acos </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2acos_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2acos_8hpp_source.html">acos.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b472e155399f39ba2d7e26abb50cd7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::acos </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the principal value of the arc cosine of a variable, in radians (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \arccos x = \frac{-1}{\sqrt{1 - x^2}}$" src="form_253.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{acos}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \arccos(x) &amp; \mbox{if } -1\leq x\leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_254.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{acos}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \frac{\partial\, \arccos(x)}{\partial x} &amp; \mbox{if } -1\leq x\leq 1 \\ \textrm{NaN} &amp; \mbox{if } x < -1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_255.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \arccos(x)}{\partial x} = -\frac{1}{\sqrt{1-x^2}} \]" src="form_256.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable in range [-1, 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Arc cosine of variable, in radians. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2acos_8hpp_source.html#l00059">59</a> of file <a class="el" href="rev_2scal_2fun_2acos_8hpp_source.html">acos.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae033720f1a26c44aa9d7fb4dcf547155"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::acosh </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2acosh_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2acosh_8hpp_source.html">acosh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8d20387e255363750b779b213d734f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::acosh </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse hyperbolic cosine function for variables (C99). </p>
<p>For non-variable function, see <a class="el" href="namespacestan_1_1math.html#ae033720f1a26c44aa9d7fb4dcf547155">acosh()</a>.</p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{acosh}(x) = \frac{x}{x^2 - 1}$" src="form_257.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{acosh}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 1 \\ \cosh^{-1}(x) &amp; \mbox{if } x \geq 1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_258.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{acosh}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 1 \\ \frac{\partial\, \cosh^{-1}(x)}{\partial x} &amp; \mbox{if } x \geq 1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_259.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \cosh^{-1}(x)=\ln\left(x+\sqrt{x^2-1}\right) \]" src="form_260.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \cosh^{-1}(x)}{\partial x} = \frac{1}{\sqrt{x^2-1}} \]" src="form_261.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse hyperbolic cosine of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2acosh_8hpp_source.html#l00063">63</a> of file <a class="el" href="rev_2scal_2fun_2acosh_8hpp_source.html">acosh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7092cc09ee412719d685be41a04982a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified matrices. </p>
<p>The two matrices must have the same dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if m1 and m2 do not have the same dimensions. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00027">27</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60c2f0966abaf6f80131423add52053d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified matrix and specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix plus the scalar. </dd></dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00052">52</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7b8d8a7b33160a0c7304efc26fb46db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::add </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the specified scalar and specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar plus the matrix. </dd></dl>

<p>Definition at line <a class="el" href="add_8hpp_source.html#l00074">74</a> of file <a class="el" href="add_8hpp_source.html">add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a238bf34fdfe67aa84300d9822f34be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::add_initial_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the state derived from the coupled system in the with the original initial state. </p>
<p>This is necessary because the coupled system subtracts out the initial state in its representation when the initial state is unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">y0</td><td>original initial values to add back into the coupled system. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>state of the coupled system on input, incremented with initial values on output. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2arr_2functor_2coupled__ode__system_8hpp_source.html#l00031">31</a> of file <a class="el" href="rev_2arr_2functor_2coupled__ode__system_8hpp_source.html">coupled_ode_system.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f2aa85e5119417b44958458dd714cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T1, T2&gt;::type, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::append_col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix. </p>
<p>The inputs can be (matrix, matrix), (matrix, vector), (vector, matrix), or (vector, vector) and the output is always a matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R1</td><td>Row specification of first matrix. </td></tr>
    <tr><td class="paramname">C1</td><td>Column specification of first matrix. </td></tr>
    <tr><td class="paramname">R2</td><td>Row specification of second matrix. </td></tr>
    <tr><td class="paramname">C2</td><td>Column specification of second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First matrix. </td></tr>
    <tr><td class="paramname">B</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of appending the first matrix followed by the second matrix side by side. </dd></dl>

<p>Definition at line <a class="el" href="append__col_8hpp_source.html#l00039">39</a> of file <a class="el" href="append__col_8hpp_source.html">append_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10572fe52ef6b2ddbe94aa1549310289"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int C1, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T1, T2&gt;::type, 1, Eigen::Dynamic&gt; stan::math::append_col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, 1, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of concatenaing the first row vector followed by the second row vector side by side, with the result being a row vector. </p>
<p>This function applies to (row_vector, row_vector) and returns a row_vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first row vector. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second row vector. </td></tr>
    <tr><td class="paramname">C1</td><td>Column specification of first row vector. </td></tr>
    <tr><td class="paramname">C2</td><td>Column specification of second row vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First vector. </td></tr>
    <tr><td class="paramname">B</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of appending the second row vector to the right of the first row vector. </dd></dl>

<p>Definition at line <a class="el" href="append__col_8hpp_source.html#l00085">85</a> of file <a class="el" href="append__col_8hpp_source.html">append_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1462dc3a656316092e0557cdc276f377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::append_col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix. </p>
<p>This is an overloaded template function for the case when both matrices have the same type.</p>
<p>The inputs can be (matrix, matrix), (matrix, vector), (vector, matrix), or (vector, vector), and the output is always a matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of both matrices. </td></tr>
    <tr><td class="paramname">R1</td><td>Row specification of first matrix. </td></tr>
    <tr><td class="paramname">C1</td><td>Column specification of first matrix. </td></tr>
    <tr><td class="paramname">R2</td><td>Row specification of second matrix. </td></tr>
    <tr><td class="paramname">C2</td><td>Column specification of second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First matrix. </td></tr>
    <tr><td class="paramname">B</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of appending the first matrix followed by the second matrix side by side. </dd></dl>

<p>Definition at line <a class="el" href="append__col_8hpp_source.html#l00128">128</a> of file <a class="el" href="append__col_8hpp_source.html">append_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5ba839958285c999e1f3bb5706bb9b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C1, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::math::append_col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of concatenaing the first row vector followed by the second row vector side by side, with the result being a row vector. </p>
<p>This function applies to (row_vector, row_vector) and returns a row_vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of both vectors. </td></tr>
    <tr><td class="paramname">C1</td><td>Column specification of first row vector. </td></tr>
    <tr><td class="paramname">C2</td><td>Column specification of second row vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First vector. </td></tr>
    <tr><td class="paramname">B</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of appending the second row vector to the right of the first row vector. </dd></dl>

<p>Definition at line <a class="el" href="append__col_8hpp_source.html#l00160">160</a> of file <a class="el" href="append__col_8hpp_source.html">append_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed867c5cdbb34fe1c10ad212665c8611"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T1, T2&gt;::type, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::append_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of stacking the rows of the first argument matrix on top of the second argument matrix. </p>
<p>The inputs can be (matrix, matrix), (matrix, row_vector), (row_vector, matrix), or (row_vector, row_vector), and the output is always a matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R1</td><td>Row specification of first matrix. </td></tr>
    <tr><td class="paramname">C1</td><td>Column specification of first matrix. </td></tr>
    <tr><td class="paramname">R2</td><td>Row specification of second matrix. </td></tr>
    <tr><td class="paramname">C2</td><td>Column specification of second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First matrix. </td></tr>
    <tr><td class="paramname">B</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of stacking first matrix on top of second. </dd></dl>

<p>Definition at line <a class="el" href="append__row_8hpp_source.html#l00037">37</a> of file <a class="el" href="append__row_8hpp_source.html">append_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3ac4765524854d6b14af8def58431dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T1, T2&gt;::type, Eigen::Dynamic, 1&gt; stan::math::append_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of stacking the first vector on top of the second vector, with the result being a vector. </p>
<p>This function applies to (vector, vector) and returns a vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first vector. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second vector. </td></tr>
    <tr><td class="paramname">R1</td><td>Row specification of first vector. </td></tr>
    <tr><td class="paramname">R2</td><td>Row specification of second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First vector. </td></tr>
    <tr><td class="paramname">B</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of stacking first vector on top of the second vector. </dd></dl>

<p>Definition at line <a class="el" href="append__row_8hpp_source.html#l00080">80</a> of file <a class="el" href="append__row_8hpp_source.html">append_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8edbdc61c53db90c4dd6039221f5a71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::append_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of stacking the rows of the first argument matrix on top of the second argument matrix. </p>
<p>This is an overload for the case when the scalar types of the two input matrix are the same.</p>
<p>The inputs can be (matrix, matrix), (matrix, row_vector), (row_vector, matrix), or (row_vector, row_vector), and the output is always a matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of both matrices. </td></tr>
    <tr><td class="paramname">R1</td><td>Row specification of first matrix. </td></tr>
    <tr><td class="paramname">C1</td><td>Column specification of first matrix. </td></tr>
    <tr><td class="paramname">R2</td><td>Row specification of second matrix. </td></tr>
    <tr><td class="paramname">C2</td><td>Column specification of second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First matrix. </td></tr>
    <tr><td class="paramname">B</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of stacking first matrix on top of second. </dd></dl>

<p>Definition at line <a class="el" href="append__row_8hpp_source.html#l00121">121</a> of file <a class="el" href="append__row_8hpp_source.html">append_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66107dc00c528f6d692bbde30d6af90c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::append_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of stacking the first vector on top of the second vector, with the result being a vector. </p>
<p>This is an overloaded template function for the case where both inputs have the same scalar type.</p>
<p>This function applies to (vector, vector) and returns a vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of both vectors. </td></tr>
    <tr><td class="paramname">R1</td><td>Row specification of first vector. </td></tr>
    <tr><td class="paramname">R2</td><td>Row specification of second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>First vector. </td></tr>
    <tr><td class="paramname">B</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of stacking first vector on top of the second vector. </dd></dl>

<p>Definition at line <a class="el" href="append__row_8hpp_source.html#l00155">155</a> of file <a class="el" href="append__row_8hpp_source.html">append_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ec93b560b654740be65de81d6f348cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::as_bool </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the argument is unequal to zero and 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if argument is equal to zero (or NaN) and 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2as__bool_8hpp_source.html#l00014">14</a> of file <a class="el" href="prim_2scal_2fun_2as__bool_8hpp_source.html">as_bool.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7ad9c5e9f0b2f99b96133ad7a158f64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::as_bool </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the argument is unequal to zero and 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if argument is equal to zero (or NaN) and 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2as__bool_8hpp_source.html#l00015">15</a> of file <a class="el" href="rev_2scal_2fun_2as__bool_8hpp_source.html">as_bool.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ab75d0165599717cfd1e90f7edcf250"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::asin </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2asin_8hpp_source.html#l00012">12</a> of file <a class="el" href="fwd_2scal_2fun_2asin_8hpp_source.html">asin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab710bf940838cc452c426597f55f74dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::asin </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the principal value of the arc sine, in radians, of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \arcsin x = \frac{1}{\sqrt{1 - x^2}}$" src="form_262.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{asin}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \arcsin(x) &amp; \mbox{if } -1\leq x\leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_263.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{asin}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \frac{\partial\, \arcsin(x)}{\partial x} &amp; \mbox{if } -1\leq x\leq 1 \\ \textrm{NaN} &amp; \mbox{if } x < -1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_264.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \arcsin(x)}{\partial x} = \frac{1}{\sqrt{1-x^2}} \]" src="form_265.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable in range [-1, 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Arc sine of variable, in radians. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2asin_8hpp_source.html#l00058">58</a> of file <a class="el" href="rev_2scal_2fun_2asin_8hpp_source.html">asin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68af8aec6bd04b4d40e5bce59f82b97c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::asinh </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2asinh_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2asinh_8hpp_source.html">asinh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6d7b01cd76067a0fa8d424b4e81a4fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::asinh </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse hyperbolic sine function for variables (C99). </p>
<p>For non-variable function, see <a class="el" href="namespacestan_1_1math.html#a68af8aec6bd04b4d40e5bce59f82b97c">asinh()</a>.</p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{asinh}(x) = \frac{x}{x^2 + 1}$" src="form_266.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{asinh}(x) = \begin{cases} \sinh^{-1}(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_267.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{asinh}(x)}{\partial x} = \begin{cases} \frac{\partial\, \sinh^{-1}(x)}{\partial x} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_268.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sinh^{-1}(x)=\ln\left(x+\sqrt{x^2+1}\right) \]" src="form_269.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \sinh^{-1}(x)}{\partial x} = \frac{1}{\sqrt{x^2+1}} \]" src="form_270.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse hyperbolic sine of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2asinh_8hpp_source.html#l00062">62</a> of file <a class="el" href="rev_2scal_2fun_2asinh_8hpp_source.html">asinh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f394c15ea3eb97743382631f91801cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RHS &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will match arguments where the right-hand side is assignable to the left and they are not both <code>std::vector</code> or <code>Eigen::Matrix</code> types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00036">36</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5371f0f914e9b79a0700577e5557c0b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; LHS, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types, but whose shapes are not compatible. The shapes are specified in the row and column template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side matrix elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R1</td><td>Row shape of left-hand side matrix. </td></tr>
    <tr><td class="paramname">C1</td><td>Column shape of left-hand side matrix. </td></tr>
    <tr><td class="paramname">R2</td><td>Row shape of right-hand side matrix. </td></tr>
    <tr><td class="paramname">C2</td><td>Column shape of right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00062">62</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a80c719463c4e3caa03df731e2c2cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; LHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types and whose shapes match. The shapes are specified in the row and column template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side matrix elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R</td><td>Row shape of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column shape of both mtarices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00094">94</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4af3a90ad3b5ec1507dfc1823fdb8da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Block&lt; LHS &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; RHS, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>Eigen::Matrix</code> types and whose shapes match. The shape of the right-hand side matrix is specified in the row and column shape template parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of matrix block elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side matrix elements. </td></tr>
    <tr><td class="paramname">R</td><td>Row shape for right-hand side matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column shape for right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side block view of matrix. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00123">123</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c6dec98c71fd478c2ee16bc274b464d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::assign </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; LHS &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; RHS &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the right-hand side's value to the left-hand side variable. </p>
<p>The <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> function is overloaded. This instance will be called for arguments that are both <code>std::vector</code>, and will call <code><a class="el" href="namespacestan_1_1math.html#a5f394c15ea3eb97743382631f91801cf" title="Copy the right-hand side&#39;s value to the left-hand side variable. ">assign()</a></code> element-by element.</p>
<p>For example, a <code>std::vector&lt;int&gt;</code> can be assigned to a <code>std::vector&lt;double&gt;</code> using this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LHS</td><td>Type of left-hand side vector elements. </td></tr>
    <tr><td class="paramname">RHS</td><td>Type of right-hand side vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Left-hand side vector. </td></tr>
    <tr><td class="paramname">y</td><td>Right-hand side vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if sizes do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="assign_8hpp_source.html#l00155">155</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f0398656b862b1b2eb80145f4877b11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::atan </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2atan_8hpp_source.html#l00012">12</a> of file <a class="el" href="fwd_2scal_2fun_2atan_8hpp_source.html">atan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85cb80cff5115679c25d7347ffa89c81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::atan </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the principal value of the arc tangent, in radians, of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \arctan x = \frac{1}{1 + x^2}$" src="form_271.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{atan}(x) = \begin{cases} \arctan(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_272.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{atan}(x)}{\partial x} = \begin{cases} \frac{\partial\, \arctan(x)}{\partial x} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_273.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \arctan(x)}{\partial x} = \frac{1}{x^2+1} \]" src="form_274.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable in range [-1, 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Arc tangent of variable, in radians. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2atan_8hpp_source.html#l00055">55</a> of file <a class="el" href="rev_2scal_2fun_2atan_8hpp_source.html">atan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c4868ee5c5ab673ee54e5dce3be37f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::atan2 </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2atan2_8hpp_source.html#l00012">12</a> of file <a class="el" href="fwd_2scal_2fun_2atan2_8hpp_source.html">atan2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee48dfb63f75612a566b876f59d4a8df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::atan2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2atan2_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2scal_2fun_2atan2_8hpp_source.html">atan2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28a4864b96b98584311eea08a6ff609e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::atan2 </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2atan2_8hpp_source.html#l00029">29</a> of file <a class="el" href="fwd_2scal_2fun_2atan2_8hpp_source.html">atan2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32fe21eb929346e553266ceda0a97f23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::atan2 </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the principal value of the arc tangent, in radians, of the first variable divided by the second (cmath). </p>
<p>The partial derivatives are defined by</p>
<p><img class="formulaInl" alt="$ \frac{\partial}{\partial x} \arctan \frac{x}{y} = \frac{y}{x^2 + y^2}$" src="form_275.png"/>, and</p>
<p><img class="formulaInl" alt="$ \frac{\partial}{\partial y} \arctan \frac{x}{y} = \frac{-x}{x^2 + y^2}$" src="form_276.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Numerator variable. </td></tr>
    <tr><td class="paramname">b</td><td>Denominator variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arc tangent of the fraction, in radians. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2atan2_8hpp_source.html#l00062">62</a> of file <a class="el" href="rev_2scal_2fun_2atan2_8hpp_source.html">atan2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf0d4eeedff1e94221e2b719d0227e25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::atan2 </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the principal value of the arc tangent, in radians, of the first variable divided by the second scalar (cmath). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$ \frac{d}{d x} \arctan \frac{x}{c} = \frac{c}{x^2 + c^2}$" src="form_277.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Numerator variable. </td></tr>
    <tr><td class="paramname">b</td><td>Denominator scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arc tangent of the fraction, in radians. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2atan2_8hpp_source.html#l00078">78</a> of file <a class="el" href="rev_2scal_2fun_2atan2_8hpp_source.html">atan2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02a3681701397c99fd57d8816869b92f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::atan2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the principal value of the arc tangent, in radians, of the first scalar divided by the second variable (cmath). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$ \frac{\partial}{\partial y} \arctan \frac{c}{y} = \frac{-c}{c^2 + y^2}$" src="form_278.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{atan2}(x, y) = \begin{cases} \arctan\left(\frac{x}{y}\right) &amp; \mbox{if } -\infty\leq x \leq \infty, -\infty\leq y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_279.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{atan2}(x, y)}{\partial x} = \begin{cases} \frac{y}{x^2+y^2} &amp; \mbox{if } -\infty\leq x\leq \infty, -\infty\leq y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_280.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{atan2}(x, y)}{\partial y} = \begin{cases} -\frac{x}{x^2+y^2} &amp; \mbox{if } -\infty\leq x\leq \infty, -\infty\leq y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_281.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Numerator scalar. </td></tr>
    <tr><td class="paramname">b</td><td>Denominator variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arc tangent of the fraction, in radians. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2atan2_8hpp_source.html#l00119">119</a> of file <a class="el" href="rev_2scal_2fun_2atan2_8hpp_source.html">atan2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e31606b2cbc69573ec0d7693c8b2a2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::atanh </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2atanh_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2atanh_8hpp_source.html">atanh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cbf81b5222fb11c01b539fab0434bdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::atanh </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse hyperbolic tangent function for variables (C99). </p>
<p>For non-variable function, see <a class="el" href="namespacestan_1_1math.html#a9e31606b2cbc69573ec0d7693c8b2a2c">atanh()</a>.</p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{atanh}(x) = \frac{1}{1 - x^2}$" src="form_282.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{atanh}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \tanh^{-1}(x) &amp; \mbox{if } -1\leq x \leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_283.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{atanh}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \frac{\partial\, \tanh^{-1}(x)}{\partial x} &amp; \mbox{if } -1\leq x\leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_284.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tanh^{-1}(x)=\frac{1}{2}\ln\left(\frac{1+x}{1-x}\right) \]" src="form_285.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \tanh^{-1}(x)}{\partial x} = \frac{1}{1-x^2} \]" src="form_286.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse hyperbolic tangent of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2atanh_8hpp_source.html#l00065">65</a> of file <a class="el" href="rev_2scal_2fun_2atanh_8hpp_source.html">atanh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd7c65ea100e48abc72f3c1e96fcdbe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::autocorrelation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::FFT&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write autocorrelation estimates for every lag for the specified input sequence into the specified result using the specified FFT engine. </p>
<p>The return vector be resized to the same length as the input sequence with lags given by array index.</p>
<p>The implementation involves a fast Fourier transform, followed by a normalization, followed by an inverse transform.</p>
<p>An FFT engine can be created for reuse for type double with:</p>
<pre>
    Eigen::FFT&lt;double&gt; fft;
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Input sequence. </td></tr>
    <tr><td class="paramname">ac</td><td>Autocorrelations. </td></tr>
    <tr><td class="paramname">fft</td><td>FFT engine instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="autocorrelation_8hpp_source.html#l00054">54</a> of file <a class="el" href="autocorrelation_8hpp_source.html">autocorrelation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a999404b2520dcd466c62c6ba3ca61f89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::autocorrelation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write autocorrelation estimates for every lag for the specified input sequence into the specified result. </p>
<p>The return vector be resized to the same length as the input sequence with lags given by array index.</p>
<p>The implementation involves a fast Fourier transform, followed by a normalization, followed by an inverse transform.</p>
<p>This method is just a light wrapper around the three-argument autocorrelation function</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Input sequence. </td></tr>
    <tr><td class="paramname">ac</td><td>Autocorrelations. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="autocorrelation_8hpp_source.html#l00123">123</a> of file <a class="el" href="autocorrelation_8hpp_source.html">autocorrelation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab515e37311a3070dbc66e69d31359a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::autocovariance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>acov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::FFT&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write autocovariance estimates for every lag for the specified input sequence into the specified result using the specified FFT engine. </p>
<p>The return vector be resized to the same length as the input sequence with lags given by array index.</p>
<p>The implementation involves a fast Fourier transform, followed by a normalization, followed by an inverse transform.</p>
<p>An FFT engine can be created for reuse for type double with:</p>
<pre>
    Eigen::FFT&lt;double&gt; fft;
</pre><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Input sequence. </td></tr>
    <tr><td class="paramname">acov</td><td>Autocovariance. </td></tr>
    <tr><td class="paramname">fft</td><td>FFT engine instance. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="autocovariance_8hpp_source.html#l00034">34</a> of file <a class="el" href="autocovariance_8hpp_source.html">autocovariance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acdfe56505f9cbe96a18fc00f76fe79fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::autocovariance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>acov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write autocovariance estimates for every lag for the specified input sequence into the specified result. </p>
<p>The return vector be resized to the same length as the input sequence with lags given by array index.</p>
<p>The implementation involves a fast Fourier transform, followed by a normalization, followed by an inverse transform.</p>
<p>This method is just a light wrapper around the three-argument autocovariance function</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Input sequence. </td></tr>
    <tr><td class="paramname">acov</td><td>Autocovariances. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="autocovariance_8hpp_source.html#l00062">62</a> of file <a class="el" href="autocovariance_8hpp_source.html">autocovariance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d8811804a3bb9a9cd943422ce3938db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::bernoulli_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__ccdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="bernoulli__ccdf__log_8hpp_source.html">bernoulli_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b80aeaa1cc10d315d915aba2ddc6180"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::bernoulli_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__cdf_8hpp_source.html#l00024">24</a> of file <a class="el" href="bernoulli__cdf_8hpp_source.html">bernoulli_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac569e9e067f4d61280974e9a54ac6476"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::bernoulli_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__cdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="bernoulli__cdf__log_8hpp_source.html">bernoulli_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e360bb277db7a3318c1c368dbccdda8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::bernoulli_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="bernoulli__log_8hpp_source.html">bernoulli_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a075f08b1d99b150b64d851139be35894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::bernoulli_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__log_8hpp_source.html#l00120">120</a> of file <a class="el" href="bernoulli__log_8hpp_source.html">bernoulli_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9048a0a4bd452c7e797cb5a496b0b97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::bernoulli_logit_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__logit__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="bernoulli__logit__log_8hpp_source.html">bernoulli_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a193781437c0aa1a48fe48b24d9ae8130"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::bernoulli_logit_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__logit__log_8hpp_source.html#l00104">104</a> of file <a class="el" href="bernoulli__logit__log_8hpp_source.html">bernoulli_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac46d3934578fb7346a900677a3e8c377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::bernoulli_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bernoulli__rng_8hpp_source.html#l00023">23</a> of file <a class="el" href="bernoulli__rng_8hpp_source.html">bernoulli_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f08e25e46df323a2429edc45d1c8954"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2bessel__first__kind_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2bessel__first__kind_8hpp_source.html">bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a367822396d06842610b32ec1d1010944"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2bessel__first__kind_8hpp_source.html#l00027">27</a> of file <a class="el" href="rev_2scal_2fun_2bessel__first__kind_8hpp_source.html">bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebfb3835848bd8550192cd5e090d3b5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_first\_kind}(v, x) = \begin{cases} J_v(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_26.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{bessel\_first\_kind}(v, x)}{\partial x} = \begin{cases} \frac{\partial\, J_v(x)}{\partial x} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_27.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ J_v(x)=\left(\frac{1}{2}x\right)^v \sum_{k=0}^\infty \frac{\left(-\frac{1}{4}x^2\right)^k}{k!\, \Gamma(v+k+1)} \]" src="form_28.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, J_v(x)}{\partial x} = \frac{v}{x}J_v(x)-J_{v+1}(x) \]" src="form_29.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2bessel__first__kind_8hpp_source.html#l00040">40</a> of file <a class="el" href="prim_2scal_2fun_2bessel__first__kind_8hpp_source.html">bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0b227eac2dd4cbc55462ecebe940294"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2bessel__second__kind_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2bessel__second__kind_8hpp_source.html">bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bff905107813b205e8cf81ace301ef9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2bessel__second__kind_8hpp_source.html#l00027">27</a> of file <a class="el" href="rev_2scal_2fun_2bessel__second__kind_8hpp_source.html">bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a645ce13c6454913ec39be807751604dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{bessel\_second\_kind}(v, x) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0 \\ Y_v(x) &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_30.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{bessel\_second\_kind}(v, x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0 \\ \frac{\partial\, Y_v(x)}{\partial x} &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_31.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Y_v(x)=\frac{J_v(x)\cos(v\pi)-J_{-v}(x)}{\sin(v\pi)} \]" src="form_32.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, Y_v(x)}{\partial x} = \frac{v}{x}Y_v(x)-Y_{v+1}(x) \]" src="form_33.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2bessel__second__kind_8hpp_source.html#l00040">40</a> of file <a class="el" href="prim_2scal_2fun_2bessel__second__kind_8hpp_source.html">bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab380fecf1c6c99b602f212cbccc28a83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_size1, T_size2&gt;::type stan::math::beta_binomial_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size1 &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size2 &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__binomial__ccdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="beta__binomial__ccdf__log_8hpp_source.html">beta_binomial_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6abc35510e01a52b5138a19bfedb2a3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_size1, T_size2&gt;::type stan::math::beta_binomial_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size1 &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size2 &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__binomial__cdf_8hpp_source.html#l00029">29</a> of file <a class="el" href="beta__binomial__cdf_8hpp_source.html">beta_binomial_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf2c63ba04c87c46bcb0db999d955e9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_size1, T_size2&gt;::type stan::math::beta_binomial_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size1 &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size2 &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__binomial__cdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="beta__binomial__cdf__log_8hpp_source.html">beta_binomial_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c2462b112bf6512c4db7c6abea6478c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_size1, T_size2&gt;::type stan::math::beta_binomial_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size1 &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size2 &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__binomial__log_8hpp_source.html#l00030">30</a> of file <a class="el" href="beta__binomial__log_8hpp_source.html">beta_binomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48a71d6f54236310fba1a94b445272f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_size1, T_size2&gt;::type stan::math::beta_binomial_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size1 &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_size2 &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__binomial__log_8hpp_source.html#l00175">175</a> of file <a class="el" href="beta__binomial__log_8hpp_source.html">beta_binomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0443ac7dbd959b40b1a958767857f5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::beta_binomial_rng </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__binomial__rng_8hpp_source.html#l00026">26</a> of file <a class="el" href="beta__binomial__rng_8hpp_source.html">beta_binomial_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a625d31cf8da1c8cd2ea99af113ed6fe6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale_succ, T_scale_fail&gt;::type stan::math::beta_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_succ &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_fail &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__ccdf__log_8hpp_source.html#l00034">34</a> of file <a class="el" href="beta__ccdf__log_8hpp_source.html">beta_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84beaaff122d602406a515a9dd97bb90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale_succ, T_scale_fail&gt;::type stan::math::beta_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_succ &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_fail &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the beta cumulative distribution function for the given variate and scale variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variate. </td></tr>
    <tr><td class="paramname">alpha</td><td>Prior sample size. </td></tr>
    <tr><td class="paramname">beta</td><td>Prior sample size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The beta cdf evaluated at the specified arguments. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y. </td></tr>
    <tr><td class="paramname">T_scale_succ</td><td>Type of alpha. </td></tr>
    <tr><td class="paramname">T_scale_fail</td><td>Type of beta. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="beta__cdf_8hpp_source.html#l00046">46</a> of file <a class="el" href="beta__cdf_8hpp_source.html">beta_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa87400b4ecd4bba0d10158cad4f3a8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale_succ, T_scale_fail&gt;::type stan::math::beta_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_succ &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_fail &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__cdf__log_8hpp_source.html#l00033">33</a> of file <a class="el" href="beta__cdf__log_8hpp_source.html">beta_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0246a55c1c14d2c7ec35a0070af63299"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale_succ, T_scale_fail&gt;::type stan::math::beta_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_succ &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_fail &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the beta density for the specified scalar(s) given the specified sample size(s). </p>
<p>y, alpha, or beta can each either be scalar or a vector. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/alpha/beta triple.</p>
<p>Prior sample sizes, alpha and beta, must be greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Sequence of) prior sample size(s). </td></tr>
    <tr><td class="paramname">beta</td><td>(Sequence of) prior sample size(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar outcome. </td></tr>
    <tr><td class="paramname">T_scale_succ</td><td>Type of prior scale for successes. </td></tr>
    <tr><td class="paramname">T_scale_fail</td><td>Type of prior scale for failures. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="beta__log_8hpp_source.html#l00052">52</a> of file <a class="el" href="beta__log_8hpp_source.html">beta_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e5818c82697944b91b483674b14ad22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale_succ, T_scale_fail&gt;::type stan::math::beta_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_succ &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale_fail &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__log_8hpp_source.html#l00209">209</a> of file <a class="el" href="beta__log_8hpp_source.html">beta_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7fa2015614535f45c2cb6d5f544643d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::beta_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="beta__rng_8hpp_source.html#l00030">30</a> of file <a class="el" href="beta__rng_8hpp_source.html">beta_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0d069b5730083b0203812d63c6f62f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::binary_log_loss </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2binary__log__loss_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2binary__log__loss_8hpp_source.html">binary_log_loss.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add2a043f562537b8cc57bb35780ac5b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::binary_log_loss </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log loss function for binary classification with specified reference and response values. </p>
<p>The log loss function for prediction <img class="formulaInl" alt="$\hat{y} \in [0, 1]$" src="form_34.png"/> given outcome <img class="formulaInl" alt="$y \in \{ 0, 1 \}$" src="form_35.png"/> is</p>
<p><img class="formulaInl" alt="$\mbox{logloss}(1, \hat{y}) = -\log \hat{y} $" src="form_36.png"/>, and</p>
<p><img class="formulaInl" alt="$\mbox{logloss}(0, \hat{y}) = -\log (1 - \hat{y}) $" src="form_37.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Reference value in { 0 , 1 }. </td></tr>
    <tr><td class="paramname">y_hat</td><td>Response value in [0, 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log loss for response given reference value. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2binary__log__loss_8hpp_source.html#l00026">26</a> of file <a class="el" href="prim_2scal_2fun_2binary__log__loss_8hpp_source.html">binary_log_loss.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87b93caccb44639dea5c47f78fe6be28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::binary_log_loss </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>y_hat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log loss function for variables (stan). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#ae0d069b5730083b0203812d63c6f62f3">stan::math::binary_log_loss()</a> for the double-based version.</p>
<p>The derivative with respect to the variable <img class="formulaInl" alt="$\hat{y}$" src="form_287.png"/> is</p>
<p><img class="formulaInl" alt="$\frac{d}{d\hat{y}} \mbox{logloss}(1, \hat{y}) = - \frac{1}{\hat{y}}$" src="form_288.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{d}{d\hat{y}} \mbox{logloss}(0, \hat{y}) = \frac{1}{1 - \hat{y}}$" src="form_289.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{binary\_log\_loss}(y, \hat{y}) = \begin{cases} y \log \hat{y} + (1 - y) \log (1 - \hat{y}) &amp; \mbox{if } 0\leq \hat{y}\leq 1, y\in\{ 0, 1 \}\\[6pt] \textrm{NaN} &amp; \mbox{if } \hat{y} = \textrm{NaN} \end{cases} \]" src="form_290.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{binary\_log\_loss}(y, \hat{y})}{\partial \hat{y}} = \begin{cases} \frac{y}{\hat{y}}-\frac{1-y}{1-\hat{y}} &amp; \mbox{if } 0\leq \hat{y}\leq 1, y\in\{ 0, 1 \}\\[6pt] \textrm{NaN} &amp; \mbox{if } \hat{y} = \textrm{NaN} \end{cases} \]" src="form_291.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Reference value. </td></tr>
    <tr><td class="paramname">y_hat</td><td>Response variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log loss of response versus reference value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2binary__log__loss_8hpp_source.html#l00068">68</a> of file <a class="el" href="rev_2scal_2fun_2binary__log__loss_8hpp_source.html">binary_log_loss.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92586706a7afc2c968e0c11a9a021f8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::binomial_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__ccdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="binomial__ccdf__log_8hpp_source.html">binomial_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25ca53e4f20460de16af84337acba3f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::binomial_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__cdf_8hpp_source.html#l00032">32</a> of file <a class="el" href="binomial__cdf_8hpp_source.html">binomial_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96b0617f8ad60887c84b0cd91ebe202e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::binomial_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__cdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="binomial__cdf__log_8hpp_source.html">binomial_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3ae920ef2089bb1686eb51c3dc153b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::binomial_coefficient_log </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2binomial__coefficient__log_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2binomial__coefficient__log_8hpp_source.html">binomial_coefficient_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a113b2443c22c0859cc797b7c1bdea59f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::binomial_coefficient_log </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2binomial__coefficient__log_8hpp_source.html#l00046">46</a> of file <a class="el" href="fwd_2scal_2fun_2binomial__coefficient__log_8hpp_source.html">binomial_coefficient_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27dad23d38c6d5e74c65e7571c70272e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_N , typename T_n &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_N, T_n&gt;::type stan::math::binomial_coefficient_log </td>
          <td>(</td>
          <td class="paramtype">const T_N&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_n&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of the binomial coefficient for the specified arguments. </p>
<p>The binomial coefficient, <img class="formulaInl" alt="${N \choose n}$" src="form_38.png"/>, read "N choose n", is defined for <img class="formulaInl" alt="$0 \leq n \leq N$" src="form_39.png"/> by</p>
<p><img class="formulaInl" alt="${N \choose n} = \frac{N!}{n! (N-n)!}$" src="form_40.png"/>.</p>
<p>This function uses Gamma functions to define the log and generalize the arguments to continuous N and n.</p>
<p><img class="formulaInl" alt="$ \log {N \choose n} = \log \ \Gamma(N+1) - \log \Gamma(n+1) - \log \Gamma(N-n+1)$" src="form_41.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{binomial\_coefficient\_log}(x, y) = \begin{cases} \textrm{error} &amp; \mbox{if } y > x \textrm{ or } y < 0\\ \ln\Gamma(x+1) &amp; \mbox{if } 0\leq y \leq x \\ \quad -\ln\Gamma(y+1)&amp; \\ \quad -\ln\Gamma(x-y+1)&amp; \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_42.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{binomial\_coefficient\_log}(x, y)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } y > x \textrm{ or } y < 0\\ \Psi(x+1) &amp; \mbox{if } 0\leq y \leq x \\ \quad -\Psi(x-y+1)&amp; \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_43.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{binomial\_coefficient\_log}(x, y)}{\partial y} = \begin{cases} \textrm{error} &amp; \mbox{if } y > x \textrm{ or } y < 0\\ -\Psi(y+1) &amp; \mbox{if } 0\leq y \leq x \\ \quad +\Psi(x-y+1)&amp; \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_44.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>total number of objects. </td></tr>
    <tr><td class="paramname">n</td><td>number of objects chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log (N choose n). </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2binomial__coefficient__log_8hpp_source.html#l00063">63</a> of file <a class="el" href="prim_2scal_2fun_2binomial__coefficient__log_8hpp_source.html">binomial_coefficient_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6816ab0a50a160820063ffe087a826"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::binomial_coefficient_log </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2binomial__coefficient__log_8hpp_source.html#l00070">70</a> of file <a class="el" href="fwd_2scal_2fun_2binomial__coefficient__log_8hpp_source.html">binomial_coefficient_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9de035dd17c118b3144a9ed9c867378f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_N , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::binomial_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__log_8hpp_source.html#l00036">36</a> of file <a class="el" href="binomial__log_8hpp_source.html">binomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b3409628d97b7ff020f2c0c694d8d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::binomial_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__log_8hpp_source.html#l00127">127</a> of file <a class="el" href="binomial__log_8hpp_source.html">binomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f5a9e223a39b11f58fe044dcb2bc7ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_N , typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::binomial_logit_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__logit__log_8hpp_source.html#l00037">37</a> of file <a class="el" href="binomial__logit__log_8hpp_source.html">binomial_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5378254419361dd7a0bfacf139b49401"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_prob&gt;::type stan::math::binomial_logit_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_prob &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__logit__log_8hpp_source.html#l00131">131</a> of file <a class="el" href="binomial__logit__log_8hpp_source.html">binomial_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa41d355d768c2258bf999bc765382f27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::binomial_rng </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binomial__rng_8hpp_source.html#l00031">31</a> of file <a class="el" href="binomial__rng_8hpp_source.html">binomial_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69be3cf865daa6eca4a859f97ffaa8f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::block </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a nrows x ncols submatrix starting at (i-1, j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row </td></tr>
    <tr><td class="paramname">j</td><td>Starting column </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows in block </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="block_8hpp_source.html#l00023">23</a> of file <a class="el" href="block_8hpp_source.html">block.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9b0e3e51b5cc7ab1da287369ff754d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::calculate_chain </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="calculate__chain_8hpp_source.html#l00008">8</a> of file <a class="el" href="calculate__chain_8hpp_source.html">calculate_chain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a583ce356e75d8d7be0126bb00c401afa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_log </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="categorical__log_8hpp_source.html">categorical_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41e12bdd3e7ba1450f8b44ea5a59b0dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_log </td>
          <td>(</td>
          <td class="paramtype">const typename math::index_type&lt; Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &gt;::type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__log_8hpp_source.html#l00056">56</a> of file <a class="el" href="categorical__log_8hpp_source.html">categorical_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a089e388c974ca67ecc06e9c67f75067f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__log_8hpp_source.html#l00068">68</a> of file <a class="el" href="categorical__log_8hpp_source.html">categorical_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aabce8d1a6154b04d2689f604b2e2373b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__log_8hpp_source.html#l00116">116</a> of file <a class="el" href="categorical__log_8hpp_source.html">categorical_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35594af0b1635f8bc2817ca8a2c767f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_logit_log </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__logit__log_8hpp_source.html#l00022">22</a> of file <a class="el" href="categorical__logit__log_8hpp_source.html">categorical_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea64526bd00e285844c6eb1246ccf431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_logit_log </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__logit__log_8hpp_source.html#l00045">45</a> of file <a class="el" href="categorical__logit__log_8hpp_source.html">categorical_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac06f8075869ffd32c8a0385e57bc2170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_logit_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__logit__log_8hpp_source.html#l00054">54</a> of file <a class="el" href="categorical__logit__log_8hpp_source.html">categorical_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac35ff747de556a8f351efda0e986a832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::categorical_logit_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__logit__log_8hpp_source.html#l00089">89</a> of file <a class="el" href="categorical__logit__log_8hpp_source.html">categorical_logit_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f8b55cdaa59f3fe7718d5b45889cda6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::categorical_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="categorical__rng_8hpp_source.html#l00020">20</a> of file <a class="el" href="categorical__rng_8hpp_source.html">categorical_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa932af729313abe32571d8a3742385ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::cauchy_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cauchy__ccdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="cauchy__ccdf__log_8hpp_source.html">cauchy_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7ecad949e8b175b4b60f6f5cb16319b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::cauchy_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cauchy cumulative distribution function for the given variate, location, and scale. </p>
<p><img class="formulaInl" alt="$\frac{1}{\pi}\arctan\left(\frac{y-\mu}{\sigma}\right) + \frac{1}{2}$" src="form_190.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variate. </td></tr>
    <tr><td class="paramname">mu</td><td>The location parameter. </td></tr>
    <tr><td class="paramname">sigma</td><td>The scale parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cauchy__cdf_8hpp_source.html#l00036">36</a> of file <a class="el" href="cauchy__cdf_8hpp_source.html">cauchy_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a689566206e25e90e590c2655d3b49032"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::cauchy_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cauchy__cdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="cauchy__cdf__log_8hpp_source.html">cauchy_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57b702de583e1883c8abd5b2fbba4b0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::cauchy_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s). </p>
<p>y, mu, or sigma can each either be scalar a vector. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mu/sigma triple.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location(s). </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of densities. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar outcome. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cauchy__log_8hpp_source.html#l00043">43</a> of file <a class="el" href="cauchy__log_8hpp_source.html">cauchy_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ffc7f40b61588318f20c738202fc5fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::cauchy_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cauchy__log_8hpp_source.html#l00145">145</a> of file <a class="el" href="cauchy__log_8hpp_source.html">cauchy_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ddbccee3c214e6fc88f297b6524d0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::cauchy_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cauchy__rng_8hpp_source.html#l00023">23</a> of file <a class="el" href="cauchy__rng_8hpp_source.html">cauchy_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64c0dfe5862fc53f1a18d76f14a1dc7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::cbrt </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2cbrt_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2cbrt_8hpp_source.html">cbrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a865962fcd8998de077f4a77b0a4ffa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::cbrt </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cube root of the specified variable (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#a64c0dfe5862fc53f1a18d76f14a1dc7e">cbrt()</a> for the double-based version.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} x^{1/3} = \frac{1}{3 x^{2/3}}$" src="form_292.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{cbrt}(x) = \begin{cases} \sqrt[3]{x} &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_293.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{cbrt}(x)}{\partial x} = \begin{cases} \frac{1}{3x^{2/3}} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_294.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Specified variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cube root of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2cbrt_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2scal_2fun_2cbrt_8hpp_source.html">cbrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1b2e9b4a947b81917612a8d1d547afb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::ceil </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2ceil_8hpp_source.html#l00011">11</a> of file <a class="el" href="fwd_2scal_2fun_2ceil_8hpp_source.html">ceil.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06e924d5a6c94f7593056b5cb1324b66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::ceil </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ceiling of the specified variable (cmath). </p>
<p>The derivative of the ceiling function is defined and zero everywhere but at integers, and we set them to zero for convenience,</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} {\lceil x \rceil} = 0$" src="form_295.png"/>.</p>
<p>The ceiling function rounds up. For double values, this is the smallest integral value that is not less than the specified value. Although this function is not differentiable because it is discontinuous at integral values, its gradient is returned as zero everywhere.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{ceil}(x) = \begin{cases} \lceil x\rceil &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_296.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{ceil}(x)}{\partial x} = \begin{cases} 0 &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_297.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ceiling of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2ceil_8hpp_source.html#l00060">60</a> of file <a class="el" href="rev_2scal_2fun_2ceil_8hpp_source.html">ceil.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16d53b31b377bc3fc120d6469af3d99e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_bounded </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the value is between the low and high values, inclusively. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of value </td></tr>
    <tr><td class="paramname">T_low</td><td>Type of low value </td></tr>
    <tr><td class="paramname">T_high</td><td>Type of high value</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Value to check </td></tr>
    <tr><td class="paramname">low</td><td>Low bound </td></tr>
    <tr><td class="paramname">high</td><td>High bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value is between low and high, inclusively. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>otherwise. This also throws if any of the arguments are NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__bounded_8hpp_source.html#l00095">95</a> of file <a class="el" href="check__bounded_8hpp_source.html">check_bounded.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b3c1ad17fc5567f1599fa9d0a218620"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid Cholesky factor. </p>
<p>A Cholesky factor is a lower triangular matrix whose diagonal elements are all positive. Note that Cholesky factors need not be square, but require at least as many rows M as columns N (i.e., M &gt;= N).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of elements of Cholesky factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid Cholesky factor </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is not a valid Choleksy factor, if number of rows is less than the number of columns, if there are 0 columns, or if any element in matrix is NaN </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cholesky__factor_8hpp_source.html#l00036">36</a> of file <a class="el" href="check__cholesky__factor_8hpp_source.html">check_cholesky_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f24b6f8e2a52523ae37a7ff2664e9b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cholesky_factor_corr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid Cholesky factor of a correlation matrix. </p>
<p>A Cholesky factor is a lower triangular matrix whose diagonal elements are all positive. Note that Cholesky factors need not be square, but require at least as many rows M as columns N (i.e., M &gt;= N).</p>
<p>Tolerance is specified by <code><a class="el" href="namespacestan_1_1math.html#aece739c5a2672028f0c7848045b89f08" title="The tolerance for checking arithmetic bounds In rank and in simplexes. ">math::CONSTRAINT_TOLERANCE</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of elements of Cholesky factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid Cholesky factor of a correlation matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is not a valid Choleksy factor, if number of rows is less than the number of columns, if there are 0 columns, or if any element in matrix is NaN </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cholesky__factor__corr_8hpp_source.html#l00040">40</a> of file <a class="el" href="check__cholesky__factor__corr_8hpp_source.html">check_cholesky_factor_corr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16b0a60f741f97efac53254839f24ff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_column_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified index is a valid column of the matrix. </p>
<p>By default, this is a 1-indexed check (as opposed to 0-indexed). Behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>. This function will throw an <code>std::out_of_range</code> exception if the index is out of bounds.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">R</td><td>Number of rows of the matrix </td></tr>
    <tr><td class="paramname">C</td><td>Number of columns of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Index to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is a valid column index of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is an invalid column index </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__column__index_8hpp_source.html#l00037">37</a> of file <a class="el" href="check__column__index_8hpp_source.html">check_column_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b6ab798e2f2a2ffad6b244efab0a58f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expected_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x is consistent, which is defined to be <code>expected_size</code> if x is a vector or 1 if x is not a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">expected_size</td><td>Expected size if x is a vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x is scalar or if x is vector-like and has size of <code>expected_size</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if the size is inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__size_8hpp_source.html#l00029">29</a> of file <a class="el" href="check__consistent__size_8hpp_source.html">check_consistent_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e8b8fb2cc649fc1f34e75d0b1fe2ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x1 is consistent with x2. </p>
<p>Consistent size is defined as having the same size if vector-like or being a scalar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of x1 </td></tr>
    <tr><td class="paramname">T2</td><td>Type of x2</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x1</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x2</td><td>Variable to check for consistent size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x1 and x2 have consistent sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if sizes are inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00031">31</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fa5d10851fe1307ed7a0ffb768ff861"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x1, x2, and x3 are consistent. </p>
<p>Consistent size is defined as having the same size if vector-like or being a scalar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of x1 </td></tr>
    <tr><td class="paramname">T2</td><td>Type of x2 </td></tr>
    <tr><td class="paramname">T3</td><td>Type of x3</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x1</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x2</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name3</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x3</td><td>Variable to check for consistent size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x1, x2, and x3 have consistent sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if sizes are inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00066">66</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a817ff4687b2d9d98f7f7bf82e9286266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the dimension of x1, x2, x3, and x4 are consistent. </p>
<p>Consistent size is defined as having the same size if vector-like or being a scalar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of x1 </td></tr>
    <tr><td class="paramname">T2</td><td>Type of x2 </td></tr>
    <tr><td class="paramname">T3</td><td>Type of x3 </td></tr>
    <tr><td class="paramname">T4</td><td>Type of x4</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x1</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x2</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name3</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x3</td><td>Variable to check for consistent size </td></tr>
    <tr><td class="paramname">name4</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x4</td><td>Variable to check for consistent size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x1, x2, x3, and x4 have consistent sizes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if sizes are inconsistent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00107">107</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8496e1bd1273f06de6712e3fb81e2c3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_consistent_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>x5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="check__consistent__sizes_8hpp_source.html#l00128">128</a> of file <a class="el" href="check__consistent__sizes_8hpp_source.html">check_consistent_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41204c48d930b46e81329d8b00a0793e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_corr_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid correlation matrix. </p>
<p>A valid correlation matrix is symmetric, has a unit diagonal (all 1 values), and has all values between -1 and 1 (inclusive).</p>
<p>This function throws exceptions if the variable is not a valid correlation matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function this was called from </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified matrix is a valid correlation matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix is 0x0 </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is non-symmetric, diagonals not near 1, not positive definite, or any of the elements nan. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__corr__matrix_8hpp_source.html#l00046">46</a> of file <a class="el" href="check__corr__matrix_8hpp_source.html">check_corr_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb915b09e2e60dd76885b6d68655790c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a valid covariance matrix. </p>
<p>A valid covariance matrix is a square, symmetric matrix that is positive definite.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a valid covariance matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix is 0x0 </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric, if the matrix is not positive definite, or if any element of the matrix is nan </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__cov__matrix_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__cov__matrix_8hpp_source.html">check_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d8cfae284cdae1bb7e83d2a136f9a04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_eq &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_eq &amp;&#160;</td>
          <td class="paramname"><em>eq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is equal to <code>eq</code>. </p>
<p>This function is vectorized over both <code>y</code> and <code>eq</code>. If both <code>y</code> and <code>eq</code> are scalar or vector-like, then each element is compared in order. If one of <code>y</code> or <code>eq</code> are vector and the other is scalar, then the scalar is broadcast to the size of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of variable </td></tr>
    <tr><td class="paramname">T_eq</td><td>Type of comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check equality </td></tr>
    <tr><td class="paramname">eq</td><td>Expected value for y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is equal to eq </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is unequal to eq or if any element of y or eq is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__equal_8hpp_source.html#l00090">90</a> of file <a class="el" href="check__equal_8hpp_source.html">check_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf014e7733b17748049ccc5f3565de3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_finite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is finite. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is finite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is infinity, -infinity, or NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__finite_8hpp_source.html#l00062">62</a> of file <a class="el" href="check__finite_8hpp_source.html">check_finite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad60ac97b8f74b7c5ce2feb4bdb9e09e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is strictly greater than <code>low</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>low</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_low</td><td>Type of lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">low</td><td>Lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is strictly greater than low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is not greater than low or if any element of y or low is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__greater_8hpp_source.html#l00084">84</a> of file <a class="el" href="check__greater_8hpp_source.html">check_greater.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d5b19f8930c14681349d8444142487e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_greater_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is greater or equal than <code>low</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>low</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_low</td><td>Type of lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">low</td><td>Lower bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is greater or equal than low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is not greater or equal to low or if any element of y or low is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__greater__or__equal_8hpp_source.html#l00084">84</a> of file <a class="el" href="check__greater__or__equal_8hpp_source.html">check_greater_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7547b05717280b1cc041309803ec797d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ldlt_factor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the argument is a valid <code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a></code>. </p>
<p><code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></code> can be constructed in an invalid state, so it must be checked. A invalid <code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></code> is constructed from a non positive definite matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar </td></tr>
    <tr><td class="paramname">R</td><td>Rows of the matrix </td></tr>
    <tr><td class="paramname">C</td><td>Columns of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">A</td><td><code><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a></code> to check for validity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive definite. </dd>
<dd>
throws <code>std::domain_error</code> the <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> was created improperly (A.success() == false) </dd></dl>

<p>Definition at line <a class="el" href="check__ldlt__factor_8hpp_source.html#l00034">34</a> of file <a class="el" href="check__ldlt__factor_8hpp_source.html">check_ldlt_factor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab225792149dceaec443ce09b93f8744"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is strictly less than <code>high</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>high</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_high</td><td>Type of upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">high</td><td>Upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is strictly less than low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is not less than low or if any element of y or high is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__less_8hpp_source.html#l00081">81</a> of file <a class="el" href="check__less_8hpp_source.html">check_less.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9dd0895901bf876eca824b41f04003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_less_or_equal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is less or equal to <code>high</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code> against each element of <code>high</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y </td></tr>
    <tr><td class="paramname">T_high</td><td>Type of upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check </td></tr>
    <tr><td class="paramname">high</td><td>Upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is less than or equal to low. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if y is not less than or equal to low or if any element of y or high is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__less__or__equal_8hpp_source.html#l00081">81</a> of file <a class="el" href="check__less__or__equal_8hpp_source.html">check_less_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe34ba3113cc8f10f179873edb9b60ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_lower_triangular </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is lower triangular. </p>
<p>A matrix x is not lower triangular if there is a non-zero entry x[m, n] with m &lt; n. This function only inspects the upper triangular portion of the matrix, not including the diagonal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is lower triangular. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not lower triangular or if any element in the upper triangular portion is NaN </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__lower__triangular_8hpp_source.html#l00035">35</a> of file <a class="el" href="check__lower__triangular_8hpp_source.html">check_lower_triangular.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1149504bbf29d464f23508ca5eccc0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_matching_dims </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the two matrices are of the same size. </p>
<p>This function checks not only the runtime sizes, but the static sizes as well. For example, a 4x1 matrix is not the same as a vector with 4 elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of the second matrix </td></tr>
    <tr><td class="paramname">R1</td><td>Rows specified at compile time of the first matrix </td></tr>
    <tr><td class="paramname">C1</td><td>Columns specified at compile time of the first matrix </td></tr>
    <tr><td class="paramname">R2</td><td>Rows specified at compile time of the second matrix </td></tr>
    <tr><td class="paramname">C2</td><td>Columns specified at compile time of the second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name for the first matrix (for error messages) </td></tr>
    <tr><td class="paramname">y1</td><td>First matrix </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name for the second matrix (for error messages) </td></tr>
    <tr><td class="paramname">y2</td><td>Second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the dimensions of the two matrices match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the dimensions of the matrices do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__matching__dims_8hpp_source.html#l00037">37</a> of file <a class="el" href="check__matching__dims_8hpp_source.html">check_matching_dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52ba893fcf6fc650e992c13d41fbc3ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y1 , typename T_y2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_matching_sizes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y1 &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y2 &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if two structures at the same size. </p>
<p>This function only checks the runtime sizes for variables that implement a <code><a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">size()</a></code> method.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y1</td><td>Type of the first variable </td></tr>
    <tr><td class="paramname">T_y2</td><td>Type of the second variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>First variable name (for error messages) </td></tr>
    <tr><td class="paramname">y1</td><td>First variable </td></tr>
    <tr><td class="paramname">name2</td><td>Second variable name (for error messages) </td></tr>
    <tr><td class="paramname">y2</td><td>Second variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sizes match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the sizes do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__matching__sizes_8hpp_source.html#l00029">29</a> of file <a class="el" href="check__matching__sizes_8hpp_source.html">check_matching_sizes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cfbb4f09fe34b9ece32be051f16ce66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_multiplicable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the matrices can be multiplied. </p>
<p>This checks the runtime sizes to determine whether the two matrices are multiplicable. This allows <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices, vectors, and row vectors to be checked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name for the first matrix (for error messages) </td></tr>
    <tr><td class="paramname">y1</td><td>First matrix </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name for the second matrix (for error messages) </td></tr>
    <tr><td class="paramname">y2</td><td>Second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two matrices are multiplicable </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrices are not multiplicable or if either matrix is size 0 for either rows or columns </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__multiplicable_8hpp_source.html#l00033">33</a> of file <a class="el" href="check__multiplicable_8hpp_source.html">check_multiplicable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a6be100befb6d08504cf5af8440b236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_nonnegative </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is non-negative. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is greater than or equal to 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is negative or if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__nonnegative_8hpp_source.html#l00066">66</a> of file <a class="el" href="check__nonnegative_8hpp_source.html">check_nonnegative.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97c3c23033e47a923ed5ce26a4deeba5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_nonzero_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix/vector is of non-zero size. </p>
<p>Throws a std:invalid_argument otherwise. The message will indicate that the variable name "has size 0".</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of container</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Container to test. This will accept matrices and vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the the specified matrix/vector is of non-zero size </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the specified matrix/vector has zero size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__nonzero__size_8hpp_source.html#l00031">31</a> of file <a class="el" href="check__nonzero__size_8hpp_source.html">check_nonzero_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7942532ef8f89cee24af75a383835ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_not_nan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is not <code>NaN</code>. </p>
<p>This function is vectorized and will check each element of <code>y</code>. If any element is <code>NaN</code>, this function will throw an exception.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is not NaN. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__not__nan_8hpp_source.html#l00063">63</a> of file <a class="el" href="check__not__nan_8hpp_source.html">check_not_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a7b212a4431aeedca59b2e94c84f788"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is sorted into strictly increasing order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Vector to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is ordered </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector elements are not ordered, if there are duplicated values, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__ordered_8hpp_source.html#l00031">31</a> of file <a class="el" href="check__ordered_8hpp_source.html">check_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af55e7669a804e68bc9d39ecd06318b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T_y &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is sorted into strictly increasing order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code>std::vector</code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is ordered </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector elements are not ordered, if there are duplicated values, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__ordered_8hpp_source.html#l00078">78</a> of file <a class="el" href="check__ordered_8hpp_source.html">check_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0133fd07702f5253126a385703b7d73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_definite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified square, symmetric matrix is positive definite. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive definite </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix has 0 size. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric, if it is not positive definite, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__pos__definite_8hpp_source.html#l00038">38</a> of file <a class="el" href="check__pos__definite_8hpp_source.html">check_pos_definite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa26244f58d5a4dfd49181b39d9b4569b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_pos_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is positive definite. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>scalar type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is positive semi-definite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix has 0 size. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric, or if it is not positive semi-definite, or if any element of the matrix is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__pos__semidefinite_8hpp_source.html#l00036">36</a> of file <a class="el" href="check__pos__semidefinite_8hpp_source.html">check_pos_semidefinite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a814694b1125e641ca7b2e7269c82f966"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is positive. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if y is greater than 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if y is negative or zero or if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive_8hpp_source.html#l00068">68</a> of file <a class="el" href="check__positive_8hpp_source.html">check_positive.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af0725693b09e454f5c8327ac89cf0245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_finite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>y</code> is positive and finite. </p>
<p>This function is vectorized and will check each element of <code>y</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Variable to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if every element of y is greater than 0 and y is not infinite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if any element of y is not positive or if any element of y is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive__finite_8hpp_source.html#l00028">28</a> of file <a class="el" href="check__positive__finite_8hpp_source.html">check_positive_finite.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87f00a8c0f07c5a82145a14712437673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_ordered </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector contains non-negative values and is sorted into strictly increasing order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Vector to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is positive, ordered </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector contains non-positive values, if the values are not ordered, if there are duplicated values, or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive__ordered_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__positive__ordered_8hpp_source.html">check_positive_ordered.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6fe1398a136f3dc36d246a2ea747500"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_positive_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if <code>size</code> is positive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">expr</td><td>Expression for the dimension size (for error messages) </td></tr>
    <tr><td class="paramname">size</td><td>Size value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>size</code> is greater than 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if <code>size</code> is zero or negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__positive__size_8hpp_source.html#l00023">23</a> of file <a class="el" href="check__positive__size_8hpp_source.html">check_positive_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adcd4dcac328824f71f31d6861b8610ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nested_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if specified index is within range. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum size of the variable </td></tr>
    <tr><td class="paramname">index</td><td>Index to check </td></tr>
    <tr><td class="paramname">nested_level</td><td>Nested level (for error messages) </td></tr>
    <tr><td class="paramname">error_msg</td><td>Additional error message (for error messages)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is within range </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is not in range </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__range_8hpp_source.html#l00029">29</a> of file <a class="el" href="check__range_8hpp_source.html">check_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8822ad6a9b8706465e8e1f90c336e3c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if specified index is within range. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum size of the variable </td></tr>
    <tr><td class="paramname">index</td><td>Index to check </td></tr>
    <tr><td class="paramname">error_msg</td><td>Additional error message (for error messages)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is within range </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is not in range </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__range_8hpp_source.html#l00062">62</a> of file <a class="el" href="check__range_8hpp_source.html">check_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e76ffb67d3c6c6c225b0ba7b991f449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if specified index is within range. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum size of the variable </td></tr>
    <tr><td class="paramname">index</td><td>Index to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is within range </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is not in range </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__range_8hpp_source.html#l00089">89</a> of file <a class="el" href="check__range_8hpp_source.html">check_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb080867499e68f688b0dcb5c8f4e061"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_row_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified index is a valid row of the matrix. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
    <tr><td class="paramname">R</td><td>Compile time rows </td></tr>
    <tr><td class="paramname">C</td><td>Compile time columns</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test </td></tr>
    <tr><td class="paramname">i</td><td>is index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is a valid row index in the matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__row__index_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__row__index_8hpp_source.html">check_row_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6affd19d4999c427291a2bbb07bce304"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_simplex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is simplex. </p>
<p>To be a simplex, all values must be greater than or equal to 0 and the values must sum to 1.</p>
<p>A valid simplex is one where the sum of hte elements is equal to 1. This function tests that the sum is within the tolerance specified by <code>CONSTRAINT_TOLERANCE</code>. This function only accepts <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors, statically typed vectors, not general matrices with 1 column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>Scalar type of the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">theta</td><td>Vector to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is a simplex </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if <code>theta</code> is a 0-vector. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector is not a simplex or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__simplex_8hpp_source.html#l00041">41</a> of file <a class="el" href="check__simplex_8hpp_source.html">check_simplex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa547146eaac690e79a611e50a6dffb4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_size1 , typename T_size2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_size_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size1&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size2&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the provided sizes match. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_size1</td><td>Type of size 1 </td></tr>
    <tr><td class="paramname">T_size2</td><td>Type of size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name_i</td><td>Variable name 1 (for error messages) </td></tr>
    <tr><td class="paramname">i</td><td>Size 1 </td></tr>
    <tr><td class="paramname">name_j</td><td>Variable name 2 (for error messages) </td></tr>
    <tr><td class="paramname">j</td><td>Size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sizes match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the sizes do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__size__match_8hpp_source.html#l00030">30</a> of file <a class="el" href="check__size__match_8hpp_source.html">check_size_match.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c66b22fce7bd878b687d550299eb248"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_size1 , typename T_size2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_size_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size1&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_size2&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the provided sizes match. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_size1</td><td>Type of size 1 </td></tr>
    <tr><td class="paramname">T_size2</td><td>Type of size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">expr_i</td><td>Expression for variable name 1 (for error messages) </td></tr>
    <tr><td class="paramname">name_i</td><td>Variable name 1 (for error messages) </td></tr>
    <tr><td class="paramname">i</td><td>Size 1 </td></tr>
    <tr><td class="paramname">expr_j</td><td>Expression for variable name 2 (for error messages) </td></tr>
    <tr><td class="paramname">name_j</td><td>Variable name 2 (for error messages) </td></tr>
    <tr><td class="paramname">j</td><td>Size 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sizes match </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the sizes do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__size__match_8hpp_source.html#l00067">67</a> of file <a class="el" href="check__size__match_8hpp_source.html">check_size_match.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30d5ef4f11dbce1a670766034b416339"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_spsd_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is a square, symmetric, and positive semi-definite. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a square, symmetric, and positive semi-definite. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square or if the matrix is 0x0 </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric or if the matrix is not positive semi-definite </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__spsd__matrix_8hpp_source.html#l00032">32</a> of file <a class="el" href="check__spsd__matrix_8hpp_source.html">check_spsd_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94cfaa76ca5bc3f0ea5ad1d5b9f80727"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_square </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is square. </p>
<p>This check allows 0x0 matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is a square matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__square_8hpp_source.html#l00028">28</a> of file <a class="el" href="check__square_8hpp_source.html">check_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ed873db07e833c14413c319a5bb9837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_std_vector_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified index is valid in std vector. </p>
<p>This check is 1-indexed by default. This behavior can be changed by setting <code><a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code>std::vector</code> to test </td></tr>
    <tr><td class="paramname">i</td><td>Index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is a valid in std vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::out_of_range&lt;/code&gt;</td><td>if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__std__vector__index_8hpp_source.html#l00030">30</a> of file <a class="el" href="check__std__vector__index_8hpp_source.html">check_std_vector_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57384e961806a959d95a5444fd8d7190"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_symmetric </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified matrix is symmetric. </p>
<p>The error message is either 0 or 1 indexed, specified by <code><a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td>Matrix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrix is symmetric </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if any element not on the main diagonal is <code>NaN</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__symmetric_8hpp_source.html#l00038">38</a> of file <a class="el" href="check__symmetric_8hpp_source.html">check_symmetric.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a14e15ece9efbe2751549da6a598964c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_unit_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified vector is unit vector. </p>
<p>A valid unit vector is one where the square of the elements summed is equal to 1. This function tests that the sum is within the tolerance specified by <code>CONSTRAINT_TOLERANCE</code>. This function only accepts <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors, statically typed vectors, not general matrices with 1 column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>Scalar type of the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">theta</td><td>Vector to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vector is a unit vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if <code>theta</code> is a 0-vector. </td></tr>
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the vector is not a unit vector or if any element is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__unit__vector_8hpp_source.html#l00038">38</a> of file <a class="el" href="check__unit__vector_8hpp_source.html">check_unit_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b78e5ddf65db13aaa65a6c58205fbf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::check_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the matrix is either a row vector or column vector. </p>
<p>This function checks the runtime size of the matrix to check whether it is a row or column vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the matrix </td></tr>
    <tr><td class="paramname">R</td><td>Compile time rows of the matrix </td></tr>
    <tr><td class="paramname">C</td><td>Compile time columns of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x</td><td>Matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if x either has 1 columns or 1 rows </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if x is not a row or column vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="check__vector_8hpp_source.html#l00034">34</a> of file <a class="el" href="check__vector_8hpp_source.html">check_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af270a4206e4a52396b386b54c9a58ae9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::chi_square_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="chi__square__ccdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="chi__square__ccdf__log_8hpp_source.html">chi_square_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa196f552535f61f4b2bd088da74cc142"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::chi_square_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the chi square cumulative distribution function for the given variate and degrees of freedom. </p>
<p>y A scalar variate. nu Degrees of freedom.</p>
<dl class="section return"><dt>Returns</dt><dd>The cdf of the chi square distribution </dd></dl>

<p>Definition at line <a class="el" href="chi__square__cdf_8hpp_source.html#l00037">37</a> of file <a class="el" href="chi__square__cdf_8hpp_source.html">chi_square_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbf0413c908e37c44c24ad81f99aa77f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::chi_square_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="chi__square__cdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="chi__square__cdf__log_8hpp_source.html">chi_square_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a1c945dce01a8a4b4485b7c5bb258ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::chi_square_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a chi-squared density for y with the specified degrees of freedom parameter. </p>
<p>The degrees of freedom prarameter must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;\sim&amp; \chi^2_\nu \\ \log (p (y \, |\, \nu)) &amp;=&amp; \log \left( \frac{2^{-\nu / 2}}{\Gamma (\nu / 2)} y^{\nu / 2 - 1} \exp^{- y / 2} \right) \\ &amp;=&amp; - \frac{\nu}{2} \log(2) - \log (\Gamma (\nu / 2)) + (\frac{\nu}{2} - 1) \log(y) - \frac{y}{2} \\ &amp; &amp; \mathrm{ where } \; y \ge 0 \end{eqnarray*}" src="form_191.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than or equal to 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="chi__square__log_8hpp_source.html#l00047">47</a> of file <a class="el" href="chi__square__log_8hpp_source.html">chi_square_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78965d5578823b4bae1dde58e42012c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::chi_square_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="chi__square__log_8hpp_source.html#l00144">144</a> of file <a class="el" href="chi__square__log_8hpp_source.html">chi_square_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1653e58694ea92bc1781e5d332c31e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::chi_square_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="chi__square__rng_8hpp_source.html#l00025">25</a> of file <a class="el" href="chi__square__rng_8hpp_source.html">chi_square_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d24004ec984f89b342414ff6312d0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cholesky_corr_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cholesky__corr__constrain_8hpp_source.html#l00020">20</a> of file <a class="el" href="cholesky__corr__constrain_8hpp_source.html">cholesky_corr_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6649012a7c4d7108fb5dc5ebd6a13683"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cholesky_corr_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cholesky__corr__constrain_8hpp_source.html#l00058">58</a> of file <a class="el" href="cholesky__corr__constrain_8hpp_source.html">cholesky_corr_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeed4fbb1adce01dfc445cae326e4c482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::cholesky_corr_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cholesky__corr__free_8hpp_source.html#l00018">18</a> of file <a class="el" href="cholesky__corr__free_8hpp_source.html">cholesky_corr_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d798c4cab5a0716a0e338de38617c8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix. </p>
<p>The return value <img class="formulaInl" alt="$L$" src="form_9.png"/> will be a lower-traingular matrix such that the original matrix <img class="formulaInl" alt="$A$" src="form_10.png"/> is given by </p>
<p><img class="formulaInl" alt="$A = L \times L^T$" src="form_11.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Symmetrix matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square root of matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if m is not a symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cholesky__decompose_8hpp_source.html#l00023">23</a> of file <a class="el" href="cholesky__decompose_8hpp_source.html">cholesky_decompose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2be4ed6bbf19487de29cfc85718ed3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cholesky_factor_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Cholesky factor of the specified size read from the specified vector. </p>
<p>A total of (N choose 2) + N + (M - N) * N elements are required to read an M by N Cholesky factor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalars in matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of unconstrained values </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cholesky factor </dd></dl>

<p>Definition at line <a class="el" href="cholesky__factor__constrain_8hpp_source.html#l00029">29</a> of file <a class="el" href="cholesky__factor__constrain_8hpp_source.html">cholesky_factor_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8eb630493ae2edfb2dbc9caeda00dfff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cholesky_factor_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Cholesky factor of the specified size read from the specified vector and increment the specified log probability reference with the log Jacobian adjustment of the transform. </p>
<p>A total of (N choose 2) + N + N * (M - N) free parameters are required to read an M by N Cholesky factor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalars in matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of unconstrained values </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability that is incremented with the log Jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cholesky factor </dd></dl>

<p>Definition at line <a class="el" href="cholesky__factor__constrain_8hpp_source.html#l00073">73</a> of file <a class="el" href="cholesky__factor__constrain_8hpp_source.html">cholesky_factor_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9d45c92d30d1120cfa4b71a766e1712"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::cholesky_factor_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the unconstrained vector of parameters correspdonding to the specified Cholesky factor. </p>
<p>A Cholesky factor must be lower triangular and have positive diagonal elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Cholesky factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unconstrained parameters for Cholesky factor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the matrix is not a Cholesky factor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cholesky__factor__free_8hpp_source.html#l00024">24</a> of file <a class="el" href="cholesky__factor__free_8hpp_source.html">cholesky_factor_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d822499055d9eefe6cd543ad06e1d3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified column of the specified matrix using start-at-1 indexing. </p>
<p>This is equivalent to calling <code>m.col(i - 1)</code> and assigning the resulting template expression to a column vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">j</td><td>Column index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified column of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="col_8hpp_source.html#l00024">24</a> of file <a class="el" href="col_8hpp_source.html">col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a871bccc233a4dcd764ffece5a3f9a399"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::cols </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cols_8hpp_source.html#l00012">12</a> of file <a class="el" href="cols_8hpp_source.html">cols.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad63b6eb8c9db16d8321d8f2f18632be1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, 1, C1&gt; stan::math::columns_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2columns__dot__product_8hpp_source.html#l00018">18</a> of file <a class="el" href="fwd_2mat_2fun_2columns__dot__product_8hpp_source.html">columns_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d03b34aa7329a68f31d1c7bc500c5c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 1, C1&gt; stan::math::columns_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2columns__dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="prim_2mat_2fun_2columns__dot__product_8hpp_source.html">columns_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09f7ba0991c234a715af5b4968a28014"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, 1, C1&gt; &gt;::type stan::math::columns_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2columns__dot__product_8hpp_source.html#l00025">25</a> of file <a class="el" href="rev_2mat_2fun_2columns__dot__product_8hpp_source.html">columns_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a415662a8443b30a03b559fad4be26e85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, 1, C1&gt; stan::math::columns_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2columns__dot__product_8hpp_source.html#l00035">35</a> of file <a class="el" href="fwd_2mat_2fun_2columns__dot__product_8hpp_source.html">columns_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ca0a75054cee6793caf8b97f47f8fa7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, 1, C1&gt; stan::math::columns_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2columns__dot__product_8hpp_source.html#l00052">52</a> of file <a class="el" href="fwd_2mat_2fun_2columns__dot__product_8hpp_source.html">columns_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3663d900f7f0bdd57e808301ff142ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, 1, C&gt; stan::math::columns_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2columns__dot__self_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2mat_2fun_2columns__dot__self_8hpp_source.html">columns_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cc404fd71124d7cea29d4f6d1a767b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, C&gt; stan::math::columns_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of each column of a matrix with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2columns__dot__self_8hpp_source.html#l00016">16</a> of file <a class="el" href="prim_2mat_2fun_2columns__dot__self_8hpp_source.html">columns_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f1e866e49a056dc81b8b6b673dda0f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, 1, C&gt; stan::math::columns_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of each column of a matrix with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2columns__dot__self_8hpp_source.html#l00022">22</a> of file <a class="el" href="rev_2mat_2fun_2columns__dot__self_8hpp_source.html">columns_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a3c8aa139b956593524b01f21c971a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::corr_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of transforming the specified scalar to have a valid correlation value between -1 and 1 (inclusive). </p>
<p>The transform used is the hyperbolic tangent function,</p>
<p><img class="formulaInl" alt="$f(x) = \tanh x = \frac{\exp(2x) - 1}{\exp(2x) + 1}$" src="form_51.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Scalar input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of transforming the input to fall between -1 and 1. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="corr__constrain_8hpp_source.html#l00025">25</a> of file <a class="el" href="corr__constrain_8hpp_source.html">corr_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40c9589bc6f6d15d7455de5ad453c8e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::corr_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of transforming the specified scalar to have a valid correlation value between -1 and 1 (inclusive). </p>
<p>The transform used is as specified for <code><a class="el" href="namespacestan_1_1math.html#a6a3c8aa139b956593524b01f21c971a1" title="Return the result of transforming the specified scalar to have a valid correlation value between -1 a...">corr_constrain(T)</a></code>. The log absolute Jacobian determinant is</p>
<p><img class="formulaInl" alt="$\log | \frac{d}{dx} \tanh x | = \log (1 - \tanh^2 x)$" src="form_52.png"/>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="corr__constrain_8hpp_source.html#l00043">43</a> of file <a class="el" href="corr__constrain_8hpp_source.html">corr_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9322e1f1baeb5a192c4972dbec311b4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::corr_free </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unconstrained scalar that when transformed to a valid correlation produces the specified value. </p>
<p>This function inverts the transform defined for <code><a class="el" href="namespacestan_1_1math.html#a6a3c8aa139b956593524b01f21c971a1" title="Return the result of transforming the specified scalar to have a valid correlation value between -1 a...">corr_constrain(T)</a></code>, which is the inverse hyperbolic tangent,</p>
<p><img class="formulaInl" alt="$ f^{-1}(y) = \mbox{atanh}\, y = \frac{1}{2} \log \frac{y + 1}{y - 1}$" src="form_53.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Correlation scalar input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Free scalar that transforms to the specified input. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="corr__free_8hpp_source.html#l00029">29</a> of file <a class="el" href="corr__free_8hpp_source.html">corr_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8321b61db6a84b5d9041777643d53550"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::corr_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename math::index_type&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values. </p>
<p>The input vector must be of length <img class="formulaInl" alt="${k \choose 2} = \frac{k(k-1)}{2}$" src="form_12.png"/>. The values in the input vector represent unconstrained (partial) correlations among the dimensions.</p>
<p>The transform based on partial correlations is as specified in</p>
<ul>
<li>
Lewandowski, Daniel, Dorota Kurowicka, and Harry Joe. 2009. Generating random correlation matrices based on vines and extended onion method. <em>Journal of Multivariate Analysis</em> <b>100</b>:1989–-2001. </li>
</ul>
<p>The free vector entries are first constrained to be valid correlation values using <code><a class="el" href="namespacestan_1_1math.html#a6a3c8aa139b956593524b01f21c971a1" title="Return the result of transforming the specified scalar to have a valid correlation value between -1 a...">corr_constrain(T)</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of unconstrained partial correlations. </td></tr>
    <tr><td class="paramname">k</td><td>Dimensionality of returned correlation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if x is not a valid correlation matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="corr__matrix__constrain_8hpp_source.html#l00040">40</a> of file <a class="el" href="corr__matrix__constrain_8hpp_source.html">corr_matrix_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65f2b4839829eda2b539a09da332a7fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::corr_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename math::index_type&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values. </p>
<p>The input vector must be of length <img class="formulaInl" alt="${k \choose 2} = \frac{k(k-1)}{2}$" src="form_12.png"/>. The values in the input vector represent unconstrained (partial) correlations among the dimensions.</p>
<p>The transform is as specified for <code>corr_matrix_constrain(Matrix, size_t)</code>; the paper it cites also defines the Jacobians for correlation inputs, which are composed with the correlation constrained Jacobians defined in <code>corr_constrain(T, double)</code> for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of unconstrained partial correlations. </td></tr>
    <tr><td class="paramname">k</td><td>Dimensionality of returned correlation matrix. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="corr__matrix__constrain_8hpp_source.html#l00078">78</a> of file <a class="el" href="corr__matrix__constrain_8hpp_source.html">corr_matrix_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34f63590ae0c736b6113d578d0899da1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::corr_matrix_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector of unconstrained partial correlations that define the specified correlation matrix when transformed. </p>
<p>The constraining transform is defined as for <code>corr_matrix_constrain(Matrix, size_t)</code>. The inverse transform in this function is simpler in that it only needs to compute the <img class="formulaInl" alt="$k \choose 2$" src="form_13.png"/> partial correlations and then free those.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The correlation matrix to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of unconstrained values that produce the specified correlation matrix when transformed. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the correlation matrix has no elements or is not a square matrix. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the correlation matrix cannot be factorized by <a class="el" href="namespacestan_1_1math.html#a9d6ef71b2e1a2a216a031d8403458bdd" title="This function is intended to make starting values, given a covariance matrix Sigma. ">factor_cov_matrix()</a> or if the sds returned by <a class="el" href="namespacestan_1_1math.html#a9d6ef71b2e1a2a216a031d8403458bdd" title="This function is intended to make starting values, given a covariance matrix Sigma. ">factor_cov_matrix()</a> on log scale are unconstrained. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="corr__matrix__free_8hpp_source.html#l00038">38</a> of file <a class="el" href="corr__matrix__free_8hpp_source.html">corr_matrix_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6cb3a9041ae0b7855b398c3e11cda48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::cos </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2cos_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2cos_8hpp_source.html">cos.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f3ac00ed58d998daed7f4d97195e967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::cos </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cosine of a radian-scaled variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \cos x = - \sin x$" src="form_298.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{cos}(x) = \begin{cases} \cos(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_299.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{cos}(x)}{\partial x} = \begin{cases} -\sin(x) &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_300.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable for radians of angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cosine of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2cos_8hpp_source.html#l00049">49</a> of file <a class="el" href="rev_2scal_2fun_2cos_8hpp_source.html">cos.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee4fa5213b343a52756c138107ac180b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::cosh </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2cosh_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2cosh_8hpp_source.html">cosh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2a43fcaf01cfef4c73074e77390a205"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::cosh </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic cosine of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \cosh x = \sinh x$" src="form_301.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{cosh}(x) = \begin{cases} \cosh(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_302.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{cosh}(x)}{\partial x} = \begin{cases} \sinh(x) &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_303.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hyperbolic cosine of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2cosh_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2scal_2fun_2cosh_8hpp_source.html">cosh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ad6b90cf2d3d3d25d2cf64a12effede"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cov_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename math::index_type&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2). </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a485d3c2cd12e516bb13a1d48f9a43386" title="The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K spec...">cov_matrix_free()</a></code> for the inverse transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to convert to a covariance matrix. </td></tr>
    <tr><td class="paramname">K</td><td>The number of rows and columns of the resulting covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if (<a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">x.size()</a> != K + (K choose 2)). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cov__matrix__constrain_8hpp_source.html#l00030">30</a> of file <a class="el" href="cov__matrix__constrain_8hpp_source.html">cov_matrix_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a417c6032fe62186f7c8fb5452e4173d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cov_matrix_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename math::index_type&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;::type&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2). </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a485d3c2cd12e516bb13a1d48f9a43386" title="The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K spec...">cov_matrix_free()</a></code> for the inverse transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The vector to convert to a covariance matrix. </td></tr>
    <tr><td class="paramname">K</td><td>The dimensions of the resulting covariance matrix. </td></tr>
    <tr><td class="paramname">lp</td><td>Reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if (<a class="el" href="namespacestan_1_1math.html#aa1f9966aade9c4515d33d3ffa7305462">x.size()</a> != K + (K choose 2)). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cov__matrix__constrain_8hpp_source.html#l00070">70</a> of file <a class="el" href="cov__matrix__constrain_8hpp_source.html">cov_matrix_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e398c69a5845680ca945fa9ec6ec401"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cov_matrix_constrain_lkj </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values. </p>
<p>The input vector must be of length <img class="formulaInl" alt="$k \choose 2 + k$" src="form_14.png"/>. The first <img class="formulaInl" alt="$k \choose 2$" src="form_13.png"/> values in the input represent unconstrained (partial) correlations and the last <img class="formulaInl" alt="$k$" src="form_15.png"/> are unconstrained standard deviations of the dimensions.</p>
<p>The transform scales the correlation matrix transform defined in <code>corr_matrix_constrain(Matrix, size_t)</code> with the constrained deviations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of unconstrained partial correlations and standard deviations. </td></tr>
    <tr><td class="paramname">k</td><td>Dimensionality of returned covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Covariance matrix derived from the unconstrained partial correlations and deviations. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cov__matrix__constrain__lkj_8hpp_source.html#l00034">34</a> of file <a class="el" href="cov__matrix__constrain__lkj_8hpp_source.html">cov_matrix_constrain_lkj.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad179abe18f235b3000ad7a000b3abb29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::cov_matrix_constrain_lkj </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values and increment the specified log probability reference with the log absolute Jacobian determinant. </p>
<p>The transform is defined as for <code>cov_matrix_constrain(Matrix, size_t)</code>.</p>
<p>The log absolute Jacobian determinant is derived by composing the log absolute Jacobian determinant for the underlying correlation matrix as defined in <code>cov_matrix_constrain(Matrix, size_t, T&amp;)</code> with the Jacobian of the transfrom of the correlation matrix into a covariance matrix by scaling by standard deviations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector of unconstrained partial correlations and standard deviations. </td></tr>
    <tr><td class="paramname">k</td><td>Dimensionality of returned covariance matrix. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Covariance matrix derived from the unconstrained partial correlations and deviations. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cov__matrix__constrain__lkj_8hpp_source.html#l00073">73</a> of file <a class="el" href="cov__matrix__constrain__lkj_8hpp_source.html">cov_matrix_constrain_lkj.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a485d3c2cd12e516bb13a1d48f9a43386"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::cov_matrix_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K specified matrix is freed to return a vector of size K + (K choose 2). </p>
<p>This is the inverse of the <code><a class="el" href="namespacestan_1_1math.html#a1ad6b90cf2d3d3d25d2cf64a12effede" title="Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the s...">cov_matrix_constrain()</a></code> function so that for any finite vector <code>x</code> of size K</p>
<ul>
<li>(K choose 2),</li>
</ul>
<p><code>x == cov_matrix_free(cov_matrix_constrain(x, K))</code>.</p>
<p>In order for this round-trip to work (and really for this function to work), the symmetric view of its lower-triangular view must be positive definite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Matrix of dimensions K by K such that he symmetric view of the lower-triangular view is positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of size K plus (K choose 2) in (-inf, inf) that produces </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if <code>y</code> is not square, has zero dimensionality, or has a non-positive diagonal element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cov__matrix__free_8hpp_source.html#l00037">37</a> of file <a class="el" href="cov__matrix__free_8hpp_source.html">cov_matrix_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9021324082d4241367fdd17da025a32d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::cov_matrix_free_lkj </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector of unconstrained partial correlations and deviations that transform to the specified covariance matrix. </p>
<p>The constraining transform is defined as for <code>cov_matrix_constrain(Matrix, size_t)</code>. The inverse first factors out the deviations, then applies the freeing transfrom of <code>corr_matrix_free(Matrix&amp;)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Covariance matrix to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of unconstrained values that transforms to the specified covariance matrix. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the correlation matrix has no elements or is not a square matrix. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the correlation matrix cannot be factorized by <a class="el" href="namespacestan_1_1math.html#a9d6ef71b2e1a2a216a031d8403458bdd" title="This function is intended to make starting values, given a covariance matrix Sigma. ">factor_cov_matrix()</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cov__matrix__free__lkj_8hpp_source.html#l00032">32</a> of file <a class="el" href="cov__matrix__free__lkj_8hpp_source.html">cov_matrix_free_lkj.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd303ef11dc0c73cda2f743a3b67fbf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, C, C&gt; stan::math::crossprod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2crossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2mat_2fun_2crossprod_8hpp_source.html">crossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62cc3a137ff3220bdd0137a52a4b9714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a> stan::math::crossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of pre-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose of M times M </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2crossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="prim_2mat_2fun_2crossprod_8hpp_source.html">crossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8605c80796abfc9c7082d001e8fd4501"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> stan::math::crossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_v &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of pre-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose of M times M </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2crossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="rev_2mat_2fun_2crossprod_8hpp_source.html">crossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7340f6be8ae1e121c6d854005560fef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::cumulative_sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cumulative sum of the specified vector. </p>
<p>The cumulative sum of a vector of values</p>
<div class="fragment"><div class="line"> is the</div>
<div class="line"></div>
<div class="line">@code x[0], x[1] + x[2], ..., x[1] + , ..., + x[x.size()-1] </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cumulative sum of values. </dd></dl>

<p>Definition at line <a class="el" href="cumulative__sum_8hpp_source.html#l00023">23</a> of file <a class="el" href="cumulative__sum_8hpp_source.html">cumulative_sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92fcacf229225bb313cf894cc1406a17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, C&gt; stan::math::cumulative_sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cumulative sum of the specified matrix. </p>
<p>The cumulative sum is of the same type as the input and has values defined by</p>
<div class="fragment"><div class="line">x(0), x(1) + x(2), ..., x(1) + , ..., + x(x.size()-1) </div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cumulative sum of values. </dd></dl>

<p>Definition at line <a class="el" href="cumulative__sum_8hpp_source.html#l00049">49</a> of file <a class="el" href="cumulative__sum_8hpp_source.html">cumulative_sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0597dca74b96a4287c6f848489288d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::derivative </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>dfx_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the derivative of the specified univariate function at the specified argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Argument type </td></tr>
    <tr><td class="paramname">F</td><td>Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Value of function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dfx_dx</td><td>Value of derivative </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="derivative_8hpp_source.html#l00028">28</a> of file <a class="el" href="derivative_8hpp_source.html">derivative.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab65e9ab0e6f725c7e11068b0be2af84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2determinant_8hpp_source.html#l00018">18</a> of file <a class="el" href="prim_2mat_2fun_2determinant_8hpp_source.html">determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63ab2582fc9a5a31d3d4f38a6420174e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2determinant_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2mat_2fun_2determinant_8hpp_source.html">determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25cf09ca9596a572e5040deaecfba87f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2determinant_8hpp_source.html#l00066">66</a> of file <a class="el" href="rev_2mat_2fun_2determinant_8hpp_source.html">determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8174ad2b40453c1bfcbdf59bf76e030d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::diag_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a square diagonal matrix with the specified vector of coefficients as the diagonal values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagonal matrix with vector as diagonal values. </dd></dl>

<p>Definition at line <a class="el" href="diag__matrix_8hpp_source.html#l00018">18</a> of file <a class="el" href="diag__matrix_8hpp_source.html">diag_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada475ab6293a9b7e5d3e6c1f92315008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C1&gt; stan::math::diag_post_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="diag__post__multiply_8hpp_source.html#l00014">14</a> of file <a class="el" href="diag__post__multiply_8hpp_source.html">diag_post_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97acdd27ef5fca2cd111010f6fccf6b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R2, C2&gt; stan::math::diag_pre_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="diag__pre__multiply_8hpp_source.html#l00014">14</a> of file <a class="el" href="diag__pre__multiply_8hpp_source.html">diag_pre_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e96160f66cf84ab9a4bae027645e5a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::diagonal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column vector of the diagonal elements of the specified matrix. </p>
<p>The matrix is not required to be square. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diagonal of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="diagonal_8hpp_source.html#l00018">18</a> of file <a class="el" href="diagonal_8hpp_source.html">diagonal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69702aaa101bf602072fa7bf5fccb48a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::digamma </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2digamma_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2digamma_8hpp_source.html">digamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a366ba0d22b63d45054e4a022e4ffa994"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::digamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2digamma_8hpp_source.html#l00024">24</a> of file <a class="el" href="rev_2scal_2fun_2digamma_8hpp_source.html">digamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5eb54ce92709046c6d168e851d2481c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::digamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{digamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \Psi(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_54.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{digamma}(x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \frac{\partial\, \Psi(x)}{\partial x} &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_55.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi(x)=\frac{\Gamma'(x)}{\Gamma(x)} \]" src="form_56.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \Psi(x)}{\partial x} = \frac{\Gamma''(x)\Gamma(x)-(\Gamma'(x))^2}{\Gamma^2(x)} \]" src="form_57.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2digamma_8hpp_source.html#l00039">39</a> of file <a class="el" href="prim_2scal_2fun_2digamma_8hpp_source.html">digamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b9073e39033e56eb31344091f0170fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00013">13</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af95a2dcde478c06e3543511821618902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00018">18</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a467589eef4220a87d457c8a268a1fd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00025">25</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33777ee768c7032331ca8b92e5323384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::dims </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dims_8hpp_source.html#l00034">34</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a301c4fce1eeb151070f72a81c33ccde4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob , typename T_prior_sample_size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob, T_prior_sample_size&gt;::type stan::math::dirichlet_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prior_sample_size, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha. </p>
<p>Each element of alpha must be greater than 0. Each element of theta must be greater than or 0. Theta sums to 1.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \theta &amp;\sim&amp; \mbox{\sf{Dirichlet}} (\alpha_1, \ldots, \alpha_k) \\ \log (p (\theta \, |\, \alpha_1, \ldots, \alpha_k) ) &amp;=&amp; \log \left( \frac{\Gamma(\alpha_1 + \cdots + \alpha_k)}{\Gamma(\alpha_1) \cdots \Gamma(\alpha_k)} \theta_1^{\alpha_1 - 1} \cdots \theta_k^{\alpha_k - 1} \right) \\ &amp;=&amp; \log (\Gamma(\alpha_1 + \cdots + \alpha_k)) - \log(\Gamma(\alpha_1)) - \cdots - \log(\Gamma(\alpha_k)) + (\alpha_1 - 1) \log (\theta_1) + \cdots + (\alpha_k - 1) \log (\theta_k) \end{eqnarray*}" src="form_20.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>A scalar vector. </td></tr>
    <tr><td class="paramname">alpha</td><td>Prior sample sizes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Dirichlet density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if any element of alpha is less than or equal to 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if any element of theta is less than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the sum of theta is not 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_prob</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_prior_sample_size</td><td>Type of prior sample sizes. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dirichlet__log_8hpp_source.html#l00046">46</a> of file <a class="el" href="dirichlet__log_8hpp_source.html">dirichlet_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a610a90b8b664189d397c8549c2aa0214"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob , typename T_prior_sample_size &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob, T_prior_sample_size&gt;::type stan::math::dirichlet_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prior_sample_size, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dirichlet__log_8hpp_source.html#l00079">79</a> of file <a class="el" href="dirichlet__log_8hpp_source.html">dirichlet_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb288324f889b7da57f2960570f459ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd stan::math::dirichlet_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a draw from a Dirichlet distribution with specified parameters and pseudo-random number generator. </p>
<p>For prior counts greater than zero, the usual algorithm that draws gamma variates and normalizes is used.</p>
<p>For prior counts less than zero (i.e., parameters with value less than one), a log-scale version of the following algorithm is used to deal with underflow:</p>
<blockquote class="doxtable">
<p>G. Marsaglia and W. Tsang. A simple method for generating gamma variables. ACM Transactions on Mathematical Software. 26(3):363&ndash;372, 2000. </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RNG</td><td>Type of pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Prior count (plus 1) parameter for Dirichlet. </td></tr>
    <tr><td class="paramname">rng</td><td>Pseudo-random number generator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dirichlet__rng_8hpp_source.html#l00046">46</a> of file <a class="el" href="dirichlet__rng_8hpp_source.html">dirichlet_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae86020a972c6efc6b3407c3cfc30f4a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dist_8hpp_source.html#l00011">11</a> of file <a class="el" href="dist_8hpp_source.html">dist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc0a62287bdf0c0420386fccc0a13ca9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="distance_8hpp_source.html#l00025">25</a> of file <a class="el" href="distance_8hpp_source.html">distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf04cebee51d38a543e0ec689ae1399c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2scal_2fun_2divide_8hpp_source.html#l00010">10</a> of file <a class="el" href="prim_2scal_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0bbb4ba8df580321dbf92d0c563cc523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2&gt;::type stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66343caaf5970081f4eedc8b178bc4d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the division of the first scalar by the second scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Specified vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Specified scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector divided by the scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2divide_8hpp_source.html#l00022">22</a> of file <a class="el" href="rev_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1f35909d12ac43b74d180a49d68b674"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html#l00023">23</a> of file <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a082ee76b34a2ea656d2c8ab9186c1a2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified matrix divided by specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix divided by scalar. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2divide_8hpp_source.html#l00023">23</a> of file <a class="el" href="prim_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0aad4b9e552bacdbcac3b0bbd783d31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2divide_8hpp_source.html#l00027">27</a> of file <a class="el" href="rev_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfbe71733db295fc195305aee8437732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html#l00034">34</a> of file <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a818fcac13304ea5c8679b3fc38e51ac1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C&gt; stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the division of the specified column vector by the specified scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Specified vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Specified scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector divided by the scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2divide_8hpp_source.html#l00039">39</a> of file <a class="el" href="rev_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab549dab5e1bff51b30678fbd8d1f8a41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html#l00046">46</a> of file <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3832e36ec9ea72ce740753adb3b0d132"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_shape stan::math::do_lkj_constant </td>
          <td>(</td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__corr__log_8hpp_source.html#l00055">55</a> of file <a class="el" href="lkj__corr__log_8hpp_source.html">lkj_corr_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeebafad688145fc64353e4f455d014bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;&lt;msg2&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error_8hpp_source.html#l00032">32</a> of file <a class="el" href="domain__error_8hpp_source.html">domain_error.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a108d489a4a749c8e429b519d9e26c157"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error_8hpp_source.html#l00067">67</a> of file <a class="el" href="domain__error_8hpp_source.html">domain_error.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c23bfe9ebcb5747ed175a59b2182072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error__vec_8hpp_source.html#l00038">38</a> of file <a class="el" href="domain__error__vec_8hpp_source.html">domain_error_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f55be80da8ff729d5850c653d2b28d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::domain_error_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain error with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing domain errors. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="domain__error__vec_8hpp_source.html#l00073">73</a> of file <a class="el" href="domain__error__vec_8hpp_source.html">domain_error_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd3b73319bd8df9dad1d3902997d8e89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="dot_8hpp_source.html#l00011">11</a> of file <a class="el" href="dot_8hpp_source.html">dot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a495321127b7e0ebdd4d52654d226e16b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00020">20</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8d73851895fb151fdf79e55bf33e98e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="prim_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58da447df259e9e092e8fd910b338e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified arrays of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First array. </td></tr>
    <tr><td class="paramname">v2</td><td>Second array. </td></tr>
    <tr><td class="paramname">length</td><td>Length of both arrays. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2dot__product_8hpp_source.html#l00037">37</a> of file <a class="el" href="prim_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af55524d5b711066af73968df35ddeb2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00037">37</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7cd93708bf432b3bd3d284958972ede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified arrays of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First array. </td></tr>
    <tr><td class="paramname">v2</td><td>Second array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the vectors are not the same size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2dot__product_8hpp_source.html#l00050">50</a> of file <a class="el" href="prim_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74f6624e3a637cb98d3ae10a42a44135"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00054">54</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a386f813bee88dc6d771ba0f0c90f82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00071">71</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af58d380f8784b977f1372ca00caa779e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00086">86</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7893eb903c5877be710060cc1f733ece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00101">101</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3dfb7deab1e93815803096f298e722a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00116">116</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade870e95240c98560c7146fc1569811e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00130">130</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a092173dbe404bf00d732a86b18ed7cc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00144">144</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d2848b5eca56fff0922803874f97b58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00158">158</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6af240b31f8d6bc2c9acce4b8fc3ebd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00170">170</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a590dde9498d871fff74858d1f7ef2667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html#l00182">182</a> of file <a class="el" href="fwd_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad70b6ae039b48ca04b071daf5e265363"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::type stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>First column vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Second column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if length of v1 is not equal to length of v2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2dot__product_8hpp_source.html#l00212">212</a> of file <a class="el" href="rev_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc208771c9df3e3e96901fb27a05dde0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::type stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const T1 *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>First array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Second array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of both arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the arrays. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2dot__product_8hpp_source.html#l00233">233</a> of file <a class="el" href="rev_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07462a84486826d0b7fe3cfebb51d386"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::type stan::math::dot_product </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sizes of v1 and v2 do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2dot__product_8hpp_source.html#l00249">249</a> of file <a class="el" href="rev_2mat_2fun_2dot__product_8hpp_source.html">dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a6a4ef7c701db7984297d153580c8d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2arr_2fun_2dot__self_8hpp_source.html#l00011">11</a> of file <a class="el" href="prim_2arr_2fun_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1edae52ce70f3f0a9f7eb15f3416007c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2dot__self_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2mat_2fun_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac81ab85d390fcb594884773a85fac657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vector with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>number of rows or <code>Eigen::Dynamic</code> for dynamic </td></tr>
    <tr><td class="paramname">C</td><td>number of rows or <code>Eigen::Dyanmic</code> for dynamic </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If v is not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2dot__self_8hpp_source.html#l00018">18</a> of file <a class="el" href="prim_2mat_2fun_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add9f13b58d14d7b7b8cc43ab30a434d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of a vector with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vector with itself. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>number of rows or <code>Eigen::Dynamic</code> for dynamic; one of R or C must be 1 </td></tr>
    <tr><td class="paramname">C</td><td>number of rows or <code>Eigen::Dyanmic</code> for dynamic; one of R or C must be 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2dot__self_8hpp_source.html#l00080">80</a> of file <a class="el" href="rev_2mat_2fun_2dot__self_8hpp_source.html">dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab670b33f7d9f8cd15406cce67ffbe2c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::double_exponential_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="double__exponential__ccdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="double__exponential__ccdf__log_8hpp_source.html">double_exponential_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a658493a49a4e83ac55393a5d43c47ba7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::double_exponential_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the double exponential cumulative density function. </p>
<p><img class="formulaInl" alt="$ f(y|\mu, \sigma) = \begin{cases} \ \frac{1}{2} \exp\left(\frac{y-\mu}{\sigma}\right), \mbox{if } y < \mu \\ 1 - \frac{1}{2} \exp\left(-\frac{y-\mu}{\sigma}\right), \mbox{if } y \ge \mu \ \end{cases}$" src="form_192.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variate. </td></tr>
    <tr><td class="paramname">mu</td><td>The location parameter. </td></tr>
    <tr><td class="paramname">sigma</td><td>The scale parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cumulative density function. </dd></dl>

<p>Definition at line <a class="el" href="double__exponential__cdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="double__exponential__cdf_8hpp_source.html">double_exponential_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa71f7d99df6f1817ad1badc771e30a5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::double_exponential_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="double__exponential__cdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="double__exponential__cdf__log_8hpp_source.html">double_exponential_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a465bb5ed0b5bb209aa43f2ac71fc3597"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::double_exponential_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="double__exponential__log_8hpp_source.html#l00029">29</a> of file <a class="el" href="double__exponential__log_8hpp_source.html">double_exponential_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac96b2758687c3d1eab564e67d18f8922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::double_exponential_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="double__exponential__log_8hpp_source.html#l00128">128</a> of file <a class="el" href="double__exponential__log_8hpp_source.html">double_exponential_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6ebff3092eb40851fa1f63b7b7196f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::double_exponential_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="double__exponential__rng_8hpp_source.html#l00024">24</a> of file <a class="el" href="double__exponential__rng_8hpp_source.html">double_exponential_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b650a0131d41167ef4837ecc7d02be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::e </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base of the natural logarithm. </p>
<dl class="section return"><dt>Returns</dt><dd>Base of natural logarithm. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00095">95</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e454ec91241f2f6e70aa05e7b7698ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::eigenvalues_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the eigenvalues of the specified symmetric matrix in descending order of magnitude. </p>
<p>This function is more efficient than the general eigenvalues function for symmetric matrices. </p>
<p>See <code>eigen_decompose()</code> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of matrix. </dd></dl>

<p>Definition at line <a class="el" href="eigenvalues__sym_8hpp_source.html#l00022">22</a> of file <a class="el" href="eigenvalues__sym_8hpp_source.html">eigenvalues_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fd77067fef0a78dd5d8f9527969631e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::eigenvectors_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="eigenvectors__sym_8hpp_source.html#l00013">13</a> of file <a class="el" href="eigenvectors__sym_8hpp_source.html">eigenvectors_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75c3cc187f569c795118c72bcc1e5c58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::elt_divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise division of the specified matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of both matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise division of matrices. </dd></dl>

<p>Definition at line <a class="el" href="elt__divide_8hpp_source.html#l00024">24</a> of file <a class="el" href="elt__divide_8hpp_source.html">elt_divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc5d04e1b1dde0ea7455380ec27d4528"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::elt_divide </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise division of the specified matrix by the specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in the matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the scalar. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of the matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>matrix </td></tr>
    <tr><td class="paramname">s</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise division of a scalar by matrix. </dd></dl>

<p>Definition at line <a class="el" href="elt__divide_8hpp_source.html#l00050">50</a> of file <a class="el" href="elt__divide_8hpp_source.html">elt_divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4d728ca306346624b833cee2777c23d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::elt_divide </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise division of the specified scalar by the specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the scalar. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in the matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of the matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>scalar </td></tr>
    <tr><td class="paramname">m</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise division of a scalar by matrix. </dd></dl>

<p>Definition at line <a class="el" href="elt__divide_8hpp_source.html#l00068">68</a> of file <a class="el" href="elt__divide_8hpp_source.html">elt_divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2edc3d65b32928692984bd66a1b3bb56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::elt_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the elementwise multiplication of the specified matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of scalars in first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of scalars in second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of both matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of both matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Elementwise product of matrices. </dd></dl>

<p>Definition at line <a class="el" href="elt__multiply_8hpp_source.html#l00025">25</a> of file <a class="el" href="elt__multiply_8hpp_source.html">elt_multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a430f171295b91277dc60dfa2177c7c0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool stan::math::empty_nested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if there is no nested autodiff being executed. </p>

<p>Definition at line <a class="el" href="empty__nested_8hpp_source.html#l00014">14</a> of file <a class="el" href="empty__nested_8hpp_source.html">empty_nested.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa283efca22c0544054a6534443e6e762"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::erf </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2erf_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2erf_8hpp_source.html">erf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a759d52872682fdf0d6a7a6d75b4f1d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::erf </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The error function for variables (C99). </p>
<p>For non-variable function, see <a class="el" href="namespacestan_1_1math.html#aa283efca22c0544054a6534443e6e762">erf()</a> from cmath.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{erf}(x) = \frac{2}{\sqrt{\pi}} \exp(-x^2)$" src="form_304.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{erf}(x) = \begin{cases} \operatorname{erf}(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_305.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{erf}(x)}{\partial x} = \begin{cases} \frac{\partial\, \operatorname{erf}(x)}{\partial x} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_306.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \operatorname{erf}(x)=\frac{2}{\sqrt{\pi}}\int_0^x e^{-t^2}dt \]" src="form_307.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \operatorname{erf}(x)}{\partial x} = \frac{2}{\sqrt{\pi}} e^{-x^2} \]" src="form_308.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error function applied to the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2erf_8hpp_source.html#l00063">63</a> of file <a class="el" href="rev_2scal_2fun_2erf_8hpp_source.html">erf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4c763e4f09069eed96a4e96e33ea8ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::erfc </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2erfc_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2erfc_8hpp_source.html">erfc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a8543e9c729e794bcbdff2ed223eb45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::erfc </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The complementary error function for variables (C99). </p>
<p>For non-variable function, see <a class="el" href="namespacestan_1_1math.html#ab4c763e4f09069eed96a4e96e33ea8ea">erfc()</a> from &lt;cmath&gt;.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{erfc}(x) = - \frac{2}{\sqrt{\pi}} \exp(-x^2)$" src="form_309.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{erfc}(x) = \begin{cases} \operatorname{erfc}(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_310.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{erfc}(x)}{\partial x} = \begin{cases} \frac{\partial\, \operatorname{erfc}(x)}{\partial x} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_311.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \operatorname{erfc}(x)=\frac{2}{\sqrt{\pi}}\int_x^\infty e^{-t^2}dt \]" src="form_312.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \operatorname{erfc}(x)}{\partial x} = -\frac{2}{\sqrt{\pi}} e^{-x^2} \]" src="form_313.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complementary error function applied to the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2erfc_8hpp_source.html#l00063">63</a> of file <a class="el" href="rev_2scal_2fun_2erfc_8hpp_source.html">erfc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11f31444e8584e4debf0d6b706d66880"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::exp </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2exp_8hpp_source.html#l00010">10</a> of file <a class="el" href="fwd_2scal_2fun_2exp_8hpp_source.html">exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ad4663394747a548b42f8cbe9def1f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Rows, Cols&gt; stan::math::exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element-wise exponentiation of the matrix or vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ret(i, j) = exp(m(i, j)) </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2exp_8hpp_source.html#l00019">19</a> of file <a class="el" href="prim_2mat_2fun_2exp_8hpp_source.html">exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3bd08f492d4ae400850ecb98b9b6cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, Rows, Cols&gt; stan::math::exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2exp_8hpp_source.html#l00028">28</a> of file <a class="el" href="prim_2mat_2fun_2exp_8hpp_source.html">exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae43b048d4a5f53f94501773c93689a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::exp </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the exponentiation of the specified variable (cmath). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{exp}(x) = \begin{cases} e^x &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_314.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{exp}(x)}{\partial x} = \begin{cases} e^x &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_315.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable to exponentiate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exponentiated variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2exp_8hpp_source.html#l00044">44</a> of file <a class="el" href="rev_2scal_2fun_2exp_8hpp_source.html">exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c3a577694c8f584e56160580fe0821b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::exp2 </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2exp2_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2exp2_8hpp_source.html">exp2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef734d7c3b8ebd689012295bf826e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::exp2 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the exponent base 2 of the specified argument (C99). </p>
<p>The exponent base 2 function is defined by</p>
<p><code>exp2(y) = pow(2.0, y)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Exponent base 2 of value. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2exp2_8hpp_source.html#l00023">23</a> of file <a class="el" href="prim_2scal_2fun_2exp2_8hpp_source.html">exp2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fd4650bbf246a10ac798c71da8b99d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::exp2 </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponentiation base 2 function for variables (C99). </p>
<p>For non-variable function, see <a class="el" href="namespacestan_1_1math.html#a9fd4650bbf246a10ac798c71da8b99d5" title="Exponentiation base 2 function for variables (C99). ">boost::math::exp2()</a>.</p>
<p>The derivatie is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} 2^x = (\log 2) 2^x$" src="form_316.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{exp2}(x) = \begin{cases} 2^x &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_317.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{exp2}(x)}{\partial x} = \begin{cases} 2^x\ln2 &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_318.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Two to the power of the specified variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2exp2_8hpp_source.html#l00052">52</a> of file <a class="el" href="rev_2scal_2fun_2exp2_8hpp_source.html">exp2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a497ff815eeadaffe3204d33359c4be82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_inv_scale&gt;::type stan::math::exp_mod_normal_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exp__mod__normal__ccdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="exp__mod__normal__ccdf__log_8hpp_source.html">exp_mod_normal_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b29301645f48dedc57b97409062250c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_inv_scale&gt;::type stan::math::exp_mod_normal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exp__mod__normal__cdf_8hpp_source.html#l00024">24</a> of file <a class="el" href="exp__mod__normal__cdf_8hpp_source.html">exp_mod_normal_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0e32ac964461952d77df48cd30c6f1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_inv_scale&gt;::type stan::math::exp_mod_normal_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exp__mod__normal__cdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="exp__mod__normal__cdf__log_8hpp_source.html">exp_mod_normal_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af27bb81f9220a9ba9082903fd55dff66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_inv_scale&gt;::type stan::math::exp_mod_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exp__mod__normal__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="exp__mod__normal__log_8hpp_source.html">exp_mod_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50a3cd94db2760437551ea466247cf8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_inv_scale&gt;::type stan::math::exp_mod_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exp__mod__normal__log_8hpp_source.html#l00139">139</a> of file <a class="el" href="exp__mod__normal__log_8hpp_source.html">exp_mod_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40d3c6fbf610e2c0e997a039f2ed98e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::exp_mod_normal_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exp__mod__normal__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="exp__mod__normal__rng_8hpp_source.html">exp_mod_normal_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a76b658b94fcf8943f4fb41c586ec94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::expm1 </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2expm1_8hpp_source.html#l00012">12</a> of file <a class="el" href="fwd_2scal_2fun_2expm1_8hpp_source.html">expm1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c632ff37556a4989fb351042da3a05a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::expm1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The exponentiation of the specified variable minus 1 (C99). </p>
<p>The derivative is given by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \exp(a) - 1 = \exp(a)$" src="form_319.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{expm1}(x) = \begin{cases} e^x-1 &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_320.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{expm1}(x)}{\partial x} = \begin{cases} e^x &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_321.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Two to the power of the specified variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2expm1_8hpp_source.html#l00052">52</a> of file <a class="el" href="rev_2scal_2fun_2expm1_8hpp_source.html">expm1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42c92f31b24600c6ce05b4f21f54fb00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_inv_scale&gt;::type stan::math::exponential_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exponential__ccdf__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="exponential__ccdf__log_8hpp_source.html">exponential_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac753dcf58b69f0bbf7b001bfe19a3e44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_inv_scale&gt;::type stan::math::exponential_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the exponential cumulative distribution function for the given y and beta. </p>
<p>Inverse scale parameter must be greater than 0. y must be greater than or equal to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_inv_scale</td><td>Type of inverse scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="exponential__cdf_8hpp_source.html#l00040">40</a> of file <a class="el" href="exponential__cdf_8hpp_source.html">exponential_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fbf986074ea063853c8d244c3c17e0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_inv_scale&gt;::type stan::math::exponential_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exponential__cdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="exponential__cdf__log_8hpp_source.html">exponential_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addcdf998d9f336fd9e4118acc6c7a129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_inv_scale&gt;::type stan::math::exponential_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of an exponential density for y with the specified inverse scale parameter. </p>
<p>Inverse scale parameter must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Expon}}(\beta) \\ \log (p (y \, |\, \beta) ) &amp;=&amp; \log \left( \beta \exp^{-\beta y} \right) \\ &amp;=&amp; \log (\beta) - \beta y \\ &amp; &amp; \mathrm{where} \; y > 0 \end{eqnarray*}" src="form_193.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_inv_scale</td><td>Type of inverse scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="exponential__log_8hpp_source.html#l00054">54</a> of file <a class="el" href="exponential__log_8hpp_source.html">exponential_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3653c4e36237f4d7403af9f64abbcd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_inv_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_inv_scale&gt;::type stan::math::exponential_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exponential__log_8hpp_source.html#l00111">111</a> of file <a class="el" href="exponential__log_8hpp_source.html">exponential_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cfcce609912c9a6e1b2fad1e5055a1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::exponential_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="exponential__rng_8hpp_source.html#l00027">27</a> of file <a class="el" href="exponential__rng_8hpp_source.html">exponential_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada2421cf831c518a6260f60d19eb5c32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::F32 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_f32_8hpp_source.html#l00011">11</a> of file <a class="el" href="_f32_8hpp_source.html">F32.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c79c9be5c64873b74f3c6924fef6911"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fabs </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fabs_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2fabs_8hpp_source.html">fabs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea8428395b18c89bc01669915993b8e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fabs </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the absolute value of the variable (cmath). </p>
<p>Choosing an arbitrary value at the non-differentiable point 0,</p>
<p><img class="formulaInl" alt="$\frac{d}{dx}|x| = \mbox{sgn}(x)$" src="form_322.png"/>.</p>
<p>where <img class="formulaInl" alt="$\mbox{sgn}(x)$" src="form_323.png"/> is the signum function, taking values -1 if <img class="formulaInl" alt="$x < 0$" src="form_324.png"/>, 0 if <img class="formulaInl" alt="$x == 0$" src="form_325.png"/>, and 1 if <img class="formulaInl" alt="$x == 1$" src="form_326.png"/>.</p>
<p>The function <code><a class="el" href="namespacestan_1_1math.html#ae560b842e3ed6e5939dc2177bf158265">abs()</a></code> provides the same behavior, with <code><a class="el" href="namespacestan_1_1math.html#ae560b842e3ed6e5939dc2177bf158265">abs()</a></code> defined in stdlib.h and <code><a class="el" href="namespacestan_1_1math.html#a6c79c9be5c64873b74f3c6924fef6911">fabs()</a></code> defined in <code>cmath</code>. The derivative is 0 if the input is 0.</p>
<p>Returns std::numeric_limits&lt;double&gt;::quiet_NaN() for NaN inputs.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{fabs}(x) = \begin{cases} |x| &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_327.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fabs}(x)}{\partial x} = \begin{cases} -1 &amp; \mbox{if } x < 0 \\ 0 &amp; \mbox{if } x = 0 \\ 1 &amp; \mbox{if } x > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_328.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Absolute value of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fabs_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2scal_2fun_2fabs_8hpp_source.html">fabs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d6ef71b2e1a2a216a031d8403458bdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::factor_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is intended to make starting values, given a covariance matrix Sigma. </p>
<p>The transformations are hard coded as log for standard deviations and Fisher transformations (<a class="el" href="namespacestan_1_1math.html#a9e31606b2cbc69573ec0d7693c8b2a2c">atanh()</a>) of CPCs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Sigma</td><td>covariance matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CPCs</td><td>fill this unbounded (does not resize) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sds</td><td>fill this unbounded (does not resize) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if any of the diagonals of Sigma are 0 </dd></dl>

<p>Definition at line <a class="el" href="factor__cov__matrix_8hpp_source.html#l00027">27</a> of file <a class="el" href="factor__cov__matrix_8hpp_source.html">factor_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6d09763679360f53f07ae20e8efc262"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::factor_U </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is intended to make starting values, given a unit upper-triangular matrix U such that U'DU is a correlation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Sigma matrix </td></tr>
    <tr><td class="paramname">CPCs</td><td>fill this unbounded </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="factor___u_8hpp_source.html#l00029">29</a> of file <a class="el" href="factor___u_8hpp_source.html">factor_U.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae3974a012285e3d020d46cc454812ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2falling__factorial_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a203c9c81e4a4b48e47e052422fcf679d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2falling__factorial_8hpp_source.html#l00026">26</a> of file <a class="el" href="fwd_2scal_2fun_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a3c08d051a8e4bc83c6ad9132af4099"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2falling__factorial_8hpp_source.html#l00037">37</a> of file <a class="el" href="fwd_2scal_2fun_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96fdf588b0a37df21c5b67ed7370b003"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2falling__factorial_8hpp_source.html#l00052">52</a> of file <a class="el" href="rev_2scal_2fun_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad65933117ab43cb486fb65023d8e5f3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{falling\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_58.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{falling\_factorial}(x, n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, (x)_n}{\partial x} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_59.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{falling\_factorial}(x, n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, (x)_n}{\partial n} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_60.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ (x)_n=\frac{\Gamma(x+1)}{\Gamma(x-n+1)} \]" src="form_61.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, (x)_n}{\partial x} = (x)_n\Psi(x+1) \]" src="form_62.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, (x)_n}{\partial n} = -(x)_n\Psi(n+1) \]" src="form_63.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2falling__factorial_8hpp_source.html#l00054">54</a> of file <a class="el" href="prim_2scal_2fun_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78f5570887f609618c63c727afda46ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2falling__factorial_8hpp_source.html#l00057">57</a> of file <a class="el" href="rev_2scal_2fun_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add6fa4b14f17cc4df149df09224a18b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2falling__factorial_8hpp_source.html#l00062">62</a> of file <a class="el" href="rev_2scal_2fun_2falling__factorial_8hpp_source.html">falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a535e91c206d8cfd9e61042c25108f23a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fdim_8hpp_source.html#l00011">11</a> of file <a class="el" href="fwd_2scal_2fun_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9af93d6decc446332dedd367db295bcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fdim_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2scal_2fun_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d2db622c0f83134b7f3ebd1eec3c1d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The positive difference function (C99). </p>
<p>The function is defined by</p>
<p><code>fdim(a, b) = (a &gt; b) ? (a - b) : 0.0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns min(a - b, 0.0). </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2fdim_8hpp_source.html#l00026">26</a> of file <a class="el" href="prim_2scal_2fun_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9448d07d7e87cd638f65ce95350c0e8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fdim_8hpp_source.html#l00032">32</a> of file <a class="el" href="fwd_2scal_2fun_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f899b184aa38d3a5f814518611a0666"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the positive difference between the first variable's the value and the second's (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#a535e91c206d8cfd9e61042c25108f23a">stan::math::fdim()</a> for the double-based version.</p>
<p>The partial derivative with respect to the first argument is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} \mbox{fdim}(x, y) = 0.0$" src="form_329.png"/> if <img class="formulaInl" alt="$x < y$" src="form_330.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} \mbox{fdim}(x, y) = 1.0$" src="form_331.png"/> if <img class="formulaInl" alt="$x \geq y$" src="form_332.png"/>.</p>
<p>With respect to the second argument, the partial is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} \mbox{fdim}(x, y) = 0.0$" src="form_333.png"/> if <img class="formulaInl" alt="$x < y$" src="form_330.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} \mbox{fdim}(x, y) = -\lfloor\frac{x}{y}\rfloor$" src="form_334.png"/> if <img class="formulaInl" alt="$x \geq y$" src="form_332.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{fdim}(x, y) = \begin{cases} 0 &amp; \mbox{if } x < y\\ x-y &amp; \mbox{if } x \geq y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_335.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fdim}(x, y)}{\partial x} = \begin{cases} 0 &amp; \mbox{if } x < y \\ 1 &amp; \mbox{if } x \geq y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_336.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fdim}(x, y)}{\partial y} = \begin{cases} 0 &amp; \mbox{if } x < y \\ -\lfloor\frac{x}{y}\rfloor &amp; \mbox{if } x \geq y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_337.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive difference between the first and second variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fdim_8hpp_source.html#l00110">110</a> of file <a class="el" href="rev_2scal_2fun_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6fe00d070fb14766341060f7f0fe2627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the positive difference between the first value and the value of the second variable (C99). </p>
<p>See fdim(var, var) for definitions of values and derivatives.</p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{d y} \mbox{fdim}(c, y) = 0.0$" src="form_338.png"/> if <img class="formulaInl" alt="$c < y$" src="form_339.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{d}{d y} \mbox{fdim}(c, y) = -\lfloor\frac{c}{y}\rfloor$" src="form_340.png"/> if <img class="formulaInl" alt="$c \geq y$" src="form_341.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive difference between the first and second arguments. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fdim_8hpp_source.html#l00135">135</a> of file <a class="el" href="rev_2scal_2fun_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a014a74412301cf66626baa1fe1491d94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fdim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the positive difference between the first variable's value and the second value (C99). </p>
<p>See fdim(var, var) for definitions of values and derivatives.</p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{d x} \mbox{fdim}(x, c) = 0.0$" src="form_342.png"/> if <img class="formulaInl" alt="$x < c$" src="form_343.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{d}{d x} \mbox{fdim}(x, c) = 1.0$" src="form_344.png"/> if <img class="formulaInl" alt="$x \geq yc$" src="form_345.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive difference between the first and second arguments. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fdim_8hpp_source.html#l00158">158</a> of file <a class="el" href="rev_2scal_2fun_2fdim_8hpp_source.html">fdim.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d362e53d3d40b61e68fdd08dc5eb38b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>This base case simply assigns the value to the container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of reference container. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00022">22</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73e791042ed648602eed1754679feff4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>The specified matrix is filled by element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar for matrix container. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00039">39</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7f5d81c4d45f2407096def8810ffe00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::fill </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the specified container with the specified value. </p>
<p>Each container in the specified standard vector is filled recursively by calling <code>fill</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of container in vector. </td></tr>
    <tr><td class="paramname">S</td><td>Type of value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container. </td></tr>
    <tr><td class="paramname">y</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00055">55</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a138f3242eba971c17756586ace2c15d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::finite_diff_grad_hessian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double,-1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double,-1,-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>hess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix&lt; double,-1,-1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_hess_fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-04</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value and the gradient of the hessian of the specified function at the specified argument using second-order autodiff and first-order finite difference. </p>
<p>The functor must implement</p>
<p><code> double operator()(const Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;&amp;) </code></p>
<p>Reference:</p>
<p>De Levie: An improved numerical approximation for the first derivative, page 3</p>
<p>4 calls to the function, f.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument to function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hess</td><td>Hessian matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad_hess_fx</td><td>gradient of Hessian of function at argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>perturbation size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="finite__diff__grad__hessian_8hpp_source.html#l00043">43</a> of file <a class="el" href="finite__diff__grad__hessian_8hpp_source.html">finite_diff_grad_hessian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab34b9d54bbdc2b13f358a73a3dface45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::finite_diff_gradient </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double,-1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double,-1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-03</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value and the gradient of the specified function at the specified argument using finite difference. </p>
<p>The functor must implement</p>
<p><code> double operator()(const Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;&amp;) </code></p>
<p>Error should be on order of epsilon ^ 6. The reference for this algorithm is:</p>
<p>De Levie: An improved numerical approximation for the first derivative, page 3</p>
<p>This function involves 6 calls to f.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument to function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad_fx</td><td>Gradient of function at argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>perturbation size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="finite__diff__gradient_8hpp_source.html#l00039">39</a> of file <a class="el" href="finite__diff__gradient_8hpp_source.html">finite_diff_gradient.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cfae14a02b57bee53b454f64b58c0b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::finite_diff_hess_helper </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-03</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="finite__diff__hessian_8hpp_source.html#l00013">13</a> of file <a class="el" href="finite__diff__hessian_8hpp_source.html">finite_diff_hessian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b6ed64f691a457cb6691d7b478b4a1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::finite_diff_hessian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double,-1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double,-1, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double,-1,-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>hess_fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-03</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value and the Hessian of the specified function at the specified argument using second-order finite difference. </p>
<p>The functor must implement</p>
<p><code> double operator()(const Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;&amp;) </code></p>
<p>Error should be on order of epsilon ^ 4, with 4 calls to the function f.</p>
<p>Reference: Eberly: Derivative Approximation by Finite Differences Page 6</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument to function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad_fx</td><td>Gradient of function at argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hess_fx</td><td>Hessian of function at argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>perturbation size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="finite__diff__hessian_8hpp_source.html#l00067">67</a> of file <a class="el" href="finite__diff__hessian_8hpp_source.html">finite_diff_hessian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16e5a2666b377e37fe807765ba5f6aaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::floor </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2floor_8hpp_source.html#l00011">11</a> of file <a class="el" href="fwd_2scal_2fun_2floor_8hpp_source.html">floor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66dea6b6d18e39c5b0f38d3204aa04d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::floor </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floor of the specified variable (cmath). </p>
<p>The derivative of the floor function is defined and zero everywhere but at integers, so we set these derivatives to zero for convenience,</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} {\lfloor x \rfloor} = 0$" src="form_346.png"/>.</p>
<p>The floor function rounds down. For double values, this is the largest integral value that is not greater than the specified value. Although this function is not differentiable because it is discontinuous at integral values, its gradient is returned as zero everywhere.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{floor}(x) = \begin{cases} \lfloor x \rfloor &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_347.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{floor}(x)}{\partial x} = \begin{cases} 0 &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_348.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floor of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2floor_8hpp_source.html#l00060">60</a> of file <a class="el" href="rev_2scal_2fun_2floor_8hpp_source.html">floor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad52e5d20122b9db1d2ec7c57417d19b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2, T3&gt;::type&gt; stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add operation (C99). </p>
<p>This double-based operation delegates to <code>fma</code>.</p>
<p>The function is defined by</p>
<p><code>fma(a, b, c) = (a * b) + c</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{fma}(x, y, z) = \begin{cases} x\cdot y+z &amp; \mbox{if } -\infty\leq x, y, z \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_0.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fma}(x, y, z)}{\partial x} = \begin{cases} y &amp; \mbox{if } -\infty\leq x, y, z \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_1.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fma}(x, y, z)}{\partial y} = \begin{cases} x &amp; \mbox{if } -\infty\leq x, y, z \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_2.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fma}(x, y, z)}{\partial z} = \begin{cases} 1 &amp; \mbox{if } -\infty\leq x, y, z \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_3.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First value. </td></tr>
    <tr><td class="paramname">x2</td><td>Second value. </td></tr>
    <tr><td class="paramname">x3</td><td>Third value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the first two values plus the third. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html#l00061">61</a> of file <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc95573545bf325172b18d2ec6b4f3f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2, T3&gt;::type&gt; stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See all-var input signature for details on the function and derivatives. </p>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html#l00074">74</a> of file <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebb72eea615a5b2effad60c4f5c1ccbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2, T3&gt;::type&gt; stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See all-var input signature for details on the function and derivatives. </p>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html#l00086">86</a> of file <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e283e1daef5282717309ddb1302d5dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2, T3&gt;::type&gt; stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See all-var input signature for details on the function and derivatives. </p>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html#l00098">98</a> of file <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a085357acaef6e7ac8f3e7d16e6b38aa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2, T3&gt;::type&gt; stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See all-var input signature for details on the function and derivatives. </p>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html#l00110">110</a> of file <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afaf7c6a98ccaf08b9964b9d9258c6d13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2, T3&gt;::type&gt; stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See all-var input signature for details on the function and derivatives. </p>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html#l00122">122</a> of file <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f3ab44e4f8a8430bd1fd19e37101555"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add function for three variables (C99). </p>
<p>This function returns the product of the first two arguments plus the third argument.</p>
<p>The double-based version <code>::fma(double, double, double)</code> is defined in <code>&lt;cmath&gt;</code>.</p>
<p>The partial derivatives are</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x * y) + z = y$" src="form_349.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (x * y) + z = x$" src="form_350.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial z} (x * y) + z = 1$" src="form_351.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>Second multiplicand. </td></tr>
    <tr><td class="paramname">c</td><td>Summand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the multiplicands plus the summand, ($a * $b) + $c. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html#l00129">129</a> of file <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31f25245e8d92c7e406808b1aad777a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2, T3&gt;::type&gt; stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See all-var input signature for details on the function and derivatives. </p>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html#l00134">134</a> of file <a class="el" href="fwd_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab57371eb5b1cf21e7fa089e89758bdef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add function for two variables and a value (C99). </p>
<p>This function returns the product of the first two arguments plus the third argument.</p>
<p>The double-based version <code>::fma(double, double, double)</code> is defined in <code>&lt;cmath&gt;</code>.</p>
<p>The partial derivatives are</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x * y) + c = y$" src="form_352.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (x * y) + c = x$" src="form_353.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>Second multiplicand. </td></tr>
    <tr><td class="paramname">c</td><td>Summand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the multiplicands plus the summand, ($a * $b) + $c. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html#l00154">154</a> of file <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1708d9819f74c9b8663c802a2d1a2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add function for a variable, value, and variable (C99). </p>
<p>This function returns the product of the first two arguments plus the third argument.</p>
<p>The double-based version <code>::fma(double, double, double)</code> is defined in <code>&lt;cmath&gt;</code>.</p>
<p>The partial derivatives are</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x * c) + z = c$" src="form_354.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial z} (x * c) + z = 1$" src="form_355.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>Second multiplicand. </td></tr>
    <tr><td class="paramname">c</td><td>Summand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the multiplicands plus the summand, ($a * $b) + $c. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html#l00179">179</a> of file <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a7340a4f23e33e671e53c2582c63272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add function for a variable and two values (C99). </p>
<p>This function returns the product of the first two arguments plus the third argument.</p>
<p>The double-based version <code>::fma(double, double, double)</code> is defined in <code>&lt;cmath&gt;</code>.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{d x} (x * c) + d = c$" src="form_356.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>Second multiplicand. </td></tr>
    <tr><td class="paramname">c</td><td>Summand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the multiplicands plus the summand, ($a * $b) + $c. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html#l00202">202</a> of file <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4becb131eda9f3e3f1ca06e373fea66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add function for a value, variable, and value (C99). </p>
<p>This function returns the product of the first two arguments plus the third argument.</p>
<p>The double-based version <code>::fma(double, double, double)</code> is defined in <code>&lt;cmath&gt;</code>.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{d y} (c * y) + d = c$" src="form_357.png"/>, and</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>Second multiplicand. </td></tr>
    <tr><td class="paramname">c</td><td>Summand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the multiplicands plus the summand, ($a * $b) + $c. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html#l00225">225</a> of file <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6917da974098b0bb02883839f1ae0e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add function for two values and a variable, and value (C99). </p>
<p>This function returns the product of the first two arguments plus the third argument.</p>
<p>The double-based version <code>::fma(double, double, double)</code> is defined in <code>&lt;cmath&gt;</code>.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial z} (c * d) + z = 1$" src="form_358.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>Second multiplicand. </td></tr>
    <tr><td class="paramname">c</td><td>Summand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the multiplicands plus the summand, ($a * $b) + $c. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html#l00248">248</a> of file <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9f288e71a8a7012ad123ca361f6a739"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fma </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fused multiply-add function for a value and two variables (C99). </p>
<p>This function returns the product of the first two arguments plus the third argument.</p>
<p>The double-based version <code>::fma(double, double, double)</code> is defined in <code>&lt;cmath&gt;</code>.</p>
<p>The partial derivaties are</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (c * y) + z = c$" src="form_359.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial z} (c * y) + z = 1$" src="form_360.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First multiplicand. </td></tr>
    <tr><td class="paramname">b</td><td>Second multiplicand. </td></tr>
    <tr><td class="paramname">c</td><td>Summand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of the multiplicands plus the summand, ($a * $b) + $c. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html#l00273">273</a> of file <a class="el" href="rev_2scal_2fun_2fma_8hpp_source.html">fma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f0dc47791c87f86c9f93d2cba273c25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmax </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmax_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2fmax_8hpp_source.html">fmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb8de59f858592b97409ca71d68f4442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmax </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmax_8hpp_source.html#l00033">33</a> of file <a class="el" href="fwd_2scal_2fun_2fmax_8hpp_source.html">fmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad0fec224f4c675618141528549640ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmax </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmax_8hpp_source.html#l00053">53</a> of file <a class="el" href="fwd_2scal_2fun_2fmax_8hpp_source.html">fmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab57bd2f169eb820c21273293d2cfa01b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum of the two variable arguments (C99). </p>
<p>No new variable implementations are created, with this function defined as if by</p>
<p><code>fmax(a, b) = a</code> if a's value is greater than b's, and .</p>
<p><code>fmax(a, b) = b</code> if b's value is greater than or equal to a's.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{fmax}(x, y) = \begin{cases} x &amp; \mbox{if } x \geq y \\ y &amp; \mbox{if } x < y \\[6pt] x &amp; \mbox{if } -\infty\leq x\leq \infty, y = \textrm{NaN}\\ y &amp; \mbox{if } -\infty\leq y\leq \infty, x = \textrm{NaN}\\ \textrm{NaN} &amp; \mbox{if } x, y = \textrm{NaN} \end{cases} \]" src="form_361.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fmax}(x, y)}{\partial x} = \begin{cases} 1 &amp; \mbox{if } x \geq y \\ 0 &amp; \mbox{if } x < y \\[6pt] 1 &amp; \mbox{if } -\infty\leq x\leq \infty, y = \textrm{NaN}\\ 0 &amp; \mbox{if } -\infty\leq y\leq \infty, x = \textrm{NaN}\\ \textrm{NaN} &amp; \mbox{if } x, y = \textrm{NaN} \end{cases} \]" src="form_362.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fmax}(x, y)}{\partial y} = \begin{cases} 0 &amp; \mbox{if } x \geq y \\ 1 &amp; \mbox{if } x < y \\[6pt] 0 &amp; \mbox{if } -\infty\leq x\leq \infty, y = \textrm{NaN}\\ 1 &amp; \mbox{if } -\infty\leq y\leq \infty, x = \textrm{NaN}\\ \textrm{NaN} &amp; \mbox{if } x, y = \textrm{NaN} \end{cases} \]" src="form_363.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the first variable's value is larger than the second's, the first variable, otherwise the second variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmax_8hpp_source.html#l00063">63</a> of file <a class="el" href="rev_2scal_2fun_2fmax_8hpp_source.html">fmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e72a34aed1af28919d940399a07c3d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum of the variable and scalar, promoting the scalar to a variable if it is larger (C99). </p>
<p>For <code>fmax(a, b)</code>, if a's value is greater than b, then a is returned, otherwise a fesh variable implementation wrapping the value b is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the first variable's value is larger than or equal to the second value, the first variable, otherwise the second value promoted to a fresh variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmax_8hpp_source.html#l00095">95</a> of file <a class="el" href="rev_2scal_2fun_2fmax_8hpp_source.html">fmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a200e969bd57383ff4f89516c0690b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmax </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum of a scalar and variable, promoting the scalar to a variable if it is larger (C99). </p>
<p>For <code>fmax(a, b)</code>, if a is greater than b's value, then a fresh variable implementation wrapping a is returned, otherwise b is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the first value is larger than the second variable's value, return the first value promoted to a variable, otherwise return the second variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmax_8hpp_source.html#l00127">127</a> of file <a class="el" href="rev_2scal_2fun_2fmax_8hpp_source.html">fmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae765dc2aa344a1893f66bffbdab0267c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmin </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmin_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2fmin_8hpp_source.html">fmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ade89f8b882cb15b0478176fd997cd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmin </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmin_8hpp_source.html#l00033">33</a> of file <a class="el" href="fwd_2scal_2fun_2fmin_8hpp_source.html">fmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00cdcc6569e6ac1d6a40d2f7157566a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmin </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmin_8hpp_source.html#l00053">53</a> of file <a class="el" href="fwd_2scal_2fun_2fmin_8hpp_source.html">fmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ff067261be560b2502178b590a7a068"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum of the two variable arguments (C99). </p>
<p>For <code>fmin(a, b)</code>, if a's value is less than b's, then a is returned, otherwise b is returned.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{fmin}(x, y) = \begin{cases} x &amp; \mbox{if } x \leq y \\ y &amp; \mbox{if } x > y \\[6pt] x &amp; \mbox{if } -\infty\leq x\leq \infty, y = \textrm{NaN}\\ y &amp; \mbox{if } -\infty\leq y\leq \infty, x = \textrm{NaN}\\ \textrm{NaN} &amp; \mbox{if } x, y = \textrm{NaN} \end{cases} \]" src="form_364.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fmin}(x, y)}{\partial x} = \begin{cases} 1 &amp; \mbox{if } x \leq y \\ 0 &amp; \mbox{if } x > y \\[6pt] 1 &amp; \mbox{if } -\infty\leq x\leq \infty, y = \textrm{NaN}\\ 0 &amp; \mbox{if } -\infty\leq y\leq \infty, x = \textrm{NaN}\\ \textrm{NaN} &amp; \mbox{if } x, y = \textrm{NaN} \end{cases} \]" src="form_365.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fmin}(x, y)}{\partial y} = \begin{cases} 0 &amp; \mbox{if } x \leq y \\ 1 &amp; \mbox{if } x > y \\[6pt] 0 &amp; \mbox{if } -\infty\leq x\leq \infty, y = \textrm{NaN}\\ 1 &amp; \mbox{if } -\infty\leq y\leq \infty, x = \textrm{NaN}\\ \textrm{NaN} &amp; \mbox{if } x, y = \textrm{NaN} \end{cases} \]" src="form_366.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the first variable's value is smaller than the second's, the first variable, otherwise the second variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmin_8hpp_source.html#l00059">59</a> of file <a class="el" href="rev_2scal_2fun_2fmin_8hpp_source.html">fmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e9c72371629b0a266acc6795d723aa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum of the variable and scalar, promoting the scalar to a variable if it is larger (C99). </p>
<p>For <code>fmin(a, b)</code>, if a's value is less than or equal to b, then a is returned, otherwise a fresh variable wrapping b is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the first variable's value is less than or equal to the second value, the first variable, otherwise the second value promoted to a fresh variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmin_8hpp_source.html#l00089">89</a> of file <a class="el" href="rev_2scal_2fun_2fmin_8hpp_source.html">fmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af78692904b139471b470740ce866468e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmin </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum of a scalar and variable, promoting the scalar to a variable if it is larger (C99). </p>
<p>For <code>fmin(a, b)</code>, if a is less than b's value, then a fresh variable implementation wrapping a is returned, otherwise b is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the first value is smaller than the second variable's value, return the first value promoted to a variable, otherwise return the second variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmin_8hpp_source.html#l00120">120</a> of file <a class="el" href="rev_2scal_2fun_2fmin_8hpp_source.html">fmin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9f40b2c56584ebd33037769fddc4d3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmod </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmod_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2fmod_8hpp_source.html">fmod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0970b532a9f823834c492e98356e730"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmod </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmod_8hpp_source.html#l00026">26</a> of file <a class="el" href="fwd_2scal_2fun_2fmod_8hpp_source.html">fmod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fdbe01b71fb403869c2fa9ebb1fb90c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::fmod </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2fmod_8hpp_source.html#l00039">39</a> of file <a class="el" href="fwd_2scal_2fun_2fmod_8hpp_source.html">fmod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a935933626162d429e5a7f06ca0bde103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmod </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floating point remainder after dividing the first variable by the second (cmath). </p>
<p>The partial derivatives with respect to the variables are defined everywhere but where <img class="formulaInl" alt="$x = y$" src="form_367.png"/>, but we set these to match other values, with</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} \mbox{fmod}(x, y) = 1$" src="form_368.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} \mbox{fmod}(x, y) = -\lfloor \frac{x}{y} \rfloor$" src="form_369.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{fmod}(x, y) = \begin{cases} x - \lfloor \frac{x}{y}\rfloor y &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_370.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fmod}(x, y)}{\partial x} = \begin{cases} 1 &amp; \mbox{if } -\infty\leq x, y\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_371.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{fmod}(x, y)}{\partial y} = \begin{cases} -\lfloor \frac{x}{y}\rfloor &amp; \mbox{if } -\infty\leq x, y\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_372.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating pointer remainder of dividing the first variable by the second. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmod_8hpp_source.html#l00103">103</a> of file <a class="el" href="rev_2scal_2fun_2fmod_8hpp_source.html">fmod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ecd1367428932c3515ef3c374e6e9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmod </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floating point remainder after dividing the the first variable by the second scalar (cmath). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{d x} \mbox{fmod}(x, c) = \frac{1}{c}$" src="form_373.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating pointer remainder of dividing the first variable by the second scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmod_8hpp_source.html#l00120">120</a> of file <a class="el" href="rev_2scal_2fun_2fmod_8hpp_source.html">fmod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6806c0d68c9e23e905b4ca36119734bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::fmod </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the floating point remainder after dividing the first scalar by the second variable (cmath). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{d y} \mbox{fmod}(c, y) = -\lfloor \frac{c}{y} \rfloor$" src="form_374.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First scalar. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Floating pointer remainder of dividing first scalar by the second variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2fmod_8hpp_source.html#l00137">137</a> of file <a class="el" href="rev_2scal_2fun_2fmod_8hpp_source.html">fmod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34680a4c6abd1d998326e44a212aa6d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::frechet_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="frechet__ccdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="frechet__ccdf__log_8hpp_source.html">frechet_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a252058aec5645d61efd61e155b788be7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::frechet_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="frechet__cdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="frechet__cdf_8hpp_source.html">frechet_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad1ba53b1f236710eed4f8377dc06471"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::frechet_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="frechet__cdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="frechet__cdf__log_8hpp_source.html">frechet_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17f910a5107250d4b47468fe1e7487cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::frechet_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="frechet__log_8hpp_source.html#l00034">34</a> of file <a class="el" href="frechet__log_8hpp_source.html">frechet_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63f05e7ee3898b2f48b4b2658dad51c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::frechet_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="frechet__log_8hpp_source.html#l00140">140</a> of file <a class="el" href="frechet__log_8hpp_source.html">frechet_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85bd113906fdeaf57e662a598ad99689"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::frechet_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="frechet__rng_8hpp_source.html#l00030">30</a> of file <a class="el" href="frechet__rng_8hpp_source.html">frechet_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f6f9efb0e1bacdc6415b6e0d6d6f00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_inv_scale&gt;::type stan::math::gamma_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gamma__ccdf__log_8hpp_source.html#l00035">35</a> of file <a class="el" href="gamma__ccdf__log_8hpp_source.html">gamma_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad927dbc83dc93b41cfb7a1ab6dccbd9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_inv_scale&gt;::type stan::math::gamma_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The cumulative density function for a gamma distribution for y with the specified shape and inverse scale parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_shape</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_inv_scale</td><td>Type of inverse scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gamma__cdf_8hpp_source.html#l00049">49</a> of file <a class="el" href="gamma__cdf_8hpp_source.html">gamma_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af878fa8fc2eaeec210aff65ec83f5323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_inv_scale&gt;::type stan::math::gamma_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gamma__cdf__log_8hpp_source.html#l00035">35</a> of file <a class="el" href="gamma__cdf__log_8hpp_source.html">gamma_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab77693b33e10406f7ca5d85ce97107f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_inv_scale&gt;::type stan::math::gamma_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a gamma density for y with the specified shape and inverse scale parameters. </p>
<p>Shape and inverse scale parameters must be greater than 0. y must be greater than or equal to 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Gamma}}(\alpha, \beta) \\ \log (p (y \, |\, \alpha, \beta) ) &amp;=&amp; \log \left( \frac{\beta^\alpha}{\Gamma(\alpha)} y^{\alpha - 1} \exp^{- \beta y} \right) \\ &amp;=&amp; \alpha \log(\beta) - \log(\Gamma(\alpha)) + (\alpha - 1) \log(y) - \beta y\\ &amp; &amp; \mathrm{where} \; y > 0 \end{eqnarray*}" src="form_194.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Inverse scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_shape</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_inv_scale</td><td>Type of inverse scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gamma__log_8hpp_source.html#l00052">52</a> of file <a class="el" href="gamma__log_8hpp_source.html">gamma_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03197f2fe5c3a96f77a9727f2db29d38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_inv_scale&gt;::type stan::math::gamma_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gamma__log_8hpp_source.html#l00164">164</a> of file <a class="el" href="gamma__log_8hpp_source.html">gamma_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0fad89bd8e78eee42230dd92bcf1b15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2gamma__p_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdd446def1c6803882dfa29838addc79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2gamma__p_8hpp_source.html#l00051">51</a> of file <a class="el" href="fwd_2scal_2fun_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed411d626d4ae01a76584c454a83673f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_p}(a, z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ P(a, z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_64.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{gamma\_p}(a, z)}{\partial a} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, P(a, z)}{\partial a} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_65.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{gamma\_p}(a, z)}{\partial z} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, P(a, z)}{\partial z} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_66.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(a, z)=\frac{1}{\Gamma(a)}\int_0^zt^{a-1}e^{-t}dt \]" src="form_67.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, P(a, z)}{\partial a} = -\frac{\Psi(a)}{\Gamma^2(a)}\int_0^zt^{a-1}e^{-t}dt + \frac{1}{\Gamma(a)}\int_0^z (a-1)t^{a-2}e^{-t}dt \]" src="form_68.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, P(a, z)}{\partial z} = \frac{z^{a-1}e^{-z}}{\Gamma(a)} \]" src="form_69.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2gamma__p_8hpp_source.html#l00053">53</a> of file <a class="el" href="prim_2scal_2fun_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a764de29e557ee65caaff1b94388a9367"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2gamma__p_8hpp_source.html#l00086">86</a> of file <a class="el" href="fwd_2scal_2fun_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9ec26628247b9e474e1b3254aae0b32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2gamma__p_8hpp_source.html#l00104">104</a> of file <a class="el" href="rev_2scal_2fun_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad392cbaa9872996da3127a359929cea4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2gamma__p_8hpp_source.html#l00109">109</a> of file <a class="el" href="rev_2scal_2fun_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa3db0274d59a42798f93e66d0d411dd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::gamma_p </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2gamma__p_8hpp_source.html#l00114">114</a> of file <a class="el" href="rev_2scal_2fun_2gamma__p_8hpp_source.html">gamma_p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a743267027c96ebef239be63589a6d594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2gamma__q_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c57ec58c3534caee0c89fbdf56ed28d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2gamma__q_8hpp_source.html#l00051">51</a> of file <a class="el" href="fwd_2scal_2fun_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0830ba049b81bc98ea9fbcf1eb7b4bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{gamma\_q}(a, z) = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ Q(a, z) &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_70.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{gamma\_q}(a, z)}{\partial a} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, Q(a, z)}{\partial a} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_71.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{gamma\_q}(a, z)}{\partial z} = \begin{cases} \textrm{error} &amp; \mbox{if } a\leq 0 \textrm{ or } z < 0\\ \frac{\partial\, Q(a, z)}{\partial z} &amp; \mbox{if } a > 0, z \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } a = \textrm{NaN or } z = \textrm{NaN} \end{cases} \]" src="form_72.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Q(a, z)=\frac{1}{\Gamma(a)}\int_z^\infty t^{a-1}e^{-t}dt \]" src="form_73.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, Q(a, z)}{\partial a} = -\frac{\Psi(a)}{\Gamma^2(a)}\int_z^\infty t^{a-1}e^{-t}dt + \frac{1}{\Gamma(a)}\int_z^\infty (a-1)t^{a-2}e^{-t}dt \]" src="form_74.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, Q(a, z)}{\partial z} = -\frac{z^{a-1}e^{-z}}{\Gamma(a)} \]" src="form_75.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2gamma__q_8hpp_source.html#l00053">53</a> of file <a class="el" href="prim_2scal_2fun_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8ed9105d1156ceaca26ab323f1a2648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2gamma__q_8hpp_source.html#l00058">58</a> of file <a class="el" href="rev_2scal_2fun_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af97d9968df786f813758bce4a8909f62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2gamma__q_8hpp_source.html#l00063">63</a> of file <a class="el" href="rev_2scal_2fun_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb9a338d5f5fd18bddf0e8225f6cc27d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2gamma__q_8hpp_source.html#l00068">68</a> of file <a class="el" href="rev_2scal_2fun_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ac85a7ace8ea6fdaa4fd19a40e8c87b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::gamma_q </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2gamma__q_8hpp_source.html#l00086">86</a> of file <a class="el" href="fwd_2scal_2fun_2gamma__q_8hpp_source.html">gamma_q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacf6ec5f55f56b5756804a1771259a58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gamma_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gamma__rng_8hpp_source.html#l00033">33</a> of file <a class="el" href="gamma__rng_8hpp_source.html">gamma_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a439b46e03e6dbd7269b60989cf31de85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_F, T_G, T_V, T_W, T_m0, T_C0&gt;::type &gt;::type stan::math::gaussian_dlm_obs_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_V, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a Gaussian dynamic linear model (GDLM). </p>
<p>This distribution is equivalent to, for <img class="formulaInl" alt="$t = 1:T$" src="form_21.png"/>, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y_t &amp; \sim N(F' \theta_t, V) \\ \theta_t &amp; \sim N(G \theta_{t-1}, W) \\ \theta_0 &amp; \sim N(m_0, C_0) \end{eqnarray*}" src="form_22.png"/>
</p>
<p>If V is a vector, then the Kalman filter is applied sequentially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A r x T matrix of observations. Rows are variables, columns are observations. </td></tr>
    <tr><td class="paramname">F</td><td>A n x r matrix. The design matrix. </td></tr>
    <tr><td class="paramname">G</td><td>A n x n matrix. The transition matrix. </td></tr>
    <tr><td class="paramname">V</td><td>A r x r matrix. The observation covariance matrix. </td></tr>
    <tr><td class="paramname">W</td><td>A n x n matrix. The state covariance matrix. </td></tr>
    <tr><td class="paramname">m0</td><td>A n x 1 matrix. The mean vector of the distribution of the initial state. </td></tr>
    <tr><td class="paramname">C0</td><td>A n x n matrix. The covariance matrix of the distribution of the initial state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the joint density of the GDLM. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if a matrix in the Kalman filter is not positive semi-definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_F</td><td>Type of design matrix. </td></tr>
    <tr><td class="paramname">T_G</td><td>Type of transition matrix. </td></tr>
    <tr><td class="paramname">T_V</td><td>Type of observation covariance matrix. </td></tr>
    <tr><td class="paramname">T_W</td><td>Type of state covariance matrix. </td></tr>
    <tr><td class="paramname">T_m0</td><td>Type of initial state mean vector. </td></tr>
    <tr><td class="paramname">T_C0</td><td>Type of initial state covariance matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html#l00079">79</a> of file <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html">gaussian_dlm_obs_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7da6e923e5a19bed55c94a109d2e4cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_F, T_G, T_V, T_W, T_m0, T_C0&gt;::type &gt;::type stan::math::gaussian_dlm_obs_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_V, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html#l00225">225</a> of file <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html">gaussian_dlm_obs_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a72bf8a0cfb7fd70089f9fb7fb5ce9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; T_y, typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_F, T_G, T_V, T_W, T_m0, T_C0&gt;::type &gt;::type stan::math::gaussian_dlm_obs_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_V, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a Gaussian dynamic linear model (GDLM) with uncorrelated observation disturbances. </p>
<p>This distribution is equivalent to, for <img class="formulaInl" alt="$t = 1:T$" src="form_21.png"/>, </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y_t &amp; \sim N(F' \theta_t, diag(V)) \\ \theta_t &amp; \sim N(G \theta_{t-1}, W) \\ \theta_0 &amp; \sim N(m_0, C_0) \end{eqnarray*}" src="form_23.png"/>
</p>
<p>If V is a vector, then the Kalman filter is applied sequentially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A r x T matrix of observations. Rows are variables, columns are observations. </td></tr>
    <tr><td class="paramname">F</td><td>A n x r matrix. The design matrix. </td></tr>
    <tr><td class="paramname">G</td><td>A n x n matrix. The transition matrix. </td></tr>
    <tr><td class="paramname">V</td><td>A size r vector. The diagonal of the observation covariance matrix. </td></tr>
    <tr><td class="paramname">W</td><td>A n x n matrix. The state covariance matrix. </td></tr>
    <tr><td class="paramname">m0</td><td>A n x 1 matrix. The mean vector of the distribution of the initial state. </td></tr>
    <tr><td class="paramname">C0</td><td>A n x n matrix. The covariance matrix of the distribution of the initial state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the joint density of the GDLM. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if a matrix in the Kalman filter is not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_F</td><td>Type of design matrix. </td></tr>
    <tr><td class="paramname">T_G</td><td>Type of transition matrix. </td></tr>
    <tr><td class="paramname">T_V</td><td>Type of observation variances </td></tr>
    <tr><td class="paramname">T_W</td><td>Type of state covariance matrix. </td></tr>
    <tr><td class="paramname">T_m0</td><td>Type of initial state mean vector. </td></tr>
    <tr><td class="paramname">T_C0</td><td>Type of initial state covariance matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html#l00285">285</a> of file <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html">gaussian_dlm_obs_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99ad1baa9f1a423304ac19aa0e345075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_F, T_G, T_V, T_W, T_m0, T_C0&gt;::type&gt;::type stan::math::gaussian_dlm_obs_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_F, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_G, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_V, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_W, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_m0, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_C0, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>C0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html#l00442">442</a> of file <a class="el" href="gaussian__dlm__obs__log_8hpp_source.html">gaussian_dlm_obs_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7535c86e2c9ee9d5391a8cc63187317e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i</td><td>Index into vector plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at <code>i - 1</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00027">27</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca7c84b936da0d3422507927cf9a68cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00053">53</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a714e39ba9fcbbd90c787a51d511c9af1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00081">81</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa23b355397df347249da513307fd6667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00111">111</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25c1fac0445beea55c521c94f360e13e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00143">143</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20a82151947fc8816c5ce5b7bc6d8abd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00178">178</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6fb72caff19c8ce19dc6e3c25c79f7b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00216">216</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accc97dd76490d575638ebb22da233a53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">i8</td><td>Eigth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00256">256</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d5ea3228150cb118441cced9ed49a92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the row of the specified vector at the specified base-one row index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<p><b>Warning</b>: Because a copy is involved, it is inefficient to access element of matrices by first using this method to get a row then using a second call to get the value at a specified column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Index into matrix plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row of matrix at <code>i - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00297">297</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51091bb67549e42c241f4e08e7d291d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified matrix at the specified base-one row and column indexes. </p>
<p>If either index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if either index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if either index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of matrix at row <code>m - 1</code> and column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00324">324</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0dbeed50ff3f8630ea3cd54f9ecb804"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified column vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Column vector from which to get a value. </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of column vector at row <code>m - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00351">351</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf9dcd5236495d3f581b31dd05b9a227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::get_base1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified row vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Row vector from which to get a value. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of row vector at column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1_8hpp_source.html#l00376">376</a> of file <a class="el" href="get__base1_8hpp_source.html">get_base1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac54b1427fd9d0765f0200dc9caa830f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i</td><td>Index into vector plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at <code>i - 1</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00027">27</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d5711f99869d05a6263218f3256e582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00053">53</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37f3ceaa6197904ef662f1edc8245e1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00081">81</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3132eb36eaf861cfbd119b38e0a85a15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00111">111</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbcc061003aabcaf675f4415adc80c0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00144">144</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1958245532761be08be7ac9bc781f3a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00179">179</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedc7fc712ebe439bec1892c8f69447cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00217">217</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64467731d9abfaf97ea8d541d528142c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified vector at the specified base-one indexes. </p>
<p>If an index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector from which to get a value. </td></tr>
    <tr><td class="paramname">i1</td><td>First index plus 1. </td></tr>
    <tr><td class="paramname">i2</td><td>Second index plus 1. </td></tr>
    <tr><td class="paramname">i3</td><td>Third index plus 1. </td></tr>
    <tr><td class="paramname">i4</td><td>Fourth index plus 1. </td></tr>
    <tr><td class="paramname">i5</td><td>Fifth index plus 1. </td></tr>
    <tr><td class="paramname">i6</td><td>Sixth index plus 1. </td></tr>
    <tr><td class="paramname">i7</td><td>Seventh index plus 1. </td></tr>
    <tr><td class="paramname">i8</td><td>Eigth index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if an index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of vector at indexes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00258">258</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0843cd960568745e5ace70f2c45ec6c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Block&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; &gt; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the row of the specified vector at the specified base-one row index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<p><b>Warning</b>: Because a copy is involved, it is inefficient to access element of matrices by first using this method to get a row then using a second call to get the value at a specified column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Index into matrix plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row of matrix at <code>i - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00301">301</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8cb7e6e670cddcdf5527ec92fa3ff37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified matrix at the specified base-one row and column indexes. </p>
<p>If either index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix from which to get a row </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if either index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if either index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of matrix at row <code>m - 1</code> and column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00328">328</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adffeab694f7588c92dc97b6736e5be7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified column vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Column vector from which to get a value. </td></tr>
    <tr><td class="paramname">m</td><td>Row index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of column vector at row <code>m - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00355">355</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6133d90708e16760b6394c6ca6a305ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; stan::math::get_base1_lhs </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value of the specified row vector at the specified base-one index. </p>
<p>If the index is out of range, throw a <code>std::out_of_range</code> exception with the specified error message and index indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Row vector from which to get a value. </td></tr>
    <tr><td class="paramname">n</td><td>Column index plus 1. </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message if the index is out of range. </td></tr>
    <tr><td class="paramname">idx</td><td>Nested index level to report in error message if the index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of row vector at column <code>n - 1</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="get__base1__lhs_8hpp_source.html#l00380">380</a> of file <a class="el" href="get__base1__lhs_8hpp_source.html">get_base1_lhs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0fd1b6e6ba9738332204bae823dc006"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_lp , typename T_lp_accum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_lp, T_lp_accum&gt;::type stan::math::get_lp </td>
          <td>(</td>
          <td class="paramtype">const T_lp &amp;&#160;</td>
          <td class="paramname"><em>lp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1accumulator.html">stan::math::accumulator</a>&lt; T_lp_accum &gt; &amp;&#160;</td>
          <td class="paramname"><em>lp_accum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="get__lp_8hpp_source.html#l00014">14</a> of file <a class="el" href="get__lp_8hpp_source.html">get_lp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6c32f9b52bef3a296432df037f96af3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stan::math::grad </td>
          <td>(</td>
          <td class="paramtype">chainable *&#160;</td>
          <td class="paramname"><em>vi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a78c351f7c1ef5ea39c047fe102f70da3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad </td>
          <td>(</td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; var, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate chain rule to calculate gradients starting from the specified variable. </p>
<p>Resizes the input vector to be the correct size.</p>
<p>The <a class="el" href="namespacestan_1_1math.html#ae6c32f9b52bef3a296432df037f96af3" title="Compute the gradient for all variables starting from the specified root variable implementation. ">grad()</a> function does not itself recover any memory. use <code><a class="el" href="namespacestan_1_1math.html#afe2cbb83ac9ef52296755690e61f4298" title="Recover memory used for all variables for reuse. ">recover_memory()</a></code> or <code><a class="el" href="namespacestan_1_1math.html#a8ebf2b2bc0f63dcb46a176b43e8b369a" title="Recover only the memory used for the top nested call. ">recover_memory_nested()</a></code> to recover memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Value of function being differentiated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Variables being differentiated with respect to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>Gradient, d/dx v, evaluated at x. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mat_2fun_2grad_8hpp_source.html#l00026">26</a> of file <a class="el" href="mat_2fun_2grad_8hpp_source.html">grad.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6c32f9b52bef3a296432df037f96af3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stan::math::grad </td>
          <td>(</td>
          <td class="paramtype">chainable *&#160;</td>
          <td class="paramname"><em>vi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient for all variables starting from the specified root variable implementation. </p>
<p>Does not recover memory. This chainable variable's adjoint is initialized using the method <code>init_dependent()</code> and then the chain rule is applied working down the stack from this chainable and calling each chainable's <code>chain()</code> method in turn.</p>
<p>This function computes a nested gradient only going back as far as the last nesting.</p>
<p>This function does not recover any memory from the computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vi</td><td>Variable implementation for root of partial derivative propagation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="core_2grad_8hpp_source.html#l00030">30</a> of file <a class="el" href="core_2grad_8hpp_source.html">grad.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43226a00b6c2d3f3a2ab5906490f3136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_2F1 </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>gradA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>gradC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad__2_f1_8hpp_source.html#l00013">13</a> of file <a class="el" href="grad__2_f1_8hpp_source.html">grad_2F1.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02dd0b6c85425c2005e265d8e66852a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_F32 </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad___f32_8hpp_source.html#l00011">11</a> of file <a class="el" href="grad___f32_8hpp_source.html">grad_F32.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66e0d2efc95d0241c473938c5850a0a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_hessian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value, the Hessian, and the gradient of the Hessian of the specified function at the specified argument. </p>
<p>The functor must implement</p>
<p><code> <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt;stan::math::fvar&lt;stan::math::var&gt; &gt; operator()(const Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt;stan::math::fvar&lt;stan::math::var&gt; &gt;, Eigen::Dynamic, 1&gt;&amp;) </code></p>
<p>using only operations that are defined for <code><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a></code> and <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code>.</p>
<p>This latter constraint usually requires the functions to be defined in terms of the libraries defined in Stan or in terms of functions with appropriately general namespace imports that eventually depend on functions defined in Stan.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument to function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td>Hessian of function at argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad_H</td><td>Gradient of the Hessian of function at argument </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="grad__hessian_8hpp_source.html#l00046">46</a> of file <a class="el" href="grad__hessian_8hpp_source.html">grad_hessian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a33cb272bd839945c13d7b41058c35c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_inc_beta </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2scal_2fun_2grad__inc__beta_8hpp_source.html#l00017">17</a> of file <a class="el" href="prim_2scal_2fun_2grad__inc__beta_8hpp_source.html">grad_inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25f15a75139ebb4a3b599a1190d39fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_inc_beta </td>
          <td>(</td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2grad__inc__beta_8hpp_source.html#l00024">24</a> of file <a class="el" href="rev_2scal_2fun_2grad__inc__beta_8hpp_source.html">grad_inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb6dcbe4585fc38ff9374aa5164582f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_inc_beta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2grad__inc__beta_8hpp_source.html#l00024">24</a> of file <a class="el" href="fwd_2scal_2fun_2grad__inc__beta_8hpp_source.html">grad_inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11eeb59eb3ae4f0710a7e417478c1212"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_reg_inc_beta </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digammaA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digammaB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digammaSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>betaAB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad__reg__inc__beta_8hpp_source.html#l00014">14</a> of file <a class="el" href="grad__reg__inc__beta_8hpp_source.html">grad_reg_inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6336e9873f3029f5abe54c4914c71cb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::grad_reg_inc_gamma </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad__reg__inc__gamma_8hpp_source.html#l00015">15</a> of file <a class="el" href="grad__reg__inc__gamma_8hpp_source.html">grad_reg_inc_gamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53f2f8fea732e1e05f78ed0dd394b33f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::grad_tr_mat_times_hessian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_tr_MH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="grad__tr__mat__times__hessian_8hpp_source.html#l00020">20</a> of file <a class="el" href="grad__tr__mat__times__hessian_8hpp_source.html">grad_tr_mat_times_hessian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42d25361a4bcf7ddb7fdb7edd35b8060"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::gradient </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_fx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value and the gradient of the specified function at the specified argument. </p>
<p>The functor must implement</p>
<p><code> <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> operator()(const Eigen::Matrix&lt;stan::math::var, Eigen::Dynamic, 1&gt;&amp;) </code></p>
<p>using only operations that are defined for <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code>. This latter constraint usually requires the functions to be defined in terms of the libraries defined in Stan or in terms of functions with appropriately general namespace imports that eventually depend on functions defined in Stan.</p>
<p>Time and memory usage is on the order of the size of the fully unfolded expression for the function applied to the argument, independently of dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument to function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad_fx</td><td>Gradient of function at argument </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2functor_2gradient_8hpp_source.html#l00044">44</a> of file <a class="el" href="rev_2mat_2functor_2gradient_8hpp_source.html">gradient.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cd625b9cec928434683f6c6502094f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::gradient </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_fx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value and the gradient of the specified function at the specified argument. </p>
<p>The functor must implement</p>
<p><code> <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a> operator()(const Eigen::Matrix&lt;stan::math::var, Eigen::Dynamic, 1&gt;&amp;) </code></p>
<p>using only operations that are defined for <code><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a></code>. This latter constraint usually requires the functions to be defined in terms of the libraries defined in Stan or in terms of functions with appropriately general namespace imports that eventually depend on functions defined in Stan.</p>
<p>Time and memory usage is on the order of the size of the fully unfolded expression for the function applied to the argument, independently of dimension.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument to function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad_fx</td><td>Gradient of function at argument </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fwd_2mat_2functor_2gradient_8hpp_source.html#l00044">44</a> of file <a class="el" href="fwd_2mat_2functor_2gradient_8hpp_source.html">gradient.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cf96fceee3cea400cdf078180c61c04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::gradient_dot_vector </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>grad_fx_dot_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gradient__dot__vector_8hpp_source.html#l00019">19</a> of file <a class="el" href="gradient__dot__vector_8hpp_source.html">gradient_dot_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9da900adc6bb1216e99f604001cd4caa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::gumbel_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gumbel__ccdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="gumbel__ccdf__log_8hpp_source.html">gumbel_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52ac5bc9a01ebadccc004463b054697c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::gumbel_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gumbel__cdf_8hpp_source.html#l00028">28</a> of file <a class="el" href="gumbel__cdf_8hpp_source.html">gumbel_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06f4009f162e58a62a583b84f2d5ccf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::gumbel_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gumbel__cdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="gumbel__cdf__log_8hpp_source.html">gumbel_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5fda97c2d23cb9fd2091e5bd1002e5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::gumbel_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gumbel__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="gumbel__log_8hpp_source.html">gumbel_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a166ad02fac07d4a084655f8fde1ec2ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::gumbel_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gumbel__log_8hpp_source.html#l00118">118</a> of file <a class="el" href="gumbel__log_8hpp_source.html">gumbel_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb7ad70ee185c1e0720086617431f71a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::gumbel_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="gumbel__rng_8hpp_source.html#l00027">27</a> of file <a class="el" href="gumbel__rng_8hpp_source.html">gumbel_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae824fde6dc6e0f4ac3d37b86fb266414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector from the front of the specified vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector input </td></tr>
    <tr><td class="paramname">n</td><td>Size of return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of v </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00024">24</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada1d4ceb7d5aac027e9ec6adcb18755a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a row vector from the front of the specified row vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>Row vector </td></tr>
    <tr><td class="paramname">n</td><td>Size of return row vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of rv </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00042">42</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e746ba14994b318a0a192a97a0a28db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::head </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the specified number of elements as a standard vector from the front of the specified standard vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value in vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>Standard vector </td></tr>
    <tr><td class="paramname">n</td><td>Size of return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first n elements of sv </dd></dl>

<p>Definition at line <a class="el" href="head_8hpp_source.html#l00058">58</a> of file <a class="el" href="head_8hpp_source.html">head.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a096c5d2b24b7de8a268a02b1f0705b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::hessian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value, the gradient, and the Hessian, of the specified function at the specified argument in O(N^2) time and O(N^2) space. </p>
<p>The functor must implement</p>
<p><code> stan::math::fvar&lt;stan::math::var&gt; operator()(const Eigen::Matrix&lt;stan::math::fvar&lt;stan::math::var&gt;, Eigen::Dynamic, 1&gt;&amp;) </code></p>
<p>using only operations that are defined for <code><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a></code> and <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code>.</p>
<p>This latter constraint usually requires the functions to be defined in terms of the libraries defined in Stan or in terms of functions with appropriately general namespace imports that eventually depend on functions defined in Stan.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument to function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad</td><td>gradient of function at argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td>Hessian of function at argument </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hessian_8hpp_source.html#l00046">46</a> of file <a class="el" href="hessian_8hpp_source.html">hessian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb8989a5749e54167301ac0720992d08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::hessian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hessian_8hpp_source.html#l00075">75</a> of file <a class="el" href="hessian_8hpp_source.html">hessian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a399d8cf66bb4db2d5139566b9da2c5f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::hessian_times_vector </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Hv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hessian__times__vector_8hpp_source.html#l00017">17</a> of file <a class="el" href="hessian__times__vector_8hpp_source.html">hessian_times_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1021570cd0ba1864f2f346cf2d78f13e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::hessian_times_vector </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Hv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hessian__times__vector_8hpp_source.html#l00046">46</a> of file <a class="el" href="hessian__times__vector_8hpp_source.html">hessian_times_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf091835ddc913687ab4d34c3eee662e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_N , typename T_a , typename T_b &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::hypergeometric_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_a &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_b &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hypergeometric__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="hypergeometric__log_8hpp_source.html">hypergeometric_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28d194254677d4503c2f5d7c6c4f6224"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_N , typename T_a , typename T_b &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::hypergeometric_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_N &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_a &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_b &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hypergeometric__log_8hpp_source.html#l00088">88</a> of file <a class="el" href="hypergeometric__log_8hpp_source.html">hypergeometric_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3878889879be4781cc8d560f534ab123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::hypergeometric_rng </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="hypergeometric__rng_8hpp_source.html#l00016">16</a> of file <a class="el" href="hypergeometric__rng_8hpp_source.html">hypergeometric_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd88cd5e3b00b9d099acd2482ca6fbf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::hypot </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2hypot_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2hypot_8hpp_source.html">hypot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a490944d221f2b68baf4092667f490ae8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::hypot </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2hypot_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2scal_2fun_2hypot_8hpp_source.html">hypot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd2f4416bf256405e515c0640dec5fe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::hypot </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2hypot_8hpp_source.html#l00031">31</a> of file <a class="el" href="fwd_2scal_2fun_2hypot_8hpp_source.html">hypot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0827e995b465dcb291c3de1a77e2b547"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::hypot </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the hypoteneuse of a right triangle with sides of the specified lengths (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#acd88cd5e3b00b9d099acd2482ca6fbf2">hypot()</a> for double-based function.</p>
<p>The partial derivatives are given by</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} \sqrt{x^2 + y^2} = \frac{x}{\sqrt{x^2 + y^2}}$" src="form_375.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} \sqrt{x^2 + y^2} = \frac{y}{\sqrt{x^2 + y^2}}$" src="form_376.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Length of first side. </td></tr>
    <tr><td class="paramname">b</td><td>Length of second side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of hypoteneuse. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2hypot_8hpp_source.html#l00053">53</a> of file <a class="el" href="rev_2scal_2fun_2hypot_8hpp_source.html">hypot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcb40e789140be0e0b93a44e055a6cfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::hypot </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the hypoteneuse of a right triangle with sides of the specified lengths (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#acd88cd5e3b00b9d099acd2482ca6fbf2">hypot()</a> for double-based function.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{d x} \sqrt{x^2 + c^2} = \frac{x}{\sqrt{x^2 + c^2}}$" src="form_377.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Length of first side. </td></tr>
    <tr><td class="paramname">b</td><td>Length of second side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of hypoteneuse. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2hypot_8hpp_source.html#l00071">71</a> of file <a class="el" href="rev_2scal_2fun_2hypot_8hpp_source.html">hypot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c9d2305ce89a46a7d182e6014fd0b3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::hypot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the hypoteneuse of a right triangle with sides of the specified lengths (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#acd88cd5e3b00b9d099acd2482ca6fbf2">hypot()</a> for double-based function.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{d y} \sqrt{c^2 + y^2} = \frac{y}{\sqrt{c^2 + y^2}}$" src="form_378.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{hypot}(x, y) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0 \text{ or } y < 0 \\ \sqrt{x^2+y^2} &amp; \mbox{if } x, y\geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_379.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{hypot}(x, y)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0 \text{ or } y < 0 \\ \frac{x}{\sqrt{x^2+y^2}} &amp; \mbox{if } x, y\geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_380.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{hypot}(x, y)}{\partial y} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0 \text{ or } y < 0 \\ \frac{y}{\sqrt{x^2+y^2}} &amp; \mbox{if } x, y\geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_381.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Length of first side. </td></tr>
    <tr><td class="paramname">b</td><td>Length of second side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of hypoteneuse. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2hypot_8hpp_source.html#l00116">116</a> of file <a class="el" href="rev_2scal_2fun_2hypot_8hpp_source.html">hypot.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7b430ac57e75ba2d55843cd868506e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::ibeta </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The normalized incomplete beta function of a, b, and x. </p>
<p>Used to compute the cumulative density function for the beta distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Shape parameter a &lt;= 0; a and b can't both be 0 </td></tr>
    <tr><td class="paramname">b</td><td>Shape parameter b &lt;= 0 </td></tr>
    <tr><td class="paramname">x</td><td>Random variate. 0 &lt;= x &lt;= 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>constraints are violated or if any argument is NaN</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized incomplete beta function. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2ibeta_8hpp_source.html#l00023">23</a> of file <a class="el" href="prim_2scal_2fun_2ibeta_8hpp_source.html">ibeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c7547dffd79bc54378fb3906345500e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::ibeta </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The normalized incomplete beta function of a, b, and x. </p>
<p>Used to compute the cumulative density function for the beta distribution.</p>
<p>Partial derivatives are those specified by wolfram alpha. The values were checked using both finite differences and by independent code for calculating the derivatives found in JSS (paper by Boik and Robison-Cox).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">b</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">x</td><td>Random variate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized incomplete beta function. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>any argument is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2ibeta_8hpp_source.html#l00238">238</a> of file <a class="el" href="rev_2scal_2fun_2ibeta_8hpp_source.html">ibeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa7ea9a437cf38e48ec72cec173d7465"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::identity_constrain </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of applying the identity constraint transform to the input. </p>
<p>This method is effectively a no-op and is mainly useful as a placeholder in auto-generated code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed input.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="identity__constrain_8hpp_source.html#l00022">22</a> of file <a class="el" href="identity__constrain_8hpp_source.html">identity_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7925ed2737df76a38ae17c13f85e9141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::identity_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of applying the identity constraint transform to the input and increments the log probability reference with the log absolute Jacobian determinant. </p>
<p>This method is effectively a no-op and mainly useful as a placeholder in auto-generated code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar. lp Reference to log probability. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed input. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="identity__constrain_8hpp_source.html#l00041">41</a> of file <a class="el" href="identity__constrain_8hpp_source.html">identity_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac50a1ae328bd1f7195b0c77a16a684ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::identity_free </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of applying the inverse of the identity constraint transform to the input. </p>
<p>This method is effectively a no-op and mainly useful as a placeholder in auto-generated code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Constrained scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="identity__free_8hpp_source.html#l00021">21</a> of file <a class="el" href="identity__free_8hpp_source.html">identity_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb35d5a60bdc11a5d09eb629c50b5db5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::if_else </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>y_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>y_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified condition is true, return the first variable, otherwise return the second variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Boolean condition. </td></tr>
    <tr><td class="paramname">y_true</td><td>Variable to return if condition is true. </td></tr>
    <tr><td class="paramname">y_false</td><td>Variable to return if condition is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2if__else_8hpp_source.html#l00017">17</a> of file <a class="el" href="rev_2scal_2fun_2if__else_8hpp_source.html">if_else.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65e2d3e3ab44f347f3ebaacb67845015"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_true , typename T_false &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_true, T_false&gt;::type stan::math::if_else </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_true&#160;</td>
          <td class="paramname"><em>y_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_false&#160;</td>
          <td class="paramname"><em>y_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the second argument if the first argument is true and otherwise return the second argument. </p>
<p>This is just a convenience method to provide a function with the same behavior as the built-in ternary operator. In general, this function behaves as if defined by</p>
<p><code>if_else(c, y1, y0) = c ? y1 : y0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Boolean condition value. </td></tr>
    <tr><td class="paramname">y_true</td><td>Value to return if condition is true. </td></tr>
    <tr><td class="paramname">y_false</td><td>Value to return if condition is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2if__else_8hpp_source.html#l00025">25</a> of file <a class="el" href="prim_2scal_2fun_2if__else_8hpp_source.html">if_else.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc1dc3a479994402ee1959b75fa2c70f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::if_else </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>y_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified condition is true, return a new variable constructed from the first scalar, otherwise return the second variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Boolean condition. </td></tr>
    <tr><td class="paramname">y_true</td><td>Value to promote to variable and return if condition is true. </td></tr>
    <tr><td class="paramname">y_false</td><td>Variable to return if condition is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2if__else_8hpp_source.html#l00029">29</a> of file <a class="el" href="rev_2scal_2fun_2if__else_8hpp_source.html">if_else.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09912038470cc9d13d754296b1fe6949"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::if_else </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>y_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>y_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the specified condition is true, return the first variable, otherwise return a new variable constructed from the second scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Boolean condition. </td></tr>
    <tr><td class="paramname">y_true</td><td>Variable to return if condition is true. </td></tr>
    <tr><td class="paramname">y_false</td><td>Value to promote to variable and return if condition is false. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2if__else_8hpp_source.html#l00044">44</a> of file <a class="el" href="rev_2scal_2fun_2if__else_8hpp_source.html">if_else.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01192e5a2e1c208f78818b57b4d6aa78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::inc_beta </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2scal_2fun_2inc__beta_8hpp_source.html#l00010">10</a> of file <a class="el" href="prim_2scal_2fun_2inc__beta_8hpp_source.html">inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9988ca802426ba048ba5d5d9ad71e2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::inc_beta </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2inc__beta_8hpp_source.html#l00020">20</a> of file <a class="el" href="fwd_2scal_2fun_2inc__beta_8hpp_source.html">inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf29f2f025873816925c6786842d0afe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::inc_beta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2inc__beta_8hpp_source.html#l00045">45</a> of file <a class="el" href="rev_2scal_2fun_2inc__beta_8hpp_source.html">inc_beta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c265eb14e915edc9bd457e93aaaf166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::inc_beta_dda </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digamma_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digamma_ab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to a. </p>
<p>The power series used to compute the deriative tends to converge slowly when a and b are large, especially if z approaches 1. The implementation will throw an exception if the series have not converged within 100,000 iterations. The current implementation has been tested for values of a and b up to 12500 and z = 0.999.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar types of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a </td></tr>
    <tr><td class="paramname">b</td><td>b </td></tr>
    <tr><td class="paramname">z</td><td>upper bound of the integral </td></tr>
    <tr><td class="paramname">digamma_a</td><td>value of digamma(a) </td></tr>
    <tr><td class="paramname">digamma_ab</td><td>value of digamma(b) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of the incomplete beta with respect to a</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>a &gt;= 0 </dd>
<dd>
b &gt;= 0 </dd>
<dd>
0 &lt;= z &lt;= 1 </dd></dl>

<p>Definition at line <a class="el" href="inc__beta__dda_8hpp_source.html#l00038">38</a> of file <a class="el" href="inc__beta__dda_8hpp_source.html">inc_beta_dda.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc99a6a1e74fd1daeab96f7eeb3b05a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::inc_beta_ddb </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digamma_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>digamma_ab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to b. </p>
<p>The power series used to compute the deriative tends to converge slowly when a and b are large, especailly if z approaches 1. The implementation will throw an exception if the series have not converged within 100,000 iterations. The current implementation has been tested for values of a and b up to 12500 and z = 0.999.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar types of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a </td></tr>
    <tr><td class="paramname">b</td><td>b </td></tr>
    <tr><td class="paramname">z</td><td>upper bound of the integral </td></tr>
    <tr><td class="paramname">digamma_b</td><td>value of digamma(b) </td></tr>
    <tr><td class="paramname">digamma_ab</td><td>value of digamma(b) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of the incomplete beta with respect to b</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>a &gt;= 0 </dd>
<dd>
b &gt;= 0 </dd>
<dd>
0 &lt;= z &lt;= 1 </dd></dl>

<p>Definition at line <a class="el" href="inc__beta__ddb_8hpp_source.html#l00038">38</a> of file <a class="el" href="inc__beta__ddb_8hpp_source.html">inc_beta_ddb.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2412f96d2114b4c15efb1ddbddaef35b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::inc_beta_ddz </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to z. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar types of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>a </td></tr>
    <tr><td class="paramname">b</td><td>b </td></tr>
    <tr><td class="paramname">z</td><td>upper bound of the integral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partial derivative of the incomplete beta with respect to z</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>a &gt; 0 </dd>
<dd>
b &gt; 0 </dd>
<dd>
0 &lt; z &lt;= 1 </dd></dl>

<p>Definition at line <a class="el" href="inc__beta__ddz_8hpp_source.html#l00027">27</a> of file <a class="el" href="inc__beta__ddz_8hpp_source.html">inc_beta_ddz.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e5957e2cb19140e6c7bacf5c68320b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::inc_beta_ddz </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inc__beta__ddz_8hpp_source.html#l00035">35</a> of file <a class="el" href="inc__beta__ddz_8hpp_source.html">inc_beta_ddz.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af81e05dfd6918524dafff10715f21a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00017">17</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ad7882cc7a7e2e07016e006d2092427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;V&gt;::value, void&gt;::type stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00023">23</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cb47e7569cabd57a1c0c6816ca48293"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C, typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00027">27</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad27706378f77dc22746ad74721d495d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="initialize_8hpp_source.html#l00032">32</a> of file <a class="el" href="initialize_8hpp_source.html">initialize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebdf0a5cd40134110da3230d6fdea989"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize_variable </td>
          <td>(</td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize variable to value. </p>
<p>(Function may look pointless, but its needed to bottom out recursion.) </p>

<p>Definition at line <a class="el" href="initialize__variable_8hpp_source.html#l00015">15</a> of file <a class="el" href="initialize__variable_8hpp_source.html">initialize_variable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1bb474a393fa5277ff69c9498cb3809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize_variable </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize every cell in the matrix to the specified value. </p>

<p>Definition at line <a class="el" href="initialize__variable_8hpp_source.html#l00024">24</a> of file <a class="el" href="initialize__variable_8hpp_source.html">initialize_variable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada62635d3e2320c9e36ac59a1c4bbdb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::initialize_variable </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the variables in the standard vector recursively. </p>

<p>Definition at line <a class="el" href="initialize__variable_8hpp_source.html#l00034">34</a> of file <a class="el" href="initialize__variable_8hpp_source.html">initialize_variable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c507cff4b7b473cd86e1d428fb03136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int stan::math::int_step </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The integer step, or Heaviside, function. </p>
<p>For double NaN input, int_step(NaN) returns 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{int\_step}(x) = \begin{cases} 0 &amp; \mbox{if } x \leq 0 \\ 1 &amp; \mbox{if } x > 0 \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_76.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if value is greater than 0 and 0 otherwise </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar argument type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="int__step_8hpp_source.html#l00025">25</a> of file <a class="el" href="int__step_8hpp_source.html">int_step.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57c148a430fffb6b4a865d25742b3412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T1, T2&gt;::type&gt; &gt; stan::math::integrate_ode </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T1 &gt;&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the solutions for the specified system of ordinary differential equations given the specified initial state, initial times, times of desired solution, and parameters and data, writing error and warning messages to the specified stream. </p>
<p><b>Warning:</b> If the system of equations is stiff, roughly defined by having varying time scales across dimensions, then this solver is likely to be slow.</p>
<p>This function is templated to allow the initial times to be either data or autodiff variables and the parameters to be data or autodiff variables. The autodiff-based implementation for reverse-mode are defined in namespace <code><a class="el" href="namespacestan_1_1math.html" title="Matrices and templated mathematical functions. ">stan::math</a></code> and may be invoked via argument-dependent lookup by including their headers.</p>
<p>This function uses the <a href="http://en.wikipedia.org/wiki/Dormand–Prince_method">Dormand-Prince method</a> as implemented in Boost's <code> boost::numeric::odeint::runge_kutta_dopri5</code> integrator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type of ODE system function. </td></tr>
    <tr><td class="paramname">T1</td><td>type of scalars for initial values. </td></tr>
    <tr><td class="paramname">T2</td><td>type of scalars for parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>functor for the base ordinary differential equation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y0</td><td>initial state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t0</td><td>initial time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ts</td><td>times of the desired solutions, in strictly increasing order, all greater than the initial time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>parameter vector for the ODE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>continuous data vector for the ODE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_int</td><td>integer data vector for the ODE. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgs</td><td>the print stream for warning messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of states, each state being a vector of the same size as the state variable, corresponding to a time in ts. </dd></dl>

<p>Definition at line <a class="el" href="integrate__ode_8hpp_source.html#l00060">60</a> of file <a class="el" href="integrate__ode_8hpp_source.html">integrate_ode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab64935e0bdac8227bfd9608285d4e699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2scal_2fun_2inv_8hpp_source.html#l00012">12</a> of file <a class="el" href="prim_2scal_2fun_2inv_8hpp_source.html">inv.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a5386561ba622e05cb64345fdad6a3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::inv </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2inv_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2inv_8hpp_source.html">inv.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b645189bc4899956bdba20158a0ee6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::inv </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv}(x) = \begin{cases} \frac{1}{x} &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_382.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{inv}(x)}{\partial x} = \begin{cases} -\frac{1}{x^2} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_383.png"/>
</p>
 
<p>Definition at line <a class="el" href="rev_2scal_2fun_2inv_8hpp_source.html#l00042">42</a> of file <a class="el" href="rev_2scal_2fun_2inv_8hpp_source.html">inv.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24a32a9537cf8218b73109b93379b5b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::inv_chi_square_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__chi__square__ccdf__log_8hpp_source.html#l00033">33</a> of file <a class="el" href="inv__chi__square__ccdf__log_8hpp_source.html">inv_chi_square_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a372e143655badb8f25e542697f689f39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::inv_chi_square_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__chi__square__cdf_8hpp_source.html#l00033">33</a> of file <a class="el" href="inv__chi__square__cdf_8hpp_source.html">inv_chi_square_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae005376416b29d9118470b9c2d18133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::inv_chi_square_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__chi__square__cdf__log_8hpp_source.html#l00033">33</a> of file <a class="el" href="inv__chi__square__cdf__log_8hpp_source.html">inv_chi_square_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae83a74c666a703da52db606eb478f50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::inv_chi_square_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of an inverse chi-squared density for y with the specified degrees of freedom parameter. </p>
<p>The degrees of freedom prarameter must be greater than 0. y must be greater than 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Inv-}}\chi^2_\nu \\ \log (p (y \, |\, \nu)) &amp;=&amp; \log \left( \frac{2^{-\nu / 2}}{\Gamma (\nu / 2)} y^{- (\nu / 2 + 1)} \exp^{-1 / (2y)} \right) \\ &amp;=&amp; - \frac{\nu}{2} \log(2) - \log (\Gamma (\nu / 2)) - (\frac{\nu}{2} + 1) \log(y) - \frac{1}{2y} \\ &amp; &amp; \mathrm{ where } \; y > 0 \end{eqnarray*}" src="form_195.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than or equal to 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="inv__chi__square__log_8hpp_source.html#l00052">52</a> of file <a class="el" href="inv__chi__square__log_8hpp_source.html">inv_chi_square_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19b9a4f2fd21b540a7d50a37d23f0869"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof&gt;::type stan::math::inv_chi_square_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__chi__square__log_8hpp_source.html#l00142">142</a> of file <a class="el" href="inv__chi__square__log_8hpp_source.html">inv_chi_square_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8159125045ed1c5ee551537c9983921f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::inv_chi_square_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__chi__square__rng_8hpp_source.html#l00031">31</a> of file <a class="el" href="inv__chi__square__rng_8hpp_source.html">inv_chi_square_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba00ed1e73c3a2366226aa4c83e4d8b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::inv_cloglog </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2inv__cloglog_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2inv__cloglog_8hpp_source.html">inv_cloglog.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab834f530318a33700ba2c66b74ea3bf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::inv_cloglog </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the inverse complementary log-log function applied specified variable (stan). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#aba00ed1e73c3a2366226aa4c83e4d8b9">stan::math::inv_cloglog()</a> for the double-based version.</p>
<p>The derivative is given by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{cloglog}^{-1}(x) = \exp (x - \exp (x))$" src="form_384.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse complementary log-log of the specified argument. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2inv__cloglog_8hpp_source.html#l00036">36</a> of file <a class="el" href="rev_2scal_2fun_2inv__cloglog_8hpp_source.html">inv_cloglog.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a008bf0b6c2ab38d088b0aba5d7b10c8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_cloglog </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse complementary log-log function. </p>
<p>The function is defined by</p>
<p><code>inv_cloglog(x) = 1 - exp(-exp(x))</code>.</p>
<p>This function can be used to implement the inverse link function for complementary-log-log regression.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_cloglog}(y) = \begin{cases} \mbox{cloglog}^{-1}(y) &amp; \mbox{if } -\infty\leq y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_77.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{inv\_cloglog}(y)}{\partial y} = \begin{cases} \frac{\partial\, \mbox{cloglog}^{-1}(y)}{\partial y} &amp; \mbox{if } -\infty\leq y\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_78.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{cloglog}^{-1}(y) = 1 - \exp \left( - \exp(y) \right) \]" src="form_79.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{cloglog}^{-1}(y)}{\partial y} = \exp(y-\exp(y)) \]" src="form_80.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse complementary log-log of the argument. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2inv__cloglog_8hpp_source.html#l00049">49</a> of file <a class="el" href="prim_2scal_2fun_2inv__cloglog_8hpp_source.html">inv_cloglog.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2b35d989d0d1a9cb6ea163bbbd14ed3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::inv_gamma_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__gamma__ccdf__log_8hpp_source.html#l00035">35</a> of file <a class="el" href="inv__gamma__ccdf__log_8hpp_source.html">inv_gamma_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a195c84d2f45abc7bcf28c1d9e3fd8cf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::inv_gamma_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CDF of an inverse gamma density for y with the specified shape and scale parameters. </p>
<p>y, shape, and scale parameters must be greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_shape</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="inv__gamma__cdf_8hpp_source.html#l00051">51</a> of file <a class="el" href="inv__gamma__cdf_8hpp_source.html">inv_gamma_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e622170c7270f1a441235f98248d3a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::inv_gamma_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__gamma__cdf__log_8hpp_source.html#l00035">35</a> of file <a class="el" href="inv__gamma__cdf__log_8hpp_source.html">inv_gamma_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad34fa642137e07f723c995d42e78df2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::inv_gamma_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of an inverse gamma density for y with the specified shape and scale parameters. </p>
<p>Shape and scale parameters must be greater than 0. y must be greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Shape parameter. </td></tr>
    <tr><td class="paramname">beta</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if alpha is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if beta is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_shape</td><td>Type of shape. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="inv__gamma__log_8hpp_source.html#l00051">51</a> of file <a class="el" href="inv__gamma__log_8hpp_source.html">inv_gamma_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a6c6fb67d4de25708140e5fce64e4f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::inv_gamma_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__gamma__log_8hpp_source.html#l00163">163</a> of file <a class="el" href="inv__gamma__log_8hpp_source.html">inv_gamma_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3222e632ba4aaeb90753a96520799867"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::inv_gamma_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__gamma__rng_8hpp_source.html#l00033">33</a> of file <a class="el" href="inv__gamma__rng_8hpp_source.html">inv_gamma_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76a22ee34432be58edb4b6ed9469370a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::inv_logit </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2inv__logit_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2inv__logit_8hpp_source.html">inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7d7861511ad7d8a82e17a1e9fa573de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::inv_logit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inverse logit function for variables (stan). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#a76a22ee34432be58edb4b6ed9469370a">stan::math::inv_logit()</a> for the double-based version.</p>
<p>The derivative of inverse logit is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{logit}^{-1}(x) = \mbox{logit}^{-1}(x) (1 - \mbox{logit}^{-1}(x))$" src="form_385.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse logit of argument. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2inv__logit_8hpp_source.html#l00034">34</a> of file <a class="el" href="rev_2scal_2fun_2inv__logit_8hpp_source.html">inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c4834fc581f55acf8491ec3f80ecb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse logit function applied to the argument. </p>
<p>The inverse logit function is defined by</p>
<p><img class="formulaInl" alt="$\mbox{logit}^{-1}(x) = \frac{1}{1 + \exp(-x)}$" src="form_81.png"/>.</p>
<p>This function can be used to implement the inverse link function for logistic regression.</p>
<p>The inverse to this function is <code><a class="el" href="namespacestan_1_1math.html#ab025eaf1e6f5c920f69c37e7a7f8b319">stan::math::logit</a></code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_logit}(y) = \begin{cases} \mbox{logit}^{-1}(y) &amp; \mbox{if } -\infty\leq y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_82.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{inv\_logit}(y)}{\partial y} = \begin{cases} \frac{\partial\, \mbox{logit}^{-1}(y)}{\partial y} &amp; \mbox{if } -\infty\leq y\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } y = \textrm{NaN} \end{cases} \]" src="form_83.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{logit}^{-1}(y) = \frac{1}{1 + \exp(-y)} \]" src="form_84.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{logit}^{-1}(y)}{\partial y} = \frac{\exp(y)}{(\exp(y)+1)^2} \]" src="form_85.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse logit of argument. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2inv__logit_8hpp_source.html#l00052">52</a> of file <a class="el" href="prim_2scal_2fun_2inv__logit_8hpp_source.html">inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b4db5e98585c71cc7c14319f96e0c04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_sqrt </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2scal_2fun_2inv__sqrt_8hpp_source.html#l00012">12</a> of file <a class="el" href="prim_2scal_2fun_2inv__sqrt_8hpp_source.html">inv_sqrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca2d4971bfd22beacb304bdd5b9d3395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::inv_sqrt </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2inv__sqrt_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2inv__sqrt_8hpp_source.html">inv_sqrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3e1382ec567be20643caef30076869"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::inv_sqrt </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_sqrt}(x) = \begin{cases} \frac{1}{\sqrt{x}} &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_386.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{inv\_sqrt}(x)}{\partial x} = \begin{cases} -\frac{1}{2\sqrt{x^3}} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_387.png"/>
</p>
 
<p>Definition at line <a class="el" href="rev_2scal_2fun_2inv__sqrt_8hpp_source.html#l00042">42</a> of file <a class="el" href="rev_2scal_2fun_2inv__sqrt_8hpp_source.html">inv_sqrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d2e922aa13e2dfae510fc13d86eaea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::inv_square </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2scal_2fun_2inv__square_8hpp_source.html#l00012">12</a> of file <a class="el" href="prim_2scal_2fun_2inv__square_8hpp_source.html">inv_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7c1f6b0f3c9f48fa30e09f2d929336d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::inv_square </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2inv__square_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2inv__square_8hpp_source.html">inv_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa347bbaada35746d4fbd644549416ce3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::inv_square </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{inv\_square}(x) = \begin{cases} \frac{1}{x^2} &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_388.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{inv\_square}(x)}{\partial x} = \begin{cases} -\frac{2}{x^3} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_389.png"/>
</p>
 
<p>Definition at line <a class="el" href="rev_2scal_2fun_2inv__square_8hpp_source.html#l00042">42</a> of file <a class="el" href="rev_2scal_2fun_2inv__square_8hpp_source.html">inv_square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56c063912bf059644103aaf8787f71e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_dof, T_scale&gt;::type stan::math::inv_wishart_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Inverse-Wishart density for the given W, degrees of freedom, and scale matrix. </p>
<p>The scale matrix, S, must be k x k, symmetric, and semi-positive definite.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} W &amp;\sim&amp; \mbox{\sf{Inv-Wishart}}_{\nu} (S) \\ \log (p (W \, |\, \nu, S) ) &amp;=&amp; \log \left( \left(2^{\nu k/2} \pi^{k (k-1) /4} \prod_{i=1}^k{\Gamma (\frac{\nu + 1 - i}{2})} \right)^{-1} \times \left| S \right|^{\nu/2} \left| W \right|^{-(\nu + k + 1) / 2} \times \exp (-\frac{1}{2} \mbox{tr} (S W^{-1})) \right) \\ &amp;=&amp; -\frac{\nu k}{2}\log(2) - \frac{k (k-1)}{4} \log(\pi) - \sum_{i=1}^{k}{\log (\Gamma (\frac{\nu+1-i}{2}))} +\frac{\nu}{2} \log(\det(S)) - \frac{\nu+k+1}{2}\log (\det(W)) - \frac{1}{2} \mbox{tr}(S W^{-1}) \end{eqnarray*}" src="form_24.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>A scalar matrix </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom </td></tr>
    <tr><td class="paramname">S</td><td>The scale matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Inverse-Wishart density at W given nu and S. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than k-1 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if S is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="inv__wishart__log_8hpp_source.html#l00052">52</a> of file <a class="el" href="inv__wishart__log_8hpp_source.html">inv_wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96f8f9a5add1c91cbe30c887265da81f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_dof, T_scale&gt;::type stan::math::inv_wishart_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__wishart__log_8hpp_source.html#l00125">125</a> of file <a class="el" href="inv__wishart__log_8hpp_source.html">inv_wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a639b9495c8bb2917100b52b7ed889d3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::inv_wishart_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="inv__wishart__rng_8hpp_source.html#l00021">21</a> of file <a class="el" href="inv__wishart__rng_8hpp_source.html">inv_wishart_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bcb1af5657f92ccadf5204fc43377fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid_argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid argument. This will allow us to change the behavior for all functions at once.</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;&lt;msg2&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument_8hpp_source.html#l00031">31</a> of file <a class="el" href="invalid__argument_8hpp_source.html">invalid_argument.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacf5709c614035ef60053a348e18554c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid_argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid argument. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt; &lt;msg1&gt;&lt;y&gt;"</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument_8hpp_source.html#l00066">66</a> of file <a class="el" href="invalid__argument_8hpp_source.html">invalid_argument.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add7b2630385b99ef7045818ba8fe2a97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid arguments. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print before the variable </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print after the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument__vec_8hpp_source.html#l00038">38</a> of file <a class="el" href="invalid__argument__vec_8hpp_source.html">invalid_argument_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a309a8690ee903eea7e5847e4d93483f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::invalid_argument_vec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an invalid argument exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing invalid arguments. This will allow us to change the behavior for all functions at once. (We've already changed behavior mulitple times up to Stan v2.5.0.)</p>
<p>The message is: "&lt;function&gt;: &lt;name&gt;[&lt;i+error_index&gt;] &lt;msg1&gt;&lt;y&gt;" where <a class="el" href="structstan_1_1error__index.html">error_index</a> is the value of <a class="el" href="structstan_1_1error__index.html#a2adc3ca217283b39a292dfce1804bb12a0878d922bbc8cd2f709a333e184dd112">stan::error_index::value</a> which indicates whether the message should be 0 or 1 indexed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">name</td><td>Name of the variable </td></tr>
    <tr><td class="paramname">y</td><td>Variable </td></tr>
    <tr><td class="paramname">i</td><td>Index </td></tr>
    <tr><td class="paramname">msg</td><td>Message to print before the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="invalid__argument__vec_8hpp_source.html#l00074">74</a> of file <a class="el" href="invalid__argument__vec_8hpp_source.html">invalid_argument_vec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad621964cbb3b06ba80811cd58e3048a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, C&gt; stan::math::inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the specified matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2inverse_8hpp_source.html#l00018">18</a> of file <a class="el" href="prim_2mat_2fun_2inverse_8hpp_source.html">inverse.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab64bf2ca0e8e628e49119ed995c1c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2inverse_8hpp_source.html#l00020">20</a> of file <a class="el" href="fwd_2mat_2fun_2inverse_8hpp_source.html">inverse.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1edc35cc581dda178263f6a4a4fd1158"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::inverse_softmax </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>simplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the inverse softmax of the simplex argument into the second argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a6f57ef7820025c7b350f84c3aebfe45e">stan::math::softmax</a></code> for the inverse function and a definition of the relation.</p>
<p>The inverse softmax function is defined by</p>
<p><img class="formulaInl" alt="$\mbox{inverse\_softmax}(x)[i] = \log x[i]$" src="form_86.png"/>.</p>
<p>This function defines the inverse of <code><a class="el" href="namespacestan_1_1math.html#a6f57ef7820025c7b350f84c3aebfe45e">stan::math::softmax</a></code> up to a scaling factor.</p>
<p>Because of the definition, values of 0.0 in the simplex are converted to negative infinity, and values of 1.0 are converted to 0.0.</p>
<p>There is no check that the input vector is a valid simplex vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>Simplex vector input. </td></tr>
    <tr><td class="paramname">y</td><td>Vector into which the inverse softmax is written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if size of the input and output vectors differ. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="inverse__softmax_8hpp_source.html#l00034">34</a> of file <a class="el" href="inverse__softmax_8hpp_source.html">inverse_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69d2c003918b45e95edb84ea58b84c68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::inverse_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inverse of the specified symmetric, pos/neg-definite matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="inverse__spd_8hpp_source.html#l00019">19</a> of file <a class="el" href="inverse__spd_8hpp_source.html">inverse_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7add35b0758b1d0541f7e919c36412f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_aligned </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bytes_aligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the specified pointer is aligned on the number of bytes. </p>
<p>This doesn't really make sense other than for powers of 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to test. </td></tr>
    <tr><td class="paramname">bytes_aligned</td><td>Number of bytes of alignment required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if pointer is aligned. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of object to which pointer points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stack__alloc_8hpp_source.html#l00034">34</a> of file <a class="el" href="stack__alloc_8hpp_source.html">stack_alloc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0020ce04cad9a5eb9b55abb690863fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::is_inf </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input is infinite and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespaceboost_1_1math.html#a3d7d6e376e25db9cff72f82ca4c3e684" title="Checks if the given number is infinite. ">boost::math::isinf</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is infinite. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2is__inf_8hpp_source.html#l00019">19</a> of file <a class="el" href="prim_2scal_2fun_2is__inf_8hpp_source.html">is_inf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad359149ebad087910f96e62f88287c1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::is_inf </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input's value is infinite and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespacestan_1_1math.html#ad359149ebad087910f96e62f88287c1f" title="Returns 1 if the input&#39;s value is infinite and 0 otherwise. ">stan::math::is_inf</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is infinite and <code>0</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2is__inf_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2scal_2fun_2is__inf_8hpp_source.html">is_inf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c050932da2e90902bda668170379545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::is_inf </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input's value is infinite and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespacestan_1_1math.html#ad359149ebad087910f96e62f88287c1f" title="Returns 1 if the input&#39;s value is infinite and 0 otherwise. ">stan::math::is_inf</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is infinite and <code>0</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2is__inf_8hpp_source.html#l00023">23</a> of file <a class="el" href="rev_2scal_2fun_2is__inf_8hpp_source.html">is_inf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae01488df30a81c36b1a00391b9541e1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_nan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input is NaN and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespaceboost_1_1math.html#a9ec9f6ad1870e35178068fd12a0d04ea" title="Checks if the given number is NaN. ">boost::math::isnan</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is NaN. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2is__nan_8hpp_source.html#l00018">18</a> of file <a class="el" href="prim_2scal_2fun_2is__nan_8hpp_source.html">is_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf8ef1e06cddc77c4c56311f937cc183"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_nan </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input's value is NaN and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespacestan_1_1math.html#ae01488df30a81c36b1a00391b9541e1d" title="Returns 1 if the input is NaN and 0 otherwise. ">stan::math::is_nan(double)</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Value to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is NaN and <code>0</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2is__nan_8hpp_source.html#l00021">21</a> of file <a class="el" href="rev_2scal_2fun_2is__nan_8hpp_source.html">is_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a921dd9cd85ce1a6fca79c7b07cd80b99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::is_nan </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if the input's value is NaN and 0 otherwise. </p>
<p>Delegates to <code><a class="el" href="namespacestan_1_1math.html#a921dd9cd85ce1a6fca79c7b07cd80b99" title="Returns 1 if the input&#39;s value is NaN and 0 otherwise. ">stan::math::is_nan</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the value is NaN and <code>0</code> otherwise. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2is__nan_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2scal_2fun_2is__nan_8hpp_source.html">is_nan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40c14c26dc55a985e05695b3ff1eeef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_uninitialized </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the specified variable is uninitialized. </p>
<p>Arithmetic types are always initialized by definition (the value is not specified).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified object is uninitialized. </dd>
<dd>
false if input is NaN. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2is__uninitialized_8hpp_source.html#l00019">19</a> of file <a class="el" href="prim_2scal_2fun_2is__uninitialized_8hpp_source.html">is_uninitialized.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f8d228f0969deddaf2c485f07452fd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::is_uninitialized </td>
          <td>(</td>
          <td class="paramtype">var&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the specified variable is uninitialized. </p>
<p>This overload of the <code><a class="el" href="namespacestan_1_1math.html#a40c14c26dc55a985e05695b3ff1eeef2" title="Returns true if the specified variable is uninitialized. ">stan::math::is_uninitialized()</a></code> function delegates the return to the <code><a class="el" href="namespacestan_1_1math.html#a40c14c26dc55a985e05695b3ff1eeef2" title="Returns true if the specified variable is uninitialized. ">is_uninitialized()</a></code> method on the specified variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Object to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified object is uninitialized. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2is__uninitialized_8hpp_source.html#l00023">23</a> of file <a class="el" href="rev_2scal_2fun_2is__uninitialized_8hpp_source.html">is_uninitialized.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40cb12dbca88db90b1b3f8654ea193a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::jacobian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2functor_2jacobian_8hpp_source.html#l00015">15</a> of file <a class="el" href="rev_2mat_2functor_2jacobian_8hpp_source.html">jacobian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72c855fa18077624b60fb19bfe1045b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::jacobian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2functor_2jacobian_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2mat_2functor_2jacobian_8hpp_source.html">jacobian.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02477dd575f3d242826df72489faac4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lower-bounded value for the specified unconstrained input and specified lower bound. </p>
<p>The transform applied is</p>
<p><img class="formulaInl" alt="$f(x) = \exp(x) + L$" src="form_87.png"/></p>
<p>where <img class="formulaInl" alt="$L$" src="form_9.png"/> is the constant lower bound.</p>
<p>If the lower bound is negative infinity, this function reduces to <code>identity_constrain(x)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Unconstrained scalar input. </td></tr>
    <tr><td class="paramname">lb</td><td>Lower-bound on constrained ouptut. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lower-bound constrained value correspdonding to inputs. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lb__constrain_8hpp_source.html#l00035">35</a> of file <a class="el" href="lb__constrain_8hpp_source.html">lb_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8344b3154a81f8601776582238bac99f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TL&gt;::type stan::math::lb_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lower-bounded value for the speicifed unconstrained input and specified lower bound, incrementing the specified reference with the log absolute Jacobian determinant of the transform. </p>
<p>If the lower bound is negative infinity, this function reduces to <code>identity_constraint(x, lp)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Unconstrained scalar input. </td></tr>
    <tr><td class="paramname">lb</td><td>Lower-bound on output. </td></tr>
    <tr><td class="paramname">lp</td><td>Reference to log probability to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Loer-bound constrained value corresponding to inputs. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lb__constrain_8hpp_source.html#l00061">61</a> of file <a class="el" href="lb__constrain_8hpp_source.html">lb_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e416b7c30dd2ea4fc78254732fa8a52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TL &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TL&gt;::type stan::math::lb_free </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unconstrained value that produces the specified lower-bound constrained value. </p>
<p>If the lower bound is negative infinity, it is ignored and the function reduces to <code>identity_free(y)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Input scalar. </td></tr>
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unconstrained value that produces the input when constrained. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is lower than the lower bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lb__free_8hpp_source.html#l00032">32</a> of file <a class="el" href="lb__free_8hpp_source.html">lb_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac51be9d210e223a8aa4241e2d725e295"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::lbeta </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2lbeta_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2lbeta_8hpp_source.html">lbeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ef6e7b5ed43b5410d852961a8050647"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::lbeta </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2lbeta_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2scal_2fun_2lbeta_8hpp_source.html">lbeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00c0745f2a667014a98b6113cc80b2a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::lbeta </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2lbeta_8hpp_source.html#l00038">38</a> of file <a class="el" href="fwd_2scal_2fun_2lbeta_8hpp_source.html">lbeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af37c166c79a3e66d101d682b3474f6ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::lbeta </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of the beta function applied to the specified arguments. </p>
<p>The beta function is defined for <img class="formulaInl" alt="$a > 0$" src="form_88.png"/> and <img class="formulaInl" alt="$b > 0$" src="form_89.png"/> by</p>
<p><img class="formulaInl" alt="$\mbox{B}(a, b) = \frac{\Gamma(a) \Gamma(b)}{\Gamma(a+b)}$" src="form_90.png"/>.</p>
<p>This function returns its log,</p>
<p><img class="formulaInl" alt="$\log \mbox{B}(a, b) = \log \Gamma(a) + \log \Gamma(b) - \log \Gamma(a+b)$" src="form_91.png"/>.</p>
<p>See <a class="el" href="namespacestan_1_1math.html#aead76f03bdbc60484ad760fc31bad40f">boost::math::lgamma()</a> for the double-based and <a class="el" href="namespacestan_1_1math.html" title="Matrices and templated mathematical functions. ">stan::math</a> for the variable-based log Gamma function.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lbeta}(\alpha, \beta) = \begin{cases} \ln\int_0^1 u^{\alpha - 1} (1 - u)^{\beta - 1} \, du &amp; \mbox{if } \alpha, \beta>0 \\[6pt] \textrm{NaN} &amp; \mbox{if } \alpha = \textrm{NaN or } \beta = \textrm{NaN} \end{cases} \]" src="form_92.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{lbeta}(\alpha, \beta)}{\partial \alpha} = \begin{cases} \Psi(\alpha)-\Psi(\alpha+\beta) &amp; \mbox{if } \alpha, \beta>0 \\[6pt] \textrm{NaN} &amp; \mbox{if } \alpha = \textrm{NaN or } \beta = \textrm{NaN} \end{cases} \]" src="form_93.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{lbeta}(\alpha, \beta)}{\partial \beta} = \begin{cases} \Psi(\beta)-\Psi(\alpha+\beta) &amp; \mbox{if } \alpha, \beta>0 \\[6pt] \textrm{NaN} &amp; \mbox{if } \alpha = \textrm{NaN or } \beta = \textrm{NaN} \end{cases} \]" src="form_94.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value </td></tr>
    <tr><td class="paramname">b</td><td>Second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log of the beta function applied to the two values. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first value. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second value. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2lbeta_8hpp_source.html#l00059">59</a> of file <a class="el" href="prim_2scal_2fun_2lbeta_8hpp_source.html">lbeta.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aead76f03bdbc60484ad760fc31bad40f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::lgamma </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2lgamma_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2lgamma_8hpp_source.html">lgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a836f46d7f63f5118a32cad11382c0551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::lgamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lgamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \ln\Gamma(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_95.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{lgamma}(x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \Psi(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_96.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2lgamma_8hpp_source.html#l00031">31</a> of file <a class="el" href="prim_2scal_2fun_2lgamma_8hpp_source.html">lgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21018562738b2bf94984bcb7e1c9865b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::lgamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log gamma function for variables (C99). </p>
<p>The derivatie is the digamma function,</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \Gamma(x) = \psi^{(0)}(x)$" src="form_390.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log gamma of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2lgamma_8hpp_source.html#l00035">35</a> of file <a class="el" href="rev_2scal_2fun_2lgamma_8hpp_source.html">lgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0399f5f1c54dbda27be7f12d7d888e1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_covar , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_covar, T_shape&gt;::type stan::math::lkj_corr_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__corr__cholesky__log_8hpp_source.html#l00057">57</a> of file <a class="el" href="lkj__corr__cholesky__log_8hpp_source.html">lkj_corr_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6e9853bf29b95ed22f4342bd2ac1629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_covar , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_covar, T_shape&gt;::type stan::math::lkj_corr_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__corr__cholesky__log_8hpp_source.html#l00099">99</a> of file <a class="el" href="lkj__corr__cholesky__log_8hpp_source.html">lkj_corr_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a873e4c1def8700568d76f9296bbd8d24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd stan::math::lkj_corr_cholesky_rng </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__corr__cholesky__rng_8hpp_source.html#l00054">54</a> of file <a class="el" href="lkj__corr__cholesky__rng_8hpp_source.html">lkj_corr_cholesky_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af0cb454dc9397439a74c185da61a3d5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_shape&gt;::type stan::math::lkj_corr_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__corr__log_8hpp_source.html#l00088">88</a> of file <a class="el" href="lkj__corr__log_8hpp_source.html">lkj_corr_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a015685882d7704cd76e15e5966e42b5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_shape&gt;::type stan::math::lkj_corr_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__corr__log_8hpp_source.html#l00124">124</a> of file <a class="el" href="lkj__corr__log_8hpp_source.html">lkj_corr_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a32027fc9306df3c5a0418fa44826fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd stan::math::lkj_corr_rng </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__corr__rng_8hpp_source.html#l00054">54</a> of file <a class="el" href="lkj__corr__rng_8hpp_source.html">lkj_corr_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d5d029cbf5c052432705dc9ad334df6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::lkj_cov_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_loc, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__cov__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="lkj__cov__log_8hpp_source.html">lkj_cov_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cfaea69c195f4531f7688a19fc7bd14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::lkj_cov_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_loc, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__cov__log_8hpp_source.html#l00074">74</a> of file <a class="el" href="lkj__cov__log_8hpp_source.html">lkj_cov_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5295c9eddd1e8643bb1c9fa0fb284917"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::lkj_cov_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__cov__log_8hpp_source.html#l00087">87</a> of file <a class="el" href="lkj__cov__log_8hpp_source.html">lkj_cov_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0a8d3846d804d39d6f0883e54aa2c7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::lkj_cov_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>eta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lkj__cov__log_8hpp_source.html#l00124">124</a> of file <a class="el" href="lkj__cov__log_8hpp_source.html">lkj_cov_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad46d6e08f7b6e9b9e8941572d30b104e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;typename <a class="el" href="structstan_1_1return__type.html">stan::return_type</a>&lt;T, int&gt;::type&gt; stan::math::lmgamma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2lmgamma_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2lmgamma_8hpp_source.html">lmgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f77e1a76bdde13d243f68d45c1d392b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::lmgamma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2lmgamma_8hpp_source.html#l00028">28</a> of file <a class="el" href="rev_2scal_2fun_2lmgamma_8hpp_source.html">lmgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ee0706b2cb6d2e1da2c3b6041c06a56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::lmgamma </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of the multivariate gamma function with the speciifed dimensions and argument. </p>
<p>The multivariate gamma function <img class="formulaInl" alt="$\Gamma_k(x)$" src="form_97.png"/> for dimensionality <img class="formulaInl" alt="$k$" src="form_15.png"/> and argument <img class="formulaInl" alt="$x$" src="form_98.png"/> is defined by</p>
<p><img class="formulaInl" alt="$\Gamma_k(x) = \pi^{k(k-1)/4} \, \prod_{j=1}^k \Gamma(x + (1 - j)/2)$" src="form_99.png"/>,</p>
<p>where <img class="formulaInl" alt="$\Gamma()$" src="form_100.png"/> is the gamma function.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{lmgamma}(n, x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \ln\Gamma_n(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_101.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{lmgamma}(n, x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \frac{\partial\, \ln\Gamma_n(x)}{\partial x} &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_102.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ln\Gamma_n(x) = \pi^{n(n-1)/4} \, \prod_{j=1}^n \Gamma(x + (1 - j)/2) \]" src="form_103.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \ln\Gamma_n(x)}{\partial x} = \sum_{j=1}^n \Psi(x + (1 - j) / 2) \]" src="form_104.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">x</td><td>Function argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of the multivariate gamma function. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2lmgamma_8hpp_source.html#l00057">57</a> of file <a class="el" href="prim_2scal_2fun_2lmgamma_8hpp_source.html">lmgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a915ada1e5971c467aa16ee926997a442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3b52b30a04e9a9f216b49ef06ab7a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows, int Cols&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Rows, Cols&gt; stan::math::log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, Cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element-wise logarithm of the matrix or vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ret(i, j) = log(m(i, j)) </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2log_8hpp_source.html#l00017">17</a> of file <a class="el" href="prim_2mat_2fun_2log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a236280de2603e0ead1966468f0ceea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural log of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \log x = \frac{1}{x}$" src="form_391.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0\\ \ln(x) &amp; \mbox{if } x \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_392.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0\\ \frac{1}{x} &amp; \mbox{if } x\geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_393.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable whose log is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2scal_2fun_2log_8hpp_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a808cbb5ac4003f28e2538805ebe338ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log10 </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log10_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2log10_8hpp_source.html">log10.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af56e2f9808a531946681d3644307edeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log10 </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base 10 log of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \log_{10} x = \frac{1}{x \log 10}$" src="form_394.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log10}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0\\ \log_{10}(x) &amp; \mbox{if } x \geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_395.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log10}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0\\ \frac{1}{x \ln10} &amp; \mbox{if } x\geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_396.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable whose log is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base 10 log of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log10_8hpp_source.html#l00054">54</a> of file <a class="el" href="rev_2scal_2fun_2log10_8hpp_source.html">log10.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21f4f7c092e2bc9a089885628b86c004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log10 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return natural logarithm of ten. </p>
<dl class="section return"><dt>Returns</dt><dd>Natural logarithm of ten. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00114">114</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d92a982acd829e77b3f5b975baa6aed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log1m </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log1m_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2log1m_8hpp_source.html">log1m.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5aaee0104c1b99038dda2dbb769abae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log1m </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log (1 - x) function for variables. </p>
<p>The derivative is given by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \log (1 - x) = -\frac{1}{1 - x}$" src="form_397.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variable representing log of 1 minus the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log1m_8hpp_source.html#l00032">32</a> of file <a class="el" href="rev_2scal_2fun_2log1m_8hpp_source.html">log1m.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f92092fb8a70b31d00898bbbe769612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of one minus the specified value. </p>
<p>The main use of this function is to cut down on intermediate values during algorithmic differentiation.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1m}(x) = \begin{cases} \ln(1-x) &amp; \mbox{if } x \leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_105.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log1m}(x)}{\partial x} = \begin{cases} -\frac{1}{1-x} &amp; \mbox{if } x \leq 1 \\ \textrm{NaN} &amp; \mbox{if } x > 1\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_106.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of one minus <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log1m_8hpp_source.html#l00040">40</a> of file <a class="el" href="prim_2scal_2fun_2log1m_8hpp_source.html">log1m.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7760d28e8fddf268113469b44463de07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log1m_exp </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log1m__exp_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2log1m__exp_8hpp_source.html">log1m_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab62e8d3067ce13dea1b2ee4f38618b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log1m_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of 1 minus the exponential of the specified variable. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log1m__exp_8hpp_source.html#l00033">33</a> of file <a class="el" href="rev_2scal_2fun_2log1m__exp_8hpp_source.html">log1m_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce261caf05bd371c430e82a0e6389a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m_exp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log of 1 minus the exponential of the specified value without overflow log1m_exp(x) = log(1-exp(x)). </p>
<p>This function is only defined for x&lt;0</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1m\_exp}(x) = \begin{cases} \ln(1-\exp(x)) &amp; \mbox{if } x < 0 \\ \textrm{NaN} &amp; \mbox{if } x \geq 0\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_107.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{asinh}(x)}{\partial x} = \begin{cases} -\frac{\exp(x)}{1-\exp(x)} &amp; \mbox{if } x < 0 \\ \textrm{NaN} &amp; \mbox{if } x \geq 0\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_108.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2log1m__exp_8hpp_source.html#l00041">41</a> of file <a class="el" href="prim_2scal_2fun_2log1m__exp_8hpp_source.html">log1m_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79f286f8a9043aee8a1a844493da0d55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log1m_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log1m__inv__logit_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2log1m__inv__logit_8hpp_source.html">log1m_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7f71c696a5e0da4daab30e5f3704842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1m_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the natural logarithm of 1 minus the inverse logit of the specified argument. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1m\_inv\_logit}(x) = \begin{cases} -\ln(\exp(x)+1) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_109.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log1m\_inv\_logit}(x)}{\partial x} = \begin{cases} -\frac{\exp(x)}{\exp(x)+1} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_110.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log of 1 minus the inverse logit of the input. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log1m__inv__logit_8hpp_source.html#l00036">36</a> of file <a class="el" href="prim_2scal_2fun_2log1m__inv__logit_8hpp_source.html">log1m_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa16e57e82fb1e17f74ef43592748ff32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log1p </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log1p_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2log1p_8hpp_source.html">log1p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9851bec44891899ceacfc17ef6e86b21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log1p </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The log (1 + x) function for variables (C99). </p>
<p>The derivative is given by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \log (1 + x) = \frac{1}{1 + x}$" src="form_398.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of 1 plus the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log1p_8hpp_source.html#l00034">34</a> of file <a class="el" href="rev_2scal_2fun_2log1p_8hpp_source.html">log1p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5166d3c58ad8ce0aedbf104179888b69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1p </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of one plus the specified value. </p>
<p>The main use of this function is to cut down on intermediate values during algorithmic differentiation.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1p}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \ln(1+x)&amp; \mbox{if } x\geq -1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_111.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log1p}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < -1\\ \frac{1}{1+x} &amp; \mbox{if } x\geq -1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_112.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Natural log of one plus <code>x</code>. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log1p_8hpp_source.html#l00039">39</a> of file <a class="el" href="prim_2scal_2fun_2log1p_8hpp_source.html">log1p.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0fe928ad2b96b802f6d488ba43167489"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log1p_exp </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log1p__exp_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2scal_2fun_2log1p__exp_8hpp_source.html">log1p_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abaffb88be27fafab634c74e14508e0f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log1p_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log of 1 plus the exponential of the specified variable. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log1p__exp_8hpp_source.html#l00028">28</a> of file <a class="el" href="rev_2scal_2fun_2log1p__exp_8hpp_source.html">log1p_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88151def26813dec3e04c4a8b9674091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log1p_exp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log of 1 plus the exponential of the specified value without overflow. </p>
<p>This function is related to other special functions by:</p>
<p><code>log1p_exp(x) </code></p>
<p><code> = log1p(exp(a))</code></p>
<p><code> = log(1 + exp(x))</code></p>
<p><code> = log_sum_exp(0, x)</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log1p\_exp}(x) = \begin{cases} \ln(1+\exp(x)) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_113.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log1p\_exp}(x)}{\partial x} = \begin{cases} \frac{\exp(x)}{1+\exp(x)} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_114.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2log1p__exp_8hpp_source.html#l00044">44</a> of file <a class="el" href="prim_2scal_2fun_2log1p__exp_8hpp_source.html">log1p_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4eea39b4ca603cff7518068499884364"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log2 </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log2_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2scal_2fun_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa25e1572bf46e3a6b9ee270f0c7e2c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log2 </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the base 2 logarithm of the argument (C99). </p>
<p>The function is defined by:</p>
<p><code>log2(a) = log(a) / std::log(2.0)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base 2 logarithm of the value. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log2_8hpp_source.html#l00025">25</a> of file <a class="el" href="prim_2scal_2fun_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a947ba3fe3c87293f7c57395007100c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return natural logarithm of two. </p>
<dl class="section return"><dt>Returns</dt><dd>Natural logarithm of two. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log2_8hpp_source.html#l00035">35</a> of file <a class="el" href="prim_2scal_2fun_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6322be7704b2efc1e36951b46bb88568"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the base 2 logarithm of the specified variable (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#a4eea39b4ca603cff7518068499884364">stan::math::log2()</a> for the double-based version.</p>
<p>The derivative is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \log_2 x = \frac{1}{x \log 2}$" src="form_399.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log2}(x) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0 \\ \log_2(x) &amp; \mbox{if } x\geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_400.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log2}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x < 0 \\ \frac{1}{x\ln2} &amp; \mbox{if } x\geq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_401.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Specified variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base 2 logarithm of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log2_8hpp_source.html#l00053">53</a> of file <a class="el" href="rev_2scal_2fun_2log2_8hpp_source.html">log2.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae83dcd77f80cb38f31af8c5284370112"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2log__determinant_8hpp_source.html#l00013">13</a> of file <a class="el" href="rev_2mat_2fun_2log__determinant_8hpp_source.html">log_determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca29dad18932e3ca17ac52fd0238b364"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log absolute determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log absolute determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2log__determinant_8hpp_source.html#l00018">18</a> of file <a class="el" href="prim_2mat_2fun_2log__determinant_8hpp_source.html">log_determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f88bd206be351748e56aebf7e58289a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_determinant </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2log__determinant_8hpp_source.html#l00020">20</a> of file <a class="el" href="fwd_2mat_2fun_2log__determinant_8hpp_source.html">log_determinant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d95f632b80e8653fe5891209bdeda45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant_ldlt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2log__determinant__ldlt_8hpp_source.html#l00012">12</a> of file <a class="el" href="prim_2mat_2fun_2log__determinant__ldlt_8hpp_source.html">log_determinant_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc785decbbbee8de2a2b8f2df9715d48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_determinant_ldlt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2log__determinant__ldlt_8hpp_source.html#l00048">48</a> of file <a class="el" href="rev_2mat_2fun_2log__determinant__ldlt_8hpp_source.html">log_determinant_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18ff74da7a827b5e433fc8d65d8b73e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_determinant_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2log__determinant__spd_8hpp_source.html#l00015">15</a> of file <a class="el" href="rev_2mat_2fun_2log__determinant__spd_8hpp_source.html">log_determinant_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a296d4414d0193108c70b350a05cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_determinant_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log absolute determinant of the specified square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log absolute determinant of the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2log__determinant__spd_8hpp_source.html#l00019">19</a> of file <a class="el" href="prim_2mat_2fun_2log__determinant__spd_8hpp_source.html">log_determinant_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ba84f8c43b399f555647a0402a710ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__diff__exp_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34180da33deb01d13fcf6c5907d1309e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T2&gt; stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__diff__exp_8hpp_source.html#l00026">26</a> of file <a class="el" href="fwd_2scal_2fun_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a246fe73ae519573f2232d2f44ac379be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T1&gt; stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__diff__exp_8hpp_source.html#l00037">37</a> of file <a class="el" href="fwd_2scal_2fun_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43fccfff5553aa860351a147ab10e301"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__diff__exp_8hpp_source.html#l00049">49</a> of file <a class="el" href="rev_2scal_2fun_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a685dbad032c2794fbc8bca7f44119eab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The natural logarithm of the difference of the natural exponentiation of x1 and the natural exponentiation of x2. </p>
<p>This function is only defined for x&lt;0</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_diff\_exp}(x, y) = \begin{cases} \textrm{NaN} &amp; \mbox{if } x \leq y\\ \ln(\exp(x)-\exp(y)) &amp; \mbox{if } x > y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_115.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_diff\_exp}(x, y)}{\partial x} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x \leq y\\ \frac{\exp(x)}{\exp(x)-\exp(y)} &amp; \mbox{if } x > y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_116.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_diff\_exp}(x, y)}{\partial y} = \begin{cases} \textrm{NaN} &amp; \mbox{if } x \leq y\\ -\frac{\exp(y)}{\exp(x)-\exp(y)} &amp; \mbox{if } x > y \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_117.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2log__diff__exp_8hpp_source.html#l00050">50</a> of file <a class="el" href="prim_2scal_2fun_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a09bd43a4ade10703b6a1fb521d09e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__diff__exp_8hpp_source.html#l00056">56</a> of file <a class="el" href="rev_2scal_2fun_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03afe35a61cd6068465799e22d600879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_diff_exp </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__diff__exp_8hpp_source.html#l00063">63</a> of file <a class="el" href="rev_2scal_2fun_2log__diff__exp_8hpp_source.html">log_diff_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58e4116dfd00db87062ef7c0f76e8c27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__falling__factorial_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f457257e68af25bdccd60c4da5c1449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__falling__factorial_8hpp_source.html#l00025">25</a> of file <a class="el" href="fwd_2scal_2fun_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50150f9605147c167f749bf31c9e42a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__falling__factorial_8hpp_source.html#l00035">35</a> of file <a class="el" href="fwd_2scal_2fun_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd407ae0bf698d58b8e59e580749e705"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_falling\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln (x)_n &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_118.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_falling\_factorial}(x, n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \Psi(x) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_119.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_falling\_factorial}(x, n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ -\Psi(n) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_120.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2log__falling__factorial_8hpp_source.html#l00041">41</a> of file <a class="el" href="prim_2scal_2fun_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f5951b9e0e640a8f2f53348015387c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__falling__factorial_8hpp_source.html#l00062">62</a> of file <a class="el" href="rev_2scal_2fun_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a6fbe2cf74d7dc89d10999d512c3efd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__falling__factorial_8hpp_source.html#l00067">67</a> of file <a class="el" href="rev_2scal_2fun_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a599bc1031e28ecc3cc192b07bdced6ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_falling_factorial </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__falling__factorial_8hpp_source.html#l00072">72</a> of file <a class="el" href="rev_2scal_2fun_2log__falling__factorial_8hpp_source.html">log_falling_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd2fe56bce70a04dd11e8a5a32b1b51c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__inv__logit_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2log__inv__logit_8hpp_source.html">log_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5be889d1ef4284654a04e400f5371a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::log_inv_logit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the natural logarithm of the inverse logit of the specified argument. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_inv\_logit}(x) = \begin{cases} \ln\left(\frac{1}{1+\exp(-x)}\right)&amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_121.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_inv\_logit}(x)}{\partial x} = \begin{cases} \frac{1}{1+\exp(x)} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_122.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log of the inverse logit of the input. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log__inv__logit_8hpp_source.html#l00036">36</a> of file <a class="el" href="prim_2scal_2fun_2log__inv__logit_8hpp_source.html">log_inv_logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4e08116b9ebf4a6592aa9f8fa393669"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::log_inv_logit_diff </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ordered__logistic__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="ordered__logistic__log_8hpp_source.html">ordered_logistic_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b7b9cda7f1b3234cc4b3fc20e595482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log mixture density with specified mixing proportion and log densities. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \log \left( \theta \lambda_1 + (1 - \theta) \lambda_2 \right). \]" src="form_123.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \theta} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = FIXME \]" src="form_124.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_1} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = FIXME \]" src="form_125.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_2} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = FIXME \]" src="form_126.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>mixing proportion in [0, 1]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda1</td><td>first log density. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda2</td><td>second log density. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log mixture of densities in specified proportion </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log__mix_8hpp_source.html#l00046">46</a> of file <a class="el" href="prim_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91f87ac712232f684f398ff5e5865887"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_theta, T_lambda1, T_lambda2&gt;::type stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const T_theta &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_lambda1 &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_lambda2 &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log mixture density with specified mixing proportion and log densities and its derivative at each. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \log \left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right). \]" src="form_4.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \theta} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \dfrac{\exp(\lambda_1) - \exp(\lambda_2)} {\left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right)} \]" src="form_5.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_1} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \dfrac{\theta \exp(\lambda_1)} {\left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right)} \]" src="form_6.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_2} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \dfrac{\theta \exp(\lambda_2)} {\left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right)} \]" src="form_7.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_theta</td><td>theta scalar type. </td></tr>
    <tr><td class="paramname">T_lambda1</td><td>lambda1 scalar type. </td></tr>
    <tr><td class="paramname">T_lambda2</td><td>lambda2 scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>mixing proportion in [0, 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda1</td><td>first log density. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda2</td><td>second log density. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log mixture of densities in specified proportion </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__mix_8hpp_source.html#l00088">88</a> of file <a class="el" href="rev_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a014f4431773309ae7fd1420b0f6aa99f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the log mixture density with specified mixing proportion and log densities and its derivative at each. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \log \left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right). \]" src="form_4.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \theta} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \dfrac{\exp(\lambda_1) - \exp(\lambda_2)} {\left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right)} \]" src="form_5.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_1} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \dfrac{\theta \exp(\lambda_1)} {\left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right)} \]" src="form_6.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial}{\partial \lambda_2} \mbox{log\_mix}(\theta, \lambda_1, \lambda_2) = \dfrac{\theta \exp(\lambda_2)} {\left( \theta \exp(\lambda_1) + (1 - \theta) \exp(\lambda_2) \right)} \]" src="form_7.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>mixing proportion in [0, 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda1</td><td>first log density. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda2</td><td>second log density.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log mixture of densities in specified proportion </dd></dl>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00116">116</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed956136160f52953529970a3ae4ef40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00142">142</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53f58fdf08759c58af217840a92ed4e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00167">167</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd1210cb19932c4552f899d1582929e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00192">192</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a780462344be6c31a646da6cfbeb6c421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00216">216</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebd9e68e3b8dc002039c1afda1dce392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00237">237</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35eaca2241efa84971cb2aaa4efacbb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_mix </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00258">258</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b3e6e5267f60e3537dd8bdd0299a3ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::log_mix_partial_helper </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lambda1_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>lambda2_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>one_m_exp_lam2_m_lam1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>one_m_t_prod_exp_lam2_m_lam1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>one_d_t_plus_one_m_t_prod_exp_lam2_m_lam1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__mix_8hpp_source.html#l00028">28</a> of file <a class="el" href="rev_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c93f2640b5f95b586b9521b09e52c31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::log_mix_partial_helper </td>
          <td>(</td>
          <td class="paramtype">const T_theta &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_lambda1 &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_lambda2 &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename promote_args&lt; T_theta, T_lambda1, T_lambda2 &gt;::type(&amp;)&#160;</td>
          <td class="paramname"><em>partials_array</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html#l00031">31</a> of file <a class="el" href="fwd_2scal_2fun_2log__mix_8hpp_source.html">log_mix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4aff0dd42a2b0b33ac55e9a45f35b1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__rising__factorial_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08d954744a945ff1f82a27d2eedb887f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__rising__factorial_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2scal_2fun_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ab4f0019045b98139b0626204e8f2a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__rising__factorial_8hpp_source.html#l00039">39</a> of file <a class="el" href="fwd_2scal_2fun_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05002f0d4de2c84705dc2bbadfce6b6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_rising\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \ln x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_127.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_rising\_factorial}(x, n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \Psi(x+n) - \Psi(x) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_128.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_rising\_factorial}(x, n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \Psi(x+n) &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_129.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2log__rising__factorial_8hpp_source.html#l00041">41</a> of file <a class="el" href="prim_2scal_2fun_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6353b21fe0f6314e677e0c0ec1d27e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__rising__factorial_8hpp_source.html#l00049">49</a> of file <a class="el" href="rev_2scal_2fun_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57ff05bb4af6475162c98f06f5ccd186"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__rising__factorial_8hpp_source.html#l00054">54</a> of file <a class="el" href="rev_2scal_2fun_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b4b56e93a461861d24468412ec75a3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__rising__factorial_8hpp_source.html#l00059">59</a> of file <a class="el" href="rev_2scal_2fun_2log__rising__factorial_8hpp_source.html">log_rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a558975cc79251cd99966f99ed8795ddc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, Eigen::Dynamic, 1&gt; stan::math::log_softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2log__softmax_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2mat_2fun_2log__softmax_8hpp_source.html">log_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f60a82d68ef90f7cd5e9f02f121a5d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::log_softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the natural logarithm of the softmax of the specified vector. </p>
<p><img class="formulaInl" alt="$ \log \mbox{softmax}(y) \ = \ y - \log \sum_{k=1}^K \exp(y_k) \ = \ y - \mbox{log\_sum\_exp}(y). $" src="form_16.png"/></p>
<p>For the log softmax function, the entries in the Jacobian are <img class="formulaInl" alt="$ \frac{\partial}{\partial y_m} \mbox{softmax}(y)[k] = \left\{ \begin{array}{ll} 1 - \mbox{softmax}(y)[m] &amp; \mbox{ if } m = k, \mbox{ and} \\[6pt] \mbox{softmax}(y)[m] &amp; \mbox{ if } m \neq k. \end{array} \right. $" src="form_17.png"/></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of values in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit simplex result of the softmax transform of the vector. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2log__softmax_8hpp_source.html#l00044">44</a> of file <a class="el" href="prim_2mat_2fun_2log__softmax_8hpp_source.html">log_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a443bda462051b08fcd0274c3ae1c73aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, Eigen::Dynamic, 1&gt; stan::math::log_softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the softmax of the specified <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector. </p>
<p>Softmax is guaranteed to return a simplex.</p>
<p>The gradient calculations are unfolded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Unconstrained input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Softmax of the input. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the input vector is size 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2log__softmax_8hpp_source.html#l00061">61</a> of file <a class="el" href="rev_2mat_2fun_2log__softmax_8hpp_source.html">log_softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac86474622fba4524c529c4b8024e4ceb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2arr_2fun_2log__sum__exp_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2arr_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a177e64b45d304afc52540d776de8dbe1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__sum__exp_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34a4bb0a8db85be07d98d3b2e2fc96c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2log__sum__exp_8hpp_source.html#l00019">19</a> of file <a class="el" href="fwd_2mat_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e67f9b1692743a9db4462e98bb49ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the sum of the exponentiated values of the specified sequence of values. </p>
<p>The function is defined as follows to prevent overflow in exponential calculations.</p>
<p><img class="formulaInl" alt="$\log \sum_{n=1}^N \exp(x_n) = \max(x) + \log \sum_{n=1}^N \exp(x_n - \max(x))$" src="form_8.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array of specified values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the sum of the exponentiated vector values. </dd></dl>

<p>Definition at line <a class="el" href="prim_2arr_2fun_2log__sum__exp_8hpp_source.html#l00024">24</a> of file <a class="el" href="prim_2arr_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0497ca733bb52ba08323b12ed654bc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__sum__exp_8hpp_source.html#l00026">26</a> of file <a class="el" href="fwd_2scal_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1fb47266493c7da21a6508944d65bdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the sum of the exponentiated values of the specified matrix of values. </p>
<p>The matrix may be a full matrix, a vector, or a row vector.</p>
<p>The function is defined as follows to prevent overflow in exponential calculations.</p>
<p><img class="formulaInl" alt="$\log \sum_{n=1}^N \exp(x_n) = \max(x) + \log \sum_{n=1}^N \exp(x_n - \max(x))$" src="form_8.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix of specified values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the sum of the exponentiated vector values. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2log__sum__exp_8hpp_source.html#l00028">28</a> of file <a class="el" href="prim_2mat_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab43880eef5d3a9017c9ab46fa2d1ef65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2log__sum__exp_8hpp_source.html#l00036">36</a> of file <a class="el" href="fwd_2scal_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add3072490832a96e50ca3143e4226e67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; var &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>

<p>Definition at line <a class="el" href="rev_2arr_2fun_2log__sum__exp_8hpp_source.html#l00045">45</a> of file <a class="el" href="rev_2arr_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a554e6f04e24049b7fe6e56f60abbc560"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the log sum of exponetials without overflow. </p>
<p><img class="formulaInl" alt="$\log (\exp(a) + \exp(b)) = m + \log(\exp(a-m) + \exp(b-m))$" src="form_130.png"/>,</p>
<p>where <img class="formulaInl" alt="$m = max(a, b)$" src="form_131.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{log\_sum\_exp}(x, y) = \begin{cases} \ln(\exp(x)+\exp(y)) &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_132.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_sum\_exp}(x, y)}{\partial x} = \begin{cases} \frac{\exp(x)}{\exp(x)+\exp(y)} &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_133.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{log\_sum\_exp}(x, y)}{\partial y} = \begin{cases} \frac{\exp(y)}{\exp(x)+\exp(y)} &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_134.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first variable </td></tr>
    <tr><td class="paramname">b</td><td>the second variable </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2log__sum__exp_8hpp_source.html#l00048">48</a> of file <a class="el" href="prim_2scal_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50e133913e946710e85efc00306a2610"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__sum__exp_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2scal_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa99a093a231daf213b589a2c96644fd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2log__sum__exp_8hpp_source.html#l00054">54</a> of file <a class="el" href="rev_2mat_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c2ea975711d2420728cce2878bca93c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__sum__exp_8hpp_source.html#l00057">57</a> of file <a class="el" href="rev_2scal_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04418b73a6d6efd660a67d9af4546840"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::log_sum_exp </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the log sum of exponentials. </p>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2log__sum__exp_8hpp_source.html#l00064">64</a> of file <a class="el" href="rev_2scal_2fun_2log__sum__exp_8hpp_source.html">log_sum_exp.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc35bab2db89b3ceda66f11e1fa53ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_and </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise. </p>
<p>Equivalent to <code>x1 != 0 &amp;&amp; x2 != 0</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator\&amp;\&amp;}(x, y) = \begin{cases} 0 &amp; \mbox{if } x = 0 \textrm{ or } y=0 \\ 1 &amp; \mbox{if } x, y \neq 0 \\[6pt] 1 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_135.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both x1 and x2 are not equal to 0. </dd></dl>

<p>Definition at line <a class="el" href="logical__and_8hpp_source.html#l00030">30</a> of file <a class="el" href="logical__and_8hpp_source.html">logical_and.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2213736b55fd6696fa0120fd3fe72e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_eq </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is equal to the second. </p>
<p>Equivalent to <code>x1 == x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 == x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__eq_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__eq_8hpp_source.html">logical_eq.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba86bfd994302061a0260e1202fca777"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_gt </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is strictly greater than the second. </p>
<p>Equivalent to <code>x1 &lt; x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &gt; x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__gt_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__gt_8hpp_source.html">logical_gt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6bb0b8623192207d35e207ea312d8be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_gte </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is greater than or equal to the second. </p>
<p>Equivalent to <code>x1 &gt;= x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &gt;= x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__gte_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__gte_8hpp_source.html">logical_gte.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b5bd91412749e10933f304b54aef88f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_lt </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is strictly less than the second. </p>
<p>Equivalent to <code>x1 &lt; x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &lt; x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__lt_8hpp_source.html#l00020">20</a> of file <a class="el" href="logical__lt_8hpp_source.html">logical_lt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3649d4c704962c4502cd6220a5e2230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_lte </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is less than or equal to the second. </p>
<p>Equivalent to <code>x1 &lt;= x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 &lt;= x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__lte_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__lte_8hpp_source.html">logical_lte.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad2fc9ce55dfac079d930335beb7e4a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_negation </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical negation function which returns 1 if the input is equal to zero and 0 otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to compare to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Value to compare to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if input is equal to zero. </dd></dl>

<p>Definition at line <a class="el" href="logical__negation_8hpp_source.html#l00017">17</a> of file <a class="el" href="logical__negation_8hpp_source.html">logical_negation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a206eb210d8e7e2c718af25c40de8f9d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_neq </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 1 if the first argument is unequal to the second. </p>
<p>Equivalent to <code>x1 != x2</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff <code>x1 != x2</code> </dd></dl>

<p>Definition at line <a class="el" href="logical__neq_8hpp_source.html#l00019">19</a> of file <a class="el" href="logical__neq_8hpp_source.html">logical_neq.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac74007e2d5f55d5ae4a308f535869aee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::logical_or </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise. </p>
<p>Equivalent to <code>x1 != 0 || x2 != 0</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator||}(x, y) = \begin{cases} 0 &amp; \mbox{if } x, y=0 \\ 1 &amp; \mbox{if } x \neq 0 \textrm{ or } y\neq0\\[6pt] 1 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_136.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>First argument </td></tr>
    <tr><td class="paramname">x2</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if either x1 or x2 is not equal to 0. </dd></dl>

<p>Definition at line <a class="el" href="logical__or_8hpp_source.html#l00029">29</a> of file <a class="el" href="logical__or_8hpp_source.html">logical_or.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fd36ac96595c375db7fddc885c30794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::logistic_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="logistic__ccdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="logistic__ccdf__log_8hpp_source.html">logistic_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e1ca40295978d785324b33f3a78c96b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::logistic_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="logistic__cdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="logistic__cdf_8hpp_source.html">logistic_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88d9fcb73b6a1d04896031edc0d8e510"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::logistic_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="logistic__cdf__log_8hpp_source.html#l00030">30</a> of file <a class="el" href="logistic__cdf__log_8hpp_source.html">logistic_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a431d5fcf935535cbe08981286652d57b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::logistic_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="logistic__log_8hpp_source.html#l00032">32</a> of file <a class="el" href="logistic__log_8hpp_source.html">logistic_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35fdf5c03ed2e39d081df54372622eec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::logistic_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="logistic__log_8hpp_source.html#l00142">142</a> of file <a class="el" href="logistic__log_8hpp_source.html">logistic_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9fc8e75fbb17cb5f22079e90fac128b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::logistic_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="logistic__rng_8hpp_source.html#l00027">27</a> of file <a class="el" href="logistic__rng_8hpp_source.html">logistic_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab025eaf1e6f5c920f69c37e7a7f8b319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::logit </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2logit_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2scal_2fun_2logit_8hpp_source.html">logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53342d0c2cd3a6e440c533070054aca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::logit </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logit function applied to the argument. </p>
<p>The logit function is defined as for <img class="formulaInl" alt="$x \in [0, 1]$" src="form_137.png"/> by returning the log odds of <img class="formulaInl" alt="$x$" src="form_98.png"/> treated as a probability,</p>
<p><img class="formulaInl" alt="$\mbox{logit}(x) = \log \left( \frac{x}{1 - x} \right)$" src="form_138.png"/>.</p>
<p>The inverse to this function is <code><a class="el" href="namespacestan_1_1math.html#a76a22ee34432be58edb4b6ed9469370a">stan::math::inv_logit</a></code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{logit}(x) = \begin{cases} \textrm{NaN}&amp; \mbox{if } x < 0 \textrm{ or } x > 1\\ \ln\frac{x}{1-x} &amp; \mbox{if } 0\leq x \leq 1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_139.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{logit}(x)}{\partial x} = \begin{cases} \textrm{NaN}&amp; \mbox{if } x < 0 \textrm{ or } x > 1\\ \frac{1}{x-x^2}&amp; \mbox{if } 0\leq x\leq 1 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_140.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logit of the argument. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2logit_8hpp_source.html#l00044">44</a> of file <a class="el" href="prim_2scal_2fun_2logit_8hpp_source.html">logit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afacb0f2c6b58bc55e506f3bfcf9ba829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::lognormal_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lognormal__ccdf__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="lognormal__ccdf__log_8hpp_source.html">lognormal_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9536cc20905aca8f393138adbe71bb73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::lognormal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lognormal__cdf_8hpp_source.html#l00023">23</a> of file <a class="el" href="lognormal__cdf_8hpp_source.html">lognormal_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a771406ab16c52532e52bebc21c31f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::lognormal_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lognormal__cdf__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="lognormal__cdf__log_8hpp_source.html">lognormal_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a623bb0aad5e3d872d52d0443a46ad270"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::lognormal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lognormal__log_8hpp_source.html#l00033">33</a> of file <a class="el" href="lognormal__log_8hpp_source.html">lognormal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bfc3796274f4ccd677f96792551c127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::lognormal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lognormal__log_8hpp_source.html#l00158">158</a> of file <a class="el" href="lognormal__log_8hpp_source.html">lognormal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5a619e160ca64fff9f2d69b32bf69b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::lognormal_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lognormal__rng_8hpp_source.html#l00022">22</a> of file <a class="el" href="lognormal__rng_8hpp_source.html">lognormal_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5cc0ef5cf22dda83988c062b529dc3a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TL, TU&gt;::type stan::math::lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TU&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the lower- and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds. </p>
<p>The transform is the transformed and scaled inverse logit,</p>
<p><img class="formulaInl" alt="$f(x) = L + (U - L) \mbox{logit}^{-1}(x)$" src="form_141.png"/></p>
<p>If the lower bound is negative infinity and upper bound finite, this function reduces to <code>ub_constrain(x, ub)</code>. If the upper bound is positive infinity and the lower bound finite, this function reduces to <code>lb_constrain(x, lb)</code>. If the upper bound is positive infinity and the lower bound negative infinity, this function reduces to <code>identity_constrain(x)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar to transform. </td></tr>
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lower- and upper-bounded scalar derived from transforming the free scalar. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if ub &lt;= lb </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lub__constrain_8hpp_source.html#l00044">44</a> of file <a class="el" href="lub__constrain_8hpp_source.html">lub_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab51cc5fe98ac938435e614765e30655a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TL , typename TU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TL, TU&gt;::type stan::math::lub_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the lower- and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds and increment the specified log probability with the log absolute Jacobian determinant. </p>
<p>The transform is as defined in <code>lub_constrain(T, double, double)</code>. The log absolute Jacobian determinant is given by</p>
<p><img class="formulaInl" alt="$\log \left| \frac{d}{dx} \left( L + (U-L) \mbox{logit}^{-1}(x) \right) \right|$" src="form_142.png"/></p>
<p><img class="formulaInl" alt="$ {} = \log | (U-L) \, (\mbox{logit}^{-1}(x)) \, (1 - \mbox{logit}^{-1}(x)) |$" src="form_143.png"/></p>
<p><img class="formulaInl" alt="$ {} = \log (U - L) + \log (\mbox{logit}^{-1}(x)) + \log (1 - \mbox{logit}^{-1}(x))$" src="form_144.png"/></p>
<p>If the lower bound is negative infinity and upper bound finite, this function reduces to <code>ub_constrain(x, ub, lp)</code>. If the upper bound is positive infinity and the lower bound finite, this function reduces to <code>lb_constrain(x, lb, lp)</code>. If the upper bound is positive infinity and the lower bound negative infinity, this function reduces to <code>identity_constrain(x, lp)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar to transform. </td></tr>
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability scalar reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lower- and upper-bounded scalar derived from transforming the free scalar. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TL</td><td>Type of lower bound. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if ub &lt;= lb </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lub__constrain_8hpp_source.html#l00114">114</a> of file <a class="el" href="lub__constrain_8hpp_source.html">lub_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9fa09fdc448652a57d364d70d6e88e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TL , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TL, TU&gt;::type stan::math::lub_free </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TL&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TU&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unconstrained scalar that transforms to the specified lower- and upper-bounded scalar given the specified bounds. </p>
<p>The transfrom in <code>lub_constrain(T, double, double)</code>, is reversed by a transformed and scaled logit,</p>
<p><img class="formulaInl" alt="$f^{-1}(y) = \mbox{logit}(\frac{y - L}{U - L})$" src="form_145.png"/></p>
<p>where <img class="formulaInl" alt="$U$" src="form_146.png"/> and <img class="formulaInl" alt="$L$" src="form_9.png"/> are the lower and upper bounds.</p>
<p>If the lower bound is negative infinity and upper bound finite, this function reduces to <code>ub_free(y, ub)</code>. If the upper bound is positive infinity and the lower bound finite, this function reduces to <code>lb_free(x, lb)</code>. If the upper bound is positive infinity and the lower bound negative infinity, this function reduces to <code>identity_free(y)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Scalar input. </td></tr>
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The free scalar that transforms to the input scalar given the bounds. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the lower bound is greater than the upper bound, y is less than the lower bound, or y is greater than the upper bound </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lub__free_8hpp_source.html#l00047">47</a> of file <a class="el" href="lub__free_8hpp_source.html">lub_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a173839dddd0a8ac8afa710b9e3d5008a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::machine_precision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the difference between 1.0 and the next value representable. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum positive number. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00151">151</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71d39c88943f3fb8e45759c62d68953b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Array&lt;T, Eigen::Dynamic, 1&gt; stan::math::make_nu </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the degrees of freedom for the t distribution that corresponds to the shape parameter in the Lewandowski et. </p>
<p>al. distribution</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eta</td><td>hyperparameter on (0, inf), eta = 1 &lt;-&gt; correlation matrix is uniform </td></tr>
    <tr><td class="paramname">K</td><td>number of variables in covariance matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="make__nu_8hpp_source.html#l00022">22</a> of file <a class="el" href="make__nu_8hpp_source.html">make_nu.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3feb895ef1190ad6e77185e70a3fa66d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_Mu, T_Sigma, T_D&gt;::type stan::math::matrix_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_Mu, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_Sigma, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_D, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the matrix normal density for the given y, mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>An mxn matrix. </td></tr>
    <tr><td class="paramname">Mu</td><td>The mean matrix. </td></tr>
    <tr><td class="paramname">Sigma</td><td>The mxm inverse covariance matrix (i.e., the precision matrix) of the rows of y. </td></tr>
    <tr><td class="paramname">D</td><td>The nxn inverse covariance matrix (i.e., the precision matrix) of the columns of y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the matrix normal density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma or D are not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_Mu</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_Sigma</td><td>Type of Sigma. </td></tr>
    <tr><td class="paramname">T_D</td><td>Type of D. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix__normal__prec__log_8hpp_source.html#l00043">43</a> of file <a class="el" href="matrix__normal__prec__log_8hpp_source.html">matrix_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add509bb48f33e775f906f8e9e0c0c4f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_Mu , typename T_Sigma , typename T_D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_Mu, T_Sigma, T_D&gt;::type stan::math::matrix_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_Mu, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_Sigma, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_D, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix__normal__prec__log_8hpp_source.html#l00112">112</a> of file <a class="el" href="matrix__normal__prec__log_8hpp_source.html">matrix_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5da0ef87756d3dbd20ca4ff5a3efa10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the size of the vector is zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="max_8hpp_source.html#l00021">21</a> of file <a class="el" href="max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acde414919e0e4dcfa72d565679819091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="max_8hpp_source.html#l00039">39</a> of file <a class="el" href="max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f299773dc20e8305fc16df1be8d029"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::max </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum coefficient in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector, or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum coefficient value in the vector. </dd></dl>

<p>Definition at line <a class="el" href="max_8hpp_source.html#l00056">56</a> of file <a class="el" href="max_8hpp_source.html">max.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f50d0ea5c9343dae0945012924f127c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__left_8hpp_source.html#l00024">24</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78e254b9ffb28a6fe6820f9f84412907"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__left_8hpp_source.html#l00025">25</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b9c580ecf4fc5b7a9e7523325a6cbe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__left_8hpp_source.html#l00068">68</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a933154f105a6d18864cfca8a8e2ff12c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__left_8hpp_source.html#l00094">94</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef0d163d45e4ee75444257dea341b731"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left_8hpp_source.html#l00274">274</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6f9550fa3c3a000d8fb1657681d7ecb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left_8hpp_source.html#l00301">301</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0203466ed040dd643c8b6d4a78d7f53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left_8hpp_source.html#l00328">328</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left_8hpp_source.html">mdivide_left.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63890dd40cd8ad08a55c3b4e8616c741"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T2&gt;, R1, C2&gt; stan::math::mdivide_left_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T2 &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html#l00025">25</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html">mdivide_left_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d06ecbc0a8e5cc50c42861bb20f1b0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_left_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html#l00026">26</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html">mdivide_left_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84f1163f092f8ce7053a67d3d46302ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html#l00246">246</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html">mdivide_left_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a4be1cd5b51a7d2758a75e9541ad042"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html#l00274">274</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html">mdivide_left_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed166703ba12f63c6cad94e0cc5a6f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html#l00302">302</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__ldlt_8hpp_source.html">mdivide_left_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af0e78140ced17ce9be79c29b9f23321b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_left_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b where A is symmetric positive definite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__left__spd_8hpp_source.html#l00028">28</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__left__spd_8hpp_source.html">mdivide_left_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ba7ed90b8091cf3dee35b9d4688cbc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__spd_8hpp_source.html#l00248">248</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__spd_8hpp_source.html">mdivide_left_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3487ef4bdd1b20d8d5e5f7d5ff57738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__spd_8hpp_source.html#l00275">275</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__spd_8hpp_source.html">mdivide_left_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b8412be81e5c41c2b59e761476ac82a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__spd_8hpp_source.html#l00302">302</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__spd_8hpp_source.html">mdivide_left_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ef591181f40598fd3c012c6e5e354d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__left__tri_8hpp_source.html#l00027">27</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e94b2554b4728e4932aded1d71eb026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R1, C1&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular and b=I. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 . </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__left__tri_8hpp_source.html#l00050">50</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2622a3a81c3faba8fa3c3dfc5f848b48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__tri_8hpp_source.html#l00304">304</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1f2d1a3336eefc43a12affb5862e663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__tri_8hpp_source.html#l00330">330</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a318338a3886f5b653a5e5d284db4ce50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; stan::math::mdivide_left_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2mdivide__left__tri_8hpp_source.html#l00356">356</a> of file <a class="el" href="rev_2mat_2fun_2mdivide__left__tri_8hpp_source.html">mdivide_left_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a154c4bb61dd8dce054238940b75aeaac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html#l00016">16</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7eb79c8ce7ae730ba02342b4241aeac1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdd9357ad5b52be5547eecdde95e968b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R1, C1&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html#l00032">32</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98e366981089fe4cd134efa82492ced2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html#l00068">68</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d6c4407f5ae843d0c12e15863591d22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::mdivide_left_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html#l00109">109</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__left__tri__low_8hpp_source.html">mdivide_left_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ad09daa535a7aeda34199d43a8e9e29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_right </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__right_8hpp_source.html#l00024">24</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__right_8hpp_source.html">mdivide_right.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3fc8c5bb0af596842ae6cc7f11556f56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_right </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__right_8hpp_source.html#l00026">26</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__right_8hpp_source.html">mdivide_right.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56f6566409d59f27b6f3086afeb0b18b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_right </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__right_8hpp_source.html#l00068">68</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__right_8hpp_source.html">mdivide_right.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9769485dc9f11852020b153b2ffe8bff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_right </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__right_8hpp_source.html#l00095">95</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__right_8hpp_source.html">mdivide_right.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9f8ca30a27a0a70d32477a9fb4c4e25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_right_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = A^-1 b, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__ldlt_8hpp_source.html#l00026">26</a> of file <a class="el" href="mdivide__right__ldlt_8hpp_source.html">mdivide_right_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f4edbfe01ea37356acd24cc948425c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, R1, C2&gt; stan::math::mdivide_right_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mdivide__right__ldlt_8hpp_source.html#l00038">38</a> of file <a class="el" href="mdivide__right__ldlt_8hpp_source.html">mdivide_right_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab73c90537220c0205f5355895a14621c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_right_spd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b where A is symmetric positive definite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__spd_8hpp_source.html#l00029">29</a> of file <a class="el" href="mdivide__right__spd_8hpp_source.html">mdivide_right_spd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43a692492445dff37a2594267d530796"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int TriView, typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_right_tri </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system Ax=b when A is triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Triangular matrix. Specify upper or lower with TriView being Eigen::Upper or Eigen::Lower. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b A^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mdivide__right__tri_8hpp_source.html#l00029">29</a> of file <a class="el" href="mdivide__right__tri_8hpp_source.html">mdivide_right_tri.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5309461c7fc32ca494e80af0722766af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::mdivide_right_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html">mdivide_right_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38aef2711a500bdb997863f0dc6b5d17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R1, C2&gt; stan::math::mdivide_right_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solution of the system tri(A)x=b when tri(A) is a lower triangular view of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Right hand side matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x = b * tri(A)^-1, solution of the linear system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if A is not square or the rows of b don't match the size of A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html#l00025">25</a> of file <a class="el" href="prim_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html">mdivide_right_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51cb38185a25a0971268ba6507af8667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_right_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html#l00068">68</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html">mdivide_right_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a046824a9236dae195f0c0e5eb69dd8a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::mdivide_right_tri_low </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html#l00103">103</a> of file <a class="el" href="fwd_2mat_2fun_2mdivide__right__tri__low_8hpp_source.html">mdivide_right_tri_low.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3443c4ac994b039a7f055c55c5afa8a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::mean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample mean (i.e., average) of the coefficients in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample mean of vector coefficients. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the size of the vector is less than 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mean_8hpp_source.html#l00023">23</a> of file <a class="el" href="mean_8hpp_source.html">mean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8074c0041b93407c473fd26a7c45dc88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::mean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample mean (i.e., average) of the coefficients in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector, or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample mean of vector coefficients. </dd></dl>

<p>Definition at line <a class="el" href="mean_8hpp_source.html#l00040">40</a> of file <a class="el" href="mean_8hpp_source.html">mean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f076860549f63d55c0e4985dce78099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="min_8hpp_source.html#l00020">20</a> of file <a class="el" href="min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e9c3a01030d96fd4c8f28e2ed8d3d61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of values being compared and returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="min_8hpp_source.html#l00038">38</a> of file <a class="el" href="min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86f2380e5c54a549e0f74ffd51204d33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::min </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum coefficient in the specified matrix, vector, or row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix, vector, or row vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum coefficient value in the vector. </dd></dl>

<p>Definition at line <a class="el" href="min_8hpp_source.html#l00055">55</a> of file <a class="el" href="min_8hpp_source.html">min.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87b343d6dc12982c2b76c453650c0797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::minus </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negation of the specified scalar or matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Subtrahend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negation of subtrahend. </dd></dl>

<p>Definition at line <a class="el" href="minus_8hpp_source.html#l00016">16</a> of file <a class="el" href="minus_8hpp_source.html">minus.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adcb3160540f6fe745abb846df2174742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::modified_bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2modified__bessel__first__kind_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2modified__bessel__first__kind_8hpp_source.html">modified_bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5625b66e071a9b57af3f0dd9325c79bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::modified_bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2modified__bessel__first__kind_8hpp_source.html#l00027">27</a> of file <a class="el" href="rev_2scal_2fun_2modified__bessel__first__kind_8hpp_source.html">modified_bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acafecf14b103c7c17da33368d07b1565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::modified_bessel_first_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_first\_kind}(v, z) = \begin{cases} I_v(z) &amp; \mbox{if } -\infty\leq z \leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_147.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{modified\_bessel\_first\_kind}(v, z)}{\partial z} = \begin{cases} \frac{\partial\, I_v(z)}{\partial z} &amp; \mbox{if } -\infty\leq z\leq \infty \\[6pt] \textrm{error} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_148.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {I_v}(z) = \left(\frac{1}{2}z\right)^v\sum_{k=0}^\infty \frac{\left(\frac{1}{4}z^2\right)^k}{k!\Gamma(v+k+1)} \]" src="form_149.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, I_v(z)}{\partial z} = I_{v-1}(z)-\frac{v}{z}I_v(z) \]" src="form_150.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2modified__bessel__first__kind_8hpp_source.html#l00039">39</a> of file <a class="el" href="prim_2scal_2fun_2modified__bessel__first__kind_8hpp_source.html">modified_bessel_first_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3277f8bf3ed3b3e36a61dedd4ed0449b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::modified_bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2modified__bessel__second__kind_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2modified__bessel__second__kind_8hpp_source.html">modified_bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f39f5d25033d6fb49cf875cc18fa956"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::modified_bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2modified__bessel__second__kind_8hpp_source.html#l00027">27</a> of file <a class="el" href="rev_2scal_2fun_2modified__bessel__second__kind_8hpp_source.html">modified_bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72ce86f3db5478cad4666c9cf1d05a6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 stan::math::modified_bessel_second_kind </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{modified\_bessel\_second\_kind}(v, z) = \begin{cases} \textrm{error} &amp; \mbox{if } z \leq 0 \\ K_v(z) &amp; \mbox{if } z > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_151.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{modified\_bessel\_second\_kind}(v, z)}{\partial z} = \begin{cases} \textrm{error} &amp; \mbox{if } z \leq 0 \\ \frac{\partial\, K_v(z)}{\partial z} &amp; \mbox{if } z > 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } z = \textrm{NaN} \end{cases} \]" src="form_152.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {K_v}(z) = \frac{\pi}{2}\cdot\frac{I_{-v}(z) - I_{v}(z)}{\sin(v\pi)} \]" src="form_153.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, K_v(z)}{\partial z} = -\frac{v}{z}K_v(z)-K_{v-1}(z) \]" src="form_154.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2modified__bessel__second__kind_8hpp_source.html#l00042">42</a> of file <a class="el" href="prim_2scal_2fun_2modified__bessel__second__kind_8hpp_source.html">modified_bessel_second_kind.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afcf62df7cae63f67b1c5c67651bc8dcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::modulus </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="modulus_8hpp_source.html#l00010">10</a> of file <a class="el" href="modulus_8hpp_source.html">modulus.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07d240bac837d28cf3d5922de0271cf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_covar, T_w&gt;::type stan::math::multi_gp_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a multivariate Gaussian Process for the given y, w, and a Cholesky factor L of the kernel matrix Sigma. </p>
<p>Sigma = LL', a square, semi-positive definite matrix.. y is a dxN matrix, where each column is a different observation and each row is a different output dimension. The Gaussian Process is assumed to have a scaled kernel matrix with a different scale for each output dimension. This distribution is equivalent to: for (i in 1:d) row(y, i) ~ multi_normal(0, (1/w[i])*LL').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dxN matrix </td></tr>
    <tr><td class="paramname">L</td><td>The Cholesky decomposition of a kernel matrix </td></tr>
    <tr><td class="paramname">w</td><td>A d-dimensional vector of positve inverse scale parameters for each output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate GP density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of kernel. </td></tr>
    <tr><td class="paramname">T_w</td><td>Type of weight. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__gp__cholesky__log_8hpp_source.html#l00043">43</a> of file <a class="el" href="multi__gp__cholesky__log_8hpp_source.html">multi_gp_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44ed8a0eabcdfa57bc7fde011d30bf8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_covar , typename T_w &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_covar, T_w&gt;::type stan::math::multi_gp_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__gp__cholesky__log_8hpp_source.html#l00106">106</a> of file <a class="el" href="multi__gp__cholesky__log_8hpp_source.html">multi_gp_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74b27063a645fbb1e20add3cc5f2aed5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_covar, T_w&gt;::type stan::math::multi_gp_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a multivariate Gaussian Process for the given y, Sigma, and w. </p>
<p>y is a dxN matrix, where each column is a different observation and each row is a different output dimension. The Gaussian Process is assumed to have a scaled kernel matrix with a different scale for each output dimension. This distribution is equivalent to: for (i in 1:d) row(y, i) ~ multi_normal(0, (1/w[i])*Sigma).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A dxN matrix </td></tr>
    <tr><td class="paramname">Sigma</td><td>The NxN kernel matrix </td></tr>
    <tr><td class="paramname">w</td><td>A d-dimensional vector of positve inverse scale parameters for each output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate GP density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if Sigma is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of kernel. </td></tr>
    <tr><td class="paramname">T_w</td><td>Type of weight. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__gp__log_8hpp_source.html#l00045">45</a> of file <a class="el" href="multi__gp__log_8hpp_source.html">multi_gp_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3535a644a9ec735e4c5ed0951909d1ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_covar , typename T_w &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_covar, T_w&gt;::type stan::math::multi_gp_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_covar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_w, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__gp__log_8hpp_source.html#l00112">112</a> of file <a class="el" href="multi__gp__log_8hpp_source.html">multi_gp_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73c48789407296b1fd9497d3e27ef26d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_covar&gt;::type stan::math::multi_normal_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix. </p>
<p>Sigma = LL', a square, semi-positive definite matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar vector </td></tr>
    <tr><td class="paramname">mu</td><td>The mean vector of the multivariate normal distribution. </td></tr>
    <tr><td class="paramname">L</td><td>The Cholesky decomposition of a variance matrix of the multivariate normal distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the multivariate normal density. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if LL' is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_covar</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__normal__cholesky__log_8hpp_source.html#l00050">50</a> of file <a class="el" href="multi__normal__cholesky__log_8hpp_source.html">multi_normal_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5aed6517d1de44fc193a8bf7b018bfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_covar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_covar&gt;::type stan::math::multi_normal_cholesky_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__normal__cholesky__log_8hpp_source.html#l00156">156</a> of file <a class="el" href="multi__normal__cholesky__log_8hpp_source.html">multi_normal_cholesky_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a05ae7884660def13b35c9d3d59a708"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd stan::math::multi_normal_cholesky_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__normal__cholesky__rng_8hpp_source.html#l00031">31</a> of file <a class="el" href="multi__normal__cholesky__rng_8hpp_source.html">multi_normal_cholesky_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69fa873591f0954b506eb709537a73f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_covar&gt;::type stan::math::multi_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__normal__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="multi__normal__log_8hpp_source.html">multi_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38c98c7961178da90570cb63499eb2b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_covar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_covar&gt;::type stan::math::multi_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__normal__log_8hpp_source.html#l00128">128</a> of file <a class="el" href="multi__normal__log_8hpp_source.html">multi_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83fb51aaff3da3d727bc12a3cdd106c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_covar&gt;::type stan::math::multi_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__normal__prec__log_8hpp_source.html#l00036">36</a> of file <a class="el" href="multi__normal__prec__log_8hpp_source.html">multi_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79191e304518140dbaf8feaab2c90aab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_covar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_covar&gt;::type stan::math::multi_normal_prec_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_covar &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__normal__prec__log_8hpp_source.html#l00143">143</a> of file <a class="el" href="multi__normal__prec__log_8hpp_source.html">multi_normal_prec_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46c260fca0e710ffa12410e53da4cbc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd stan::math::multi_normal_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__normal__rng_8hpp_source.html#l00025">25</a> of file <a class="el" href="multi__normal__rng_8hpp_source.html">multi_normal_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7b9a72ca7018cbf7883d7104345b4f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_loc, T_scale&gt;::type stan::math::multi_student_t_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the log of the multivariate Student t distribution at the specified arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>Carry out calculations up to a proportion </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multi__student__t__log_8hpp_source.html#l00037">37</a> of file <a class="el" href="multi__student__t__log_8hpp_source.html">multi_student_t_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e1b7da1cebae4c8db3067f614c777aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_loc, T_scale&gt;::type stan::math::multi_student_t_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>Sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__student__t__log_8hpp_source.html#l00171">171</a> of file <a class="el" href="multi__student__t__log_8hpp_source.html">multi_student_t_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca9dfb65a8ae0210632ae0c42b2ae5c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd stan::math::multi_student_t_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multi__student__t__rng_8hpp_source.html#l00030">30</a> of file <a class="el" href="multi__student__t__rng_8hpp_source.html">multi_student_t_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65b47c026be99de35988287412664e3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::multinomial_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multinomial__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="multinomial__log_8hpp_source.html">multinomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae23c14c3cb5d40c6fa46b89ddc5d5285"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_prob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_prob&gt;::type stan::math::multinomial_log </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_prob, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multinomial__log_8hpp_source.html#l00059">59</a> of file <a class="el" href="multinomial__log_8hpp_source.html">multinomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99ab77cc7ea8b9f49a61abe7576c8331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::multinomial_rng </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multinomial__rng_8hpp_source.html#l00023">23</a> of file <a class="el" href="multinomial__rng_8hpp_source.html">multinomial_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35a69b84ead3c81cbaff702ac429e1cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00020">20</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a919d4a6495c489841df3d0423200b147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified matrix multiplied by specified scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of matrix and scalar. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html#l00025">25</a> of file <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a064999d72ccfe825466a8d35221270c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; (boost::is_scalar&lt;T1&gt;::value || boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value) &amp;&amp; (boost::is_scalar&lt;T2&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value), typename boost::math::tools::promote_args&lt;T1, T2&gt;::type&gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of two scalars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>First scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Specified scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of scalars. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html#l00031">31</a> of file <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa473aa547cf1bb658edb99fd1182e989"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R2, C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00032">32</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2287bd9466a58f7df6ca88bf3374c7e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R2, C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of scalar and matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Specified scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of scalar and matrix. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html#l00043">43</a> of file <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81ca3cf29874f3f7a3334b0b7e5db09b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00044">44</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a2b6dbfb5543b73dac8496091745ec1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_arithmetic&lt;T&gt;::value, Eigen::Matrix&lt;double, R, C&gt; &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return specified scalar multiplied by specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Scalar. </td></tr>
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of scalar and matrix. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html#l00045">45</a> of file <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00de5667a1e8f49293a35bcd21e86104"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00056">56</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0671954ee3596b7ca59ec1e3bf832c63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C1&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of scalar and matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Specified scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of scalar and matrix. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html#l00057">57</a> of file <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeefbdef5245cd4f80dcee30d2a36131f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, R1, C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of the specified matrices. </p>
<p>The number of columns in the first matrix must be the same as the number of rows in the second matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the first and second matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the number of columns of m1 does not match the number of rows of m2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html#l00062">62</a> of file <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad58b9aa1f80267935b6dc1bf57a20090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00063">63</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18ef18d2345a17eb4044bb4697c18ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C1&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00070">70</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ba7d9d70a0b0c4515d767bcde7d2f66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, C2&gt; &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of the specified matrices. </p>
<p>The number of columns in the first matrix must be the same as the number of rows in the second matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the first and second matrices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the number of columns of m1 does not match the number of rows of m2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html#l00076">76</a> of file <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79dea45b5f0a70316514dadfa5bd5ea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00077">77</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e67698775aaac248efa49b646ca2a51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int C1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the scalar product of the specified row vector and specified column vector. </p>
<p>The return is the same as the dot product. The two vectors must be the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>Row vector. </td></tr>
    <tr><td class="paramname">v</td><td>Column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar result of multiplying row vector by column vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rv and v are not the same size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html#l00080">80</a> of file <a class="el" href="prim_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa34755674f81a0403550b728a50b390d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00096">96</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22fc2abfda7f892c5eeb8fec8f8cd765"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, C2&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00115">115</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeaecf22fee1b8944975a8124cd294bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int C1, typename T2 , int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the scalar product of the specified row vector and specified column vector. </p>
<p>The return is the same as the dot product. The two vectors must be the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>Row vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar result of multiplying row vector by column vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if rv and v are not the same size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html#l00128">128</a> of file <a class="el" href="rev_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69034d7594d58dd7f6362caa5aebe03d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00134">134</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace64b783b01a987d981c17cbcc33e4b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00145">145</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7af8534a80b35c3af6a6cf23cdddd46c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C1, int R2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html#l00156">156</a> of file <a class="el" href="fwd_2mat_2fun_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a055efd6bb49a1df5ea4da98d1078d0e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2multiply__log_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abafa25b9871a31fc9bad3b23e43f24e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2multiply__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="fwd_2scal_2fun_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0df8fa73f8f9435f44780baa1379dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2multiply__log_8hpp_source.html#l00035">35</a> of file <a class="el" href="fwd_2scal_2fun_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f15d9bf40cdab5e3ef75cea2595244c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_a , typename T_b &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_a, T_b&gt;::type stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const T_a&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_b&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculated the value of the first argument times log of the second argument while behaving properly with 0 inputs. </p>
<p><img class="formulaInl" alt="$ a * \log b $" src="form_155.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{multiply\_log}(x, y) = \begin{cases} 0 &amp; \mbox{if } x=y=0\\ x\ln y &amp; \mbox{if } x, y\neq0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_156.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{multiply\_log}(x, y)}{\partial x} = \begin{cases} \infty &amp; \mbox{if } x=y=0\\ \ln y &amp; \mbox{if } x, y\neq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_157.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{multiply\_log}(x, y)}{\partial y} = \begin{cases} \infty &amp; \mbox{if } x=y=0\\ \frac{x}{y} &amp; \mbox{if } x, y\neq 0 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_158.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first variable </td></tr>
    <tr><td class="paramname">b</td><td>the second variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a * log(b) </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2multiply__log_8hpp_source.html#l00051">51</a> of file <a class="el" href="prim_2scal_2fun_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3da7e77b75bf5f288ddc7c546f941c70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a*log(b). </p>
<p>When both a and b are 0, the value returned is 0. The partial deriviative with respect to a is log(b). The partial deriviative with respect to b is a/b. When a and b are both 0, this is set to Inf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of a*log(b) </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2multiply__log_8hpp_source.html#l00074">74</a> of file <a class="el" href="rev_2scal_2fun_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa05bd638024e60440e56c8ee4a0dbab3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a*log(b). </p>
<p>When both a and b are 0, the value returned is 0. The partial deriviative with respect to a is log(b).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of a*log(b) </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2multiply__log_8hpp_source.html#l00087">87</a> of file <a class="el" href="rev_2scal_2fun_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c980d72501fd340f6148c125c1da018"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::multiply_log </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a*log(b). </p>
<p>When both a and b are 0, the value returned is 0. The partial deriviative with respect to b is a/b. When a and b are both 0, this is set to Inf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First scalar. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of a*log(b) </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2multiply__log_8hpp_source.html#l00101">101</a> of file <a class="el" href="rev_2scal_2fun_2multiply__log_8hpp_source.html">multiply_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d671dcfc6f4c1b4896c5d8bc4568acf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, R&gt; stan::math::multiply_lower_tri_self_transpose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2multiply__lower__tri__self__transpose_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2mat_2fun_2multiply__lower__tri__self__transpose_8hpp_source.html">multiply_lower_tri_self_transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c0c953951f141b35277fe2308777cff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a> stan::math::multiply_lower_tri_self_transpose </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lower triangular values in L times their own transpose. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the input matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2multiply__lower__tri__self__transpose_8hpp_source.html#l00018">18</a> of file <a class="el" href="prim_2mat_2fun_2multiply__lower__tri__self__transpose_8hpp_source.html">multiply_lower_tri_self_transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f4d12daa275a9a471974f6447396266"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> stan::math::multiply_lower_tri_self_transpose </td>
          <td>(</td>
          <td class="paramtype">const matrix_v &amp;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2multiply__lower__tri__self__transpose_8hpp_source.html#l00019">19</a> of file <a class="el" href="rev_2mat_2fun_2multiply__lower__tri__self__transpose_8hpp_source.html">multiply_lower_tri_self_transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63d35a349ee49712178c19dde27fcc5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_location , typename T_precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_location, T_precision&gt;::type stan::math::neg_binomial_2_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_location &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__ccdf__log_8hpp_source.html#l00033">33</a> of file <a class="el" href="neg__binomial__2__ccdf__log_8hpp_source.html">neg_binomial_2_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6bc7b5ee1f4534f7c6eb509f08c1dd8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_location , typename T_precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_location, T_precision&gt;::type stan::math::neg_binomial_2_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_location &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__cdf_8hpp_source.html#l00037">37</a> of file <a class="el" href="neg__binomial__2__cdf_8hpp_source.html">neg_binomial_2_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade0a4ada20d2611ea7b7c717bcfd42ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_location , typename T_precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_location, T_precision&gt;::type stan::math::neg_binomial_2_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_location &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__cdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="neg__binomial__2__cdf__log_8hpp_source.html">neg_binomial_2_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72735047f883b88395f4e50e515140d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_location , typename T_precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_location, T_precision&gt;::type stan::math::neg_binomial_2_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_location &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__log_8hpp_source.html#l00037">37</a> of file <a class="el" href="neg__binomial__2__log_8hpp_source.html">neg_binomial_2_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf533af613ce70cc7b53fd678c2363b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_location , typename T_precision &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_location, T_precision&gt;::type stan::math::neg_binomial_2_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_location &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__log_8hpp_source.html#l00141">141</a> of file <a class="el" href="neg__binomial__2__log_8hpp_source.html">neg_binomial_2_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07f9603fcb9767d59c7aa75cfbd489e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_log_location , typename T_precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_log_location, T_precision&gt;::type stan::math::neg_binomial_2_log_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_location &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__log__log_8hpp_source.html#l00033">33</a> of file <a class="el" href="neg__binomial__2__log__log_8hpp_source.html">neg_binomial_2_log_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef63f32976322da20fcea2a0c15fb888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_log_location , typename T_precision &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_log_location, T_precision&gt;::type stan::math::neg_binomial_2_log_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_location &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__log__log_8hpp_source.html#l00140">140</a> of file <a class="el" href="neg__binomial__2__log__log_8hpp_source.html">neg_binomial_2_log_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a626a27ed755b59249175c99dd2548ea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::neg_binomial_2_log_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__log__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="neg__binomial__2__log__rng_8hpp_source.html">neg_binomial_2_log_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1088da4c2c0c2b157862fbad43c75d0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::neg_binomial_2_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__2__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="neg__binomial__2__rng_8hpp_source.html">neg_binomial_2_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a176323fd45f7f70cf9fa801310c3c614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_shape, T_inv_scale&gt;::type stan::math::neg_binomial_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__ccdf__log_8hpp_source.html#l00032">32</a> of file <a class="el" href="neg__binomial__ccdf__log_8hpp_source.html">neg_binomial_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31e90bd5f65cafdcd66b41617bf31718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_shape, T_inv_scale&gt;::type stan::math::neg_binomial_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__cdf_8hpp_source.html#l00029">29</a> of file <a class="el" href="neg__binomial__cdf_8hpp_source.html">neg_binomial_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51e5ebf37ccf49350280631039a23017"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_shape, T_inv_scale&gt;::type stan::math::neg_binomial_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__cdf__log_8hpp_source.html#l00032">32</a> of file <a class="el" href="neg__binomial__cdf__log_8hpp_source.html">neg_binomial_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b3f283f0d71f78bb437e1e1c4fdb805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_shape , typename T_inv_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_shape, T_inv_scale&gt;::type stan::math::neg_binomial_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__log_8hpp_source.html#l00039">39</a> of file <a class="el" href="neg__binomial__log_8hpp_source.html">neg_binomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24147a6471d65586101de3a5dfa4a53c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_shape, T_inv_scale&gt;::type stan::math::neg_binomial_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_inv_scale &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__log_8hpp_source.html#l00183">183</a> of file <a class="el" href="neg__binomial__log_8hpp_source.html">neg_binomial_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a898e2ab003c78229367378b150c78aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::neg_binomial_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="neg__binomial__rng_8hpp_source.html#l00030">30</a> of file <a class="el" href="neg__binomial__rng_8hpp_source.html">neg_binomial_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34bffe91b7a24cb29bd69cb60814c39e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::negative_infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return negative infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>Negative infinity. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00132">132</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0f68ac575a2b8dff3a7a2359962c607"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t stan::math::nested_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="nested__size_8hpp_source.html#l00012">12</a> of file <a class="el" href="nested__size_8hpp_source.html">nested_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2214490cfe7d81bdc51318028cd7df94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::normal_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="normal__ccdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="normal__ccdf__log_8hpp_source.html">normal_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2b9ee666af5f1741dc9f75108176386"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::normal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the normal cumulative distribution function for the given variate, location, and scale. </p>
<p><img class="formulaInl" alt="$\Phi(x) = \frac{1}{\sqrt{2 \pi}} \int_{-\inf}^x e^{-t^2/2} dt$" src="form_196.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variate. </td></tr>
    <tr><td class="paramname">mu</td><td>The location of the normal distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>The scale of the normal distriubtion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit normal cdf evaluated at the specified arguments. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of y. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of mean parameter. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of standard deviation paramater. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="normal__cdf_8hpp_source.html#l00038">38</a> of file <a class="el" href="normal__cdf_8hpp_source.html">normal_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d0b3b3339016b3282cf360feb7cd0f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::normal_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="normal__cdf__log_8hpp_source.html#l00024">24</a> of file <a class="el" href="normal__cdf__log_8hpp_source.html">normal_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b7d387734f07e63bf2713b610f73a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s). </p>
<p>y, mu, or sigma can each be either a scalar or a vector. Any vector inputs must be the same length.</p>
<p>The result log probability is defined to be the sum of the log probabilities for each observation/mean/deviation triple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>(Sequence of) scalar(s). </td></tr>
    <tr><td class="paramname">mu</td><td>(Sequence of) location parameter(s) for the normal distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameters for the normal distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the product of the densities. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Underlying type of scalar in sequence. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of location parameter. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="normal__log_8hpp_source.html#l00043">43</a> of file <a class="el" href="normal__log_8hpp_source.html">normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc2fd29076680ce830285130b5fd6f81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="normal__log_8hpp_source.html#l00136">136</a> of file <a class="el" href="normal__log_8hpp_source.html">normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac70652885c9903a1122575590075bc78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::normal_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="normal__rng_8hpp_source.html#l00020">20</a> of file <a class="el" href="normal__rng_8hpp_source.html">normal_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a381493bccc58bd993d797a2a5458c486"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::not_a_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return (quiet) not-a-number. </p>
<dl class="section return"><dt>Returns</dt><dd>Quiet not-a-number. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00141">141</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac360c5b10dbf87d81e346f2be7d19ade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::num_elements </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1, the number of elements in a primitive type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument of primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 </dd></dl>

<p>Definition at line <a class="el" href="num__elements_8hpp_source.html#l00019">19</a> of file <a class="el" href="num__elements_8hpp_source.html">num_elements.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e716815601bf5055a2d7fbfd8a757ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::num_elements </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the specified matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>argument matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of matrix </dd></dl>

<p>Definition at line <a class="el" href="num__elements_8hpp_source.html#l00031">31</a> of file <a class="el" href="num__elements_8hpp_source.html">num_elements.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38a5d6d7f867666902fcd0adbe602920"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::num_elements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the specified vector. </p>
<p>This assumes it is not ragged and that each of its contained elements has the same number of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>argument vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of contained arguments </dd></dl>

<p>Definition at line <a class="el" href="num__elements_8hpp_source.html#l00045">45</a> of file <a class="el" href="num__elements_8hpp_source.html">num_elements.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeee31e071296bea410dd943347b9a65d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator! </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefix logical negation for the value of variables (C++). </p>
<p>The expression (!a) is equivalent to negating the scalar value of the variable a.</p>
<p>Note that this is the only logical operator defined for variables. Overridden logical conjunction (&amp;&amp;) and disjunction (||) operators do not apply the same "short circuit" rules as the built-in logical operators.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator!}(x) = \begin{cases} 0 &amp; \mbox{if } x \neq 0 \\ 1 &amp; \mbox{if } x = 0 \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_247.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if variable is non-zero. </dd></dl>

<p>Definition at line <a class="el" href="operator__unary__not_8hpp_source.html#l00031">31</a> of file <a class="el" href="operator__unary__not_8hpp_source.html">operator_unary_not.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65438bf17da7bbedb06bc7c381cea865"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacestan_1_1math.html#aeee31e071296bea410dd943347b9a65d">stan::math::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__not__equal_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__not__equal_8hpp_source.html">operator_not_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41e121241958fdcc4d2190bc532e9bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacestan_1_1math.html#aeee31e071296bea410dd943347b9a65d">stan::math::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__not__equal_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2core_2operator__not__equal_8hpp_source.html">operator_not_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae23eb5d64637b32c92292456aa006ff0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacestan_1_1math.html#aeee31e071296bea410dd943347b9a65d">stan::math::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator comparing two variables' values (C++). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator!=}(x, y) = \begin{cases} 0 &amp; \mbox{if } x = y\\ 1 &amp; \mbox{if } x \neq y \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_236.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first variable's value is not the same as the second's. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__not__equal_8hpp_source.html#l00026">26</a> of file <a class="el" href="rev_2core_2operator__not__equal_8hpp_source.html">operator_not_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae982faec66434385fda1c728b0b2bf3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacestan_1_1math.html#aeee31e071296bea410dd943347b9a65d">stan::math::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__not__equal_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2core_2operator__not__equal_8hpp_source.html">operator_not_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a570111dc15835a88afcfb8130b4746fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacestan_1_1math.html#aeee31e071296bea410dd943347b9a65d">stan::math::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator comparing a variable's value and a double (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first variable's value is not the same as the second value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__not__equal_8hpp_source.html#l00039">39</a> of file <a class="el" href="rev_2core_2operator__not__equal_8hpp_source.html">operator_not_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6464b66683b8cf12702e71c155853b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacestan_1_1math.html#aeee31e071296bea410dd943347b9a65d">stan::math::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator comparing a double and a variable's value (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first value is not the same as the second variable's value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__not__equal_8hpp_source.html#l00052">52</a> of file <a class="el" href="rev_2core_2operator__not__equal_8hpp_source.html">operator_not_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afcc9ba66175e049c6020fe363231d694"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__multiplication_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__multiplication_8hpp_source.html">operator_multiplication.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad613e6b4387544fecd361475490d9dd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__multiplication_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2core_2operator__multiplication_8hpp_source.html">operator_multiplication.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ee4488ea32a5bf3cce50117e14b2d07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__multiplication_8hpp_source.html#l00029">29</a> of file <a class="el" href="fwd_2core_2operator__multiplication_8hpp_source.html">operator_multiplication.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a436203414c825bb8765ea82786313909"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for two variables (C++). </p>
<p>The partial derivatives are</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x * y) = y$" src="form_229.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (x * y) = x$" src="form_230.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator*}(x, y) = \begin{cases} xy &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_231.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator*}(x, y)}{\partial x} = \begin{cases} y &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_232.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator*}(x, y)}{\partial y} = \begin{cases} x &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_233.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of multiplying operands. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__multiplication_8hpp_source.html#l00083">83</a> of file <a class="el" href="rev_2core_2operator__multiplication_8hpp_source.html">operator_multiplication.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae63dc18994ab79b22ff3f6a37fe784db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for a variable and a scalar (C++). </p>
<p>The partial derivative for the variable is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x * c) = c$" src="form_234.png"/>, and</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Scalar operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of multiplying operands. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__multiplication_8hpp_source.html#l00098">98</a> of file <a class="el" href="rev_2core_2operator__multiplication_8hpp_source.html">operator_multiplication.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6de4291925b8d2f8a7060617e276c5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for a scalar and a variable (C++). </p>
<p>The partial derivative for the variable is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (c * y) = c$" src="form_235.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Scalar operand. </td></tr>
    <tr><td class="paramname">b</td><td>Variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of multiplying the operands. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__multiplication_8hpp_source.html#l00115">115</a> of file <a class="el" href="rev_2core_2operator__multiplication_8hpp_source.html">operator_multiplication.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51a0614c9ba674f03e3d1b7586e99d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__addition_8hpp_source.html#l00013">13</a> of file <a class="el" href="fwd_2core_2operator__addition_8hpp_source.html">operator_addition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3fbabb3f7eeef5d7605eefad9c2fbef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__addition_8hpp_source.html#l00020">20</a> of file <a class="el" href="fwd_2core_2operator__addition_8hpp_source.html">operator_addition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbceec5a6822fd0c58529d6f64208f3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__addition_8hpp_source.html#l00027">27</a> of file <a class="el" href="fwd_2core_2operator__addition_8hpp_source.html">operator_addition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28f17a8253887d3b573fd59c5a4c6769"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary plus operator for variables (C++). </p>
<p>The function simply returns its input, because</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} +x = \frac{d}{dx} x = 1$" src="form_248.png"/>.</p>
<p>The effect of unary plus on a built-in C++ scalar type is integer promotion. Because variables are all double-precision floating point already, promotion is not necessary.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator+}(x) = \begin{cases} x &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_249.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator+}(x)}{\partial x} = \begin{cases} 1 &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_250.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input reference. </dd></dl>

<p>Definition at line <a class="el" href="operator__unary__plus_8hpp_source.html#l00043">43</a> of file <a class="el" href="operator__unary__plus_8hpp_source.html">operator_unary_plus.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afcb4c7bced043de79d94676dac3cfc4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for variables (C++). </p>
<p>The partial derivatives are defined by</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x+y) = 1$" src="form_210.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (x+y) = 1$" src="form_211.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator+}(x, y) = \begin{cases} x+y &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_212.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator+}(x, y)}{\partial x} = \begin{cases} 1 &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_213.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator+}(x, y)}{\partial y} = \begin{cases} 1 &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_214.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of adding two variables. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__addition_8hpp_source.html#l00084">84</a> of file <a class="el" href="rev_2core_2operator__addition_8hpp_source.html">operator_addition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7ec1a6c24e3a21e00c42142d582d944"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for variable and scalar (C++). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} (x + c) = 1$" src="form_215.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second scalar operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of adding variable and scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__addition_8hpp_source.html#l00099">99</a> of file <a class="el" href="rev_2core_2operator__addition_8hpp_source.html">operator_addition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe2a79efe1e8415fb532a27b26406798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for scalar and variable (C++). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{dy} (c + y) = 1$" src="form_216.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First scalar operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of adding variable and scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__addition_8hpp_source.html#l00116">116</a> of file <a class="el" href="rev_2core_2operator__addition_8hpp_source.html">operator_addition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab33c64042765d924f07e7490788e6d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&amp; stan::math::operator++ </td>
          <td>(</td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefix increment operator for variables (C++). </p>
<p>Following C++, (++a) is defined to behave exactly as (a = a + 1.0) does, but is faster and uses less memory. In particular, the result is an assignable lvalue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference the result of incrementing this input variable. </dd></dl>

<p>Definition at line <a class="el" href="operator__unary__increment_8hpp_source.html#l00036">36</a> of file <a class="el" href="operator__unary__increment_8hpp_source.html">operator_unary_increment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3597f71f364d94814268d4911f111674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator++ </td>
          <td>(</td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postfix increment operator for variables (C++). </p>
<p>Following C++, the expression <code>(a++)</code> is defined to behave like the sequence of operations</p>
<p><code>var temp = a; a = a + 1.0; return temp;</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input variable. </dd></dl>

<p>Definition at line <a class="el" href="operator__unary__increment_8hpp_source.html#l00052">52</a> of file <a class="el" href="operator__unary__increment_8hpp_source.html">operator_unary_increment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a200e70e0f2b422b6623cf4b19d04da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__subtraction_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__subtraction_8hpp_source.html">operator_subtraction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedeee50b418200d06eb867d0ef3b3125"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="operator__unary__minus_8hpp_source.html#l00014">14</a> of file <a class="el" href="operator__unary__minus_8hpp_source.html">operator_unary_minus.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87d89d23df91de283beda449d480b437"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__subtraction_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2core_2operator__subtraction_8hpp_source.html">operator_subtraction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd8dea434972aa3008e352349069e206"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__subtraction_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2core_2operator__subtraction_8hpp_source.html">operator_subtraction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f8564365599db5cea0b51b635ea482a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary negation operator for variables (C++). </p>
<p><img class="formulaInl" alt="$\frac{d}{dx} -x = -1$" src="form_244.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator-}(x) = \begin{cases} -x &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_245.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator-}(x)}{\partial x} = \begin{cases} -1 &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_246.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negation of variable. </dd></dl>

<p>Definition at line <a class="el" href="operator__unary__negative_8hpp_source.html#l00051">51</a> of file <a class="el" href="operator__unary__negative_8hpp_source.html">operator_unary_negative.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a971b741313ecc65a639076acc188614a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for variables (C++). </p>
<p>The partial derivatives are defined by</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x-y) = 1$" src="form_237.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (x-y) = -1$" src="form_238.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator-}(x, y) = \begin{cases} x-y &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_239.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator-}(x, y)}{\partial x} = \begin{cases} 1 &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_240.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator-}(x, y)}{\partial y} = \begin{cases} -1 &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_241.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of subtracting the second variable from the first. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__subtraction_8hpp_source.html#l00099">99</a> of file <a class="el" href="rev_2core_2operator__subtraction_8hpp_source.html">operator_subtraction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abec4b5043616cea0be01ee41fd899198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for variable and scalar (C++). </p>
<p>The derivative for the variable is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x-c) = 1$" src="form_242.png"/>, and</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second scalar operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of subtracting the scalar from the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__subtraction_8hpp_source.html#l00114">114</a> of file <a class="el" href="rev_2core_2operator__subtraction_8hpp_source.html">operator_subtraction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9586c6690c5088deedcbac089158960a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for scalar and variable (C++). </p>
<p>The derivative for the variable is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (c-y) = -1$" src="form_243.png"/>, and</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First scalar operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of sutracting a variable from a scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__subtraction_8hpp_source.html#l00131">131</a> of file <a class="el" href="rev_2core_2operator__subtraction_8hpp_source.html">operator_subtraction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10e496e6e1fd02a0378a729ada4f39df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a>&amp; stan::math::operator-- </td>
          <td>(</td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prefix decrement operator for variables (C++). </p>
<p>Following C++, <code>(&ndash;a)</code> is defined to behave exactly as</p>
<p><code>a = a - 1.0)</code></p>
<p>does, but is faster and uses less memory. In particular, the result is an assignable lvalue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable to decrement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference the result of decrementing this input variable. </dd></dl>

<p>Definition at line <a class="el" href="operator__unary__decrement_8hpp_source.html#l00040">40</a> of file <a class="el" href="operator__unary__decrement_8hpp_source.html">operator_unary_decrement.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcadc96f506e9f1408647cdce4d09092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator-- </td>
          <td>(</td>
          <td class="paramtype">var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postfix decrement operator for variables (C++). </p>
<p>Following C++, the expression <code>(a&ndash;)</code> is defined to behave like the sequence of operations</p>
<p><code>var temp = a; a = a - 1.0; return temp;</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable to decrement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input variable. </dd></dl>

<p>Definition at line <a class="el" href="operator__unary__decrement_8hpp_source.html#l00056">56</a> of file <a class="el" href="operator__unary__decrement_8hpp_source.html">operator_unary_decrement.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eba6f623c3c2c0714e2eabbae90290f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__division_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__division_8hpp_source.html">operator_division.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02aad69947e40bd42636143eadd38621"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__division_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2core_2operator__division_8hpp_source.html">operator_division.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef4e969693a718ffefbe5d45916ddef3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__division_8hpp_source.html#l00030">30</a> of file <a class="el" href="fwd_2core_2operator__division_8hpp_source.html">operator_division.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cbbe36fe5dcdd2996fe40afdd874983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html#l00058">58</a> of file <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48b310fd13ba04c615b74671f262b25d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html#l00064">64</a> of file <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7174185d7dd2b83e370d535d35870c4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html#l00070">70</a> of file <a class="el" href="fwd_2mat_2fun_2divide_8hpp_source.html">divide.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac15f9adeb9753deea83b30e18aaf8e98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for two variables (C++). </p>
<p>The partial derivatives for the variables are</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x/y) = 1/y$" src="form_217.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} (x/y) = -x / y^2$" src="form_218.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator/}(x, y) = \begin{cases} \frac{x}{y} &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_219.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator/}(x, y)}{\partial x} = \begin{cases} \frac{1}{y} &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_220.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{operator/}(x, y)}{\partial y} = \begin{cases} -\frac{x}{y^2} &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_221.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of dividing the first variable by the second. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__division_8hpp_source.html#l00096">96</a> of file <a class="el" href="rev_2core_2operator__division_8hpp_source.html">operator_division.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa12be933cc2e01e203a6ffa09508d319"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for dividing a variable by a scalar (C++). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} (x/c) = 1/c$" src="form_222.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable operand. </td></tr>
    <tr><td class="paramname">b</td><td>Scalar operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of dividing the variable by the scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__division_8hpp_source.html#l00111">111</a> of file <a class="el" href="rev_2core_2operator__division_8hpp_source.html">operator_division.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81ad2fbfb99eb063eda9ef0b466b2014"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for dividing a scalar by a variable (C++). </p>
<p>The derivative with respect to the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{d y} (c/y) = -c / y^2$" src="form_223.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Scalar operand. </td></tr>
    <tr><td class="paramname">b</td><td>Variable operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variable result of dividing the scalar by the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__division_8hpp_source.html#l00128">128</a> of file <a class="el" href="rev_2core_2operator__division_8hpp_source.html">operator_division.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2c489941c560664036ee190c9028360"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__less__than_8hpp_source.html#l00012">12</a> of file <a class="el" href="fwd_2core_2operator__less__than_8hpp_source.html">operator_less_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0194df340cc3564835ff04086374cf97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__less__than_8hpp_source.html#l00018">18</a> of file <a class="el" href="fwd_2core_2operator__less__than_8hpp_source.html">operator_less_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50b0c7ff4961eb7333aa81f685da55f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__less__than_8hpp_source.html#l00024">24</a> of file <a class="el" href="fwd_2core_2operator__less__than_8hpp_source.html">operator_less_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe39e7c1b0831663418188ab23b98965"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than operator comparing variables' values (C++). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator\textless}(x, y) = \begin{cases} 0 &amp; \mbox{if } x \geq y \\ 1 &amp; \mbox{if } x < y \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_227.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is less than second's. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__less__than_8hpp_source.html#l00024">24</a> of file <a class="el" href="rev_2core_2operator__less__than_8hpp_source.html">operator_less_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a021f473185983f63d23ee362605249d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than operator comparing variable's value and a double (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is less than second value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__less__than_8hpp_source.html#l00036">36</a> of file <a class="el" href="rev_2core_2operator__less__than_8hpp_source.html">operator_less_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec5a959d8186caa585d5922a4facf649"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than operator comparing a double and variable's value (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first value is less than second variable's value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__less__than_8hpp_source.html#l00048">48</a> of file <a class="el" href="rev_2core_2operator__less__than_8hpp_source.html">operator_less_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a450ef8aaef08c3137f70a087ae3905c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__less__than__or__equal_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__less__than__or__equal_8hpp_source.html">operator_less_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab95d660226997cbba13176cec459adaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__less__than__or__equal_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2core_2operator__less__than__or__equal_8hpp_source.html">operator_less_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee09427479a707c4e715677d5036307b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal operator comparing two variables' values (C++). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator\textless=}(x, y) = \begin{cases} 0 &amp; \mbox{if } x > y\\ 1 &amp; \mbox{if } x \leq y \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_228.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is less than or equal to the second's. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__less__than__or__equal_8hpp_source.html#l00026">26</a> of file <a class="el" href="rev_2core_2operator__less__than__or__equal_8hpp_source.html">operator_less_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca5de0aa5a40e981ece663f96ad41997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__less__than__or__equal_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2core_2operator__less__than__or__equal_8hpp_source.html">operator_less_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f46c552a80c056955c460a1796d724d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal operator comparing a variable's value and a scalar (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is less than or equal to the second value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__less__than__or__equal_8hpp_source.html#l00039">39</a> of file <a class="el" href="rev_2core_2operator__less__than__or__equal_8hpp_source.html">operator_less_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79e6962678ac8407d6d004c48988c1a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than or equal operator comparing a double and variable's value (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first value is less than or equal to the second variable's value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__less__than__or__equal_8hpp_source.html#l00052">52</a> of file <a class="el" href="rev_2core_2operator__less__than__or__equal_8hpp_source.html">operator_less_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a431129b4a75d77ab60f6cd749bef5a11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator== </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__equal_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__equal_8hpp_source.html">operator_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15161ab182b02d135f79a13d68c7318d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator== </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__equal_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2core_2operator__equal_8hpp_source.html">operator_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62e8c00dc01b2df161d0d242c124b046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator== </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator comparing two variables' values (C++). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator==}(x, y) = \begin{cases} 0 &amp; \mbox{if } x \neq y\\ 1 &amp; \mbox{if } x = y \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_224.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first variable's value is the same as the second's. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__equal_8hpp_source.html#l00026">26</a> of file <a class="el" href="rev_2core_2operator__equal_8hpp_source.html">operator_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4930059b979a995acd759a0746bfc201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator== </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__equal_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2core_2operator__equal_8hpp_source.html">operator_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad239b56697788a42a944361e26b56e56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator== </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator comparing a variable's value and a double (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first variable's value is the same as the second value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__equal_8hpp_source.html#l00039">39</a> of file <a class="el" href="rev_2core_2operator__equal_8hpp_source.html">operator_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add97c0c3a895203b8ab3205aca59d088"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator== </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator comparing a scalar and a variable's value (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First scalar. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the variable's value is equal to the scalar. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__equal_8hpp_source.html#l00051">51</a> of file <a class="el" href="rev_2core_2operator__equal_8hpp_source.html">operator_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17fefa51b18df1adec77e49f4e792fbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__greater__than_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__greater__than_8hpp_source.html">operator_greater_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c850c94b22aab8ffd895bdf8faebded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__greater__than_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2core_2operator__greater__than_8hpp_source.html">operator_greater_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a465afbe6fb2692b02b60d9760e5cbda9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than operator comparing variables' values (C++). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator\textgreater}(x, y) = \begin{cases} 0 &amp; \mbox{if } x \leq y\\ 1 &amp; \mbox{if } x > y \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_225.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is greater than second's. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__greater__than_8hpp_source.html#l00025">25</a> of file <a class="el" href="rev_2core_2operator__greater__than_8hpp_source.html">operator_greater_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba7b92bb244d32edb94b17c8039ae826"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__greater__than_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2core_2operator__greater__than_8hpp_source.html">operator_greater_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a361d2b2ac2c39919dc71183312855c92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than operator comparing variable's value and double (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is greater than second value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__greater__than_8hpp_source.html#l00037">37</a> of file <a class="el" href="rev_2core_2operator__greater__than_8hpp_source.html">operator_greater_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34b9438d0ef1f58b41a228a1154308aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than operator comparing a double and a variable's value (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first value is greater than second variable's value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__greater__than_8hpp_source.html#l00049">49</a> of file <a class="el" href="rev_2core_2operator__greater__than_8hpp_source.html">operator_greater_than.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dee5c21281cc75cad8ebf9f6c43b98f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__greater__than__or__equal_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2core_2operator__greater__than__or__equal_8hpp_source.html">operator_greater_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2097caea2b790905ee2948ef72727df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__greater__than__or__equal_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2core_2operator__greater__than__or__equal_8hpp_source.html">operator_greater_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a938fb84cef113596828ad131e513fa1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal operator comparing two variables' values (C++). </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{operator\textgreater=}(x, y) = \begin{cases} 0 &amp; \mbox{if } x < y\\ 1 &amp; \mbox{if } x \geq y \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_226.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is greater than or equal to the second's. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__greater__than__or__equal_8hpp_source.html#l00027">27</a> of file <a class="el" href="rev_2core_2operator__greater__than__or__equal_8hpp_source.html">operator_greater_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a813edaa4311e1a4c206952f75a85eba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2core_2operator__greater__than__or__equal_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2core_2operator__greater__than__or__equal_8hpp_source.html">operator_greater_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a055bb2d4f3560761f3383b0f499e7fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal operator comparing variable's value and double (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First variable. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if first variable's value is greater than or equal to second value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__greater__than__or__equal_8hpp_source.html#l00040">40</a> of file <a class="el" href="rev_2core_2operator__greater__than__or__equal_8hpp_source.html">operator_greater_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4492a18f751e82a980740f7beac0e025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater than or equal operator comparing double and variable's value (C++). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first value is greater than or equal to the second variable's value. </dd></dl>

<p>Definition at line <a class="el" href="rev_2core_2operator__greater__than__or__equal_8hpp_source.html#l00053">53</a> of file <a class="el" href="rev_2core_2operator__greater__than__or__equal_8hpp_source.html">operator_greater_than_or_equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5062f9b21b2fb755ad3189fe236bed93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an increasing ordered vector derived from the specified free vector. </p>
<p>The returned constrained vector will have the same dimensionality as the specified free vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free vector of scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Positive, increasing ordered vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ordered__constrain_8hpp_source.html#l00023">23</a> of file <a class="el" href="ordered__constrain_8hpp_source.html">ordered_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5638796e15590c237b7eaece1531631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a positive valued, increasing ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform. </p>
<p>The returned constrained vector will have the same dimensionality as the specified free vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free vector of scalars. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Positive, increasing ordered vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ordered__constrain_8hpp_source.html#l00056">56</a> of file <a class="el" href="ordered__constrain_8hpp_source.html">ordered_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a679b3a9baaf02aeee0c15d763efa06b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::ordered_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector of unconstrained scalars that transform to the specified positive ordered vector. </p>
<p>This function inverts the constraining operation defined in <code>ordered_constrain(Matrix)</code>,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Vector of positive, ordered scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Free vector that transforms into the input vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is not a vector of positive, ordered scalars. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ordered__free_8hpp_source.html#l00028">28</a> of file <a class="el" href="ordered__free_8hpp_source.html">ordered_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae845ae3d07989bc9976a15f52caa997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_lambda , typename T_cut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_lambda, T_cut&gt;::type stan::math::ordered_logistic_log </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_lambda &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_cut, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the (natural) log probability of the specified integer outcome given the continuous location and specified cutpoints in an ordered logistic model. </p>
<p>Typically the continous location will be the dot product of a vector of regression coefficients and a vector of predictors for the outcome.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculating up to a proportion. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Location type. </td></tr>
    <tr><td class="paramname">T_cut</td><td>Cut-point type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Outcome. </td></tr>
    <tr><td class="paramname">lambda</td><td>Location. </td></tr>
    <tr><td class="paramname">c</td><td>Positive increasing vector of cutpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Log probability of outcome given location and cutpoints.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the outcome is not between 1 and the number of cutpoints plus 2; if the cutpoint vector is empty; if the cutpoint vector contains a non-positive, non-finite value; or if the cutpoint vector is not sorted in ascending order. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ordered__logistic__log_8hpp_source.html#l00061">61</a> of file <a class="el" href="ordered__logistic__log_8hpp_source.html">ordered_logistic_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5623d34d128b956b6dfb2031150c8c87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_lambda , typename T_cut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_lambda, T_cut&gt;::type stan::math::ordered_logistic_log </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_lambda &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_cut, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ordered__logistic__log_8hpp_source.html#l00107">107</a> of file <a class="el" href="ordered__logistic__log_8hpp_source.html">ordered_logistic_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a432a3d83d286fe609fc79c6ef4f8ea74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::ordered_logistic_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ordered__logistic__rng_8hpp_source.html#l00024">24</a> of file <a class="el" href="ordered__logistic__rng_8hpp_source.html">ordered_logistic_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34583d3983ee4d61d09004ce3e278250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::out_of_range </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg1</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg2</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an out_of_range exception with a consistently formatted message. </p>
<p>This is an abstraction for all Stan functions to use when throwing out of range. This will allow us to change the behavior for all functions at once.</p>
<p>The message is: "&lt;function&gt;: index &lt;index&gt; out of range; expecting index to be between " "1 and &lt;max&gt;&lt;msg1&gt;&lt;msg2&gt;"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Name of the function </td></tr>
    <tr><td class="paramname">max</td><td>Max </td></tr>
    <tr><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramname">msg1</td><td>Message to print. Default is "". </td></tr>
    <tr><td class="paramname">msg2</td><td>Message to print. Default is "". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="out__of__range_8hpp_source.html#l00030">30</a> of file <a class="el" href="out__of__range_8hpp_source.html">out_of_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b09a69d6aeee461a009b6355889e9e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2owens__t_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69de529b5013ba833af1ea6eff199194"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2owens__t_8hpp_source.html#l00034">34</a> of file <a class="el" href="fwd_2scal_2fun_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a316ab3b95493d045d77de4f8b96ed56a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2owens__t_8hpp_source.html#l00048">48</a> of file <a class="el" href="fwd_2scal_2fun_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af099f2a72adf07f89f5f27f405d7afab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Owen's T function of h and a. </p>
<p>Used to compute the cumulative density function for the skew normal distribution.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{owens\_t}(h, a) = \begin{cases} \mbox{owens\_t}(h, a) &amp; \mbox{if } -\infty\leq h, a \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } h = \textrm{NaN or } a = \textrm{NaN} \end{cases} \]" src="form_159.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{owens\_t}(h, a)}{\partial h} = \begin{cases} \frac{\partial\, \mbox{owens\_t}(h, a)}{\partial h} &amp; \mbox{if } -\infty\leq h, a\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } h = \textrm{NaN or } a = \textrm{NaN} \end{cases} \]" src="form_160.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{owens\_t}(h, a)}{\partial a} = \begin{cases} \frac{\partial\, \mbox{owens\_t}(h, a)}{\partial a} &amp; \mbox{if } -\infty\leq h, a\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } h = \textrm{NaN or } a = \textrm{NaN} \end{cases} \]" src="form_161.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{owens\_t}(h, a) = \frac{1}{2\pi} \int_0^a \frac{\exp(-\frac{1}{2}h^2(1+x^2))}{1+x^2}dx \]" src="form_162.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{owens\_t}(h, a)}{\partial h} = -\frac{1}{2\sqrt{2\pi}} \operatorname{erf}\left(\frac{ha}{\sqrt{2}}\right) \exp\left(-\frac{h^2}{2}\right) \]" src="form_163.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \mbox{owens\_t}(h, a)}{\partial a} = \frac{\exp\left(-\frac{1}{2}h^2(1+a^2)\right)}{2\pi (1+a^2)} \]" src="form_164.png"/>
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first argument. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>First argument </td></tr>
    <tr><td class="paramname">a</td><td>Second argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Owen's T function. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2owens__t_8hpp_source.html#l00062">62</a> of file <a class="el" href="prim_2scal_2fun_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a3be132b9586de8773f1489ad485e0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Owen's T function of h and a. </p>
<p>Used to compute the cumulative density function for the skew normal distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>var parameter. </td></tr>
    <tr><td class="paramname">a</td><td>var parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Owen's T function. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2owens__t_8hpp_source.html#l00066">66</a> of file <a class="el" href="rev_2scal_2fun_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa226754d101430c9bdf91ece0a9eb1d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Owen's T function of h and a. </p>
<p>Used to compute the cumulative density function for the skew normal distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>var parameter. </td></tr>
    <tr><td class="paramname">a</td><td>double parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Owen's T function. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2owens__t_8hpp_source.html#l00080">80</a> of file <a class="el" href="rev_2scal_2fun_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a8dab8811eeb8705651daeefc449816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::owens_t </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Owen's T function of h and a. </p>
<p>Used to compute the cumulative density function for the skew normal distribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>double parameter. </td></tr>
    <tr><td class="paramname">a</td><td>var parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Owen's T function. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2owens__t_8hpp_source.html#l00094">94</a> of file <a class="el" href="rev_2scal_2fun_2owens__t_8hpp_source.html">owens_t.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae265a3d80fc60a58c6642e3cb32e5a3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale, T_shape&gt;::type stan::math::pareto_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__ccdf__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="pareto__ccdf__log_8hpp_source.html">pareto_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04334b6b9aefbc902c156c6ebabd1b7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale, T_shape&gt;::type stan::math::pareto_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__cdf_8hpp_source.html#l00024">24</a> of file <a class="el" href="pareto__cdf_8hpp_source.html">pareto_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32b395deb308bc16b82587a97bfb1eba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale, T_shape&gt;::type stan::math::pareto_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__cdf__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="pareto__cdf__log_8hpp_source.html">pareto_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4eefb96c196d0c61694de1fda5d9a8c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale, T_shape&gt;::type stan::math::pareto_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="pareto__log_8hpp_source.html">pareto_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f851b988a9325dc6ea8398d45ff1601"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale, T_shape&gt;::type stan::math::pareto_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__log_8hpp_source.html#l00130">130</a> of file <a class="el" href="pareto__log_8hpp_source.html">pareto_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a624fd25c2bd925d2b96971c70b695245"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::pareto_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>y_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__rng_8hpp_source.html#l00022">22</a> of file <a class="el" href="pareto__rng_8hpp_source.html">pareto_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f7adad4637fb745bceb3be2db2c6d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::pareto_type_2_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__type__2__ccdf__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="pareto__type__2__ccdf__log_8hpp_source.html">pareto_type_2_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6aa9090877913c41608ec9edc7644718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::pareto_type_2_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__type__2__cdf_8hpp_source.html#l00025">25</a> of file <a class="el" href="pareto__type__2__cdf_8hpp_source.html">pareto_type_2_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc69970c0086687e5c19c7c3d4fe5108"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::pareto_type_2_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__type__2__cdf__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="pareto__type__2__cdf__log_8hpp_source.html">pareto_type_2_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a078e211e38ac272092603cdf728f3f02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::pareto_type_2_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__type__2__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="pareto__type__2__log_8hpp_source.html">pareto_type_2_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bd3253943ad32c19d36887e748a4aa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::pareto_type_2_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__type__2__log_8hpp_source.html#l00147">147</a> of file <a class="el" href="pareto__type__2__log_8hpp_source.html">pareto_type_2_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af55974320ebae90f0e36341934d8a57b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::pareto_type_2_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="pareto__type__2__rng_8hpp_source.html#l00023">23</a> of file <a class="el" href="pareto__type__2__rng_8hpp_source.html">pareto_type_2_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbb5b4072a22debb013dab8742e321df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::partial_derivative </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>dfx_dxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the partial derivative of the specified multiivariate function at the specified argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Argument type </td></tr>
    <tr><td class="paramname">F</td><td>Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Argument vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Index of argument with which to take derivative </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fx</td><td>Value of function applied to argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dfx_dxn</td><td>Value of partial derivative </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="partial__derivative_8hpp_source.html#l00029">29</a> of file <a class="el" href="partial__derivative_8hpp_source.html">partial_derivative.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac73a2c7f20161172ffee17c7c880019f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::Phi </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2_phi_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2_phi_8hpp_source.html">Phi.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac85644bbd92359d699f374adea62c643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::Phi </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unit normal cumulative distribution function. </p>
<p>The return value for a specified input is the probability that a random unit normal variate is less than or equal to the specified value, defined by</p>
<p><img class="formulaInl" alt="$\Phi(x) = \int_{-\infty}^x \mbox{\sf Norm}(x|0, 1) \ dx$" src="form_165.png"/></p>
<p>This function can be used to implement the inverse link function for probit regression.</p>
<p>Phi will underflow to 0 below -37.5 and overflow to 1 above 8</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability random sample is less than or equal to argument. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2_phi_8hpp_source.html#l00031">31</a> of file <a class="el" href="prim_2scal_2fun_2_phi_8hpp_source.html">Phi.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad88a365e721ffe6c1da4115e378bebf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::Phi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unit normal cumulative density function for variables (stan). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#ac73a2c7f20161172ffee17c7c880019f">stan::math::Phi()</a> for the double-based version.</p>
<p>The derivative is the unit normal density function,</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \Phi(x) = \mbox{\sf Norm}(x|0, 1) = \frac{1}{\sqrt{2\pi}} \exp(-\frac{1}{2} x^2)$" src="form_402.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{Phi}(x) = \begin{cases} 0 &amp; \mbox{if } x < -37.5 \\ \Phi(x) &amp; \mbox{if } -37.5 \leq x \leq 8.25 \\ 1 &amp; \mbox{if } x > 8.25 \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_403.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{Phi}(x)}{\partial x} = \begin{cases} 0 &amp; \mbox{if } x < -27.5 \\ \frac{\partial\, \Phi(x)}{\partial x} &amp; \mbox{if } -27.5 \leq x \leq 27.5 \\ 0 &amp; \mbox{if } x > 27.5 \\[6pt] \textrm{error} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_404.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Phi(x) = \frac{1}{\sqrt{2\pi}} \int_{0}^{x} e^{-t^2/2} dt \]" src="form_405.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \Phi(x)}{\partial x} = \frac{e^{-x^2/2}}{\sqrt{2\pi}} \]" src="form_406.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit normal cdf evaluated at the specified argument. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2_phi_8hpp_source.html#l00066">66</a> of file <a class="el" href="rev_2scal_2fun_2_phi_8hpp_source.html">Phi.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cf4bf2074175fd7bcde43f9f94e4d16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::Phi_approx </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximation of the unit normal CDF. </p>
<p><a href="http://www.jiem.org/index.php/jiem/article/download/60/27">http://www.jiem.org/index.php/jiem/article/download/60/27</a></p>
<p>This function can be used to implement the inverse link function for probit regression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability random sample is less than or equal to argument. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2_phi__approx_8hpp_source.html#l00023">23</a> of file <a class="el" href="prim_2scal_2fun_2_phi__approx_8hpp_source.html">Phi_approx.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa0a2a4530d320ca7945a09ae88783f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::Phi_approx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximation of the unit normal CDF for variables (stan). </p>
<p><a href="http://www.jiem.org/index.php/jiem/article/download/60/27">http://www.jiem.org/index.php/jiem/article/download/60/27</a></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{Phi\_approx}(x) = \begin{cases} \Phi_{\mbox{\footnotesize approx}}(x) &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_407.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{Phi\_approx}(x)}{\partial x} = \begin{cases} \frac{\partial\, \Phi_{\mbox{\footnotesize approx}}(x)}{\partial x} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_408.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Phi_{\mbox{\footnotesize approx}}(x) = \mbox{logit}^{-1}(0.07056 \, x^3 + 1.5976 \, x) \]" src="form_409.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \Phi_{\mbox{\footnotesize approx}}(x)}{\partial x} = -\Phi_{\mbox{\footnotesize approx}}^2(x) e^{-0.07056x^3 - 1.5976x}(-0.21168x^2-1.5976) \]" src="form_410.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding unit normal cdf approximation. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2_phi__approx_8hpp_source.html#l00047">47</a> of file <a class="el" href="rev_2scal_2fun_2_phi__approx_8hpp_source.html">Phi_approx.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2ffd66726e0532160e16e6b48d6f428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::pi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of pi. </p>
<dl class="section return"><dt>Returns</dt><dd>Pi. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00086">86</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad069a055750c038c054eb7ecabfb53bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_rate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_rate&gt;::type stan::math::poisson_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_rate &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__ccdf__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="poisson__ccdf__log_8hpp_source.html">poisson_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84009ffe822acedc6362015fd08107be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_rate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_rate&gt;::type stan::math::poisson_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_rate &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__cdf_8hpp_source.html#l00026">26</a> of file <a class="el" href="poisson__cdf_8hpp_source.html">poisson_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc9138a37ffe00ff85c6824447e85db1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_rate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_rate&gt;::type stan::math::poisson_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_rate &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__cdf__log_8hpp_source.html#l00025">25</a> of file <a class="el" href="poisson__cdf__log_8hpp_source.html">poisson_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7a95ee36796c1a077510303bb2535c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_rate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_rate&gt;::type stan::math::poisson_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_rate &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="poisson__log_8hpp_source.html">poisson_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a202d918359198306069f71f1477a046f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_rate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_rate&gt;::type stan::math::poisson_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_rate &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__log_8hpp_source.html#l00099">99</a> of file <a class="el" href="poisson__log_8hpp_source.html">poisson_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a06118d9d96bde7ee5d8c28eb08e5ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_n , typename T_log_rate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_log_rate&gt;::type stan::math::poisson_log_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_rate &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__log__log_8hpp_source.html#l00030">30</a> of file <a class="el" href="poisson__log__log_8hpp_source.html">poisson_log_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d441b4aee12ece4fc2d1b4d8027c7a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_n , typename T_log_rate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_log_rate&gt;::type stan::math::poisson_log_log </td>
          <td>(</td>
          <td class="paramtype">const T_n &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_log_rate &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__log__log_8hpp_source.html#l00110">110</a> of file <a class="el" href="poisson__log__log_8hpp_source.html">poisson_log_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3cdc8d2997b25f9ed799555ecf37106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::poisson_log_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__log__rng_8hpp_source.html#l00024">24</a> of file <a class="el" href="poisson__log__rng_8hpp_source.html">poisson_log_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f7aaf7ee5cf0eb93778d7f30db23834"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::poisson_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="poisson__rng_8hpp_source.html#l00025">25</a> of file <a class="el" href="poisson__rng_8hpp_source.html">poisson_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cf6708d0fb577e217e81463282cae71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::positive_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the positive value for the specified unconstrained input. </p>
<p>The transform applied is</p>
<p><img class="formulaInl" alt="$f(x) = \exp(x)$" src="form_166.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Arbitrary input scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input transformed to be positive. </dd></dl>

<p>Definition at line <a class="el" href="positive__constrain_8hpp_source.html#l00022">22</a> of file <a class="el" href="positive__constrain_8hpp_source.html">positive_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f9c43fc857272a76bb4030122ac91ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::positive_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the positive value for the specified unconstrained input, incrementing the scalar reference with the log absolute Jacobian determinant. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a6cf6708d0fb577e217e81463282cae71" title="Return the positive value for the specified unconstrained input. ">positive_constrain(T)</a></code> for details of the transform. The log absolute Jacobian determinant is</p>
<p><img class="formulaInl" alt="$\log | \frac{d}{dx} \mbox{exp}(x) | = \log | \mbox{exp}(x) | = x$" src="form_167.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Arbitrary input scalar. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input transformed to be positive. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="positive__constrain_8hpp_source.html#l00044">44</a> of file <a class="el" href="positive__constrain_8hpp_source.html">positive_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a20798b12abb29d73f7391168f836f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::positive_free </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unconstrained value corresponding to the specified positive-constrained value. </p>
<p>The transform is the inverse of the transform <img class="formulaInl" alt="$f$" src="form_168.png"/> applied by <code><a class="el" href="namespacestan_1_1math.html#a6cf6708d0fb577e217e81463282cae71" title="Return the positive value for the specified unconstrained input. ">positive_constrain(T)</a></code>, namely</p>
<p><img class="formulaInl" alt="$f^{-1}(x) = \log(x)$" src="form_169.png"/>.</p>
<p>The input is validated using <code><a class="el" href="namespacestan_1_1math.html#a814694b1125e641ca7b2e7269c82f966" title="Return true if y is positive. ">stan::math::check_positive()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Input scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unconstrained value that produces the input when constrained. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the variable is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="positive__free_8hpp_source.html#l00029">29</a> of file <a class="el" href="positive__free_8hpp_source.html">positive_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34675a70d3df614d88d33ddbdd49b49a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::positive_infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return positive infinity. </p>
<dl class="section return"><dt>Returns</dt><dd>Positive infinity. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00123">123</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada937f012b7d54cebdf8d9414f6fdbad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::positive_ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an increasing positive ordered vector derived from the specified free vector. </p>
<p>The returned constrained vector will have the same dimensionality as the specified free vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free vector of scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Positive, increasing ordered vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="positive__ordered__constrain_8hpp_source.html#l00023">23</a> of file <a class="el" href="positive__ordered__constrain_8hpp_source.html">positive_ordered_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7879746a7bed2564ae72c2916658e5a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::positive_ordered_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a positive valued, increasing positive ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform. </p>
<p>The returned constrained vector will have the same dimensionality as the specified free vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free vector of scalars. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Positive, increasing ordered vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="positive__ordered__constrain_8hpp_source.html#l00055">55</a> of file <a class="el" href="positive__ordered__constrain_8hpp_source.html">positive_ordered_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af81e69a15e82f86eefba93f8dcd3966e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::positive_ordered_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector of unconstrained scalars that transform to the specified positive ordered vector. </p>
<p>This function inverts the constraining operation defined in <code>positive_ordered_constrain(Matrix)</code>,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Vector of positive, ordered scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Free vector that transforms into the input vector. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is not a vector of positive, ordered scalars. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="positive__ordered__free_8hpp_source.html#l00028">28</a> of file <a class="el" href="positive__ordered__free_8hpp_source.html">positive_ordered_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27caea996a79cd150f26db44fd635684"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::pow </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2pow_8hpp_source.html#l00018">18</a> of file <a class="el" href="fwd_2scal_2fun_2pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab594b61f84170ba4b4b887f6a911a0d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::pow </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2pow_8hpp_source.html#l00030">30</a> of file <a class="el" href="fwd_2scal_2fun_2pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b8ae604ced89240175e69281577be04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::pow </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2pow_8hpp_source.html#l00040">40</a> of file <a class="el" href="fwd_2scal_2fun_2pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32adb49018d9fd61d3c568d1edcdb3c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::pow </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base raised to the power of the exponent (cmath). </p>
<p>The partial derivatives are</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial x} \mbox{pow}(x, y) = y x^{y-1}$" src="form_411.png"/>, and</p>
<p><img class="formulaInl" alt="$\frac{\partial}{\partial y} \mbox{pow}(x, y) = x^y \ \log x$" src="form_412.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{pow}(x, y) = \begin{cases} x^y &amp; \mbox{if } -\infty\leq x, y \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_413.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{pow}(x, y)}{\partial x} = \begin{cases} yx^{y-1} &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_414.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{pow}(x, y)}{\partial y} = \begin{cases} x^y\ln x &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } y = \textrm{NaN} \end{cases} \]" src="form_415.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base variable. </td></tr>
    <tr><td class="paramname">exponent</td><td>Exponent variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base raised to the exponent. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2pow_8hpp_source.html#l00103">103</a> of file <a class="el" href="rev_2scal_2fun_2pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff1b3f97cd1cf4c7391d160f9a3db4f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::pow </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base variable raised to the power of the exponent scalar (cmath). </p>
<p>The derivative for the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{pow}(x, c) = c x^{c-1}$" src="form_416.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base variable. </td></tr>
    <tr><td class="paramname">exponent</td><td>Exponent scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base raised to the exponent. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2pow_8hpp_source.html#l00119">119</a> of file <a class="el" href="rev_2scal_2fun_2pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52dafae271ea06210bf3cbe2545ead16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::pow </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base scalar raised to the power of the exponent variable (cmath). </p>
<p>The derivative for the variable is</p>
<p><img class="formulaInl" alt="$\frac{d}{d y} \mbox{pow}(c, y) = c^y \log c $" src="form_417.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base scalar. </td></tr>
    <tr><td class="paramname">exponent</td><td>Exponent variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Base raised to the exponent. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2pow_8hpp_source.html#l00141">141</a> of file <a class="el" href="rev_2scal_2fun_2pow_8hpp_source.html">pow.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ae0c4c9c64db8bb166f67caf352b35f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::precomputed_gradients </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; var &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a var for an expression that has the specified value, vector of operands, and vector of partial derivatives of value with respect to the operands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the resulting dependent variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operands</td><td>operands. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradients</td><td>vector of partial derivatives of result with respect to operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An auto-diff variable that uses the precomputed gradients provided. </dd></dl>

<p>Definition at line <a class="el" href="precomputed__gradients_8hpp_source.html#l00098">98</a> of file <a class="el" href="precomputed__gradients_8hpp_source.html">precomputed_gradients.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ccbe1638f463027973553dec7175dbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::primitive_value </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the primitive double value for the specified auto-diff variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of input. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2primitive__value_8hpp_source.html#l00017">17</a> of file <a class="el" href="rev_2scal_2fun_2primitive__value_8hpp_source.html">primitive_value.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24337e3af682981f05d1cc022e675891"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::primitive_value </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the primitive value of the specified forward-mode autodiff variable. </p>
<p>This function applies recursively to higher-order autodiff types to return a primitive double value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type for autodiff variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>input variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>primitive value of input. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2primitive__value_8hpp_source.html#l00022">22</a> of file <a class="el" href="fwd_2scal_2fun_2primitive__value_8hpp_source.html">primitive_value.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8cbc3a490edf340544fb12df544269e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;boost::is_arithmetic&lt;T&gt;, T&gt;::type stan::math::primitive_value </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified arithmetic argument unmodified with its own declared type. </p>
<p>This template function can only be instantiated with arithmetic types as defined by Boost's <code>is_arithmetic</code> trait metaprogram.</p>
<p>This function differs from <code><a class="el" href="namespacestan_1_1math.html#a541f8f9d951f4d48c457dcecad5e326b" title="Return the value of the specified variable. ">stan::math::value_of</a></code> in that it does not cast all return types to <code>double</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of arithmetic input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input unmodified. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2primitive__value_8hpp_source.html#l00030">30</a> of file <a class="el" href="prim_2scal_2fun_2primitive__value_8hpp_source.html">primitive_value.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0491e419195548cdede51a384547aef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_arithmetic&lt;T&gt;, double&gt;::type stan::math::primitive_value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the primitive value of the specified argument. </p>
<p>This implementation only applies to non-arithmetic types as defined by Boost's <code>is_arithmetic</code> trait metaprogram.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of non-arithmetic input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of input. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2primitive__value_8hpp_source.html#l00047">47</a> of file <a class="el" href="prim_2scal_2fun_2primitive__value_8hpp_source.html">primitive_value.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0611cecb5356e187818c1901134c7665"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::print_stack </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the auto-dif variable stack. </p>
<p>This function is used for debugging purposes.</p>
<p>Only works if all members of stack are vari* as it casts to vari*.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>ostream to modify </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="print__stack_8hpp_source.html#l00022">22</a> of file <a class="el" href="print__stack_8hpp_source.html">print_stack.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a0b9c35bc619ea5fbac226e985bbc1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prob_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar. </p>
<p>The transform is the inverse logit,</p>
<p><img class="formulaInl" alt="$f(x) = \mbox{logit}^{-1}(x) = \frac{1}{1 + \exp(x)}$" src="form_170.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability-constrained result of transforming the free scalar. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prob__constrain_8hpp_source.html#l00027">27</a> of file <a class="el" href="prob__constrain_8hpp_source.html">prob_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b5c8822124337e5d000cfa60046c5fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prob_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar and increment the specified log probability reference with the log absolute Jacobian determinant of the transform. </p>
<p>The transform is as defined for <code><a class="el" href="namespacestan_1_1math.html#a7a0b9c35bc619ea5fbac226e985bbc1d" title="Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free sca...">prob_constrain(T)</a></code>. The log absolute Jacobian determinant is</p>
<p>The log absolute Jacobian determinant is</p>
<p><img class="formulaInl" alt="$\log | \frac{d}{dx} \mbox{logit}^{-1}(x) |$" src="form_171.png"/> </p>
<p><img class="formulaInl" alt="$\log ((\mbox{logit}^{-1}(x)) (1 - \mbox{logit}^{-1}(x))$" src="form_172.png"/> </p>
<p><img class="formulaInl" alt="$\log (\mbox{logit}^{-1}(x)) + \log (1 - \mbox{logit}^{-1}(x))$" src="form_173.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability-constrained result of transforming the free scalar. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prob__constrain_8hpp_source.html#l00055">55</a> of file <a class="el" href="prob__constrain_8hpp_source.html">prob_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a533afff719fe3e21bf53d2fa53d2fbe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prob_free </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the free scalar that when transformed to a probability produces the specified scalar. </p>
<p>The function that reverses the constraining transform specified in <code><a class="el" href="namespacestan_1_1math.html#a7a0b9c35bc619ea5fbac226e985bbc1d" title="Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free sca...">prob_constrain(T)</a></code> is the logit function,</p>
<p><img class="formulaInl" alt="$f^{-1}(y) = \mbox{logit}(y) = \frac{1 - y}{y}$" src="form_174.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Scalar input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if y is less than 0 or greater than 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prob__free_8hpp_source.html#l00027">27</a> of file <a class="el" href="prob__free_8hpp_source.html">prob_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1649a895ec6e79097d5645a3f8b8a1e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prod </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of the coefficients of the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00017">17</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7082de8742d87f7a0fa0842207341c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::prod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the product of the coefficients of the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="prod_8hpp_source.html#l00032">32</a> of file <a class="el" href="prod_8hpp_source.html">prod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a300cf63dd3332cff2161fdc32aec4026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1common__type.html">common_type</a>&lt;T1, T2&gt;::type stan::math::promote_common </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="promote__common_8hpp_source.html#l00014">14</a> of file <a class="el" href="promote__common_8hpp_source.html">promote_common.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4815c45c3f87ea98453880863e3a0b94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a>&lt;T, S&gt;::type stan::math::promote_scalar </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the top-level function to call to promote the scalar types of an input of type S to type T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type of output. </td></tr>
    <tr><td class="paramname">S</td><td>input type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input vector with scalars promoted to type T. </dd></dl>

<p>Definition at line <a class="el" href="scal_2fun_2promote__scalar_8hpp_source.html#l00100">100</a> of file <a class="el" href="scal_2fun_2promote__scalar_8hpp_source.html">promote_scalar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9559f36eb30f7c55b3576d8540b6bad2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2qr___q_8hpp_source.html#l00014">14</a> of file <a class="el" href="prim_2mat_2fun_2qr___q_8hpp_source.html">qr_Q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4badef735ea8b1cbfca31cbe49a534cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::qr_Q </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2qr___q_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2mat_2fun_2qr___q_8hpp_source.html">qr_Q.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebb8132560117eeef1a07ced4b144598"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::qr_R </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2qr___r_8hpp_source.html#l00014">14</a> of file <a class="el" href="prim_2mat_2fun_2qr___r_8hpp_source.html">qr_R.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2c6e003d4aa779acef714b05a153c1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::qr_R </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2qr___r_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2mat_2fun_2qr___r_8hpp_source.html">qr_R.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88f53cb144d0e550d5113e565a91a947"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, CB, CB&gt; stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute B^T A B. </p>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2quad__form_8hpp_source.html#l00021">21</a> of file <a class="el" href="prim_2mat_2fun_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8166027d80ecdbc607ef3c1c44fd1e8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2quad__form_8hpp_source.html#l00033">33</a> of file <a class="el" href="prim_2mat_2fun_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae29c95a66e3c89b411b47a9613f7d00c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;TB, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, CB, CB&gt; &gt;::type stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2quad__form_8hpp_source.html#l00124">124</a> of file <a class="el" href="rev_2mat_2fun_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78760f17a4a1aa70975f3c4abbc1d03d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , int RA, int CA, typename TB , int RB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;TB, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type stan::math::quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; TB, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2quad__form_8hpp_source.html#l00141">141</a> of file <a class="el" href="rev_2mat_2fun_2quad__form_8hpp_source.html">quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55363638ef70a37127901ecb57962048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;typename promote_args&lt;T1, T2&gt;::type, Dynamic, Dynamic&gt; stan::math::quad_form_diag </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T1, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="quad__form__diag_8hpp_source.html#l00020">20</a> of file <a class="el" href="quad__form__diag_8hpp_source.html">quad_form_diag.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4936ab9c3dab8c4194195de5aa398394"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, CB, CB&gt; stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2quad__form__sym_8hpp_source.html#l00019">19</a> of file <a class="el" href="prim_2mat_2fun_2quad__form__sym_8hpp_source.html">quad_form_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e0e772a20247cedc2da98a9c8946c89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;TB, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, CB, CB&gt; &gt;::type stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2quad__form__sym_8hpp_source.html#l00025">25</a> of file <a class="el" href="rev_2mat_2fun_2quad__form__sym_8hpp_source.html">quad_form_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b0b2bfea6c360dcc5739fd908b39d60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2quad__form__sym_8hpp_source.html#l00034">34</a> of file <a class="el" href="prim_2mat_2fun_2quad__form__sym_8hpp_source.html">quad_form_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e79db5761062cc2b5eebe9edca4127e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , int RA, int CA, typename TB , int RB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;TB, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type stan::math::quad_form_sym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; TB, RB, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2quad__form__sym_8hpp_source.html#l00043">43</a> of file <a class="el" href="rev_2mat_2fun_2quad__form__sym_8hpp_source.html">quad_form_sym.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1baa9539e0a8d4ea50aa16b73d736d93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rank </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components of v less than v[s]. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of components of v less than v[s]. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rank_8hpp_source.html#l00018">18</a> of file <a class="el" href="rank_8hpp_source.html">rank.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a808d3133624cd36ac410ba872ea653c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rank </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of components of v less than v[s]. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of components of v less than v[s]. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rank_8hpp_source.html#l00038">38</a> of file <a class="el" href="rank_8hpp_source.html">rank.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ca6e149995234eee4801ea4090b34cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale&gt;::type stan::math::rayleigh_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rayleigh__ccdf__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="rayleigh__ccdf__log_8hpp_source.html">rayleigh_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abca0bc173ef3459a1eac46296bcd83bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale&gt;::type stan::math::rayleigh_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rayleigh__cdf_8hpp_source.html#l00028">28</a> of file <a class="el" href="rayleigh__cdf_8hpp_source.html">rayleigh_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae588257225777f6a33cffb2139f8a4d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale&gt;::type stan::math::rayleigh_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rayleigh__cdf__log_8hpp_source.html#l00028">28</a> of file <a class="el" href="rayleigh__cdf__log_8hpp_source.html">rayleigh_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60039dc0a79268bbb0da0a715b309af9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale&gt;::type stan::math::rayleigh_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rayleigh__log_8hpp_source.html#l00029">29</a> of file <a class="el" href="rayleigh__log_8hpp_source.html">rayleigh_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87968a836e36d11622dbe52db277f36e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_scale&gt;::type stan::math::rayleigh_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rayleigh__log_8hpp_source.html#l00109">109</a> of file <a class="el" href="rayleigh__log_8hpp_source.html">rayleigh_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab42ace2560fde585011d2f3c5459139"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::rayleigh_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rayleigh__rng_8hpp_source.html#l00027">27</a> of file <a class="el" href="rayleigh__rng_8hpp_source.html">rayleigh_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57f4b9ccc58d2d03aec434abb0795e41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::read_corr_L </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations. </p>
<p>It is generally better to work with the Cholesky factor rather than the correlation matrix itself when the determinant, inverse, etc. of the correlation matrix is needed for some statistical calculation.</p>
<p>See <code>read_corr_matrix(Array, size_t, T)</code> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CPCs</td><td>The (K choose 2) canonical partial correlations in (-1, 1). </td></tr>
    <tr><td class="paramname">K</td><td>Dimensionality of correlation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cholesky factor of correlation matrix for specified canonical partial correlations.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of underlying scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="read__corr___l_8hpp_source.html#l00041">41</a> of file <a class="el" href="read__corr___l_8hpp_source.html">read_corr_L.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6d327921ea7356872f0eec002c0b032"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::read_corr_L </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>log_prob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation. </p>
<p>The implementation is Ben Goodrich's Cholesky factor-based approach to the C-vine method of:</p>
<ul>
<li>
Daniel Lewandowski, Dorota Kurowicka, and Harry Joe, Generating random correlation matrices based on vines and extended onion method Journal of Multivariate Analysis 100 (2009) 1989–2001 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CPCs</td><td>The (K choose 2) canonical partial correlations in (-1, 1). </td></tr>
    <tr><td class="paramname">K</td><td>Dimensionality of correlation matrix. </td></tr>
    <tr><td class="paramname">log_prob</td><td>Reference to variable to increment with the log Jacobian determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cholesky factor of correlation matrix for specified partial correlations. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of underlying scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="read__corr___l_8hpp_source.html#l00095">95</a> of file <a class="el" href="read__corr___l_8hpp_source.html">read_corr_L.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2510336c2dac321c32b171f8ef407a06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::read_corr_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations. </p>
<p>See <code>read_corr_matrix(Array, size_t, T)</code> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CPCs</td><td>The (K choose 2) canonical partial correlations in (-1, 1). </td></tr>
    <tr><td class="paramname">K</td><td>Dimensionality of correlation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cholesky factor of correlation matrix for specified canonical partial correlations. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of underlying scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="read__corr__matrix_8hpp_source.html#l00028">28</a> of file <a class="el" href="read__corr__matrix_8hpp_source.html">read_corr_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09c8a74b36fb456b0baf2d049427487b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::read_corr_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>log_prob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation. </p>
<p>It is usually preferable to utilize the version that returns the Cholesky factor of the correlation matrix rather than the correlation matrix itself in statistical calculations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CPCs</td><td>The (K choose 2) canonical partial correlations in (-1, 1). </td></tr>
    <tr><td class="paramname">K</td><td>Dimensionality of correlation matrix. </td></tr>
    <tr><td class="paramname">log_prob</td><td>Reference to variable to increment with the log Jacobian determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Correlation matrix for specified partial correlations. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of underlying scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="read__corr__matrix_8hpp_source.html#l00056">56</a> of file <a class="el" href="read__corr__matrix_8hpp_source.html">read_corr_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34dc4b0fb00808b0d444b2c656c44c28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::read_cov_L </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>log_prob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function that should be called prior to evaluating the density of any elliptical distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CPCs</td><td>on (-1, 1) </td></tr>
    <tr><td class="paramname">sds</td><td>on (0, inf) </td></tr>
    <tr><td class="paramname">log_prob</td><td>the log probability value to increment with the Jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cholesky factor of covariance matrix for specified partial correlations. </dd></dl>

<p>Definition at line <a class="el" href="read__cov___l_8hpp_source.html#l00023">23</a> of file <a class="el" href="read__cov___l_8hpp_source.html">read_cov_L.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aecf731d715f789bfad7dbb712851c52e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::read_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>log_prob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generally worse alternative to call prior to evaluating the density of an elliptical distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CPCs</td><td>on (-1, 1) </td></tr>
    <tr><td class="paramname">sds</td><td>on (0, inf) </td></tr>
    <tr><td class="paramname">log_prob</td><td>the log probability value to increment with the Jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Covariance matrix for specified partial correlations. </dd></dl>

<p>Definition at line <a class="el" href="read__cov__matrix_8hpp_source.html#l00023">23</a> of file <a class="el" href="read__cov__matrix_8hpp_source.html">read_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60bca98247a2b43a06388e08eade3ea5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::read_cov_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>CPCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a covariance matrix from CPCs and standard deviations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CPCs</td><td>in (-1, 1) </td></tr>
    <tr><td class="paramname">sds</td><td>in (0, inf) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="read__cov__matrix_8hpp_source.html#l00041">41</a> of file <a class="el" href="read__cov__matrix_8hpp_source.html">read_cov_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe2cbb83ac9ef52296755690e61f4298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stan::math::recover_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recover memory used for all variables for reuse. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code><a class="el" href="namespacestan_1_1math.html#a430f171295b91277dc60dfa2177c7c0b" title="Return true if there is no nested autodiff being executed. ">empty_nested()</a></code> returns <code>false</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="recover__memory_8hpp_source.html#l00019">19</a> of file <a class="el" href="recover__memory_8hpp_source.html">recover_memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ebf2b2bc0f63dcb46a176b43e8b369a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stan::math::recover_memory_nested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recover only the memory used for the top nested call. </p>
<p>If there is nothing on the nested stack, then a <code>std::logic_error</code> exception is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code><a class="el" href="namespacestan_1_1math.html#a430f171295b91277dc60dfa2177c7c0b" title="Return true if there is no nested autodiff being executed. ">empty_nested()</a></code> returns <code>true</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="recover__memory__nested_8hpp_source.html#l00021">21</a> of file <a class="el" href="recover__memory__nested_8hpp_source.html">recover_memory_nested.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3d78d2735a35451f02bcd2f4da24886"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00013">13</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8edf0b7ec2ad24b1fda26a8d58513106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00021">21</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53054db4cfa6672654fbaedafbdae242"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;T&gt; &gt; &gt; stan::math::rep_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__array_8hpp_source.html#l00031">31</a> of file <a class="el" href="rep__array_8hpp_source.html">rep_array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacc2f4a71f9187885d1fa61a79285eec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00016">16</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44e90dfa0b0247bee1e9c739d5aee3b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00026">26</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbe06e42d623e4c975cd636d06bcd383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__matrix_8hpp_source.html#l00036">36</a> of file <a class="el" href="rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9320ac189d0991ef6200daed95bd3c2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, 1, Eigen::Dynamic&gt; stan::math::rep_row_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__row__vector_8hpp_source.html#l00015">15</a> of file <a class="el" href="rep__row__vector_8hpp_source.html">rep_row_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a323f6ee7be13a0f7fa7cffa12204ba88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T&gt;::type, Eigen::Dynamic, 1&gt; stan::math::rep_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rep__vector_8hpp_source.html#l00016">16</a> of file <a class="el" href="rep__vector_8hpp_source.html">rep_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8abf3ffa6d67a158348134225c9d3090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::resize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vectors or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Array-like object to resize. </td></tr>
    <tr><td class="paramname">dims</td><td>New dimensions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object being resized. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="resize_8hpp_source.html#l00063">63</a> of file <a class="el" href="resize_8hpp_source.html">resize.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5aa264060b3c4ed7954f07dc0fcf138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2rising__factorial_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60a96a3d8a0a67f4ab99175db6b4e859"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2rising__factorial_8hpp_source.html#l00028">28</a> of file <a class="el" href="fwd_2scal_2fun_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1964156202b850138f2accd71ff18724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2rising__factorial_8hpp_source.html#l00041">41</a> of file <a class="el" href="fwd_2scal_2fun_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a317b1161dabe541d3011714f97684ca4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2rising__factorial_8hpp_source.html#l00054">54</a> of file <a class="el" href="rev_2scal_2fun_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6db558a6d0b54bf4ea23d9f247c6fbdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{rising\_factorial}(x, n) = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ x^{(n)} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_175.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{rising\_factorial}(x, n)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, x^{(n)}}{\partial x} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_176.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{rising\_factorial}(x, n)}{\partial n} = \begin{cases} \textrm{error} &amp; \mbox{if } x \leq 0\\ \frac{\partial\, x^{(n)}}{\partial n} &amp; \mbox{if } x > 0 \textrm{ and } -\infty \leq n \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN or } n = \textrm{NaN} \end{cases} \]" src="form_177.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x^{(n)}=\frac{\Gamma(x+n)}{\Gamma(x)} \]" src="form_178.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, x^{(n)}}{\partial x} = x^{(n)}(\Psi(x+n)-\Psi(x)) \]" src="form_179.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, x^{(n)}}{\partial n} = (x)_n\Psi(x+n) \]" src="form_180.png"/>
</p>
 
<p>Definition at line <a class="el" href="prim_2scal_2fun_2rising__factorial_8hpp_source.html#l00054">54</a> of file <a class="el" href="prim_2scal_2fun_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b35a50161c460ac1d885c61bd705d5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2rising__factorial_8hpp_source.html#l00059">59</a> of file <a class="el" href="rev_2scal_2fun_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4b13a596449384f742cc4b758c2e3b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::rising_factorial </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2scal_2fun_2rising__factorial_8hpp_source.html#l00064">64</a> of file <a class="el" href="rev_2scal_2fun_2rising__factorial_8hpp_source.html">rising_factorial.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb73c37a4cec41a69516391a2336fb11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::round </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2round_8hpp_source.html#l00011">11</a> of file <a class="el" href="fwd_2scal_2fun_2round_8hpp_source.html">round.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab259f70f4c7ebcdf3e032f01efb66c02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::round </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rounded form of the specified variable (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#adb73c37a4cec41a69516391a2336fb11">round()</a> for the double-based version.</p>
<p>The derivative is zero everywhere but numbers half way between whole numbers, so for convenience the derivative is defined to be everywhere zero,</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{round}(x) = 0$" src="form_418.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{round}(x) = \begin{cases} \lceil x \rceil &amp; \mbox{if } x-\lfloor x\rfloor \geq 0.5 \\ \lfloor x \rfloor &amp; \mbox{if } x-\lfloor x\rfloor < 0.5 \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_419.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{round}(x)}{\partial x} = \begin{cases} 0 &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_420.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Specified variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rounded variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2round_8hpp_source.html#l00057">57</a> of file <a class="el" href="rev_2scal_2fun_2round_8hpp_source.html">round.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab98e74182d133e210dda425a689f2fb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::math::row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified row of the specified matrix, using start-at-1 indexing. </p>
<p>This is equivalent to calling <code>m.row(i - 1)</code> and assigning the resulting template expression to a row vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar value type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
    <tr><td class="paramname">i</td><td>Row index (count from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified row of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="row_8hpp_source.html#l00025">25</a> of file <a class="el" href="row_8hpp_source.html">row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb157990709e17068a450238d0a579fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::rows </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rows_8hpp_source.html#l00012">12</a> of file <a class="el" href="rows_8hpp_source.html">rows.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a060626b1758db1e659c0820f77eb7dcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, 1&gt; stan::math::rows_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2rows__dot__product_8hpp_source.html#l00018">18</a> of file <a class="el" href="fwd_2mat_2fun_2rows__dot__product_8hpp_source.html">rows_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e1fb33918f8c4e61cc7709905db012c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, R1, 1&gt; stan::math::rows_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2rows__dot__product_8hpp_source.html#l00022">22</a> of file <a class="el" href="prim_2mat_2fun_2rows__dot__product_8hpp_source.html">rows_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a719a9c5d9d748a503b52d44ed4802193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;boost::is_same&lt;T1, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;T2, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R1, 1&gt; &gt;::type stan::math::rows_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2rows__dot__product_8hpp_source.html#l00025">25</a> of file <a class="el" href="rev_2mat_2fun_2rows__dot__product_8hpp_source.html">rows_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab5f5461d67d595a0c0fd720ae6cd6bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, 1&gt; stan::math::rows_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2rows__dot__product_8hpp_source.html#l00035">35</a> of file <a class="el" href="fwd_2mat_2fun_2rows__dot__product_8hpp_source.html">rows_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6b02f2791c9c5a29811bf411e5f6e4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R1, 1&gt; stan::math::rows_dot_product </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2rows__dot__product_8hpp_source.html#l00052">52</a> of file <a class="el" href="fwd_2mat_2fun_2rows__dot__product_8hpp_source.html">rows_dot_product.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b6208b5b257e2a7efac35e88ab93e8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, 1&gt; stan::math::rows_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2rows__dot__self_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2mat_2fun_2rows__dot__self_8hpp_source.html">rows_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ae75387d4a15a928dfe2be6c987e2cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, 1&gt; stan::math::rows_dot_self </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dot product of each row of a matrix with itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>scalar type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2rows__dot__self_8hpp_source.html#l00016">16</a> of file <a class="el" href="prim_2mat_2fun_2rows__dot__self_8hpp_source.html">rows_dot_self.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2eb786f14699d69c39cfdd49893a8006"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::scaled_add </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="scaled__add_8hpp_source.html#l00011">11</a> of file <a class="el" href="scaled__add_8hpp_source.html">scaled_add.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fefbbf10f04d62902c383f26d98eaee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_scale&gt;::type stan::math::scaled_inv_chi_square_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="scaled__inv__chi__square__ccdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="scaled__inv__chi__square__ccdf__log_8hpp_source.html">scaled_inv_chi_square_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac5ccd3b4bbd2f80b59a6cfaa2a7ebcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_scale&gt;::type stan::math::scaled_inv_chi_square_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CDF of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
    <tr><td class="paramname">s</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if s is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="scaled__inv__chi__square__cdf_8hpp_source.html#l00046">46</a> of file <a class="el" href="scaled__inv__chi__square__cdf_8hpp_source.html">scaled_inv_chi_square_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f8d0c1c0ea0a346e972a2b461fb2b51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_scale&gt;::type stan::math::scaled_inv_chi_square_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="scaled__inv__chi__square__cdf__log_8hpp_source.html#l00032">32</a> of file <a class="el" href="scaled__inv__chi__square__cdf__log_8hpp_source.html">scaled_inv_chi_square_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa760eab5a913100acb5ad73851ec520f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_scale&gt;::type stan::math::scaled_inv_chi_square_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{Inv-}}\chi^2(\nu, s^2) \\ \log (p (y \, |\, \nu, s)) &amp;=&amp; \log \left( \frac{(\nu / 2)^{\nu / 2}}{\Gamma (\nu / 2)} s^\nu y^{- (\nu / 2 + 1)} \exp^{-\nu s^2 / (2y)} \right) \\ &amp;=&amp; \frac{\nu}{2} \log(\frac{\nu}{2}) - \log (\Gamma (\nu / 2)) + \nu \log(s) - (\frac{\nu}{2} + 1) \log(y) - \frac{\nu s^2}{2y} \\ &amp; &amp; \mathrm{ where } \; y > 0 \end{eqnarray*}" src="form_197.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
    <tr><td class="paramname">s</td><td>Scale parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than 0 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if s is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="scaled__inv__chi__square__log_8hpp_source.html#l00051">51</a> of file <a class="el" href="scaled__inv__chi__square__log_8hpp_source.html">scaled_inv_chi_square_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a469a0510198f66cfb4a23d9f0d185541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_scale&gt;::type stan::math::scaled_inv_chi_square_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="scaled__inv__chi__square__log_8hpp_source.html#l00173">173</a> of file <a class="el" href="scaled__inv__chi__square__log_8hpp_source.html">scaled_inv_chi_square_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aefb144e1487af0dcab52c5f47fcbc93f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::scaled_inv_chi_square_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="scaled__inv__chi__square__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="scaled__inv__chi__square__rng_8hpp_source.html">scaled_inv_chi_square_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34fd02fe795ea38c98f4a02befed309f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unbiased sample standard deviation of the coefficients in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2sd_8hpp_source.html#l00022">22</a> of file <a class="el" href="prim_2mat_2fun_2sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e1cb72c1528f0ff383033c642341147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unbiased sample standard deviation of the coefficients in the specified vector, row vector, or matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector, row vector or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2sd_8hpp_source.html#l00037">37</a> of file <a class="el" href="prim_2mat_2fun_2sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6a5f3ceef72929ae7b80e83338d33f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; var &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sample standard deviation of the specified standard vector. </p>
<p>Raise domain error if size is not greater than zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sample standard deviation of specified vector </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2sd_8hpp_source.html#l00065">65</a> of file <a class="el" href="rev_2mat_2fun_2sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a706c4baf534be70bbaa1cceae41da186"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::sd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2sd_8hpp_source.html#l00082">82</a> of file <a class="el" href="rev_2mat_2fun_2sd_8hpp_source.html">sd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad87f51c66f702f242b3c5d207896f5d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector starting from the specified element - 1 of the specified vector. </p>

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00019">19</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6068f2afa41aeec7f65229719dfda963"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00035">35</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a721232b5c8e7c068a120719255f5fb0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::segment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="segment_8hpp_source.html#l00052">52</a> of file <a class="el" href="segment_8hpp_source.html">segment.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9614efc6fd66533b74b43ddb69f21d3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stan::math::set_zero_all_adjoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all adjoint values in the stack to zero. </p>

<p>Definition at line <a class="el" href="set__zero__all__adjoints_8hpp_source.html#l00014">14</a> of file <a class="el" href="set__zero__all__adjoints_8hpp_source.html">set_zero_all_adjoints.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad825f81b97ddf0b2e1217f30913559a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sign_8hpp_source.html#l00009">9</a> of file <a class="el" href="sign_8hpp_source.html">sign.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6341abfdbb8a7f35432a73f27b131688"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::simplex_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the simplex corresponding to the specified free vector. </p>
<p>A simplex is a vector containing values greater than or equal to 0 that sum to 1. A vector with (K-1) unconstrained values will produce a simplex of size K.</p>
<p>The transform is based on a centered stick-breaking process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Free vector input of dimensionality K - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Simplex of dimensionality K. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simplex__constrain_8hpp_source.html#l00030">30</a> of file <a class="el" href="simplex__constrain_8hpp_source.html">simplex_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a552a1c130bd90d93271bc9169b2e0ce2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::simplex_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the simplex corresponding to the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform. </p>
<p>The simplex transform is defined through a centered stick-breaking process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Free vector input of dimensionality K - 1. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Simplex of dimensionality K. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simplex__constrain_8hpp_source.html#l00069">69</a> of file <a class="el" href="simplex__constrain_8hpp_source.html">simplex_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a110fab43edbb2ebb9206643900083971"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::simplex_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an unconstrained vector that when transformed produces the specified simplex. </p>
<p>It applies to a simplex of dimensionality K and produces an unconstrained vector of dimensionality (K-1).</p>
<p>The simplex transform is defined through a centered stick-breaking process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Simplex of dimensionality K. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Free vector of dimensionality (K-1) that transfroms to the simplex. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x is not a valid simplex </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="simplex__free_8hpp_source.html#l00030">30</a> of file <a class="el" href="simplex__free_8hpp_source.html">simplex_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff3f2dd84567a0566cfdd7eb10e13607"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::sin </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2sin_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2sin_8hpp_source.html">sin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae306538402ac590b8b84e6ed58989629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::sin </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sine of a radian-scaled variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \sin x = \cos x$" src="form_421.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{sin}(x) = \begin{cases} \sin(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_422.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{sin}(x)}{\partial x} = \begin{cases} \cos(x) &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_423.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable for radians of angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sine of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2sin_8hpp_source.html#l00049">49</a> of file <a class="el" href="rev_2scal_2fun_2sin_8hpp_source.html">sin.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56518b3d36f8b7ce72c9b8f4b77c8f22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::singular_values </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector of the singular values of the specified matrix in decreasing order of magnitude. </p>
<p>See the documentation for <code>svd()</code> for information on the signular values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Singular values of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="singular__values_8hpp_source.html#l00021">21</a> of file <a class="el" href="singular__values_8hpp_source.html">singular_values.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a646a34790ca2b692b2a8c74c4e4fb726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::sinh </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2sinh_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2sinh_8hpp_source.html">sinh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a241b79300774f40a6e67b7156b494462"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::sinh </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic sine of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \sinh x = \cosh x$" src="form_424.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{sinh}(x) = \begin{cases} \sinh(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_425.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{sinh}(x)}{\partial x} = \begin{cases} \cosh(x) &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_426.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hyperbolic sine of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2sinh_8hpp_source.html#l00049">49</a> of file <a class="el" href="rev_2scal_2fun_2sinh_8hpp_source.html">sinh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1f9966aade9c4515d33d3ffa7305462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="size_8hpp_source.html#l00011">11</a> of file <a class="el" href="size_8hpp_source.html">size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a764774344adc0fc192a79bb25cab62ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::skew_normal_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="skew__normal__ccdf__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="skew__normal__ccdf__log_8hpp_source.html">skew_normal_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4619194e1d367590916fb133f99385a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::skew_normal_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="skew__normal__cdf_8hpp_source.html#l00026">26</a> of file <a class="el" href="skew__normal__cdf_8hpp_source.html">skew_normal_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a244e671c45143752fe0d8e50dd8d64dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::skew_normal_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="skew__normal__cdf__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="skew__normal__cdf__log_8hpp_source.html">skew_normal_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a063fa4970b1aced1fe47505e950c5ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::skew_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="skew__normal__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="skew__normal__log_8hpp_source.html">skew_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f3802cc8e1abfde6592284133457854"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale, T_shape&gt;::type stan::math::skew_normal_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="skew__normal__log_8hpp_source.html#l00146">146</a> of file <a class="el" href="skew__normal__log_8hpp_source.html">skew_normal_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae20ce3e4d117da5792ace24dfc92b1ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::skew_normal_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="skew__normal__rng_8hpp_source.html#l00024">24</a> of file <a class="el" href="skew__normal__rng_8hpp_source.html">skew_normal_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f57ef7820025c7b350f84c3aebfe45e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, Eigen::Dynamic, 1&gt; stan::math::softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2softmax_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2mat_2fun_2softmax_8hpp_source.html">softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd226ffb6c2a089f2e133b74b5fed2b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the softmax of the specified vector. </p>
<p><img class="formulaInl" alt="$ \mbox{softmax}(y) = \frac{\exp(y)} {\sum_{k=1}^K \exp(y_k)}, $" src="form_18.png"/></p>
<p>The entries in the Jacobian of the softmax function are given by <img class="formulaInl" alt="$ \begin{array}{l} \displaystyle \frac{\partial}{\partial y_m} \mbox{softmax}(y)[k] \\[8pt] \displaystyle \mbox{ } \ \ \ = \left\{ \begin{array}{ll} \mbox{softmax}(y)[k] - \mbox{softmax}(y)[k] \times \mbox{softmax}(y)[m] &amp; \mbox{ if } m = k, \mbox{ and} \\[6pt] \mbox{softmax}(y)[k] * \mbox{softmax}(y)[m] &amp; \mbox{ if } m \neq k. \end{array} \right. \end{array} $" src="form_19.png"/></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of values in vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit simplex result of the softmax transform of the vector. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2softmax_8hpp_source.html#l00046">46</a> of file <a class="el" href="prim_2mat_2fun_2softmax_8hpp_source.html">softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc994b4977baae2d53f2d0a60c77522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, Eigen::Dynamic, 1&gt; stan::math::softmax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the softmax of the specified <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector. </p>
<p>Softmax is guaranteed to return a simplex.</p>
<p>The gradient calculations are unfolded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Unconstrained input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Softmax of the input. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the input vector is size 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2softmax_8hpp_source.html#l00059">59</a> of file <a class="el" href="rev_2mat_2fun_2softmax_8hpp_source.html">softmax.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a941784bb46a4a2fabf3deacebbd71ec5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; &gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; fvar&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2sort__asc_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2mat_2fun_2sort__asc_8hpp_source.html">sort_asc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80f5418b16ea26e9bc6d2a8f9b764897"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sort_8hpp_source.html#l00020">20</a> of file <a class="el" href="sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8583739553a742829c5e0b39879af0dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; var &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in ascending order with gradients kept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2sort__asc_8hpp_source.html#l00021">21</a> of file <a class="el" href="rev_2mat_2fun_2sort__asc_8hpp_source.html">sort_asc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4181de091dfd2ded22cefa4df86720e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2sort__asc_8hpp_source.html#l00025">25</a> of file <a class="el" href="fwd_2mat_2fun_2sort__asc_8hpp_source.html">sort_asc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0391669326527e057a3f0865703b13d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; var, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in ascending order with gradients kept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2sort__asc_8hpp_source.html#l00035">35</a> of file <a class="el" href="rev_2mat_2fun_2sort__asc_8hpp_source.html">sort_asc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9e46c9e96c0e88cc503e4b903247cce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, C&gt; stan::math::sort_asc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sort_8hpp_source.html#l00046">46</a> of file <a class="el" href="sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c06412237c5d6879a4c07f0706303e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; &gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; fvar&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2sort__desc_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2mat_2fun_2sort__desc_8hpp_source.html">sort_desc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cefcb10a8af1224993d04e812f74e5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; var &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in descending order with gradients kept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2sort__desc_8hpp_source.html#l00021">21</a> of file <a class="el" href="rev_2mat_2fun_2sort__desc_8hpp_source.html">sort_desc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27e74300574eb2a6e80e0f4cb029596e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2sort__desc_8hpp_source.html#l00025">25</a> of file <a class="el" href="fwd_2mat_2fun_2sort__desc_8hpp_source.html">sort_desc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0b2712eab9b95535c0589455ed11cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified standard vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sort_8hpp_source.html#l00033">33</a> of file <a class="el" href="sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d8d83ef27eeacd30d11964ce32f4186"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classstan_1_1math_1_1var.html">var</a>, R, C&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; var, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in descending order with gradients kept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2sort__desc_8hpp_source.html#l00035">35</a> of file <a class="el" href="rev_2mat_2fun_2sort__desc_8hpp_source.html">sort_desc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60648efc106b7596ddc356b765b6df81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, C&gt; stan::math::sort_desc </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified eigen vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector to order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> vector ordered. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sort_8hpp_source.html#l00060">60</a> of file <a class="el" href="sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a13ccb29cba05ef0daa9712ee9bf7a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::sort_indices_asc </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sorted copy of the argument container in ascending order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>type of container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Container to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted version of container </dd></dl>

<p>Definition at line <a class="el" href="sort__indices__asc_8hpp_source.html#l00023">23</a> of file <a class="el" href="sort__indices__asc_8hpp_source.html">sort_indices_asc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27f6f9085eb850e9e0fcb98df345aeba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; stan::math::sort_indices_desc </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sorted copy of the argument container in ascending order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>type of container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Container to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted version of container </dd></dl>

<p>Definition at line <a class="el" href="sort__indices__desc_8hpp_source.html#l00023">23</a> of file <a class="el" href="sort__indices__desc_8hpp_source.html">sort_indices_desc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5231d132852d58cd3fe610221c9766f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::sqrt </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2sqrt_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2sqrt_8hpp_source.html">sqrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab438f4b0a11d8551fe5605237f655730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::sqrt </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \sqrt{x} = \frac{1}{2 \sqrt{x}}$" src="form_427.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{sqrt}(x) = \begin{cases} \textrm{NaN} &amp; x < 0 \\ \sqrt{x} &amp; \mbox{if } x\geq 0\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_428.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{sqrt}(x)}{\partial x} = \begin{cases} \textrm{NaN} &amp; x < 0 \\ \frac{1}{2\sqrt{x}} &amp; x\geq 0\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_429.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable whose square root is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square root of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2sqrt_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2scal_2fun_2sqrt_8hpp_source.html">sqrt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1369f60a09e3af4933096de3a54ac28c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sqrt2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of two. </p>
<dl class="section return"><dt>Returns</dt><dd>Square root of two. </dd></dl>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00104">104</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ed68bdfff9b340a187964ef7684091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::square </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2square_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2square_8hpp_source.html">square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a056b82f11f784f321bce2c5677089e24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::square </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of the specified argument. </p>
<p><img class="formulaInl" alt="$\mbox{square}(x) = x^2$" src="form_181.png"/>.</p>
<p>The implementation of <code>square(x)</code> is just <code>x * x</code>. Given this, this method is mainly useful in cases where <code>x</code> is not a simple primitive type, particularly when it is an auto-dif type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input to square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square of input. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2square_8hpp_source.html#l00022">22</a> of file <a class="el" href="prim_2scal_2fun_2square_8hpp_source.html">square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1b349cd070427c412c2c0a0d32327b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::square </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of the input variable. </p>
<p>Using <code>square(x)</code> is more efficient than using <code>x * x</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{square}(x) = \begin{cases} x^2 &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_430.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{square}(x)}{\partial x} = \begin{cases} 2x &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_431.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Variable to square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2square_8hpp_source.html#l00046">46</a> of file <a class="el" href="rev_2scal_2fun_2square_8hpp_source.html">square.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a292e430d422bfe4984f9eaa1d20840ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2, typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T1, T2&gt;::type stan::math::squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the squared distance between the specified vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First vector. </td></tr>
    <tr><td class="paramname">v2</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If the vectors are not the same size or if they are both not vector dimensioned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2squared__distance_8hpp_source.html#l00022">22</a> of file <a class="el" href="prim_2mat_2fun_2squared__distance_8hpp_source.html">squared_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d2e9c8de72e19836336f70e6c03341c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2squared__distance_8hpp_source.html#l00112">112</a> of file <a class="el" href="rev_2mat_2fun_2squared__distance_8hpp_source.html">squared_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57b6cfbac0ae13e4217fba5ff20ac9e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2squared__distance_8hpp_source.html#l00122">122</a> of file <a class="el" href="rev_2mat_2fun_2squared__distance_8hpp_source.html">squared_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5483c9ea2644a3b127b36f32668bbec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R1, int C1, int R2, int C2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2squared__distance_8hpp_source.html#l00132">132</a> of file <a class="el" href="rev_2mat_2fun_2squared__distance_8hpp_source.html">squared_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab45f57a15327ae4f94a1aef0bcd869f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2stan__print_8hpp_source.html#l00010">10</a> of file <a class="el" href="rev_2mat_2fun_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c14b7fd70050f03a07fdf73a1df06d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html#l00012">12</a> of file <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37cb2d874adcc950cb0439af044f549f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html#l00017">17</a> of file <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae94f7170ee85d4b353f55e3a044d2345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html#l00027">27</a> of file <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9c9057d71cf2795d0042f665c0f89c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html#l00038">38</a> of file <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adffa61a0521d0c07b8c4cd7ccbbb4aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::stan_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html#l00049">49</a> of file <a class="el" href="prim_2mat_2fun_2stan__print_8hpp_source.html">stan_print.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4a72c89ed9143a7760cc3611e8a0df0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stan::math::start_nested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record the current position so that <code><a class="el" href="namespacestan_1_1math.html#a8ebf2b2bc0f63dcb46a176b43e8b369a" title="Recover only the memory used for the top nested call. ">recover_memory_nested()</a></code> can find it. </p>

<p>Definition at line <a class="el" href="start__nested_8hpp_source.html#l00013">13</a> of file <a class="el" href="start__nested_8hpp_source.html">start_nested.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a7c701333f443140d6d4bfdde5b15b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the step, or heaviside, function applied to the specified variable (stan). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#a8fdc5e5ba8e306c2a594e928bfd62ea2" title="The step, or Heaviside, function. ">stan::math::step()</a> for the double-based version.</p>
<p>The derivative of the step function is zero everywhere but at 0, so for convenience, it is taken to be everywhere zero,</p>
<p><img class="formulaInl" alt="$\mbox{step}(x) = 0$" src="form_432.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constant variable with value 1.0 if the argument's value is greater than or equal to 0.0, and value 0.0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2step_8hpp_source.html#l00025">25</a> of file <a class="el" href="rev_2scal_2fun_2step_8hpp_source.html">step.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fdc5e5ba8e306c2a594e928bfd62ea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::step </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The step, or Heaviside, function. </p>
<p>The function is defined by</p>
<p><code>step(y) = (y &lt; 0.0) ? 0 : 1</code>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{step}(x) = \begin{cases} 0 &amp; \mbox{if } x \leq 0 \\ 1 &amp; \mbox{if } x > 0 \\[6pt] 0 &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_182.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Scalar argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the specified argument is greater than or equal to 0.0, and 0 otherwise. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2step_8hpp_source.html#l00029">29</a> of file <a class="el" href="prim_2scal_2fun_2step_8hpp_source.html">step.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7330bcb373ce5df4f6cedb70d4ba571"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_loc, T_scale&gt;::type stan::math::student_t_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="student__t__ccdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="student__t__ccdf__log_8hpp_source.html">student_t_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c3707b197842a840217b04e3cc1b0da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_loc, T_scale&gt;::type stan::math::student_t_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="student__t__cdf_8hpp_source.html#l00031">31</a> of file <a class="el" href="student__t__cdf_8hpp_source.html">student_t_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf7b73942cfee4fec76599b966796d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_loc, T_scale&gt;::type stan::math::student_t_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="student__t__cdf__log_8hpp_source.html#l00031">31</a> of file <a class="el" href="student__t__cdf__log_8hpp_source.html">student_t_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20962dd5b3da2477c4c2a9170904fb27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_loc, T_scale&gt;::type stan::math::student_t_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Student-t density for the given y, nu, mean, and scale parameter. </p>
<p>The scale parameter must be greater than 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;\sim&amp; t_{\nu} (\mu, \sigma^2) \\ \log (p (y \, |\, \nu, \mu, \sigma) ) &amp;=&amp; \log \left( \frac{\Gamma((\nu + 1) /2)} {\Gamma(\nu/2)\sqrt{\nu \pi} \sigma} \left( 1 + \frac{1}{\nu} (\frac{y - \mu}{\sigma})^2 \right)^{-(\nu + 1)/2} \right) \\ &amp;=&amp; \log( \Gamma( (\nu+1)/2 )) - \log (\Gamma (\nu/2) - \frac{1}{2} \log(\nu \pi) - \log(\sigma) -\frac{\nu + 1}{2} \log (1 + \frac{1}{\nu} (\frac{y - \mu}{\sigma})^2) \end{eqnarray*}" src="form_198.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom. </td></tr>
    <tr><td class="paramname">mu</td><td>The mean of the Student-t distribution. </td></tr>
    <tr><td class="paramname">sigma</td><td>The scale parameter of the Student-t distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Student-t density at y. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if sigma is not greater than 0. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
    <tr><td class="paramname">T_loc</td><td>Type of location. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="student__t__log_8hpp_source.html#l00056">56</a> of file <a class="el" href="student__t__log_8hpp_source.html">student_t_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab25a0e28b3bd50cfc9fb14e9f410bd3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_dof, T_loc, T_scale&gt;::type stan::math::student_t_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_loc &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="student__t__log_8hpp_source.html#l00220">220</a> of file <a class="el" href="student__t__log_8hpp_source.html">student_t_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d151fedbd83f49080ef17c148ef1dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::student_t_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="student__t__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="student__t__rng_8hpp_source.html">student_t_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e4c5e5b76b18a41b28f646104b3cd46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::sub </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sub_8hpp_source.html#l00010">10</a> of file <a class="el" href="sub_8hpp_source.html">sub.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a943cb439569c2dc588661a1cc171e2d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::sub_col </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a nrows x 1 subcolumn starting at (i-1, j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row + 1 </td></tr>
    <tr><td class="paramname">j</td><td>Starting column + 1 </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sub__col_8hpp_source.html#l00022">22</a> of file <a class="el" href="sub__col_8hpp_source.html">sub_col.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a019d635ee39f24b69c3f27e96bba4be1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::math::sub_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a 1 x nrows subrow starting at (i-1, j-1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix </td></tr>
    <tr><td class="paramname">i</td><td>Starting row + 1 </td></tr>
    <tr><td class="paramname">j</td><td>Starting column + 1 </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns in block </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sub__row_8hpp_source.html#l00023">23</a> of file <a class="el" href="sub__row_8hpp_source.html">sub_row.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38ba678d90cda4868c14d6d6bc6b509d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of subtracting the second specified matrix from the first specified matrix. </p>
<p>The return scalar type is the promotion of the input types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Scalar type of first matrix. </td></tr>
    <tr><td class="paramname">T2</td><td>Scalar type of second matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrices. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Difference between first matrix and second matrix. </dd></dl>

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00027">27</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46fb2ca306088487251df70b19e73aff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00043">43</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8a3f79fa67648f8145c6692d19334b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename boost::math::tools::promote_args&lt;T1, T2&gt;::type, R, C&gt; stan::math::subtract </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="subtract_8hpp_source.html#l00056">56</a> of file <a class="el" href="subtract_8hpp_source.html">subtract.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1efee0b4f8879a114af50b7e9802745c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the values in the specified standard vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements summed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Standard vector to sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of elements. </dd></dl>

<p>Definition at line <a class="el" href="prim_2arr_2fun_2sum_8hpp_source.html#l00018">18</a> of file <a class="el" href="prim_2arr_2fun_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5dda5a9c244efdbd023cc01d47cbf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fvar&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the entries of the specified standard vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of vector entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of vector entries. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2arr_2fun_2sum_8hpp_source.html#l00020">20</a> of file <a class="el" href="fwd_2arr_2fun_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03ac5708411da911ccf11be4a5f511f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of the entries of the specified matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of matrix entries. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of matrix entries. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2sum_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2mat_2fun_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44c32c2d7e895378feb11c99091765ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of the coefficients of the specified column vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements in matrix. </td></tr>
    <tr><td class="paramname">R</td><td>Row type of matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of coefficients of vector. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2sum_8hpp_source.html#l00022">22</a> of file <a class="el" href="prim_2mat_2fun_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1ec64f77d2621d9f1aada5a8d2e90c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of the coefficients of the specified matrix, column vector or row vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Row type for matrix. </td></tr>
    <tr><td class="paramname">C</td><td>Column type for matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified matrix or vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of coefficients of matrix. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2sum_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2mat_2fun_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2538f04d0c683772fb3f46197d8c0059"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::sum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; var &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of the entries of the specified vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of vector entries. </dd></dl>

<p>Definition at line <a class="el" href="rev_2arr_2fun_2sum_8hpp_source.html#l00053">53</a> of file <a class="el" href="rev_2arr_2fun_2sum_8hpp_source.html">sum.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55548f1b502d1dd6283268b79fc41507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a vector from the back of the specified vector. </p>

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00023">23</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d79ddf4f28c8bd68ae569b94fb693c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified number of elements as a row vector from the back of the specified row vector. </p>

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00038">38</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9956cf78180c6340f61667e797cf7055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::tail </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tail_8hpp_source.html#l00046">46</a> of file <a class="el" href="tail_8hpp_source.html">tail.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae09b685b660830075f80caaf8a350676"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::tan </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2tan_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2tan_8hpp_source.html">tan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf8320fd61a3c0c73f2ab8d78d949e58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::tan </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tangent of a radian-scaled variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \tan x = \sec^2 x$" src="form_433.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{tan}(x) = \begin{cases} \tan(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_434.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{tan}(x)}{\partial x} = \begin{cases} \sec^2(x) &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_435.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable for radians of angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tangent of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2tan_8hpp_source.html#l00049">49</a> of file <a class="el" href="rev_2scal_2fun_2tan_8hpp_source.html">tan.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae11dc45fd471bec1a19462ce58f434b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::tanh </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2tanh_8hpp_source.html#l00014">14</a> of file <a class="el" href="fwd_2scal_2fun_2tanh_8hpp_source.html">tanh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d342831ec24762b18f71ba4fba54621"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::tanh </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic tangent of the specified variable (cmath). </p>
<p>The derivative is defined by</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \tanh x = \frac{1}{\cosh^2 x}$" src="form_436.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{tanh}(x) = \begin{cases} \tanh(x) &amp; \mbox{if } -\infty\leq x \leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_437.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{tanh}(x)}{\partial x} = \begin{cases} \mbox{sech}^2(x) &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_438.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hyperbolic tangent of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2tanh_8hpp_source.html#l00050">50</a> of file <a class="el" href="rev_2scal_2fun_2tanh_8hpp_source.html">tanh.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16b07b3f7d18cdb710806c5793a83d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">matrix_d</a> stan::math::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_d &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of post-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M times its transpose. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2tcrossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="prim_2mat_2fun_2tcrossprod_8hpp_source.html">tcrossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab379e9a9f74dab16c41d82978cc4b58e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, R&gt; stan::math::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2tcrossprod_8hpp_source.html#l00017">17</a> of file <a class="el" href="fwd_2mat_2fun_2tcrossprod_8hpp_source.html">tcrossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03ab719a94e19bfcf26e208ffcf5ff9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> stan::math::tcrossprod </td>
          <td>(</td>
          <td class="paramtype">const matrix_v &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of post-multiplying a matrix by its own transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Matrix to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M times its transpose. </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2tcrossprod_8hpp_source.html#l00025">25</a> of file <a class="el" href="rev_2mat_2fun_2tcrossprod_8hpp_source.html">tcrossprod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73eaf0a5d0593bb8610234e0d69e7cec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::tgamma </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2tgamma_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2scal_2fun_2tgamma_8hpp_source.html">tgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af27ba386c3836a69c7d270f89c946268"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::tgamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1var.html">stan::math::var</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Gamma function applied to the specified variable (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#af27ba386c3836a69c7d270f89c946268" title="Return the Gamma function applied to the specified variable (C99). ">boost::math::tgamma()</a> for the double-based version.</p>
<p>The derivative with respect to the argument is</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \Gamma(x) = \Gamma(x) \Psi^{(0)}(x)$" src="form_439.png"/></p>
<p>where <img class="formulaInl" alt="$\Psi^{(0)}(x)$" src="form_440.png"/> is the digamma function.</p>
<p>See <a class="el" href="namespacestan_1_1math.html#a69702aaa101bf602072fa7bf5fccb48a">boost::math::digamma()</a> for the double-based version.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{tgamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \Gamma(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_441.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{tgamma}(x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \frac{\partial\, \Gamma(x)}{\partial x} &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_442.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma(x)=\int_0^{\infty} u^{x - 1} \exp(-u) \, du \]" src="form_443.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \Gamma(x)}{\partial x} = \Gamma(x)\Psi(x) \]" src="form_444.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Argument to function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Gamma function applied to the specified argument. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2tgamma_8hpp_source.html#l00065">65</a> of file <a class="el" href="rev_2scal_2fun_2tgamma_8hpp_source.html">tgamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a88c990ca9770c6c37d883d87eb82eb6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; stan::math::to_array_1d </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__array__1d_8hpp_source.html#l00019">19</a> of file <a class="el" href="to__array__1d_8hpp_source.html">to_array_1d.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad927f0ff9564aa04073f673d5e6bddfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; stan::math::to_array_1d </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__array__1d_8hpp_source.html#l00031">31</a> of file <a class="el" href="to__array__1d_8hpp_source.html">to_array_1d.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8108c33b0612c8fe8f47767fa1ca6ad1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;typename <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a>&lt;T&gt;::type&gt; stan::math::to_array_1d </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__array__1d_8hpp_source.html#l00038">38</a> of file <a class="el" href="to__array__1d_8hpp_source.html">to_array_1d.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cdd0729c27213abdf446412e7f7793c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt;T&gt; &gt; stan::math::to_array_2d </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__array__2d_8hpp_source.html#l00017">17</a> of file <a class="el" href="to__array__2d_8hpp_source.html">to_array_2d.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad19a5837a9b5c3e219e5081d8dca3c89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::to_fvar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__fvar_8hpp_source.html#l00016">16</a> of file <a class="el" href="to__fvar_8hpp_source.html">to_fvar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d9d67d772eeec5340fde5d2753a14b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::to_fvar </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__fvar_8hpp_source.html#l00023">23</a> of file <a class="el" href="to__fvar_8hpp_source.html">to_fvar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adfb48ecaf381b03e60f9df8bab82e60c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, C&gt; stan::math::to_fvar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__fvar_8hpp_source.html#l00031">31</a> of file <a class="el" href="to__fvar_8hpp_source.html">to_fvar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a866da3d4ca122849b1e0ab9b38687a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;double&gt;, R, C&gt; stan::math::to_fvar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__fvar_8hpp_source.html#l00038">38</a> of file <a class="el" href="to__fvar_8hpp_source.html">to_fvar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafb79996a9efea5b41d2d61ac2e0ecd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt;, R, C&gt; stan::math::to_fvar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>deriv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__fvar_8hpp_source.html#l00048">48</a> of file <a class="el" href="to__fvar_8hpp_source.html">to_fvar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95a142c1899afa9dea4bdc053e959bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, Dynamic&gt; stan::math::to_matrix </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T, R, C &gt;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__matrix_8hpp_source.html#l00020">20</a> of file <a class="el" href="to__matrix_8hpp_source.html">to_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d53d7c1ac5bb3a3eff436d70b2cfbd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, Dynamic&gt; stan::math::to_matrix </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__matrix_8hpp_source.html#l00027">27</a> of file <a class="el" href="to__matrix_8hpp_source.html">to_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa5894e034cf63df686f4a32b78facbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double, Dynamic, Dynamic&gt; stan::math::to_matrix </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__matrix_8hpp_source.html#l00044">44</a> of file <a class="el" href="to__matrix_8hpp_source.html">to_matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69c7bf292d2f253217a813e6327899ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, 1, Dynamic&gt; stan::math::to_row_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__row__vector_8hpp_source.html#l00020">20</a> of file <a class="el" href="to__row__vector_8hpp_source.html">to_row_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8eb83869b0604ee1a484547330db06f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, 1, Dynamic&gt; stan::math::to_row_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__row__vector_8hpp_source.html#l00028">28</a> of file <a class="el" href="to__row__vector_8hpp_source.html">to_row_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e184ac2d303916513687b326bb01035"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double, 1, Dynamic&gt; stan::math::to_row_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__row__vector_8hpp_source.html#l00034">34</a> of file <a class="el" href="to__row__vector_8hpp_source.html">to_row_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06ea285d4408c28e9ec6dc2ca1b571b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A scalar value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An automatic differentiation variable with the input value. </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00021">21</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adad5c0d61bde25dc78e090509b4b3149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An automatic differentiation variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An automatic differentiation variable with the input value. </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00032">32</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adae9f601dd5faa6dcfa6e4edd7e84be9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacestan_1_1math.html#a735db87876a1e603cdfb3c8b3c41aab6">stan::math::matrix_d</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A Matrix with scalars </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Matrix with automatic differentiation variables </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00043">43</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40674afd6b5163ad3e859fc7da721faf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a5eec679edf26abd1fdf8cf56053caf8e">matrix_v</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const matrix_v &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>A Matrix with automatic differentiation variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Matrix with automatic differentiation variables. </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00058">58</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a345ee377fd33a8f5101a87482e098247"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#aa7d3137027b10bc7758d4c1763b58a8e">vector_v</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacestan_1_1math.html#ac9e96c15b87fbd704ab9bcf77e7597db">stan::math::vector_d</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A Vector of scalars </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Vector of automatic differentiation variables with values of v </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00070">70</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdd6f29816f4c58601da47f272848187"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#aa7d3137027b10bc7758d4c1763b58a8e">vector_v</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const vector_v &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A Vector of automatic differentiation variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Vector of automatic differentiation variables with values of v </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00085">85</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac98e7e17d969cb7ee4b36dce58137cba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a05401bf8bb7f886d11b1ee90495fe153">row_vector_v</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacestan_1_1math.html#ac61a9b8f4000b9e69bf2d1dcfb34c984">stan::math::row_vector_d</a> &amp;&#160;</td>
          <td class="paramname"><em>rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>A row vector of scalars </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A row vector of automatic differentation variables with values of rv. </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00097">97</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac28a0e06bb7bd6be39ef50f90e529ccd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestan_1_1math.html#a05401bf8bb7f886d11b1ee90495fe153">row_vector_v</a> stan::math::to_var </td>
          <td>(</td>
          <td class="paramtype">const row_vector_v &amp;&#160;</td>
          <td class="paramname"><em>rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to an automatic differentiation variable. </p>
<p>Returns a <a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> variable with the input value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>A row vector with automatic differentiation variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A row vector with automatic differentiation variables with values of rv. </dd></dl>

<p>Definition at line <a class="el" href="to__var_8hpp_source.html#l00112">112</a> of file <a class="el" href="to__var_8hpp_source.html">to_var.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2aa02a20972263242e2f6a8785cf58d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, 1&gt; stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__vector_8hpp_source.html#l00020">20</a> of file <a class="el" href="to__vector_8hpp_source.html">to_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cc7916ec81b929389e94c7fd725fd87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T, Dynamic, 1&gt; stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__vector_8hpp_source.html#l00028">28</a> of file <a class="el" href="to__vector_8hpp_source.html">to_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc3b48fe1676d80fd5775f97f2b6a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double, Dynamic, 1&gt; stan::math::to_vector </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__vector_8hpp_source.html#l00034">34</a> of file <a class="el" href="to__vector_8hpp_source.html">to_vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7001fd7e0296d5dae6ab0a88e1a28547"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::trace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the trace of the specified matrix. </p>
<p>The trace is defined as the sum of the elements on the diagonal. The matrix is not required to be square. Returns 0 if matrix is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Specified matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace of the matrix. </dd></dl>

<p>Definition at line <a class="el" href="trace_8hpp_source.html#l00020">20</a> of file <a class="el" href="trace_8hpp_source.html">trace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb2aa245d794e2a6c352038f4811a37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::trace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="trace_8hpp_source.html#l00026">26</a> of file <a class="el" href="trace_8hpp_source.html">trace.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2dc9df09e11dc3e66438bb5d9aa457f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , int R1, int C1, typename T2 , int R2, int C2, typename T3 , int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T1&gt;::value || <a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T2&gt;::value || <a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T3&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::type stan::math::trace_gen_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the trace of an inverse quadratic form. </p>
<p>I.E., this computes trace(D B^T A^-1 B) where D is a square matrix and the <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A is provided. </p>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2trace__gen__inv__quad__form__ldlt_8hpp_source.html#l00027">27</a> of file <a class="el" href="rev_2mat_2fun_2trace__gen__inv__quad__form__ldlt_8hpp_source.html">trace_gen_inv_quad_form_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03da89fcbd2829c84a5beeb9ccbf2ccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , int R1, int C1, int R2, int C2, int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T1&gt;::value &amp;&amp; !<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T2&gt;::value &amp;&amp; !<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T3&gt;::value, typename boost::math::tools::promote_args&lt;T1, T2, T3&gt;::type&gt;::type stan::math::trace_gen_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T1, R1, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2trace__gen__inv__quad__form__ldlt_8hpp_source.html#l00030">30</a> of file <a class="el" href="prim_2mat_2fun_2trace__gen__inv__quad__form__ldlt_8hpp_source.html">trace_gen_inv_quad_form_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd59dd23ba6d346713d117001b99507f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RD, int CD, int RA, int CA, int RB, int CB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::trace_gen_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, RD, CD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; fvar&lt; T &gt;, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2trace__gen__quad__form_8hpp_source.html#l00015">15</a> of file <a class="el" href="fwd_2mat_2fun_2trace__gen__quad__form_8hpp_source.html">trace_gen_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09d402800ee27ba77d03dc3ec365d22e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RD, int CD, int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_gen_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RD, CD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute trace(D B^T A B). </p>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2trace__gen__quad__form_8hpp_source.html#l00017">17</a> of file <a class="el" href="prim_2mat_2fun_2trace__gen__quad__form_8hpp_source.html">trace_gen_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c0d37f9fa5d50999308a19d8e67714e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TD , int RD, int CD, typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;TD, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;TB, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type stan::math::trace_gen_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; TD, RD, CD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2trace__gen__quad__form_8hpp_source.html#l00116">116</a> of file <a class="el" href="rev_2mat_2fun_2trace__gen__quad__form_8hpp_source.html">trace_gen_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaddc5785e5e629683ca0c3d11346d025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , int R2, int C2, int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;!<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T1&gt;::value &amp;&amp; !<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T2&gt;::value, typename boost::math::tools::promote_args&lt;T1, T2&gt;::type&gt;::type stan::math::trace_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T1, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T2, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="prim_2mat_2fun_2trace__inv__quad__form__ldlt_8hpp_source.html#l00027">27</a> of file <a class="el" href="prim_2mat_2fun_2trace__inv__quad__form__ldlt_8hpp_source.html">trace_inv_quad_form_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04f24e9594341db1cc4ceaf5a69f039b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 , int R2, int C2, typename T3 , int R3, int C3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt;<a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T2&gt;::value || <a class="el" href="structstan_1_1is__var.html">stan::is_var</a>&lt;T3&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::type stan::math::trace_inv_quad_form_ldlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">stan::math::LDLT_factor</a>&lt; T2, R2, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T3, R3, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the trace of an inverse quadratic form. </p>
<p>I.E., this computes trace(B^T A^-1 B) where the <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a> of A is provided. </p>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2trace__inv__quad__form__ldlt_8hpp_source.html#l00177">177</a> of file <a class="el" href="rev_2mat_2fun_2trace__inv__quad__form__ldlt_8hpp_source.html">trace_inv_quad_form_ldlt.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a097af33142548fd565d1dab2233fa3e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::trace_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute trace(B^T A B). </p>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2trace__quad__form_8hpp_source.html#l00017">17</a> of file <a class="el" href="prim_2mat_2fun_2trace__quad__form_8hpp_source.html">trace_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6077d5db50f265d5279c62ff5922e0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RA, int CA, int RB, int CB, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt;T&gt; stan::math::trace_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt;, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2mat_2fun_2trace__quad__form_8hpp_source.html#l00018">18</a> of file <a class="el" href="fwd_2mat_2fun_2trace__quad__form_8hpp_source.html">trace_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c7a80225b1cb62153ba5d47a45870fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , int RA, int CA, typename TB , int RB, int CB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; boost::is_same&lt;TA, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value || boost::is_same&lt;TB, <a class="el" href="classstan_1_1math_1_1var.html">var</a>&gt;::value, <a class="el" href="classstan_1_1math_1_1var.html">var</a> &gt;::type stan::math::trace_quad_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; TA, RA, CA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; TB, RB, CB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2trace__quad__form_8hpp_source.html#l00098">98</a> of file <a class="el" href="rev_2mat_2fun_2trace__quad__form_8hpp_source.html">trace_quad_form.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89f315f3af384f2d49a3a26eaef209ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, C, R&gt; stan::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="transpose_8hpp_source.html#l00012">12</a> of file <a class="el" href="transpose_8hpp_source.html">transpose.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab18c21bad37c9af26424d0922936355e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::trigamma </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{trigamma}(x) = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \Psi_1(x) &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_183.png"/>
</p>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{trigamma}(x)}{\partial x} = \begin{cases} \textrm{error} &amp; \mbox{if } x\in \{\dots, -3, -2, -1, 0\}\\ \frac{\partial\, \Psi_1(x)}{\partial x} &amp; \mbox{if } x\not\in \{\dots, -3, -2, -1, 0\}\\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_184.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi_1(x)=\sum_{n=0}^\infty \frac{1}{(x+n)^2} \]" src="form_185.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial \, \Psi_1(x)}{\partial x} = -2\sum_{n=0}^\infty \frac{1}{(x+n)^3} \]" src="form_186.png"/>
</p>
 
<p>Definition at line <a class="el" href="trigamma_8hpp_source.html#l00050">50</a> of file <a class="el" href="trigamma_8hpp_source.html">trigamma.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79abc1d4f747b3c26c07b2b1e4871603"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt;T&gt; stan::math::trunc </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2trunc_8hpp_source.html#l00012">12</a> of file <a class="el" href="fwd_2scal_2fun_2trunc_8hpp_source.html">trunc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80e85e1eba4076438c72cd986fde40e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::trunc </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the truncatation of the specified variable (C99). </p>
<p>See <a class="el" href="namespacestan_1_1math.html#a79abc1d4f747b3c26c07b2b1e4871603">trunc()</a> for the double-based version.</p>
<p>The derivative is zero everywhere but at integer values, so for convenience the derivative is defined to be everywhere zero,</p>
<p><img class="formulaInl" alt="$\frac{d}{dx} \mbox{trunc}(x) = 0$" src="form_445.png"/>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{trunc}(x) = \begin{cases} \lfloor x \rfloor &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_446.png"/>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\, \mbox{trunc}(x)}{\partial x} = \begin{cases} 0 &amp; \mbox{if } -\infty\leq x\leq \infty \\[6pt] \textrm{NaN} &amp; \mbox{if } x = \textrm{NaN} \end{cases} \]" src="form_447.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Specified variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Truncation of the variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2trunc_8hpp_source.html#l00055">55</a> of file <a class="el" href="rev_2scal_2fun_2trunc_8hpp_source.html">trunc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9440f04c389ecf55094919dd4a29561"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TU&gt;::type stan::math::ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the upper-bounded value for the specified unconstrained scalar and upper bound. </p>
<p>The transform is</p>
<p><img class="formulaInl" alt="$f(x) = U - \exp(x)$" src="form_187.png"/></p>
<p>where <img class="formulaInl" alt="$U$" src="form_146.png"/> is the upper bound.</p>
<p>If the upper bound is positive infinity, this function reduces to <code>identity_constrain(x)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed scalar with specified upper bound. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ub__constrain_8hpp_source.html#l00037">37</a> of file <a class="el" href="ub__constrain_8hpp_source.html">ub_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e07e6f25d9cc21ce1467d0d74913a74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TU&gt;::type stan::math::ub_constrain </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the upper-bounded value for the specified unconstrained scalar and upper bound and increment the specified log probability reference with the log absolute Jacobian determinant of the transform. </p>
<p>The transform is as specified for <code>ub_constrain(T, double)</code>. The log absolute Jacobian determinant is</p>
<p><img class="formulaInl" alt="$ \log | \frac{d}{dx} -\mbox{exp}(x) + U | = \log | -\mbox{exp}(x) + 0 | = x$" src="form_188.png"/>.</p>
<p>If the upper bound is positive infinity, this function reduces to <code>identity_constrain(x, lp)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Free scalar. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">lp</td><td>Log probability reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed scalar with specified upper bound. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ub__constrain_8hpp_source.html#l00070">70</a> of file <a class="el" href="ub__constrain_8hpp_source.html">ub_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac11bdd8c7f6eed39bbac5a663c8a81bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T, TU&gt;::type stan::math::ub_free </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TU&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the free scalar that corresponds to the specified upper-bounded value with respect to the specified upper bound. </p>
<p>The transform is the reverse of the <code>ub_constrain(T, double)</code> transform,</p>
<p><img class="formulaInl" alt="$f^{-1}(y) = \log -(y - U)$" src="form_189.png"/></p>
<p>where <img class="formulaInl" alt="$U$" src="form_146.png"/> is the upper bound.</p>
<p>If the upper bound is positive infinity, this function reduces to <code>identity_free(y)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Upper-bounded scalar. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Free scalar corresponding to upper-bounded scalar. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">TU</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if y is greater than the upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ub__free_8hpp_source.html#l00039">39</a> of file <a class="el" href="ub__free_8hpp_source.html">ub_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e2b8fa3c8f27cf5fe06e35971810d52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_low, T_high&gt;::type stan::math::uniform_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uniform__ccdf__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="uniform__ccdf__log_8hpp_source.html">uniform_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa15c5027f6cc08a719ce42c82f42e8ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_low, T_high&gt;::type stan::math::uniform_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uniform__cdf_8hpp_source.html#l00022">22</a> of file <a class="el" href="uniform__cdf_8hpp_source.html">uniform_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f377bbfcb2c65d7c9b22f2a007cdc71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_low, T_high&gt;::type stan::math::uniform_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uniform__cdf__log_8hpp_source.html#l00023">23</a> of file <a class="el" href="uniform__cdf__log_8hpp_source.html">uniform_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae39a215713172d13a104cf33d6186c65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_low , typename T_high &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_low, T_high&gt;::type stan::math::uniform_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of a uniform density for the given y, lower, and upper bound. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y &amp;\sim&amp; \mbox{\sf{U}}(\alpha, \beta) \\ \log (p (y \, |\, \alpha, \beta)) &amp;=&amp; \log \left( \frac{1}{\beta-\alpha} \right) \\ &amp;=&amp; \log (1) - \log (\beta - \alpha) \\ &amp;=&amp; -\log (\beta - \alpha) \\ &amp; &amp; \mathrm{ where } \; y \in [\alpha, \beta], \log(0) \; \mathrm{otherwise} \end{eqnarray*}" src="form_199.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variable. </td></tr>
    <tr><td class="paramname">alpha</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">beta</td><td>Upper bound. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the lower bound is greater than or equal to the lower bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_low</td><td>Type of lower bound. </td></tr>
    <tr><td class="paramname">T_high</td><td>Type of upper bound. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="uniform__log_8hpp_source.html#l00046">46</a> of file <a class="el" href="uniform__log_8hpp_source.html">uniform_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c32b2aba8ca5e5eb4ebe76fd1f9a832"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_low , typename T_high &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_low, T_high&gt;::type stan::math::uniform_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_low &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_high &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uniform__log_8hpp_source.html#l00124">124</a> of file <a class="el" href="uniform__log_8hpp_source.html">uniform_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10447d2a77f0fdf32e0adce2546cd3cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::uniform_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="uniform__rng_8hpp_source.html#l00022">22</a> of file <a class="el" href="uniform__rng_8hpp_source.html">uniform_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a07474ecb0ca5f4fdbed0ce6957300f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::unit_vector_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the unit length vector corresponding to the free vector y. </p>
<p>The free vector contains K-1 spherical coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>of K - 1 spherical coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit length vector of dimension K </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="unit__vector__constrain_8hpp_source.html#l00024">24</a> of file <a class="el" href="unit__vector__constrain_8hpp_source.html">unit_vector_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac069d9e617c38341a12a33c73a7090d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::unit_vector_constrain </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the unit length vector corresponding to the free vector y. </p>
<p>The free vector contains K-1 spherical coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>of K - 1 spherical coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unit length vector of dimension K </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lp</td><td>Log probability reference to increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="unit__vector__constrain_8hpp_source.html#l00053">53</a> of file <a class="el" href="unit__vector__constrain_8hpp_source.html">unit_vector_constrain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65fb60ad466e375f68798ff25881e378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; stan::math::unit_vector_free </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="unit__vector__free_8hpp_source.html#l00016">16</a> of file <a class="el" href="unit__vector__free_8hpp_source.html">unit_vector_free.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb591fca3d88d2a5d587ce6172b62bf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::validate_non_negative_index </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="validate__non__negative__index_8hpp_source.html#l00012">12</a> of file <a class="el" href="validate__non__negative__index_8hpp_source.html">validate_non_negative_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a541f8f9d951f4d48c457dcecad5e326b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::value_of </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of variable. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2value__of_8hpp_source.html#l00016">16</a> of file <a class="el" href="fwd_2scal_2fun_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a759dd2a7ff07dbf11f60d9e1352bb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified variable. </p>
<p>This function is used internally by auto-dif functions along with <code><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e" title="Return the value of the specified scalar argument converted to a double value. ">stan::math::value_of(T x)</a></code> to extract the <code>double</code> value of either a scalar or an auto-dif variable. This function will be called when the argument is a <code><a class="el" href="classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a></code> even if the function is not referred to by namespace because of argument-dependent lookup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2value__of_8hpp_source.html#l00022">22</a> of file <a class="el" href="rev_2scal_2fun_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73087d72fd937f4be66684bd2613ae6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified scalar argument converted to a double value. </p>
<p>See the <code><a class="el" href="namespacestan_1_1math.html#a24337e3af682981f05d1cc022e675891" title="Return the primitive value of the specified forward-mode autodiff variable. ">stan::math::primitive_value</a></code> function to extract values without casting to <code>double</code>.</p>
<p>This function is meant to cover the primitive types. For types requiring pass-by-reference, this template function should be specialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Scalar to convert to double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of scalar cast to a double. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2value__of_8hpp_source.html#l00024">24</a> of file <a class="el" href="prim_2scal_2fun_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6ac4b37c5723681111ef69072288fd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename <a class="el" href="structstan_1_1math_1_1child__type.html">child_type</a>&lt;T&gt;::type, R, C&gt; stan::math::value_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a matrix of type T to a matrix of doubles. </p>
<p>T must implement value_of. See test/math/fwd/mat/fun/value_of.cpp for fvar and var usage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type in matrix </td></tr>
    <tr><td class="paramname">R</td><td>Rows of matrix </td></tr>
    <tr><td class="paramname">C</td><td>Columns of matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Matrix to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of values </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2value__of_8hpp_source.html#l00025">25</a> of file <a class="el" href="prim_2mat_2fun_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d7774df98215b7d113075019d74ebbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacestan_1_1math.html#a541f8f9d951f4d48c457dcecad5e326b">stan::math::value_of</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e" title="Return the value of the specified scalar argument converted to a double value. ">value_of(T)</a></code> for a polymorphic implementation using static casts.</p>
<p>This inline pass-through no-op should be compiled away.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified value. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2value__of_8hpp_source.html#l00040">40</a> of file <a class="el" href="prim_2scal_2fun_2value__of_8hpp_source.html">value_of.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab481d22f60e4cb93d629ac5d9f43bb00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of_rec </td>
          <td>(</td>
          <td class="paramtype">const var &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of variable. </dd></dl>

<p>Definition at line <a class="el" href="rev_2scal_2fun_2value__of__rec_8hpp_source.html#l00015">15</a> of file <a class="el" href="rev_2scal_2fun_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00b8cbdec7c35e7c93b0f47dae3c5498"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of_rec </td>
          <td>(</td>
          <td class="paramtype">const fvar&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified variable. </p>
<p>T must implement value_of_rec.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of variable. </dd></dl>

<p>Definition at line <a class="el" href="fwd_2scal_2fun_2value__of__rec_8hpp_source.html#l00021">21</a> of file <a class="el" href="fwd_2scal_2fun_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a99d6e8d6986fffb421e859770560bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::value_of_rec </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the specified scalar argument converted to a double value. </p>
<p>See the <code><a class="el" href="namespacestan_1_1math.html#a24337e3af682981f05d1cc022e675891" title="Return the primitive value of the specified forward-mode autodiff variable. ">stan::math::primitive_value</a></code> function to extract values without casting to <code>double</code>.</p>
<p>This function is meant to cover the primitive types. For types requiring pass-by-reference, this template function should be specialized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Scalar to convert to double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of scalar cast to a double. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2value__of__rec_8hpp_source.html#l00024">24</a> of file <a class="el" href="prim_2scal_2fun_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b0847f7611d8f396a1f4e112200185"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, R, C&gt; stan::math::value_of_rec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a matrix of type T to a matrix of doubles. </p>
<p>T must implement value_of_rec. See test/unit/math/fwd/mat/fun/value_of_test.cpp for fvar and var usage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type in matrix </td></tr>
    <tr><td class="paramname">R</td><td>Rows of matrix </td></tr>
    <tr><td class="paramname">C</td><td>Columns of matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Matrix to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of values </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2value__of__rec_8hpp_source.html#l00024">24</a> of file <a class="el" href="prim_2mat_2fun_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bb47fffd6ec0b1864d5e8bf0b99cf55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacestan_1_1math.html#a00b8cbdec7c35e7c93b0f47dae3c5498">stan::math::value_of_rec</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified argument. </p>
<p>See <code><a class="el" href="namespacestan_1_1math.html#a73087d72fd937f4be66684bd2613ae6e" title="Return the value of the specified scalar argument converted to a double value. ">value_of(T)</a></code> for a polymorphic implementation using static casts.</p>
<p>This inline pass-through no-op should be compiled away.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specified value. </dd></dl>

<p>Definition at line <a class="el" href="prim_2scal_2fun_2value__of__rec_8hpp_source.html#l00040">40</a> of file <a class="el" href="prim_2scal_2fun_2value__of__rec_8hpp_source.html">value_of_rec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa433ac2fc47bbd40a6d87f62574dff85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if the size of the vector is less than 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2variance_8hpp_source.html#l00024">24</a> of file <a class="el" href="prim_2mat_2fun_2variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f055da8754c2215aac70d7787692f54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T&gt;::type stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample variance (divide by length - 1) of the coefficients in the specified column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sample variance of vector. </dd></dl>

<p>Definition at line <a class="el" href="prim_2mat_2fun_2variance_8hpp_source.html#l00046">46</a> of file <a class="el" href="prim_2mat_2fun_2variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0400489c86a0f208ed17371ab97254f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; var &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sample variance of the specified standard vector. </p>
<p>Raise domain error if size is not greater than zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sample variance of specified vector </dd></dl>

<p>Definition at line <a class="el" href="rev_2mat_2fun_2variance_8hpp_source.html#l00052">52</a> of file <a class="el" href="rev_2mat_2fun_2variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c5dc6176d49564ace17029793589421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R, int C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstan_1_1math_1_1var.html">var</a> stan::math::variance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; var, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="rev_2mat_2fun_2variance_8hpp_source.html#l00069">69</a> of file <a class="el" href="rev_2mat_2fun_2variance_8hpp_source.html">variance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e7a36cd810a693a04ef145882894754"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::von_mises_log </td>
          <td>(</td>
          <td class="paramtype">T_y const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_loc const &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_scale const &amp;&#160;</td>
          <td class="paramname"><em>kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="von__mises__log_8hpp_source.html#l00026">26</a> of file <a class="el" href="von__mises__log_8hpp_source.html">von_mises_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a06353ba5a996ebfc43ec69decf9fb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_loc , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_loc, T_scale&gt;::type stan::math::von_mises_log </td>
          <td>(</td>
          <td class="paramtype">T_y const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_loc const &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_scale const &amp;&#160;</td>
          <td class="paramname"><em>kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="von__mises__log_8hpp_source.html#l00132">132</a> of file <a class="el" href="von__mises__log_8hpp_source.html">von_mises_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71998db3e6cfebf31463452f99878b99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::von_mises_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="von__mises__rng_8hpp_source.html#l00033">33</a> of file <a class="el" href="von__mises__rng_8hpp_source.html">von_mises_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0033ce06f5f7b1109a42eee2579955a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::weibull_ccdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="weibull__ccdf__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="weibull__ccdf__log_8hpp_source.html">weibull_ccdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae943a8f5c87e946a45a4f3b62f99b187"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::weibull_cdf </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="weibull__cdf_8hpp_source.html#l00027">27</a> of file <a class="el" href="weibull__cdf_8hpp_source.html">weibull_cdf.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae94334459868c125f2a6504b69f46158"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::weibull_cdf_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="weibull__cdf__log_8hpp_source.html#l00027">27</a> of file <a class="el" href="weibull__cdf__log_8hpp_source.html">weibull_cdf_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3a52747636627895374aa555279a92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::weibull_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="weibull__log_8hpp_source.html#l00030">30</a> of file <a class="el" href="weibull__log_8hpp_source.html">weibull_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76561164f1ff9ed6e70bf4a75e6f8ae2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_shape , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_shape, T_scale&gt;::type stan::math::weibull_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_shape &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="weibull__log_8hpp_source.html#l00141">141</a> of file <a class="el" href="weibull__log_8hpp_source.html">weibull_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd376b3fe82077f0565de1fbef6b4202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double stan::math::weibull_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="weibull__rng_8hpp_source.html#l00024">24</a> of file <a class="el" href="weibull__rng_8hpp_source.html">weibull_rng.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7a28135e8fe64782357d52062380796"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_alpha, T_tau, T_beta, T_delta&gt;::type stan::math::wiener_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_tau &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_delta &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the first passage time density function for a (Wiener) drift diffusion model for the given <img class="formulaInl" alt="$y$" src="form_200.png"/>, boundary separation <img class="formulaInl" alt="$\alpha$" src="form_201.png"/>, nondecision time <img class="formulaInl" alt="$\tau$" src="form_202.png"/>, relative bias <img class="formulaInl" alt="$\beta$" src="form_203.png"/>, and drift rate <img class="formulaInl" alt="$\delta$" src="form_204.png"/>. </p>
<p><img class="formulaInl" alt="$\alpha$" src="form_201.png"/> and <img class="formulaInl" alt="$\tau$" src="form_202.png"/> must be greater than 0, and <img class="formulaInl" alt="$\beta$" src="form_203.png"/> must be between 0 and 1. <img class="formulaInl" alt="$y$" src="form_200.png"/> should contain reaction times in seconds, with upper-boundary responses strictly positive and lower-boundary response times coded as strictly negative numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>A scalar variate. </td></tr>
    <tr><td class="paramname">alpha</td><td>The boundary separation. </td></tr>
    <tr><td class="paramname">tau</td><td>The nondecision time. </td></tr>
    <tr><td class="paramname">beta</td><td>The relative bias. </td></tr>
    <tr><td class="paramname">delta</td><td>The drift rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Wiener first passage time density of the specified arguments. </dd></dl>

<p>Definition at line <a class="el" href="wiener__log_8hpp_source.html#l00068">68</a> of file <a class="el" href="wiener__log_8hpp_source.html">wiener_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51ee0070ef7fdeac83b11eae40b1646a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1return__type.html">return_type</a>&lt;T_y, T_alpha, T_tau, T_beta, T_delta&gt;::type stan::math::wiener_log </td>
          <td>(</td>
          <td class="paramtype">const T_y &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_tau &amp;&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_delta &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="wiener__log_8hpp_source.html#l00221">221</a> of file <a class="el" href="wiener__log_8hpp_source.html">wiener_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91db893054b635d18034d06c161365a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_dof, T_scale&gt;::type stan::math::wishart_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log of the Wishart density for the given W, degrees of freedom, and scale matrix. </p>
<p>The scale matrix, S, must be k x k, symmetric, and semi-positive definite. Dimension, k, is implicit. nu must be greater than k-1</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} W &amp;\sim&amp; \mbox{\sf{Wishart}}_{\nu} (S) \\ \log (p (W \, |\, \nu, S) ) &amp;=&amp; \log \left( \left(2^{\nu k/2} \pi^{k (k-1) /4} \prod_{i=1}^k{\Gamma (\frac{\nu + 1 - i}{2})} \right)^{-1} \times \left| S \right|^{-\nu/2} \left| W \right|^{(\nu - k - 1) / 2} \times \exp (-\frac{1}{2} \mbox{tr} (S^{-1} W)) \right) \\ &amp;=&amp; -\frac{\nu k}{2}\log(2) - \frac{k (k-1)}{4} \log(\pi) - \sum_{i=1}^{k}{\log (\Gamma (\frac{\nu+1-i}{2}))} -\frac{\nu}{2} \log(\det(S)) + \frac{\nu-k-1}{2}\log (\det(W)) - \frac{1}{2} \mbox{tr} (S^{-1}W) \end{eqnarray*}" src="form_25.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>A scalar matrix </td></tr>
    <tr><td class="paramname">nu</td><td>Degrees of freedom </td></tr>
    <tr><td class="paramname">S</td><td>The scale matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The log of the Wishart density at W given nu and S. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if nu is not greater than k-1 </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if S is not square, not symmetric, or not semi-positive definite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_y</td><td>Type of scalar. </td></tr>
    <tr><td class="paramname">T_dof</td><td>Type of degrees of freedom. </td></tr>
    <tr><td class="paramname">T_scale</td><td>Type of scale. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="wishart__log_8hpp_source.html#l00058">58</a> of file <a class="el" href="wishart__log_8hpp_source.html">wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a951a06ccbb12ca44a08544000372dbf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_y , typename T_dof , typename T_scale &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::math::tools::promote_args&lt;T_y, T_dof, T_scale&gt;::type stan::math::wishart_log </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T_y, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_dof &amp;&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_scale, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="wishart__log_8hpp_source.html#l00127">127</a> of file <a class="el" href="wishart__log_8hpp_source.html">wishart_log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7025b4916694aa80aa0d758a11647b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RNG &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt; stan::math::wishart_rng </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RNG &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="wishart__rng_8hpp_source.html#l00029">29</a> of file <a class="el" href="wishart__rng_8hpp_source.html">wishart_rng.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aece739c5a2672028f0c7848045b89f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::CONSTRAINT_TOLERANCE = 1E-8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The tolerance for checking arithmetic bounds In rank and in simplexes. </p>
<p>The default value is <code>1E-8</code>. </p>

<p>Definition at line <a class="el" href="constraint__tolerance_8hpp_source.html#l00011">11</a> of file <a class="el" href="constraint__tolerance_8hpp_source.html">constraint_tolerance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66f94e47c6dc073bbd3929903b4431fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::E = boost::math::constants::e&lt;double&gt;()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base of the natural logarithm, <img class="formulaInl" alt="$ e $" src="form_45.png"/>. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00015">15</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ffd625c2083751d7ccabb7dbe39cbe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::EPSILON = std::numeric_limits&lt;double&gt;::epsilon()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smallest positive value. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00061">61</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f2ac8ebf3095e9934715bb34f0669b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INFTY = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Positive infinity. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00044">44</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5491e346d5a812af988f8de4a5948c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INV_SQRT_2 = 1.0 / <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value of 1 over the square root of 2, <img class="formulaInl" alt="$ 1 / \sqrt{2} $" src="form_47.png"/>. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00027">27</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44d54686aa26009d0e9101be42afd877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::INV_SQRT_TWO_PI = 1.0 / std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00166">166</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab773773e2db53015eb48ab1730816fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_10 = std::log(10.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of 10, <img class="formulaInl" alt="$ \log 10 $" src="form_49.png"/>. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00039">39</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43fb48f0a7f26bc60c1dfb572283b149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_2 = std::log(2.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of 2, <img class="formulaInl" alt="$ \log 2 $" src="form_48.png"/>. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00033">33</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84525339d1870944d63c1cce6caa1af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_HALF = std::log(0.5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00179">179</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6dd9cf6abfd8930528d3635890982b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_PI = std::log(boost::math::constants::pi&lt;double&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00170">170</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a177764626d2378e0d7bdfb26aac187b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_PI_OVER_FOUR = std::log(boost::math::constants::pi&lt;double&gt;()) / 4.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log pi divided by 4 <img class="formulaInl" alt="$ \log \pi / 4 $" src="form_50.png"/>. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00079">79</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab836723c882918b6263042bdefa3c0d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_SQRT_PI = std::log(<a class="el" href="namespacestan_1_1math.html#a3e31fd76fde6e97d14dfb26c5f4ab8d0">SQRT_PI</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00173">173</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7a5d92de812b4b632801cf8e32dbe7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_TWO = std::log(2.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00177">177</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a938e5d349b0ffdfdae9674f9dd4dbebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_TWO_PI = <a class="el" href="namespacestan_1_1math.html#ad7a5d92de812b4b632801cf8e32dbe7d">LOG_TWO</a> + <a class="el" href="namespacestan_1_1math.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00193">193</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd99e429af3a997976a017d6a580e3f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::LOG_ZERO = std::log(0.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00175">175</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a063d6b0347cc193b69270211e8aadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::math::MAJOR_VERSION = <a class="el" href="version_8hpp.html#a0c96447c79362b9df7ef76867a44d3be">STAN_STRING</a>(<a class="el" href="version_8hpp.html#a64f03843f4437f40d083b7bc1a1206e1">STAN_MATH_MAJOR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Major version number for Stan math library. </p>

<p>Definition at line <a class="el" href="version_8hpp_source.html#l00022">22</a> of file <a class="el" href="version_8hpp_source.html">version.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60295ca22b8701af9a3ccf3b607231f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::math::MINOR_VERSION = <a class="el" href="version_8hpp.html#a0c96447c79362b9df7ef76867a44d3be">STAN_STRING</a>(<a class="el" href="version_8hpp.html#afae12a425638d2799b253d3eb268190c">STAN_MATH_MINOR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minor version number for Stan math library. </p>

<p>Definition at line <a class="el" href="version_8hpp_source.html#l00025">25</a> of file <a class="el" href="version_8hpp_source.html">version.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f964e25c3ad3515549ead08428ff7cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_LOG_PI = - <a class="el" href="namespacestan_1_1math.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00186">186</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb4a282e2196987e10d2bb65f12ec55a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_LOG_SQRT_PI = -std::log(std::sqrt(boost::math::constants::pi&lt;double&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00189">189</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59f7f156224f9e60c2fb3e99034212eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_LOG_SQRT_TWO_PI = - std::log(std::sqrt(2.0 * boost::math::constants::pi&lt;double&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00184">184</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa546788809cd7f0be4a9872bc8009325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_LOG_TWO = - <a class="el" href="namespacestan_1_1math.html#ad7a5d92de812b4b632801cf8e32dbe7d">LOG_TWO</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00181">181</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b0bc03717322aa20ea2be9d6e488738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_LOG_TWO_OVER_TWO = - <a class="el" href="namespacestan_1_1math.html#ad7a5d92de812b4b632801cf8e32dbe7d">LOG_TWO</a> / 2.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00191">191</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc867325cdad6b9dcc2e7443ddf5956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_LOG_TWO_PI = - <a class="el" href="namespacestan_1_1math.html#a938e5d349b0ffdfdae9674f9dd4dbebe">LOG_TWO_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00195">195</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a344504ea0c1f4f956c85ea8027a07ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEG_TWO_OVER_SQRT_PI = -<a class="el" href="namespacestan_1_1math.html#a935530f53a026ebb80fcd9006059e9c8">TWO_OVER_SQRT_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00163">163</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1dcea3a9752d079c9f972040b873b704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEGATIVE_EPSILON = - std::numeric_limits&lt;double&gt;::epsilon()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Largest negative value (i.e., smallest absolute value). </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00067">67</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa37d0f67f02e0a0b5797ed9f4df56bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NEGATIVE_INFTY = - std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negative infinity. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00050">50</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cf147700a2e38335abc618b2c913b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::NOT_A_NUMBER = std::numeric_limits&lt;double&gt;::quiet_NaN()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Quiet) not-a-number value. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00056">56</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4c620fffa8fa7ddd68ffb46fb64667b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string stan::math::PATCH_VERSION = <a class="el" href="version_8hpp.html#a0c96447c79362b9df7ef76867a44d3be">STAN_STRING</a>(<a class="el" href="version_8hpp.html#aacfcdd8a078a3dc181112e6d04b82f49">STAN_MATH_PATCH</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch version for Stan math library. </p>

<p>Definition at line <a class="el" href="version_8hpp_source.html#l00028">28</a> of file <a class="el" href="version_8hpp_source.html">version.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ea938c86917d89bbd13e4edcbecb1be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::POISSON_MAX_RATE = std::pow(2.0, 30)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Largest rate parameter allowed in Poisson RNG. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00072">72</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a491d6e40aaa2a3e205ea6708dc3c75dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::SQRT_2 = std::sqrt(2.0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value of the square root of 2, <img class="formulaInl" alt="$ \sqrt{2} $" src="form_46.png"/>. </p>

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00021">21</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa628c5af5a85d53472f0126fcca44524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::SQRT_2_TIMES_SQRT_PI = <a class="el" href="namespacestan_1_1math.html#a491d6e40aaa2a3e205ea6708dc3c75dd">SQRT_2</a> * <a class="el" href="namespacestan_1_1math.html#a3e31fd76fde6e97d14dfb26c5f4ab8d0">SQRT_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00158">158</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e31fd76fde6e97d14dfb26c5f4ab8d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::SQRT_PI = std::sqrt(boost::math::constants::pi&lt;double&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00156">156</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a935530f53a026ebb80fcd9006059e9c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double stan::math::TWO_OVER_SQRT_PI = 2.0 / <a class="el" href="namespacestan_1_1math.html#a3e31fd76fde6e97d14dfb26c5f4ab8d0">SQRT_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constants_8hpp_source.html#l00161">161</a> of file <a class="el" href="constants_8hpp_source.html">constants.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr/>
<div class="conents" style="font-size:80%;">
  <span style="float:left; margin=0 1em 0 1em;">
  &nbsp;&nbsp;&nbsp;&nbsp;
  [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
  </span>
  <span style="float:right; margin=0 1em 0 1em;">
  <i>&copy; 2011&ndash;2015,
  Stan Development Team.
  &nbsp;&nbsp;&nbsp;&nbsp;
  </i>
  </span>
</div>
