<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: OpenCL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__opencl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">OpenCL</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Stan's OpenCL backend allows for computation to be executed in parallel on a GPU or in multithreaded CPUs. </p>
<p>It is meant to easily conform with <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> such that you can create and read from a <code>matrix_cl</code> by doing</p>
<div class="fragment"><div class="line">Eigen::MatrixXd A_eig = Eigen::MatrixXd::Random(10, 10);</div>
<div class="line">matrix_cl&lt;double&gt; A(A_eig);</div>
<div class="line">matrix_cl&lt;double&gt; B = to_matrix_cl(A_eig);</div>
<div class="line">matrix_cl&lt;double&gt; C = cholesky_decompose(A * B);</div>
<div class="line"><span class="comment">// Read back to eigen matrix.</span></div>
<div class="line">Eigen::MatrixXd C_eig = from_matrix_cl(C);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Also for vectors and raw pointers of pointers</span></div>
<div class="line">std::vector&lt;var&gt; A_vec(10, 0);</div>
<div class="line">matrix_cl&lt;var&gt; B_var(A_vec, 10, 1);</div>
<div class="line"> </div>
<div class="line">vari** A_vari= <span class="comment">// fill</span></div>
<div class="line">matrix_cl&lt;var&gt; B_vari(A_vari, 10, 1);</div>
</div><!-- fragment --><p>Execution is performed in async and Kernel operations are compounded and compiled Just In Time. This allows for a low amount of overhead when passing data to and from the device and executing computations.</p>
<p>For more details see the paper on Arvix. <a href="https://arxiv.org/pdf/1907.01063.pdf">https://arxiv.org/pdf/1907.01063.pdf</a> </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__opencl__kernel__generator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator.html">OpenCL Kernel Generator</a></td></tr>
<tr class="memdesc:group__opencl__kernel__generator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OpenCL kernel generator is used to combine multiple matrix operations into a single OpenCL kernel. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__matrix__cl__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matrix__cl__group.html">Matrix</a></td></tr>
<tr class="memdesc:group__matrix__cl__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> class - allocates memory space on the OpenCL device. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__opencl__context__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__context__group.html">OpenCL Context</a></td></tr>
<tr class="memdesc:group__opencl__context__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for OpenCL Context: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__error__checks__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl.html">Error Checks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__kernel__executor__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__executor__opencl.html">Kernel Executor</a></td></tr>
<tr class="memdesc:group__kernel__executor__opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kernel executor allows OpenCL kernels to be executed in async. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__opencl__kernels"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels.html">Custom OpenCL kernels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__prim__fun__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prim__fun__opencl.html">OpenCL overloads of stan/math/prim functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga55b628b5a271afb9f569c34187fd82ad.html#ga55b628b5a271afb9f569c34187fd82ad">stan::math::opencl::cholesky_decompose</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga55b628b5a271afb9f569c34187fd82ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an in-place computation of the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <br /></td></tr>
<tr class="separator:ga55b628b5a271afb9f569c34187fd82ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6779742b7bf4dfa2b9e7d6cc58806179.html#ga6779742b7bf4dfa2b9e7d6cc58806179">stan::math::to_matrix_cl</a> (T &amp;&amp;src)</td></tr>
<tr class="memdesc:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, <code>std::vector</code> or scalar to the destination matrix that is stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T_ret &gt; *  = nullptr, <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__same__types_ga138d3e9c6d2deaf56afdac86932d73bd.html#ga138d3e9c6d2deaf56afdac86932d73bd">require_st_same</a>&lt; T_ret, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadf2a61125c6dca5e5a400d56e24cc6d5.html#gadf2a61125c6dca5e5a400d56e24cc6d5">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix that is stored on the OpenCL device to the destination <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__matrix__cl__types_ga1af53d2ea2874ab39e60e796c8f2c074.html#ga1af53d2ea2874ab39e60e796c8f2c074">require_not_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad35b73b8bb6ac116683220a20f4c317d.html#gad35b73b8bb6ac116683220a20f4c317d">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:gad35b73b8bb6ac116683220a20f4c317d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies result of a kernel generator expression to the specified destination type.  <br /></td></tr>
<tr class="separator:gad35b73b8bb6ac116683220a20f4c317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__same__types_ga29595127b6ba2b597e5723c80dee1b61.html#ga29595127b6ba2b597e5723c80dee1b61">require_same_t</a>&lt; T_dst, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga44e84cc75a88ea72d01c090997fdc556.html#ga44e84cc75a88ea72d01c090997fdc556">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga44e84cc75a88ea72d01c090997fdc556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy A 1 by 1 source matrix from the Device to the host.  <br /></td></tr>
<tr class="separator:ga44e84cc75a88ea72d01c090997fdc556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1f99f6ae3dd35f205631e839119f5541.html#ga1f99f6ae3dd35f205631e839119f5541">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga1f99f6ae3dd35f205631e839119f5541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source kernel generator expression or matrix that is stored on the OpenCL device to the destination <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:ga1f99f6ae3dd35f205631e839119f5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga490df7651c22c9e06d09da69ad303e30.html#ga490df7651c22c9e06d09da69ad303e30">stan::math::packed_copy</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga490df7651c22c9e06d09da69ad303e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs the square flat triangular matrix on the OpenCL device and copies it to the std::vector.  <br /></td></tr>
<tr class="separator:ga490df7651c22c9e06d09da69ad303e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e616a6b56f91890a325b9aa28adc22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, <a class="el" href="group__vector__types_ga038ee4f0c3ca5d626e5159485ac74c8a.html#ga038ee4f0c3ca5d626e5159485ac74c8a">require_vector_vt</a>&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae2e616a6b56f91890a325b9aa28adc22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae2e616a6b56f91890a325b9aa28adc22.html#gae2e616a6b56f91890a325b9aa28adc22">stan::math::packed_copy</a> (Vec &amp;&amp;src, int <a class="el" href="group__opencl_ga3d2a437bd1589a69547c959adda767f5.html#ga3d2a437bd1589a69547c959adda767f5">rows</a>)</td></tr>
<tr class="memdesc:gae2e616a6b56f91890a325b9aa28adc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the packed triangular matrix from the source std::vector to an OpenCL buffer and unpacks it to a flat matrix on the OpenCL device.  <br /></td></tr>
<tr class="separator:gae2e616a6b56f91890a325b9aa28adc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4aa1f3ae0bc5f8b2d42217b8dc26f78c.html#ga4aa1f3ae0bc5f8b2d42217b8dc26f78c">stan::math::copy_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix to the destination matrix.  <br /></td></tr>
<tr class="separator:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga9850bbd8d516b87d722ad54947bb9c9f.html#ga9850bbd8d516b87d722ad54947bb9c9f">stan::math::either</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="memdesc:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in any of the input views.  <br /></td></tr>
<tr class="separator:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338a285d4ba933ba6aa7240908919e0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga338a285d4ba933ba6aa7240908919e0f.html#ga338a285d4ba933ba6aa7240908919e0f">stan::math::both</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="memdesc:ga338a285d4ba933ba6aa7240908919e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in both input views.  <br /></td></tr>
<tr class="separator:ga338a285d4ba933ba6aa7240908919e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63c8a601189c916c8a2157066adb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gadd63c8a601189c916c8a2157066adb7c.html#gadd63c8a601189c916c8a2157066adb7c">stan::math::contains_nonzero</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> part)</td></tr>
<tr class="memdesc:gadd63c8a601189c916c8a2157066adb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a view contains certain nonzero part.  <br /></td></tr>
<tr class="separator:gadd63c8a601189c916c8a2157066adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccee2b081b9edd7c6e6d211157e5490"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gafccee2b081b9edd7c6e6d211157e5490.html#gafccee2b081b9edd7c6e6d211157e5490">stan::math::transpose</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="memdesc:gafccee2b081b9edd7c6e6d211157e5490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a view - swaps lower and upper parts.  <br /></td></tr>
<tr class="separator:gafccee2b081b9edd7c6e6d211157e5490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f014e58d824281b725a7d4868dd77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga747f014e58d824281b725a7d4868dd77.html#ga747f014e58d824281b725a7d4868dd77">stan::math::invert</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="memdesc:ga747f014e58d824281b725a7d4868dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a view.  <br /></td></tr>
<tr class="separator:ga747f014e58d824281b725a7d4868dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e938e6fdd621c5903cc37401c54909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga27e938e6fdd621c5903cc37401c54909.html#ga27e938e6fdd621c5903cc37401c54909">stan::math::from_eigen_uplo_type</a> (Eigen::UpLoType eigen_type)</td></tr>
<tr class="memdesc:ga27e938e6fdd621c5903cc37401c54909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view from <code>Eigen::UpLoType</code>.  <br /></td></tr>
<tr class="separator:ga27e938e6fdd621c5903cc37401c54909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac9df9f4a3afc7cd815fc369d54ab2a9c.html#gac9df9f4a3afc7cd815fc369d54ab2a9c">stan::math::multiply_transpose</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a square OpenCL matrix with its transpose.  <br /></td></tr>
<tr class="separator:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada680649d4f1ecf2a665168c088465b5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gada680649d4f1ecf2a665168c088465b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gada680649d4f1ecf2a665168c088465b5.html#gada680649d4f1ecf2a665168c088465b5">stan::math::bernoulli_logit_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gada680649d4f1ecf2a665168c088465b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <br /></td></tr>
<tr class="separator:gada680649d4f1ecf2a665168c088465b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458b9954e62495f1d9165725c14603d4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga458b9954e62495f1d9165725c14603d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga458b9954e62495f1d9165725c14603d4.html#ga458b9954e62495f1d9165725c14603d4">stan::math::bernoulli_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga458b9954e62495f1d9165725c14603d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:ga458b9954e62495f1d9165725c14603d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4aef070113680165b3cc5423f93950"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_size1_cl , typename T_size2_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e4aef070113680165b3cc5423f93950"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2e4aef070113680165b3cc5423f93950.html#ga2e4aef070113680165b3cc5423f93950">stan::math::beta_binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_size1_cl &amp;alpha, const T_size2_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga2e4aef070113680165b3cc5423f93950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Beta-Binomial distribution with given population size, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga2e4aef070113680165b3cc5423f93950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1958cd702be988949f2f5054302b8514"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1958cd702be988949f2f5054302b8514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1958cd702be988949f2f5054302b8514.html#ga1958cd702be988949f2f5054302b8514">stan::math::beta_lpdf</a> (const T_y_cl &amp;y, const T_scale_succ_cl &amp;alpha, const T_scale_fail_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga1958cd702be988949f2f5054302b8514"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for the specified scalar(s) given the specified sample stan::math::size(s).  <br /></td></tr>
<tr class="separator:ga1958cd702be988949f2f5054302b8514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga88348aa350be49d2b9b4eab03ddecbdb.html#ga88348aa350be49d2b9b4eab03ddecbdb">stan::math::beta_proportion_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_prec_cl &amp;kappa)</td></tr>
<tr class="memdesc:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for specified y, location, and precision: beta_proportion_lpdf(y | mu, kappa) = beta_lpdf(y | mu * kappa, (1 - mu) * kappa).  <br /></td></tr>
<tr class="separator:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22974de84a4f7c530aad6fd2657e098d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga1e58259e90935ab5ef20d2a5835104df.html#ga1e58259e90935ab5ef20d2a5835104df">require_any_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga22974de84a4f7c530aad6fd2657e098d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga22974de84a4f7c530aad6fd2657e098d.html#ga22974de84a4f7c530aad6fd2657e098d">stan::math::binomial_logit_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga22974de84a4f7c530aad6fd2657e098d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial log PMF in logit parametrization.  <br /></td></tr>
<tr class="separator:ga22974de84a4f7c530aad6fd2657e098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c30135fdfb922c32838de8223ac8ae"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga1e58259e90935ab5ef20d2a5835104df.html#ga1e58259e90935ab5ef20d2a5835104df">require_any_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga31c30135fdfb922c32838de8223ac8ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga31c30135fdfb922c32838de8223ac8ae.html#ga31c30135fdfb922c32838de8223ac8ae">stan::math::binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga31c30135fdfb922c32838de8223ac8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF for the binomial distribution evaluated at the specified success, population size, and chance of success.  <br /></td></tr>
<tr class="separator:ga31c30135fdfb922c32838de8223ac8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaebba67775ecfd1a8bd3c4f0e146b8504.html#gaebba67775ecfd1a8bd3c4f0e146b8504">stan::math::categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function.  <br /></td></tr>
<tr class="separator:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7142ba28cdfdffee8b453c6d5ad6a325.html#ga7142ba28cdfdffee8b453c6d5ad6a325">stan::math::cauchy_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f5400878f7e042bbe910af7b89b122"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40f5400878f7e042bbe910af7b89b122"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga40f5400878f7e042bbe910af7b89b122.html#ga40f5400878f7e042bbe910af7b89b122">stan::math::cauchy_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga40f5400878f7e042bbe910af7b89b122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga40f5400878f7e042bbe910af7b89b122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6bf031eab3679d4f6f39b9f5626241dc.html#ga6bf031eab3679d4f6f39b9f5626241dc">stan::math::cauchy_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f93dad000040f304fca4d7e64faa415"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3f93dad000040f304fca4d7e64faa415"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3f93dad000040f304fca4d7e64faa415.html#ga3f93dad000040f304fca4d7e64faa415">stan::math::cauchy_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga3f93dad000040f304fca4d7e64faa415"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <br /></td></tr>
<tr class="separator:ga3f93dad000040f304fca4d7e64faa415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27802809e14425c3dbdf22129b9dc443"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga27802809e14425c3dbdf22129b9dc443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga27802809e14425c3dbdf22129b9dc443.html#ga27802809e14425c3dbdf22129b9dc443">stan::math::chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="memdesc:ga27802809e14425c3dbdf22129b9dc443"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a chi-squared density for y with the specified degrees of freedom parameter.  <br /></td></tr>
<tr class="separator:ga27802809e14425c3dbdf22129b9dc443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0576c38beac678f1164a2cfc172e941e.html#ga0576c38beac678f1164a2cfc172e941e">stan::math::col</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="memdesc:ga0576c38beac678f1164a2cfc172e941e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified kernel generator expression using start-at-1 indexing.  <br /></td></tr>
<tr class="separator:ga0576c38beac678f1164a2cfc172e941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2bf6efe8102f577be540859fde068f"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b2bf6efe8102f577be540859fde068f"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2b2bf6efe8102f577be540859fde068f.html#ga2b2bf6efe8102f577be540859fde068f">stan::math::cols</a> (const T_x &amp;x)</td></tr>
<tr class="memdesc:ga2b2bf6efe8102f577be540859fde068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the specified kernel generator expression.  <br /></td></tr>
<tr class="separator:ga2b2bf6efe8102f577be540859fde068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaff473895b1f11e364afd4c2d3cb5cab4.html#gaff473895b1f11e364afd4c2d3cb5cab4">stan::math::dims</a> (const T_x &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> overload of the dims helper function in <a class="el" href="prim_2fun_2dims_8hpp.html">prim/fun/dims.hpp</a>.  <br /></td></tr>
<tr class="separator:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5603f6eef0dc72e15804d640a005841e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob_cl , typename T_prior_size_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5603f6eef0dc72e15804d640a005841e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl, T_prior_size_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5603f6eef0dc72e15804d640a005841e.html#ga5603f6eef0dc72e15804d640a005841e">stan::math::dirichlet_lpdf</a> (const T_prob_cl &amp;theta, const T_prior_size_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga5603f6eef0dc72e15804d640a005841e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha.  <br /></td></tr>
<tr class="separator:ga5603f6eef0dc72e15804d640a005841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7fcb23d1bea081595030aedd230f5cf9.html#ga7fcb23d1bea081595030aedd230f5cf9">stan::math::divide</a> (T_a &amp;&amp;a, double d)</td></tr>
<tr class="memdesc:ga7fcb23d1bea081595030aedd230f5cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise division of the kernel generator expression.  <br /></td></tr>
<tr class="separator:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2cc44cdfe2d3632d1e5481cff15fb65b.html#ga2cc44cdfe2d3632d1e5481cff15fb65b">stan::math::divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;B)</td></tr>
<tr class="memdesc:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a vector.  <br /></td></tr>
<tr class="separator:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8eb269aa25fab63bb03b617210151e4a.html#ga8eb269aa25fab63bb03b617210151e4a">stan::math::divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const T2 &amp;divisor)</td></tr>
<tr class="memdesc:ga8eb269aa25fab63bb03b617210151e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a scalar.  <br /></td></tr>
<tr class="separator:ga8eb269aa25fab63bb03b617210151e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2894417c746d65ba9021b076e37bc163"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2894417c746d65ba9021b076e37bc163"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2894417c746d65ba9021b076e37bc163.html#ga2894417c746d65ba9021b076e37bc163">stan::math::double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga2894417c746d65ba9021b076e37bc163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga2894417c746d65ba9021b076e37bc163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7d0996b3465a9ebeb23d16b3f3b17cb5.html#ga7d0996b3465a9ebeb23d16b3f3b17cb5">stan::math::double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log complementary cumulative density function.  <br /></td></tr>
<tr class="separator:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5b3b220580811803b6992e61887a13"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e5b3b220580811803b6992e61887a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e5b3b220580811803b6992e61887a13.html#ga5e5b3b220580811803b6992e61887a13">stan::math::double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga5e5b3b220580811803b6992e61887a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log cumulative density function.  <br /></td></tr>
<tr class="separator:ga5e5b3b220580811803b6992e61887a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac068dac657d8b37285df182b652f308a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac068dac657d8b37285df182b652f308a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac068dac657d8b37285df182b652f308a.html#gac068dac657d8b37285df182b652f308a">stan::math::double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gac068dac657d8b37285df182b652f308a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log probability density function.  <br /></td></tr>
<tr class="separator:gac068dac657d8b37285df182b652f308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ed504293af9cdc9cd8599ee49f737c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac9ed504293af9cdc9cd8599ee49f737c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac9ed504293af9cdc9cd8599ee49f737c.html#gac9ed504293af9cdc9cd8599ee49f737c">stan::math::exp_mod_normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:gac9ed504293af9cdc9cd8599ee49f737c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:gac9ed504293af9cdc9cd8599ee49f737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32fcb6886b7ff193f317af94e439203d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga32fcb6886b7ff193f317af94e439203d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga32fcb6886b7ff193f317af94e439203d.html#ga32fcb6886b7ff193f317af94e439203d">stan::math::exp_mod_normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:ga32fcb6886b7ff193f317af94e439203d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exp mod normal log complementary cumulative density function.  <br /></td></tr>
<tr class="separator:ga32fcb6886b7ff193f317af94e439203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cbc426176ab6b9924cc1acff27c37c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga10cbc426176ab6b9924cc1acff27c37c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga10cbc426176ab6b9924cc1acff27c37c.html#ga10cbc426176ab6b9924cc1acff27c37c">stan::math::exp_mod_normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:ga10cbc426176ab6b9924cc1acff27c37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exp mod normal log cumulative density function.  <br /></td></tr>
<tr class="separator:ga10cbc426176ab6b9924cc1acff27c37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae039c40c36fc71cd9c4714e5c5fe0aa1.html#gae039c40c36fc71cd9c4714e5c5fe0aa1">stan::math::exp_mod_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the exp mod normal distribution.  <br /></td></tr>
<tr class="separator:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gafd3aa08ca68b5172c7ab6707f40150d5.html#gafd3aa08ca68b5172c7ab6707f40150d5">stan::math::exponential_cdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the exponential cumulative distribution function for the given y and beta.  <br /></td></tr>
<tr class="separator:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0a717f891977f057b1b959432fb047"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e0a717f891977f057b1b959432fb047"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2e0a717f891977f057b1b959432fb047.html#ga2e0a717f891977f057b1b959432fb047">stan::math::exponential_lccdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga2e0a717f891977f057b1b959432fb047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log exponential cumulative distribution function for the given y and beta.  <br /></td></tr>
<tr class="separator:ga2e0a717f891977f057b1b959432fb047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d45dda59c036aa28a02cefb705144c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5d45dda59c036aa28a02cefb705144c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5d45dda59c036aa28a02cefb705144c1.html#ga5d45dda59c036aa28a02cefb705144c1">stan::math::exponential_lcdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga5d45dda59c036aa28a02cefb705144c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log exponential cumulative distribution function for the given y and beta.  <br /></td></tr>
<tr class="separator:ga5d45dda59c036aa28a02cefb705144c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17062b58db7edb5ce19299e743101ea"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab17062b58db7edb5ce19299e743101ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab17062b58db7edb5ce19299e743101ea.html#gab17062b58db7edb5ce19299e743101ea">stan::math::exponential_lpdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gab17062b58db7edb5ce19299e743101ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an exponential density for y with the specified inverse scale parameter.  <br /></td></tr>
<tr class="separator:gab17062b58db7edb5ce19299e743101ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74727b2f75188f45d939879917da067"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf74727b2f75188f45d939879917da067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf74727b2f75188f45d939879917da067.html#gaf74727b2f75188f45d939879917da067">stan::math::frechet_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaf74727b2f75188f45d939879917da067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frechet cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaf74727b2f75188f45d939879917da067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e65c8e3e2c35410a0351008149d8f5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae6e65c8e3e2c35410a0351008149d8f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae6e65c8e3e2c35410a0351008149d8f5.html#gae6e65c8e3e2c35410a0351008149d8f5">stan::math::frechet_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gae6e65c8e3e2c35410a0351008149d8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frechet log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gae6e65c8e3e2c35410a0351008149d8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1e4df0fd56d7b6aa89f3593cd4b9ef00.html#ga1e4df0fd56d7b6aa89f3593cd4b9ef00">stan::math::frechet_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frechet log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0299951bbc9cf5045068dc51841342"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4f0299951bbc9cf5045068dc51841342"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4f0299951bbc9cf5045068dc51841342.html#ga4f0299951bbc9cf5045068dc51841342">stan::math::frechet_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga4f0299951bbc9cf5045068dc51841342"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the frechet density for the specified scalar(s) given the specified sample stan::math::size(s).  <br /></td></tr>
<tr class="separator:ga4f0299951bbc9cf5045068dc51841342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga269c6886b8fe609e094cf4f9c07e9f74.html#ga269c6886b8fe609e094cf4f9c07e9f74">stan::math::gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a gamma density for y with the specified shape and inverse scale parameters.  <br /></td></tr>
<tr class="separator:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7ae66d06eb626b8357a5fc74289bfe42.html#ga7ae66d06eb626b8357a5fc74289bfe42">stan::math::gp_dot_prod_cov</a> (const T_x &amp;x, const T_sigma sigma)</td></tr>
<tr class="memdesc:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , typename T_sigma , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_y &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadfb569d6717740727352a2b67d23adfc.html#gadfb569d6717740727352a2b67d23adfc">stan::math::gp_dot_prod_cov</a> (const T_x &amp;x, const T_y &amp;y, const T_sigma sigma)</td></tr>
<tr class="memdesc:gadfb569d6717740727352a2b67d23adfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product kernel on the GPU.  <br /></td></tr>
<tr class="separator:gadfb569d6717740727352a2b67d23adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c459084eb40e844e676391316c5bc9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </td></tr>
<tr class="memitem:ga67c459084eb40e844e676391316c5bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga67c459084eb40e844e676391316c5bc9.html#ga67c459084eb40e844e676391316c5bc9">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:ga67c459084eb40e844e676391316c5bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga67c459084eb40e844e676391316c5bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff43fb0f414ae018ece6488dc112d22d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </td></tr>
<tr class="memitem:gaff43fb0f414ae018ece6488dc112d22d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaff43fb0f414ae018ece6488dc112d22d.html#gaff43fb0f414ae018ece6488dc112d22d">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:gaff43fb0f414ae018ece6488dc112d22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:gaff43fb0f414ae018ece6488dc112d22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac47f7d0f97a1035236ac74de3b965020.html#gac47f7d0f97a1035236ac74de3b965020">stan::math::gp_exponential_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:gac47f7d0f97a1035236ac74de3b965020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:gac47f7d0f97a1035236ac74de3b965020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga63ac2500cbe6777efe781d2738148ed4.html#ga63ac2500cbe6777efe781d2738148ed4">stan::math::gp_exponential_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga63ac2500cbe6777efe781d2738148ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga63ac2500cbe6777efe781d2738148ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga42d71e19927c390c7e2ca70ffe71d600.html#ga42d71e19927c390c7e2ca70ffe71d600">stan::math::gp_matern32_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:ga42d71e19927c390c7e2ca70ffe71d600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 3/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85aa537a04d32939114f7dd8b75fdc5b.html#ga85aa537a04d32939114f7dd8b75fdc5b">stan::math::gp_matern32_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 3/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaea5e4b95241432025c0dbf5693659fda.html#gaea5e4b95241432025c0dbf5693659fda">stan::math::gp_matern52_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:gaea5e4b95241432025c0dbf5693659fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 5/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:gaea5e4b95241432025c0dbf5693659fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga07fab169578cad9bff602bc9c60453a7.html#ga07fab169578cad9bff602bc9c60453a7">stan::math::gp_matern52_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga07fab169578cad9bff602bc9c60453a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 5/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga07fab169578cad9bff602bc9c60453a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac840c0972e9a72dd9791352953c6904b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac840c0972e9a72dd9791352953c6904b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac840c0972e9a72dd9791352953c6904b.html#gac840c0972e9a72dd9791352953c6904b">stan::math::gumbel_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gac840c0972e9a72dd9791352953c6904b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gumbel cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gac840c0972e9a72dd9791352953c6904b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26240cad067ee7137cc57ae7e71c8da"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac26240cad067ee7137cc57ae7e71c8da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac26240cad067ee7137cc57ae7e71c8da.html#gac26240cad067ee7137cc57ae7e71c8da">stan::math::gumbel_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gac26240cad067ee7137cc57ae7e71c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gac26240cad067ee7137cc57ae7e71c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga37b5904be5c33f9ef6b1ee7a5a3f46c1.html#ga37b5904be5c33f9ef6b1ee7a5a3f46c1">stan::math::gumbel_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga88e0447c99bb53c2c8a2ff906e47c39e.html#ga88e0447c99bb53c2c8a2ff906e47c39e">stan::math::gumbel_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log probability density for the given location and scale.  <br /></td></tr>
<tr class="separator:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba5763101e834c65f55ae9061198e91"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaaba5763101e834c65f55ae9061198e91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaaba5763101e834c65f55ae9061198e91.html#gaaba5763101e834c65f55ae9061198e91">stan::math::inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="memdesc:gaaba5763101e834c65f55ae9061198e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse chi-squared density for y with the specified degrees of freedom parameter.  <br /></td></tr>
<tr class="separator:gaaba5763101e834c65f55ae9061198e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b17b21db462d52896cbb001bd7fe4f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab7b17b21db462d52896cbb001bd7fe4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab7b17b21db462d52896cbb001bd7fe4f.html#gab7b17b21db462d52896cbb001bd7fe4f">stan::math::inv_gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gab7b17b21db462d52896cbb001bd7fe4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse gamma density for y with the specified shape and scale parameters.  <br /></td></tr>
<tr class="separator:gab7b17b21db462d52896cbb001bd7fe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68390747f8d9f5584914e8cf87ca2da"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae68390747f8d9f5584914e8cf87ca2da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae68390747f8d9f5584914e8cf87ca2da.html#gae68390747f8d9f5584914e8cf87ca2da">stan::math::logistic_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gae68390747f8d9f5584914e8cf87ca2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logistic cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gae68390747f8d9f5584914e8cf87ca2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebd76af5a9ea78a039810c3f627ff61"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadebd76af5a9ea78a039810c3f627ff61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadebd76af5a9ea78a039810c3f627ff61.html#gadebd76af5a9ea78a039810c3f627ff61">stan::math::logistic_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gadebd76af5a9ea78a039810c3f627ff61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logistic cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gadebd76af5a9ea78a039810c3f627ff61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa0c7858f9b0a323ade684a1e3e51e87b.html#gaa0c7858f9b0a323ade684a1e3e51e87b">stan::math::logistic_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logistic cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f3378444fb1fa2e05e1257d000d417"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac7f3378444fb1fa2e05e1257d000d417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac7f3378444fb1fa2e05e1257d000d417.html#gac7f3378444fb1fa2e05e1257d000d417">stan::math::logistic_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gac7f3378444fb1fa2e05e1257d000d417"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a logistic density for y with the specified location and scale parameters.  <br /></td></tr>
<tr class="separator:gac7f3378444fb1fa2e05e1257d000d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade92ae2463a65a4572405954733abac8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gade92ae2463a65a4572405954733abac8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gade92ae2463a65a4572405954733abac8.html#gade92ae2463a65a4572405954733abac8">stan::math::lognormal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gade92ae2463a65a4572405954733abac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loghormal cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gade92ae2463a65a4572405954733abac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4348a862c0a6befed9be0c57fac8e8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafb4348a862c0a6befed9be0c57fac8e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gafb4348a862c0a6befed9be0c57fac8e8.html#gafb4348a862c0a6befed9be0c57fac8e8">stan::math::lognormal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gafb4348a862c0a6befed9be0c57fac8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lognormal log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gafb4348a862c0a6befed9be0c57fac8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga74d9217ec565de7e187bdb359f8e2b6f.html#ga74d9217ec565de7e187bdb359f8e2b6f">stan::math::lognormal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lognormal log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab3dca7015ae3977e1fadf1e1b3a13f9e.html#gab3dca7015ae3977e1fadf1e1b3a13f9e">stan::math::lognormal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the lognormal density for the specified scalar(s) given the specified sample stan::math::size(s).  <br /></td></tr>
<tr class="separator:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_covar_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_covar_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_covar_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3ea5feae3e40c37cdc845d98fc222c80.html#ga3ea5feae3e40c37cdc845d98fc222c80">stan::math::multi_normal_cholesky_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_covar_cl &amp;L)</td></tr>
<tr class="memdesc:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix.  <br /></td></tr>
<tr class="separator:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824d3723d9c0f93302dc974faee0e8fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga824d3723d9c0f93302dc974faee0e8fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga824d3723d9c0f93302dc974faee0e8fc.html#ga824d3723d9c0f93302dc974faee0e8fc">stan::math::multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ga824d3723d9c0f93302dc974faee0e8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of the specified matrices with the option of specifying the triangularity of either input matrices.  <br /></td></tr>
<tr class="separator:ga824d3723d9c0f93302dc974faee0e8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85c5d9590a8fe49a6a71e4b0894897b8.html#ga85c5d9590a8fe49a6a71e4b0894897b8">stan::math::neg_binomial_2_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_phi_cl &amp;phi)</td></tr>
<tr class="memdesc:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function.  <br /></td></tr>
<tr class="separator:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ee28a9bb35e74b0742539416b23a2a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga70ee28a9bb35e74b0742539416b23a2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga70ee28a9bb35e74b0742539416b23a2a.html#ga70ee28a9bb35e74b0742539416b23a2a">stan::math::neg_binomial_2_log_lpmf</a> (const T_n_cl &amp;n, const T_log_location_cl &amp;eta, const T_precision_cl &amp;phi)</td></tr>
<tr class="memdesc:ga70ee28a9bb35e74b0742539416b23a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the log transformed negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:ga70ee28a9bb35e74b0742539416b23a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24209b61d1f95246013701478577160f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga24209b61d1f95246013701478577160f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga24209b61d1f95246013701478577160f.html#ga24209b61d1f95246013701478577160f">stan::math::neg_binomial_2_lpmf</a> (const T_n_cl &amp;n, const T_location_cl &amp;mu, const T_precision_cl &amp;phi)</td></tr>
<tr class="memdesc:ga24209b61d1f95246013701478577160f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:ga24209b61d1f95246013701478577160f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213891b28b3707c76327cfe7c674401"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9213891b28b3707c76327cfe7c674401"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9213891b28b3707c76327cfe7c674401.html#ga9213891b28b3707c76327cfe7c674401">stan::math::neg_binomial_lpmf</a> (const T_n_cl &amp;n, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga9213891b28b3707c76327cfe7c674401"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:ga9213891b28b3707c76327cfe7c674401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb1b528cffdef8f13b7640d279214e6"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6fb1b528cffdef8f13b7640d279214e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6fb1b528cffdef8f13b7640d279214e6.html#ga6fb1b528cffdef8f13b7640d279214e6">stan::math::normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga6fb1b528cffdef8f13b7640d279214e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normal cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga6fb1b528cffdef8f13b7640d279214e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25418219cf2e8dd541ecac94d6579ce7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga25418219cf2e8dd541ecac94d6579ce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga25418219cf2e8dd541ecac94d6579ce7.html#ga25418219cf2e8dd541ecac94d6579ce7">stan::math::normal_id_glm_lpdf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_sigma_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga25418219cf2e8dd541ecac94d6579ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function.  <br /></td></tr>
<tr class="separator:ga25418219cf2e8dd541ecac94d6579ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcdac87f80488a7cf40c80f353f31c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacfcdac87f80488a7cf40c80f353f31c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacfcdac87f80488a7cf40c80f353f31c1.html#gacfcdac87f80488a7cf40c80f353f31c1">stan::math::normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gacfcdac87f80488a7cf40c80f353f31c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normal log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gacfcdac87f80488a7cf40c80f353f31c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8b8007efbb1c8d98d247403f1ab387d1.html#ga8b8007efbb1c8d98d247403f1ab387d1">stan::math::normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normal log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad305d01ff13ab2f04921def01f434ff"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaad305d01ff13ab2f04921def01f434ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaad305d01ff13ab2f04921def01f434ff.html#gaad305d01ff13ab2f04921def01f434ff">stan::math::normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaad305d01ff13ab2f04921def01f434ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:gaad305d01ff13ab2f04921def01f434ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4cebeb5b59455b65807650b71a7fe0a1.html#ga4cebeb5b59455b65807650b71a7fe0a1">stan::math::ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="memdesc:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the ordinal regression Generalized Linear Model (GLM).  <br /></td></tr>
<tr class="separator:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_cuts_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacc83b68972d42ac3bbf64fc0ccf454bf.html#gacc83b68972d42ac3bbf64fc0ccf454bf">stan::math::ordered_logistic_lpmf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;lambda, const T_cuts_cl &amp;cuts)</td></tr>
<tr class="memdesc:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and specified cutpoints in an ordered logistic model.  <br /></td></tr>
<tr class="separator:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e5942c7c5a6138d96230806f6acef9"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga60e5942c7c5a6138d96230806f6acef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga60e5942c7c5a6138d96230806f6acef9.html#ga60e5942c7c5a6138d96230806f6acef9">stan::math::pareto_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga60e5942c7c5a6138d96230806f6acef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pareto cumulative density function.  <br /></td></tr>
<tr class="separator:ga60e5942c7c5a6138d96230806f6acef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3266e056f6cc2b8b7e2f3f30674798ca.html#ga3266e056f6cc2b8b7e2f3f30674798ca">stan::math::pareto_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pareto cumulative density function.  <br /></td></tr>
<tr class="separator:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9efb4cfe069238c77cd6616f4b2c9170.html#ga9efb4cfe069238c77cd6616f4b2c9170">stan::math::pareto_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pareto cumulative density function.  <br /></td></tr>
<tr class="separator:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787b804a23dd71fd6087363231e98339"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga787b804a23dd71fd6087363231e98339"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga787b804a23dd71fd6087363231e98339.html#ga787b804a23dd71fd6087363231e98339">stan::math::pareto_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga787b804a23dd71fd6087363231e98339"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <br /></td></tr>
<tr class="separator:ga787b804a23dd71fd6087363231e98339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef789587dd8f528f3898006b911db0cc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaef789587dd8f528f3898006b911db0cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaef789587dd8f528f3898006b911db0cc.html#gaef789587dd8f528f3898006b911db0cc">stan::math::pareto_type_2_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:gaef789587dd8f528f3898006b911db0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pareto type 2 cumulative density function.  <br /></td></tr>
<tr class="separator:gaef789587dd8f528f3898006b911db0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7436040baf4a148c636344039b07defc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7436040baf4a148c636344039b07defc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7436040baf4a148c636344039b07defc.html#ga7436040baf4a148c636344039b07defc">stan::math::pareto_type_2_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga7436040baf4a148c636344039b07defc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pareto type 2 log complementaty cumulative density function.  <br /></td></tr>
<tr class="separator:ga7436040baf4a148c636344039b07defc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga19c5e7e7166cb87bb0ec5bd9f513713a.html#ga19c5e7e7166cb87bb0ec5bd9f513713a">stan::math::pareto_type_2_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pareto type 2 log cumulative density function.  <br /></td></tr>
<tr class="separator:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga702c56bfb2c74ddeafd14c3a455d356f.html#ga702c56bfb2c74ddeafd14c3a455d356f">stan::math::pareto_type_2_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Pareto type 2 distribution.  <br /></td></tr>
<tr class="separator:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c582a0f0ff921ed988b627e8e54de47"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8c582a0f0ff921ed988b627e8e54de47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8c582a0f0ff921ed988b627e8e54de47.html#ga8c582a0f0ff921ed988b627e8e54de47">stan::math::poisson_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga8c582a0f0ff921ed988b627e8e54de47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function.  <br /></td></tr>
<tr class="separator:ga8c582a0f0ff921ed988b627e8e54de47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e7e62c68ef3bf00be621c40df533f7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae6e7e62c68ef3bf00be621c40df533f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae6e7e62c68ef3bf00be621c40df533f7.html#gae6e7e62c68ef3bf00be621c40df533f7">stan::math::poisson_log_lpmf</a> (const T_n_cl &amp;n, const T_log_rate_cl &amp;alpha)</td></tr>
<tr class="memdesc:gae6e7e62c68ef3bf00be621c40df533f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Poisson log distribution.  <br /></td></tr>
<tr class="separator:gae6e7e62c68ef3bf00be621c40df533f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9553d34b32b0c23306872195462eee31"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_rate_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9553d34b32b0c23306872195462eee31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9553d34b32b0c23306872195462eee31.html#ga9553d34b32b0c23306872195462eee31">stan::math::poisson_lpmf</a> (const T_n_cl &amp;n, const T_rate_cl &amp;lambda)</td></tr>
<tr class="memdesc:ga9553d34b32b0c23306872195462eee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Poisson distribution.  <br /></td></tr>
<tr class="separator:ga9553d34b32b0c23306872195462eee31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fd90c8278288b2545d7b815ce48b9a"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga24fd90c8278288b2545d7b815ce48b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga24fd90c8278288b2545d7b815ce48b9a.html#ga24fd90c8278288b2545d7b815ce48b9a">stan::math::rayleigh_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga24fd90c8278288b2545d7b815ce48b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Rayleigh cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga24fd90c8278288b2545d7b815ce48b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014dce391185d0870589394401b5e570"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga014dce391185d0870589394401b5e570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga014dce391185d0870589394401b5e570.html#ga014dce391185d0870589394401b5e570">stan::math::rayleigh_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga014dce391185d0870589394401b5e570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Rayleigh log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga014dce391185d0870589394401b5e570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1c06d7aee92d4cf2da1baf6aae1a3230.html#ga1c06d7aee92d4cf2da1baf6aae1a3230">stan::math::rayleigh_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Rayleigh log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57652d7c59a9813457f972c48aad0933"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57652d7c59a9813457f972c48aad0933"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga57652d7c59a9813457f972c48aad0933.html#ga57652d7c59a9813457f972c48aad0933">stan::math::rayleigh_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga57652d7c59a9813457f972c48aad0933"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an Rayleigh density for y with the specified scale parameter.  <br /></td></tr>
<tr class="separator:ga57652d7c59a9813457f972c48aad0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; T &gt;, <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3bbe5a508d5789497afc2cbd03f8004c.html#ga3bbe5a508d5789497afc2cbd03f8004c">stan::math::rep_array</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing an array by replicating the input value.  <br /></td></tr>
<tr class="separator:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e2c7f71203a6ba2b93d5372ed6cf01e.html#ga5e2c7f71203a6ba2b93d5372ed6cf01e">stan::math::rep_matrix</a> (const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;x, int n, int m)</td></tr>
<tr class="memdesc:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the given value of arithmetic type.  <br /></td></tr>
<tr class="separator:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga78f19ec991d6f0ed60695ef33003868d.html#ga78f19ec991d6f0ed60695ef33003868d">stan::math::rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga78f19ec991d6f0ed60695ef33003868d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the input vector or row_vector.  <br /></td></tr>
<tr class="separator:ga78f19ec991d6f0ed60695ef33003868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; T &gt;, <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabbac6d303d27c8ee22511862dce6c565.html#gabbac6d303d27c8ee22511862dce6c565">stan::math::rep_row_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:gabbac6d303d27c8ee22511862dce6c565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing a row vector by replicating the input value.  <br /></td></tr>
<tr class="separator:gabbac6d303d27c8ee22511862dce6c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; T &gt;, <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabd9fbe441671cf2a2f88cd3e8d9b8ca8.html#gabd9fbe441671cf2a2f88cd3e8d9b8ca8">stan::math::rep_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing a vector by replicating the input value.  <br /></td></tr>
<tr class="separator:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga80392ae5670adea53e79770aa29c816a.html#ga80392ae5670adea53e79770aa29c816a">stan::math::row</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="memdesc:ga80392ae5670adea53e79770aa29c816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified kernel generator expression using start-at-1 indexing.  <br /></td></tr>
<tr class="separator:ga80392ae5670adea53e79770aa29c816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2a437bd1589a69547c959adda767f5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3d2a437bd1589a69547c959adda767f5"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3d2a437bd1589a69547c959adda767f5.html#ga3d2a437bd1589a69547c959adda767f5">stan::math::rows</a> (const T_x &amp;x)</td></tr>
<tr class="memdesc:ga3d2a437bd1589a69547c959adda767f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the specified kernel generator expression.  <br /></td></tr>
<tr class="separator:ga3d2a437bd1589a69547c959adda767f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912f7b32021ce895e66e39fd448bf613"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga912f7b32021ce895e66e39fd448bf613"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga912f7b32021ce895e66e39fd448bf613.html#ga912f7b32021ce895e66e39fd448bf613">stan::math::scaled_inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_scale_cl &amp;s)</td></tr>
<tr class="memdesc:ga912f7b32021ce895e66e39fd448bf613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.  <br /></td></tr>
<tr class="separator:ga912f7b32021ce895e66e39fd448bf613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad4e2c50dc4b8dbf53e8f11b2ae50450d.html#gad4e2c50dc4b8dbf53e8f11b2ae50450d">stan::math::skew_double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66bd3722a04acc00a36998d1f4f7d593"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga66bd3722a04acc00a36998d1f4f7d593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga66bd3722a04acc00a36998d1f4f7d593.html#ga66bd3722a04acc00a36998d1f4f7d593">stan::math::skew_double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:ga66bd3722a04acc00a36998d1f4f7d593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga66bd3722a04acc00a36998d1f4f7d593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a41630a4084c4b59479102e31c20d52"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8a41630a4084c4b59479102e31c20d52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8a41630a4084c4b59479102e31c20d52.html#ga8a41630a4084c4b59479102e31c20d52">stan::math::skew_double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:ga8a41630a4084c4b59479102e31c20d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga8a41630a4084c4b59479102e31c20d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce8c6ede664f99d533a6324ac91a3c7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadce8c6ede664f99d533a6324ac91a3c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadce8c6ede664f99d533a6324ac91a3c7.html#gadce8c6ede664f99d533a6324ac91a3c7">stan::math::skew_double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:gadce8c6ede664f99d533a6324ac91a3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the skew double exponential distribution.  <br /></td></tr>
<tr class="separator:gadce8c6ede664f99d533a6324ac91a3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e843ba6d42af1a8ce55a11fd850972"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga09e843ba6d42af1a8ce55a11fd850972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga09e843ba6d42af1a8ce55a11fd850972.html#ga09e843ba6d42af1a8ce55a11fd850972">stan::math::skew_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga09e843ba6d42af1a8ce55a11fd850972"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the skew normal density for the specified scalar(s) given the specified mean(s), deviation(s) and shape(s).  <br /></td></tr>
<tr class="separator:ga09e843ba6d42af1a8ce55a11fd850972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf6809b2ab19bb25be5d2d3996f12b41f.html#gaf6809b2ab19bb25be5d2d3996f12b41f">stan::math::std_normal_cdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard normal cumulative distribution function.  <br /></td></tr>
<tr class="separator:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeff7263315d228431625d22ff671de7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabeff7263315d228431625d22ff671de7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabeff7263315d228431625d22ff671de7.html#gabeff7263315d228431625d22ff671de7">stan::math::std_normal_lccdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:gabeff7263315d228431625d22ff671de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log standard normal complementary cumulative distribution function.  <br /></td></tr>
<tr class="separator:gabeff7263315d228431625d22ff671de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85cd9947c3408ca4344662b885b17bed"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85cd9947c3408ca4344662b885b17bed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85cd9947c3408ca4344662b885b17bed.html#ga85cd9947c3408ca4344662b885b17bed">stan::math::std_normal_lcdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:ga85cd9947c3408ca4344662b885b17bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log standard normal complementary cumulative distribution function.  <br /></td></tr>
<tr class="separator:ga85cd9947c3408ca4344662b885b17bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga99fe4b661e6f91ecd647d1a2fc4b91fc.html#ga99fe4b661e6f91ecd647d1a2fc4b91fc">stan::math::std_normal_lpdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given a location of 0 and a scale of 1.  <br /></td></tr>
<tr class="separator:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52baf62a7ad07470a7e5879144aab8fd"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga52baf62a7ad07470a7e5879144aab8fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga52baf62a7ad07470a7e5879144aab8fd.html#ga52baf62a7ad07470a7e5879144aab8fd">stan::math::student_t_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga52baf62a7ad07470a7e5879144aab8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Student-t density for the given y, nu, mean, and scale parameter.  <br /></td></tr>
<tr class="separator:ga52baf62a7ad07470a7e5879144aab8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaccde2dd41ea6e10cce3f5fd53dbfa0ea.html#gaccde2dd41ea6e10cce3f5fd53dbfa0ea">stan::math::to_array_1d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix reshaped into a vector.  <br /></td></tr>
<tr class="separator:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae58346dcff1afcdf893e0c0e2ab7fbe3.html#gae58346dcff1afcdf893e0c0e2ab7fbe3">stan::math::to_array_2d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix converted into a nested std vector.  <br /></td></tr>
<tr class="separator:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0aabc784b5f56edb079f21a48efdad54.html#ga0aabc784b5f56edb079f21a48efdad54">stan::math::to_matrix</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ga0aabc784b5f56edb079f21a48efdad54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix.  <br /></td></tr>
<tr class="separator:ga0aabc784b5f56edb079f21a48efdad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga08a3715205cf6c1564a87de73c13c22a.html#ga08a3715205cf6c1564a87de73c13c22a">stan::math::to_row_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ga08a3715205cf6c1564a87de73c13c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix reshaped into a row vector.  <br /></td></tr>
<tr class="separator:ga08a3715205cf6c1564a87de73c13c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0026608053df548f73f9556ffa94dc03.html#ga0026608053df548f73f9556ffa94dc03">stan::math::to_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ga0026608053df548f73f9556ffa94dc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix reshaped into a vector.  <br /></td></tr>
<tr class="separator:ga0026608053df548f73f9556ffa94dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57df18629a507dddf44e3c2c5fdddce"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa57df18629a507dddf44e3c2c5fdddce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa57df18629a507dddf44e3c2c5fdddce.html#gaa57df18629a507dddf44e3c2c5fdddce">stan::math::uniform_cdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gaa57df18629a507dddf44e3c2c5fdddce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uniform cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaa57df18629a507dddf44e3c2c5fdddce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a645c422b583574a641e7aacafdac70"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0a645c422b583574a641e7aacafdac70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0a645c422b583574a641e7aacafdac70.html#ga0a645c422b583574a641e7aacafdac70">stan::math::uniform_lccdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga0a645c422b583574a641e7aacafdac70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log uniform complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga0a645c422b583574a641e7aacafdac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga62cdd868dd6647ab0ca6ea0cce3c76bc.html#ga62cdd868dd6647ab0ca6ea0cce3c76bc">stan::math::uniform_lcdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log uniform cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04339e808a990b203d278764668bf813"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga04339e808a990b203d278764668bf813"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga04339e808a990b203d278764668bf813.html#ga04339e808a990b203d278764668bf813">stan::math::uniform_lpdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga04339e808a990b203d278764668bf813"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a uniform density for the given y, lower, and upper bound.  <br /></td></tr>
<tr class="separator:ga04339e808a990b203d278764668bf813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe7af31180b175d4781aff1ea3d834c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1fe7af31180b175d4781aff1ea3d834c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1fe7af31180b175d4781aff1ea3d834c.html#ga1fe7af31180b175d4781aff1ea3d834c">stan::math::weibull_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga1fe7af31180b175d4781aff1ea3d834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weibull cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga1fe7af31180b175d4781aff1ea3d834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac04a465e4b5185102599824a1fe96ea"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaac04a465e4b5185102599824a1fe96ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaac04a465e4b5185102599824a1fe96ea.html#gaac04a465e4b5185102599824a1fe96ea">stan::math::weibull_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaac04a465e4b5185102599824a1fe96ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weibull log cumulative complementary distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaac04a465e4b5185102599824a1fe96ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac1477c0a3bc8847863337e0acb2b9cb8.html#gac1477c0a3bc8847863337e0acb2b9cb8">stan::math::weibull_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weibull log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad8f8507ee479b6cce5492bc736a6fcc4.html#gad8f8507ee479b6cce5492bc736a6fcc4">stan::math::weibull_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Weibull log probability density for the given location and scale.  <br /></td></tr>
<tr class="separator:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0789d6a3951103d547f105a799180f7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0789d6a3951103d547f105a799180f7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0789d6a3951103d547f105a799180f7d.html#ga0789d6a3951103d547f105a799180f7d">stan::math::to_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga0789d6a3951103d547f105a799180f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var containing <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices to destination var that has data stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga0789d6a3951103d547f105a799180f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b584aee1b254d84f7277c0091cd774"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga90b584aee1b254d84f7277c0091cd774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga90b584aee1b254d84f7277c0091cd774.html#ga90b584aee1b254d84f7277c0091cd774">stan::math::to_matrix_cl</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:ga90b584aee1b254d84f7277c0091cd774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source std::vector of vars to a destination var that has data stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga90b584aee1b254d84f7277c0091cd774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b768c5f90ad1a392ba7311103095fc2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6b768c5f90ad1a392ba7311103095fc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6b768c5f90ad1a392ba7311103095fc2.html#ga6b768c5f90ad1a392ba7311103095fc2">stan::math::to_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga6b768c5f90ad1a392ba7311103095fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix of vars to the destination matrix that is stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga6b768c5f90ad1a392ba7311103095fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga244b9eabd30b04007c6acaa9a0a76ef9.html#ga244b9eabd30b04007c6acaa9a0a76ef9">stan::math::to_matrix_cl</a> (const std::vector&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source vector of <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices of vars to the destination matrix that is stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, T_dst &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaedf3e76a11e9efeae4a1215bfb67c8be.html#gaedf3e76a11e9efeae4a1215bfb67c8be">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var that has data stored on the OpenCL device to destination var containing <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T_dst &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_dst &gt; &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga016b4e7e4fd48ee3333c5c37507e3d01.html#ga016b4e7e4fd48ee3333c5c37507e3d01">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var that has data stored on the OpenCL device to destination <code>std::vector</code> containing vars.  <br /></td></tr>
<tr class="separator:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaeefdbbf87e96786f8460982c80c5c06f.html#gaeefdbbf87e96786f8460982c80c5c06f">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:gaeefdbbf87e96786f8460982c80c5c06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var that has data stored on the OpenCL device to destination <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix containing vars.  <br /></td></tr>
<tr class="separator:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b39037e357255bda858f7ad0e3c3d4"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, T_ret &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga52b39037e357255bda858f7ad0e3c3d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga52b39037e357255bda858f7ad0e3c3d4.html#ga52b39037e357255bda858f7ad0e3c3d4">stan::math::rep_matrix</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;A, int n, int m)</td></tr>
<tr class="memdesc:ga52b39037e357255bda858f7ad0e3c3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the given value of arithmetic type.  <br /></td></tr>
<tr class="separator:ga52b39037e357255bda858f7ad0e3c3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga77d0f9106510dd46a4d9ce8b1e888795.html#ga77d0f9106510dd46a4d9ce8b1e888795">stan::math::rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A, int m)</td></tr>
<tr class="memdesc:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the input vector or row_vector.  <br /></td></tr>
<tr class="separator:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> matrix_view = matrix_cl_view::Entire, typename T , <a class="el" href="group__matrix__cl__types_gace64828b1d0e81550a510d7ce11155e4.html#gace64828b1d0e81550a510d7ce11155e4">require_matrix_cl_st</a>&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0600f9f85f3b1c2424cd2e6d9a52b450.html#ga0600f9f85f3b1c2424cd2e6d9a52b450">stan::math::tri_inverse</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a triangular matrix.  <br /></td></tr>
<tr class="separator:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
