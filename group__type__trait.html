<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Type Traits</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__type__trait.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Type Traits</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The type traits in Stan math are a mix of custom traits for detecting value and container types of <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices, standard vectors, standard complex numbers, and backports of C++17 traits. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00205e3dfc4aa428638a4e542fee8c2c7d.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, fvar&lt; Dx &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00205e3dfc4aa428638a4e542fee8c2c7d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value and sets it to true if the type of the elements in the provided matrix_cl is constant, false otherwise.  <a href="structstan_1_1is__constant_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1internal_1_1ops__partials__edge.html">stan::math::internal::ops_partials_edge&lt; ViewElt, Op, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge holds both the operands and its associated partial derivatives.  <a href="classstan_1_1math_1_1internal_1_1ops__partials__edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, T_return_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1operands__and__partials.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1internal_1_1partials__propagator_3_01_return_type_00_01require__arithmetic_546dd1abdc60ef359e088ffb98cbe7df.html">stan::math::internal::partials_propagator&lt; ReturnType, require_arithmetic_t&lt; ReturnType &gt;, Ops... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1internal_1_1partials__propagator_3_01_return_type_00_01require__arithmetic_546dd1abdc60ef359e088ffb98cbe7df.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ad__promotable.html">stan::math::ad_promotable&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type From can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true.  <a href="structstan_1_1math_1_1ad__promotable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type.html">stan::math::append_return_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4.html">stan::math::append_return_type&lt; int, int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f.html">stan::math::append_return_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html">stan::math::append_return_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type.html">stan::base_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base base type of a template argument.  <a href="structstan_1_1base__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html">stan::base_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstan_1_1base__type.html" title="Metaprogram structure to determine the base base type of a template argument.">base_type</a> for vector to recursively return the inner base type.  <a href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4.html">stan::base_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base base type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <a href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1conjunction.html">stan::math::conjunction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with zero or more template parameters, all of which extend the std::true_type.  <a href="structstan_1_1math_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1disjunction.html">stan::math::disjunction&lt; Conds &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::false_type when instantiated with zero or more template parameters, all of which extend the std::false_type.  <a href="structstan_1_1math_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1include__summand.html">stan::math::include_summand&lt; propto, T, T_pack &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate whether a summand needs to be included in a proportional (log) probability calculation.  <a href="structstan_1_1math_1_1include__summand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html">stan::math::include_summand&lt; propto, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if a term with the specified propto value and subterm types should be included in a proportionality calculation.  <a href="structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type.html">stan::math::index_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for the metaprogram to compute the index type of a container.  <a href="structstan_1_1math_1_1index__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html">stan::math::index_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstan_1_1math_1_1index__type.html" title="Primary template class for the metaprogram to compute the index type of a container.">index_type</a> for pointers.  <a href="structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">stan::math::index_type&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of index for a standard vector.  <a href="structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">stan::math::index_type&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining typedef for the type of index for an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__arena__matrix.html">stan::is_arena_matrix&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is <code>arena_matrix&lt;T&gt;</code>  <a href="structstan_1_1is__arena__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__autodiff.html">stan::is_autodiff&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var or fvar.  <a href="structstan_1_1is__autodiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__base__pointer__convertible.html">stan::is_base_pointer_convertible&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type's pointer is convertible to a templated base type's pointer.  <a href="structstan_1_1is__base__pointer__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__complex__impl.html">stan::internal::is_complex_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member constant <code>value</code> which is equal to <code>true</code> if <code>T</code> is an instance of <code>std::complex</code> and <code>false</code> otherwise.  <a href="structstan_1_1internal_1_1is__complex__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex.html">stan::is_complex&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is a complex type (that is, an instance of <code>std::complex</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html">stan::scalar_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the scalar type for values stored in a complex number.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html">stan::base_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base type for values stored in a complex number.  <a href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex__arithmetic.html">stan::is_complex_arithmetic&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is a complex type with an inner arithmetic type (that is, an instance of <code>std::complex&lt;Arithmetic&gt;</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__complex__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex__ad.html">stan::is_complex_ad&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is a complex type with an inner autodiff type (that is, an instance of <code>std::complex&lt;var&gt;</code> or <code>std::complex&lt;fvar&lt;T&gt;&gt;</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__complex__ad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vt__complex.html">stan::is_vt_complex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> of the type <code>T</code> is of type <code>std::complex</code> or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__vt__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vt__not__complex.html">stan::is_vt_not_complex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> of the type <code>T</code> is not of type <code>std::complex</code> or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__vt__not__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant.html">stan::is_constant&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming struct to detect whether a given type is constant in the mathematical sense (not the C++ <code>const</code> sense).  <a href="structstan_1_1is__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value and sets it to true if the type of the elements in the provided std::vector is constant, false otherwise.  <a href="structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a public enum named value and sets it to true if the type of the elements in the provided <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix is constant, false otherwise.  <a href="structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__double__or__int.html">stan::is_double_or_int&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a double or integer.  <a href="structstan_1_1is__double__or__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen.html">stan::is_eigen&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type derives from <code>EigenBase</code>  <a href="structstan_1_1is__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_04b21f7115cf968f92528472b60798cb7.html">stan::scalar_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base scalar type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_04b21f7115cf968f92528472b60798cb7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01d6460066794d0b0fe8aa7bc4db11e6ce.html">stan::value_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01d6460066794d0b0fe8aa7bc4db11e6ce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_0ccf9db19ce8a9663af531dce04a2ccd4.html">stan::scalar_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;!internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base scalar type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_0ccf9db19ce8a9663af531dce04a2ccd4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01f58c467b4f23839dbf43671c1d1794e4.html">stan::value_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;!internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01f58c467b4f23839dbf43671c1d1794e4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__array.html">stan::is_eigen_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::ArrayBase</code>  <a href="structstan_1_1is__eigen__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__contiguous__map.html">stan::is_eigen_contiguous_map&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Map</code> with contiguous stride.  <a href="structstan_1_1is__eigen__contiguous__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase.  <a href="structstan_1_1is__eigen__dense__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">stan::is_eigen_matrix_dynamic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::MatrixBase and has columns and rows not equal to 1.  <a href="structstan_1_1is__eigen__matrix__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__matrix__base.html">stan::is_eigen_matrix_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::MatrixBase.  <a href="structstan_1_1is__eigen__matrix__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__sparse__base.html">stan::is_eigen_sparse_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::SparseMatrixBase.  <a href="structstan_1_1is__eigen__sparse__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__fvar.html">stan::is_fvar&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member function type which is defined to be false as the primitive scalar types cannot be a <a class="el" href="structstan_1_1math_1_1fvar.html" title="This template class represents scalars used in forward-mode automatic differentiation,...">stan::math::fvar</a> type.  <a href="structstan_1_1is__fvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__matrix.html">stan::is_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::EigenBase</code> or is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__real.html">stan::is_real&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var, fvar, or arithmetic.  <a href="structstan_1_1is__real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__matrix.html">stan::is_rev_matrix&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__rev__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__col__vector.html">stan::is_rev_col_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__row__vector.html">stan::is_rev_row_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__vector.html">stan::is_rev_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__stan__scalar.html">stan::is_stan_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var, fvar, or arithmetic.  <a href="structstan_1_1is__stan__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var.html">stan::is_var&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be false as the primitive scalar types cannot be a <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> type.  <a href="structstan_1_1is__var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__dense__dynamic.html">stan::is_var_dense_dynamic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code> and has dynamic rows and columns.  <a href="structstan_1_1is__var__dense__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__eigen.html">stan::is_var_eigen&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__var__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__matrix.html">stan::is_var_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__col__vector.html">stan::is_var_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__var__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__row__vector.html">stan::is_var_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__var__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__vector.html">stan::is_var_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__var__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__any__var__matrix.html">stan::is_any_var_matrix&lt; Types &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any types in a parameter pack are a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__any__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__or__arithmetic__type.html">stan::is_var_or_arithmetic_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member value which is defined to be true (1) if the unqualified cv of type T or its underlying type (if a container) is either var or an arithmetic type, and false (0) otherwise.  <a href="structstan_1_1is__var__or__arithmetic__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vari.html">stan::is_vari&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier and pointer is a vari.  <a href="structstan_1_1is__vari.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__std__vector.html">stan::is_std_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base implementation for checking if type is std vector.  <a href="structstan_1_1is__std__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__eigen__col__vector__impl.html">stan::internal::is_eigen_col_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix is a column vector.  <a href="structstan_1_1internal_1_1is__eigen__col__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__eigen__col__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_col_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an eigen vector.  <a href="structstan_1_1internal_1_1is__eigen__col__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__eigen__row__vector__impl.html">stan::internal::is_eigen_row_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix is a row vector.  <a href="structstan_1_1internal_1_1is__eigen__row__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__eigen__row__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_row_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an eigen vector.  <a href="structstan_1_1internal_1_1is__eigen__row__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__col__vector__impl.html">stan::internal::is_col_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if a Matrix is a column vector.  <a href="structstan_1_1internal_1_1is__col__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__col__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_col_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not a vector.  <a href="structstan_1_1internal_1_1is__col__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__row__vector__impl.html">stan::internal::is_row_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if a Matrix is a row vector.  <a href="structstan_1_1internal_1_1is__row__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__row__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_row_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an vector.  <a href="structstan_1_1internal_1_1is__row__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__col__vector.html">stan::is_eigen_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 row at compile time this has a static member with a value of true.  <a href="structstan_1_1is__eigen__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__col__vector.html">stan::is_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T has a static comple time constant type <code>ColsAtCompileTime</code> equal to 1 this has a static member with a value of true.  <a href="structstan_1_1is__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__row__vector.html">stan::is_eigen_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column at compile time this has a static member with a value of true.  <a href="structstan_1_1is__eigen__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__row__vector.html">stan::is_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T has a static comple time constant type <code>RowsAtCompileTime</code> equal to 1 this has a static member with a value of true.  <a href="structstan_1_1is__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__vector.html">stan::is_eigen_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column or 1 row at compile time this has a static member with a value of true.  <a href="structstan_1_1is__eigen__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vector.html">stan::is_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is either an eigen matrix with 1 column or 1 row at compile time or a standard vector, this has a static member with a value of true.  <a href="structstan_1_1is__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__std__vector__impl.html">stan::internal::is_std_vector_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This underlying implementation is used when the type is not an std vector.  <a href="structstan_1_1internal_1_1is__std__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1internal_1_1is__std__vector__impl_3_01std_1_1vector_3_01_args_8_8_8_01_4_01_4.html">stan::internal::is_std_vector_impl&lt; std::vector&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization implementation has a static member named value when the template type is an std vector.  <a href="structstan_1_1internal_1_1is__std__vector__impl_3_01std_1_1vector_3_01_args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__std__vector_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__std__vector__28c6aea3001284899b87957f6f2ae7d6.html">stan::is_std_vector&lt; T, std::enable_if_t&lt; internal::is_std_vector_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the decayed type of T is a standard vector.  <a href="structstan_1_1is__std__vector_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__std__vector__28c6aea3001284899b87957f6f2ae7d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html">stan::scalar_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstan_1_1scalar__type.html" title="Metaprogram structure to determine the base scalar type of a template argument.">scalar_type</a> for vector to recursively return the inner scalar type.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html">stan::value_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of values stored in a standard vector.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vector__like.html">stan::is_vector_like&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram indicates whether a type is vector_like.  <a href="structstan_1_1is__vector__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__return__type.html">stan::partials_return_type&lt; T, T_pack &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the partial derivative type resulting from promoting all the scalar types of the template parameters.  <a href="structstan_1_1partials__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__type.html">stan::partials_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base implementation will contain a static member function named type equal to the type passed into it.  <a href="structstan_1_1partials__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1real__return.html">stan::real_return&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member type alias named <code>type</code>, the value of which is the least type under Stan's assignability relation that can be assigned a <code>double</code> and all of the base types of the specified arguments after removing qualifiers (<code>const</code> and <code>volatile</code>) and decaying (lvalue to rvalue by removing references) and array to pointer).  <a href="structstan_1_1real__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__lub.html">stan::scalar_lub&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a member type named <code>type</code> that is the least scalar type to which both template parameter scalar types are assignable in Stan.  <a href="structstan_1_1scalar__lub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1return__type.html">stan::return_type&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the base scalar return type resulting from promoting all the scalar types of the template parameters to the least type to which all the base types of the arguments are assignable.  <a href="structstan_1_1return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base scalar type of a template argument.  <a href="structstan_1_1scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_std_vector_builder.html">stan::StdVectorBuilder&lt; used, T1, T2, T3, T4, T5, T6, T7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1_std_vector_builder.html" title="StdVectorBuilder allocates type T1 values to be used as intermediate values.">StdVectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="classstan_1_1_std_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type.html">stan::value_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute the type of values stored in a container.  <a href="structstan_1_1value__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html">stan::value_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointers returns the underlying value the pointer is pointing to.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_vector_builder.html">stan::VectorBuilder&lt; used, T1, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values.">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="classstan_1_1_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_vector_builder_helper.html">stan::VectorBuilderHelper&lt; T1, used, is_vec &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values.">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="classstan_1_1_vector_builder_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html">stan::VectorBuilderHelper&lt; T1, true, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for using a vector.  <a href="classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4.html">stan::scalar_type&lt; T, std::enable_if_t&lt; is_var&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization defining the scalar type of values stored in var_value.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1internal_1_1ops__partials__edge_3_01double_00_01var_01_4.html">stan::math::internal::ops_partials_edge&lt; double, var &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_000785b81a4e0cd5b6ed5a4706b0c63f75.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_000785b81a4e0cd5b6ed5a4706b0c63f75.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1internal_1_1partials__propagator_3_01_return_type_00_01require__var__t_3_01ee8aa9fa123c0d998f47a26c55fd248e.html">stan::math::internal::partials_propagator&lt; ReturnType, require_var_t&lt; ReturnType &gt;, Ops... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1internal_1_1partials__propagator_3_01_return_type_00_01require__var__t_3_01ee8aa9fa123c0d998f47a26c55fd248e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__arena__matrix_3_01_t_00_01require__t_3_01internal_1_1is__arena__matrix__impl_382c328ab88094a24a9cfff97c4ae9a76.html">stan::is_arena_matrix&lt; T, require_t&lt; internal::is_arena_matrix_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is <code>arena_matrix&lt;T&gt;</code>  <a href="structstan_1_1is__arena__matrix_3_01_t_00_01require__t_3_01internal_1_1is__arena__matrix__impl_382c328ab88094a24a9cfff97c4ae9a76.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__matrix_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3_01_t1ddd3dfbec50668d893a6befdfb0b45a.html">stan::is_rev_matrix&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; math::conjunction&lt; is_var&lt; T &gt;, is_eigen&lt; value_type_t&lt; T &gt; &gt; &gt;, is_eigen&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__rev__matrix_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3_01_t1ddd3dfbec50668d893a6befdfb0b45a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__col__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_30dc403fb8542198c3091e4e6e1e54ba5.html">stan::is_rev_col_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_col_vector&lt; T &gt;, is_eigen_col_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__col__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_30dc403fb8542198c3091e4e6e1e54ba5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__row__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3f675c2ac2e6bea3e3104996f22b12a50.html">stan::is_rev_row_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_row_vector&lt; T &gt;, is_eigen_row_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__row__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3f675c2ac2e6bea3e3104996f22b12a50.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__vector_3_01_t_00_01require__any__t_3_01is__rev__col__vector_3_01_t_01_4_0ee983b7fdcdd0eeacbfc45ed12837bd6.html">stan::is_rev_vector&lt; T, require_any_t&lt; is_rev_col_vector&lt; T &gt;, is_rev_row_vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__vector_3_01_t_00_01require__any__t_3_01is__rev__col__vector_3_01_t_01_4_0ee983b7fdcdd0eeacbfc45ed12837bd6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__var__impl_3_01std_1_14fc46eebc2d7d167cda3892bd7b10182.html">stan::is_var&lt; T, std::enable_if_t&lt; internal::is_var_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier is a var_value.  <a href="structstan_1_1is__var_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__var__impl_3_01std_1_14fc46eebc2d7d167cda3892bd7b10182.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vari_3_01_t_00_01require__t_3_01internal_1_1is__vari__impl_3_01std_1_1decay__t_3_01_t_01_4_01_4_01_4_01_4.html">stan::is_vari&lt; T, require_t&lt; internal::is_vari_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier and pointer is a vari_value.  <a href="structstan_1_1is__vari_3_01_t_00_01require__t_3_01internal_1_1is__vari__impl_3_01std_1_1decay__t_3_01_t_01_4_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html">stan::partials_type&lt; T, require_var_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of partials type returns double if input type is a double.  <a href="structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">stan::bool_constant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gad1046e42476333dc3c08c35bfe420302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for structs used for wraps a static constant of bool.  <br /></td></tr>
<tr class="separator:gad1046e42476333dc3c08c35bfe420302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaaa1b1eb615a4b1b30b46ef33ace88cdf.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">stan::contains_std_vector</a> = <a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; Ts &gt;... &gt;</td></tr>
<tr class="memdesc:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any types are std vectors.  <br /></td></tr>
<tr class="separator:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga880b82cbb2b83ccaba2426e73996b8bd.html#ga880b82cbb2b83ccaba2426e73996b8bd">stan::is_constant_all</a> = <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__constant.html">is_constant</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram defining an enum <code>value</code> which is <code>true</code> if all of the type parameters are constant (i.e., primitive types) and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad118aaa390bacd754a1a06c9518739ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad118aaa390bacd754a1a06c9518739ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gad118aaa390bacd754a1a06c9518739ce.html#gad118aaa390bacd754a1a06c9518739ce">stan::is_dense_dynamic</a> = <a class="el" href="structstan_1_1internal_1_1is__dense__dynamic__impl.html">internal::is_dense_dynamic_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gad118aaa390bacd754a1a06c9518739ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns or is a <code>var_value&lt;&gt;</code> whose inner type satisfies the conditions above.  <br /></td></tr>
<tr class="separator:gad118aaa390bacd754a1a06c9518739ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga3e24dfe00dd09775b290fc2221b2739d.html#ga3e24dfe00dd09775b290fc2221b2739d">stan::is_eigen_matrix_or_array</a> = <a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga3e24dfe00dd09775b290fc2221b2739d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::MatrixBase</code> or <code>Eigen::ArrayBase</code>  <br /></td></tr>
<tr class="separator:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f64859b99515465810d1dbf2885a8e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9f64859b99515465810d1dbf2885a8e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">stan::is_eigen_dense_dynamic</a> = <a class="el" href="structstan_1_1internal_1_1is__eigen__matrix__dynamic__impl.html">stan::internal::is_eigen_matrix_dynamic_impl</a>&lt; std::decay_t&lt; T &gt;, <a class="el" href="structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base</a>&lt; std::decay_t&lt; T &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga9f64859b99515465810d1dbf2885a8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns.  <br /></td></tr>
<tr class="separator:ga9f64859b99515465810d1dbf2885a8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">stan::is_plain_type</a> = std::is_same&lt; std::decay_t&lt; S &gt;, <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; S &gt; &gt;</td></tr>
<tr class="memdesc:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the template type <code>T</code> is an assignable type.  <br /></td></tr>
<tr class="separator:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597c18eee233b7aa27f52a2068e5b881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga597c18eee233b7aa27f52a2068e5b881"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga597c18eee233b7aa27f52a2068e5b881.html#ga597c18eee233b7aa27f52a2068e5b881">stan::is_stan_scalar_or_eigen</a> = <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; T &gt; &gt;::value||<a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; T &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga597c18eee233b7aa27f52a2068e5b881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type if all the provided types are either a Stan Scalar type or a type inheriting from <code>EigenBase</code>.  <br /></td></tr>
<tr class="separator:ga597c18eee233b7aa27f52a2068e5b881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">stan::is_string_convertible</a> = std::is_convertible&lt; T, std::string &gt;</td></tr>
<tr class="memdesc:ga0f2252ae22390725feb09d9ea11b7896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces whether type is convertible to string.  <br /></td></tr>
<tr class="separator:ga0f2252ae22390725feb09d9ea11b7896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2d91e7563632c296825ea46b0482f52"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gab2d91e7563632c296825ea46b0482f52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gab2d91e7563632c296825ea46b0482f52.html#gab2d91e7563632c296825ea46b0482f52">stan::is_var_and_matrix_types</a> = <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Types... &gt; &gt;::value &amp;&amp;<a class="el" href="structstan_1_1math_1_1disjunction.html">stan::math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; Types &gt;... &gt;::value &gt;</td></tr>
<tr class="memdesc:gab2d91e7563632c296825ea46b0482f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with at least one type that has a var <code><a class="el" href="structstan_1_1scalar__type.html" title="Metaprogram structure to determine the base scalar type of a template argument.">scalar_type</a></code> and at least one type is a matrix.  <br /></td></tr>
<tr class="separator:gab2d91e7563632c296825ea46b0482f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">stan::is_var_or_arithmetic</a> = <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var__or__arithmetic__type.html">is_var_or_arithmetic_type</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type if all the provided types are either var or an arithmetic type, extends std::false_type otherwise.  <br /></td></tr>
<tr class="separator:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga1310fb459dbad72fa5594b6d1eaad959.html#ga1310fb459dbad72fa5594b6d1eaad959">stan::partials_type_t</a> = typename <a class="el" href="structstan_1_1partials__type.html">partials_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga1310fb459dbad72fa5594b6d1eaad959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for accessing the partial type.  <br /></td></tr>
<tr class="separator:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga546483131616701876a9f1307f5a413d.html#ga546483131616701876a9f1307f5a413d">stan::promote_args_t</a> = typename boost::math::tools::promote_args&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ga546483131616701876a9f1307f5a413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for boost tools promote_args.  <br /></td></tr>
<tr class="separator:ga546483131616701876a9f1307f5a413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a> = typename <a class="el" href="structstan_1_1real__return.html">real_return</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gac9d3fe14d5102916bf0b5b05712c833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the real return type.  <br /></td></tr>
<tr class="separator:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">stan::complex_return_t</a> = std::complex&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga876ae6b470c58e692b4a4273a32f7ea3.html#ga876ae6b470c58e692b4a4273a32f7ea3">stan::std_vector_return_t</a> = std::vector&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gab3412a1caaad7f8eef55a9ee2a0d3921.html#gab3412a1caaad7f8eef55a9ee2a0d3921">stan::matrix_return_t</a> = Eigen::Matrix&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, -1 &gt;</td></tr>
<tr class="memdesc:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga1b070b6ae219eccccf07b44243307b8b.html#ga1b070b6ae219eccccf07b44243307b8b">stan::vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, 1 &gt;</td></tr>
<tr class="memdesc:ga1b070b6ae219eccccf07b44243307b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:ga1b070b6ae219eccccf07b44243307b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga2fa4e21b37c08e6abce2919ac4c2cd57.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">stan::row_vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, 1, -1 &gt;</td></tr>
<tr class="memdesc:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gace9d2d5da99a3e14fcadd7bf0f6cffee.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">stan::scalar_lub_t</a> = typename <a class="el" href="structstan_1_1scalar__lub.html">scalar_lub</a>&lt; T1, T2 &gt;::type</td></tr>
<tr class="memdesc:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering.  <br /></td></tr>
<tr class="separator:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> = typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gacbaff683cd2683209e6855e2c7aaeffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> = typename <a class="el" href="structstan_1_1value__type.html">value_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga57121ded0440567e8dfb0d80b1290922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for accessing underlying type.  <br /></td></tr>
<tr class="separator:ga57121ded0440567e8dfb0d80b1290922"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0b6f4361a2548ec3532a6e35d88fbb54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00205e3dfc4aa428638a4e542fee8c2c7d_a474116398e93704a039b4ac962d3aa50.html#a474116398e93704a039b4ac962d3aa50">T_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga0b6f4361a2548ec3532a6e35d88fbb54.html#ga0b6f4361a2548ec3532a6e35d88fbb54">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, fvar&lt; Dx &gt; &gt;::build</a> (Dx value)</td></tr>
<tr class="memdesc:ga0b6f4361a2548ec3532a6e35d88fbb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <br /></td></tr>
<tr class="separator:ga0b6f4361a2548ec3532a6e35d88fbb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819722bbfdc30ef04e8923214ecc05e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1internal_1_1partials__propagator_3_01_return_type_00_01require__fvar__t_3_021ae0ba06b0fad46687a497e91e66f95_ab009bf737dcd743b13a508b5a1933141.html#ab009bf737dcd743b13a508b5a1933141">T_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga819722bbfdc30ef04e8923214ecc05e0.html#ga819722bbfdc30ef04e8923214ecc05e0">stan::math::internal::partials_propagator&lt; ReturnType, require_fvar_t&lt; ReturnType &gt;, Ops... &gt;::build</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1partials__propagator_3_01_return_type_00_01require__fvar__t_3_021ae0ba06b0fad46687a497e91e66f95_ab3e913746505d4555b12a10911aeae96.html#ab3e913746505d4555b12a10911aeae96">Dx</a> value)</td></tr>
<tr class="memdesc:ga819722bbfdc30ef04e8923214ecc05e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <br /></td></tr>
<tr class="separator:ga819722bbfdc30ef04e8923214ecc05e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gad2a93cdd718b76d4994d0f7c6c05fbba.html#gad2a93cdd718b76d4994d0f7c6c05fbba">stan::get</a> (const T &amp;x, size_t n)</td></tr>
<tr class="memdesc:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the provided element.  <br /></td></tr>
<tr class="separator:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga431bd201f09a215cccb16cda10a1e840.html#ga431bd201f09a215cccb16cda10a1e840">stan::get</a> (const std::vector&lt; T &gt; &amp;x, size_t n)</td></tr>
<tr class="memdesc:ga431bd201f09a215cccb16cda10a1e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the n-th element of the provided std::vector.  <br /></td></tr>
<tr class="separator:ga431bd201f09a215cccb16cda10a1e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaf82cac3bdccc9b64e7a55a8bd47880a7.html#gaf82cac3bdccc9b64e7a55a8bd47880a7">stan::math::size</a> (const T &amp;m)</td></tr>
<tr class="memdesc:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of the elements) of a <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> or <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;T&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; ScalarT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaa8aaf093d045fbc9a6bf4b9792cb874d.html#gaa8aaf093d045fbc9a6bf4b9792cb874d">stan::math::size_mvt</a> (const ScalarT &amp;)</td></tr>
<tr class="memdesc:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the size of a multivariate argument.  <br /></td></tr>
<tr class="separator:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga9b28065e82cdcee1c320a7120cb8a83d.html#ga9b28065e82cdcee1c320a7120cb8a83d">stan::math::internal::broadcast_array&lt; T &gt;::operator=</a> (const Y &amp;m)</td></tr>
<tr class="memdesc:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast array can be assigned a scalar or a vector.  <br /></td></tr>
<tr class="separator:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99e556c0f0f926c77121accae6e7113"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_gab99e556c0f0f926c77121accae6e7113.html#gab99e556c0f0f926c77121accae6e7113">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator[]</a> (int)</td></tr>
<tr class="memdesc:gab99e556c0f0f926c77121accae6e7113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:gab99e556c0f0f926c77121accae6e7113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga390dff20f30679c8e57ca2c3efe6d766.html#ga390dff20f30679c8e57ca2c3efe6d766">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator=</a> (const Y &amp;)</td></tr>
<tr class="memdesc:ga390dff20f30679c8e57ca2c3efe6d766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff5e53787585f2d6b2bec8c69107699"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga4ff5e53787585f2d6b2bec8c69107699.html#ga4ff5e53787585f2d6b2bec8c69107699">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator[]</a> (int)</td></tr>
<tr class="memdesc:ga4ff5e53787585f2d6b2bec8c69107699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga4ff5e53787585f2d6b2bec8c69107699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c734590d3f66b0d49d213e71e31062f"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga0c734590d3f66b0d49d213e71e31062f.html#ga0c734590d3f66b0d49d213e71e31062f">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator()</a> (int)</td></tr>
<tr class="memdesc:ga0c734590d3f66b0d49d213e71e31062f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga0c734590d3f66b0d49d213e71e31062f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501ec44e68851a8396f5f693e35a2e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga501ec44e68851a8396f5f693e35a2e69.html#ga501ec44e68851a8396f5f693e35a2e69">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator=</a> (const <a class="el" href="classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4_ae60f68cce56bd8855479f31c9d37ca50.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a> &amp;)</td></tr>
<tr class="memdesc:ga501ec44e68851a8396f5f693e35a2e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga501ec44e68851a8396f5f693e35a2e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d157dabee552a681aa5e4406b86474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga84d157dabee552a681aa5e4406b86474.html#ga84d157dabee552a681aa5e4406b86474">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator+=</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4_ae60f68cce56bd8855479f31c9d37ca50.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>)</td></tr>
<tr class="memdesc:ga84d157dabee552a681aa5e4406b86474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga84d157dabee552a681aa5e4406b86474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50070330d69c12c87811fcaf4e643803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga50070330d69c12c87811fcaf4e643803.html#ga50070330d69c12c87811fcaf4e643803">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator-=</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1empty__broadcast__array_3_01_view_elt_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4_ae60f68cce56bd8855479f31c9d37ca50.html#ae60f68cce56bd8855479f31c9d37ca50">T_arg</a>)</td></tr>
<tr class="memdesc:ga50070330d69c12c87811fcaf4e643803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga50070330d69c12c87811fcaf4e643803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8f4b2ef1638b6bad6dd14ded52beaa"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga6c8f4b2ef1638b6bad6dd14ded52beaa.html#ga6c8f4b2ef1638b6bad6dd14ded52beaa">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::row</a> (int)</td></tr>
<tr class="memdesc:ga6c8f4b2ef1638b6bad6dd14ded52beaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga6c8f4b2ef1638b6bad6dd14ded52beaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c0898b50ea04635aebe06a24482403"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga16c0898b50ea04635aebe06a24482403.html#ga16c0898b50ea04635aebe06a24482403">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::col</a> (int)</td></tr>
<tr class="memdesc:ga16c0898b50ea04635aebe06a24482403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <br /></td></tr>
<tr class="separator:ga16c0898b50ea04635aebe06a24482403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073d91b307fd7de39592be3fa418d92a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_ga073d91b307fd7de39592be3fa418d92a.html#ga073d91b307fd7de39592be3fa418d92a">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, T_return_type &gt;::build</a> (double value) const noexcept</td></tr>
<tr class="memdesc:ga073d91b307fd7de39592be3fa418d92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <br /></td></tr>
<tr class="separator:ga073d91b307fd7de39592be3fa418d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fec705e050ccb34f7507e6d4f080d1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_gaa8fec705e050ccb34f7507e6d4f080d1.html#gaa8fec705e050ccb34f7507e6d4f080d1">stan::math::internal::partials_propagator&lt; ReturnType, require_arithmetic_t&lt; ReturnType &gt;, Ops... &gt;::build</a> (double value) noexcept</td></tr>
<tr class="memdesc:gaa8fec705e050ccb34f7507e6d4f080d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <br /></td></tr>
<tr class="separator:gaa8fec705e050ccb34f7507e6d4f080d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T_actual&gt;,                                          std::decay_t&lt;T_desired&gt;&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gabc28f5f2b014cdb24e4e2ad58a6294c4.html#gabc28f5f2b014cdb24e4e2ad58a6294c4">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <br /></td></tr>
<tr class="separator:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              !std::is_same&lt;std::decay&lt;T_actual&gt;, std::decay&lt;T_desired&gt;&gt;::value              &amp;&amp; (!is_eigen&lt;T_desired&gt;::value || !is_eigen&lt;T_actual&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga6cc77bba018fff06dd1f0f0f2d79e5b9.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">stan::math::forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="memdesc:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <br /></td></tr>
<tr class="separator:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08de2733477ccf3033ae2449d357e7bd"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T_desired &gt; *  = nullptr, std::enable_if_t&lt; std::is_same&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_actual &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_desired &gt; &gt;::value &amp;&amp;<a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; T_desired &gt;::value &amp;&amp;<a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; T_actual &gt;::value &amp;&amp;<a class="el" href="namespacestan_1_1math_1_1internal_a96d04a3ec2c9b0e26f1722efbd48776e.html#a96d04a3ec2c9b0e26f1722efbd48776e">internal::eigen_static_size_match</a>(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime) &amp;&amp;<a class="el" href="namespacestan_1_1math_1_1internal_a96d04a3ec2c9b0e26f1722efbd48776e.html#a96d04a3ec2c9b0e26f1722efbd48776e">internal::eigen_static_size_match</a>(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga08de2733477ccf3033ae2449d357e7bd"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga08de2733477ccf3033ae2449d357e7bd.html#ga08de2733477ccf3033ae2449d357e7bd">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:ga08de2733477ccf3033ae2449d357e7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <br /></td></tr>
<tr class="separator:ga08de2733477ccf3033ae2449d357e7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5ad66b8f73c928573ba12de5c3e32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_gaac5ad66b8f73c928573ba12de5c3e32d.html#gaac5ad66b8f73c928573ba12de5c3e32d">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, var &gt;::build</a> (double value)</td></tr>
<tr class="memdesc:gaac5ad66b8f73c928573ba12de5c3e32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <br /></td></tr>
<tr class="separator:gaac5ad66b8f73c928573ba12de5c3e32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b23126025e63f4c38b8e36c52ef095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type__trait_gab9b23126025e63f4c38b8e36c52ef095.html#gab9b23126025e63f4c38b8e36c52ef095">stan::math::internal::partials_propagator&lt; ReturnType, require_var_t&lt; ReturnType &gt;, Ops... &gt;::build</a> (double value)</td></tr>
<tr class="memdesc:gab9b23126025e63f4c38b8e36c52ef095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <br /></td></tr>
<tr class="separator:gab9b23126025e63f4c38b8e36c52ef095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
