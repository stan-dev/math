<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Boost.Unordered</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Boost.Unordered</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#intro">Introduction</a></li>
<li><a href="#buckets">The Data Structure</a>
<ul class="sectlevel2">
<li><a href="#buckets_controlling_the_number_of_buckets">Controlling the number of buckets</a></li>
<li><a href="#buckets_iterator_invalidation">Iterator Invalidation</a></li>
</ul>
</li>
<li><a href="#hash_equality">Equality Predicates and Hash Functions</a>
<ul class="sectlevel2">
<li><a href="#hash_equality_custom_types">Custom Types</a></li>
</ul>
</li>
<li><a href="#comparison">Comparison with Associative Containers</a></li>
<li><a href="#compliance">Standard Compliance</a>
<ul class="sectlevel2">
<li><a href="#compliance_move_emulation">Move emulation</a></li>
<li><a href="#compliance_use_of_allocators">Use of allocators</a></li>
<li><a href="#compliance_constructiondestruction_using_allocators">Construction/Destruction using allocators</a></li>
<li><a href="#compliance_pointer_traits">Pointer Traits</a></li>
<li><a href="#compliance_pairs">Pairs</a></li>
<li><a href="#compliance_miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li><a href="#rationale">Implementation Rationale</a>
<ul class="sectlevel2">
<li><a href="#rationale_data_structure">Data Structure</a></li>
<li><a href="#rationale_number_of_buckets">Number of Buckets</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#unordered_map">Class template unordered_map</a>
<ul class="sectlevel3">
<li><a href="#unordered_map_synopsis">Synopsis</a></li>
<li><a href="#unordered_map_description">Description</a></li>
<li><a href="#unordered_map_typedefs">Typedefs</a></li>
<li><a href="#unordered_map_constructors">Constructors</a></li>
<li><a href="#unordered_map_destructor">Destructor</a></li>
<li><a href="#unordered_map_assignment">Assignment</a></li>
<li><a href="#unordered_map_iterators">Iterators</a></li>
<li><a href="#unordered_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_map_modifiers">Modifiers</a></li>
<li><a href="#unordered_map_observers">Observers</a></li>
<li><a href="#unordered_map_lookup">Lookup</a></li>
<li><a href="#unordered_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_map_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_map_swap_2">Swap</a></li>
<li><a href="#unordered_map_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_multimap">Class template unordered_multimap</a>
<ul class="sectlevel3">
<li><a href="#unordered_multimap_synopsis">Synopsis</a></li>
<li><a href="#unordered_multimap_description">Description</a></li>
<li><a href="#unordered_multimap_typedefs">Typedefs</a></li>
<li><a href="#unordered_multimap_constructors">Constructors</a></li>
<li><a href="#unordered_multimap_destructor">Destructor</a></li>
<li><a href="#unordered_multimap_assignment">Assignment</a></li>
<li><a href="#unordered_multimap_iterators">Iterators</a></li>
<li><a href="#unordered_multimap_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_multimap_modifiers">Modifiers</a></li>
<li><a href="#unordered_multimap_observers">Observers</a></li>
<li><a href="#unordered_multimap_lookup">Lookup</a></li>
<li><a href="#unordered_multimap_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_multimap_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_multimap_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_multimap_swap_2">Swap</a></li>
<li><a href="#unordered_multimap_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_set">Class template unordered_set</a>
<ul class="sectlevel3">
<li><a href="#unordered_set_synopsis">Synopsis</a></li>
<li><a href="#unordered_set_description">Description</a></li>
<li><a href="#unordered_set_typedefs">Typedefs</a></li>
<li><a href="#unordered_set_constructors">Constructors</a></li>
<li><a href="#unordered_set_destructor">Destructor</a></li>
<li><a href="#unordered_set_assignment">Assignment</a></li>
<li><a href="#unordered_set_iterators">Iterators</a></li>
<li><a href="#unordered_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_set_modifiers">Modifiers</a></li>
<li><a href="#unordered_set_observers">Observers</a></li>
<li><a href="#unordered_set_lookup">Lookup</a></li>
<li><a href="#unordered_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_set_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_set_swap_2">Swap</a></li>
<li><a href="#unordered_set_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_multiset">Class template unordered_multiset</a>
<ul class="sectlevel3">
<li><a href="#unordered_multiset_synopsis">Synopsis</a></li>
<li><a href="#unordered_multiset_description">Description</a></li>
<li><a href="#unordered_multiset_typedefs">Typedefs</a></li>
<li><a href="#unordered_multiset_constructors">Constructors</a></li>
<li><a href="#unordered_multiset_destructor">Destructor</a></li>
<li><a href="#unordered_multiset_assignment">Assignment</a></li>
<li><a href="#unordered_multiset_iterators">Iterators</a></li>
<li><a href="#unordered_multiset_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_multiset_modifiers">Modifiers</a></li>
<li><a href="#unordered_multiset_observers">Observers</a></li>
<li><a href="#unordered_multiset_lookup">Lookup</a></li>
<li><a href="#unordered_multiset_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_multiset_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_multiset_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_multiset_swap_2">Swap</a></li>
<li><a href="#unordered_multiset_erase_if">erase_if</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#changes">Change Log</a>
<ul class="sectlevel2">
<li><a href="#changes_release_1_79_0">Release 1.79.0</a></li>
<li><a href="#changes_release_1_67_0">Release 1.67.0</a></li>
<li><a href="#changes_release_1_66_0">Release 1.66.0</a></li>
<li><a href="#changes_release_1_65_0">Release 1.65.0</a></li>
<li><a href="#changes_release_1_64_0">Release 1.64.0</a></li>
<li><a href="#changes_release_1_63_0">Release 1.63.0</a></li>
<li><a href="#changes_release_1_62_0">Release 1.62.0</a></li>
<li><a href="#changes_release_1_58_0">Release 1.58.0</a></li>
<li><a href="#changes_release_1_57_0">Release 1.57.0</a></li>
<li><a href="#changes_release_1_56_0">Release 1.56.0</a></li>
<li><a href="#changes_release_1_55_0">Release 1.55.0</a></li>
<li><a href="#changes_release_1_54_0">Release 1.54.0</a></li>
<li><a href="#changes_release_1_53_0">Release 1.53.0</a></li>
<li><a href="#changes_release_1_52_0">Release 1.52.0</a></li>
<li><a href="#changes_release_1_51_0">Release 1.51.0</a></li>
<li><a href="#changes_release_1_50_0">Release 1.50.0</a></li>
<li><a href="#changes_release_1_49_0">Release 1.49.0</a></li>
<li><a href="#changes_release_1_48_0_major_update">Release 1.48.0 - Major update</a></li>
<li><a href="#changes_release_1_45_0">Release 1.45.0</a></li>
<li><a href="#changes_release_1_43_0">Release 1.43.0</a></li>
<li><a href="#changes_release_1_42_0">Release 1.42.0</a></li>
<li><a href="#changes_release_1_41_0_major_update">Release 1.41.0 - Major update</a></li>
<li><a href="#changes_release_1_40_0">Release 1.40.0</a></li>
<li><a href="#changes_release_1_39_0">Release 1.39.0</a></li>
<li><a href="#changes_release_1_38_0">Release 1.38.0</a></li>
<li><a href="#changes_release_1_37_0">Release 1.37.0</a></li>
<li><a href="#changes_release_1_36_0">Release 1.36.0</a></li>
<li><a href="#changes_boost_1_35_0_add_on_31st_march_2008">Boost 1.35.0 Add-on - 31st March 2008</a></li>
<li><a href="#changes_review_version">Review Version</a></li>
</ul>
</li>
<li><a href="#bibliography">Bibliography</a></li>
<li><a href="#copyright">Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="intro"><a class="link" href="#intro">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>For accessing data based on key lookup, the C++ standard library offers <code>std::set</code>,
<code>std::map</code>, <code>std::multiset</code> and <code>std::multimap</code>. These are generally
implemented using balanced binary trees so that lookup time has
logarithmic complexity. That is generally okay, but in many cases a
<a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">hash table</a> can perform better, as accessing data has constant complexity,
on average. The worst case complexity is linear, but that occurs rarely and
with some care, can be avoided.</p>
</div>
<div class="paragraph">
<p>Also, the existing containers require a 'less than' comparison object
to order their elements. For some data types this is impossible to implement
or isn&#8217;t practical. In contrast, a hash table only needs an equality function
and a hash function for the key.</p>
</div>
<div class="paragraph">
<p>With this in mind, unordered associative containers were added to the C++
standard. This is an implementation of the containers described in C++11,
with some <a href="#compliance">deviations from the standard</a> in
order to work with non-C++11 compilers and libraries.</p>
</div>
<div class="paragraph">
<p><code>unordered_set</code> and <code>unordered_multiset</code> are defined in the header
<code>&lt;boost/unordered_set.hpp&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_set</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_multiset</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unordered_map</code> and <code>unordered_multimap</code> are defined in the header
<code>&lt;boost/unordered_map.hpp&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_map</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_multimap</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When using Boost.TR1, these classes are included from <code>&lt;unordered_set&gt;</code> and
<code>&lt;unordered_map&gt;</code>, with the classes added to the <code>std::tr1</code> namespace.</p>
</div>
<div class="paragraph">
<p>The containers are used in a similar manner to the normal associative
containers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
<span class="n">map</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"one"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"two"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"three"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"missing"</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But since the elements aren&#8217;t ordered, the output of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">BOOST_FOREACH</span><span class="p">(</span><span class="n">map</span><span class="o">::</span><span class="n">value_type</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">","</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>can be in any order. For example, it might be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">two</span><span class="p">,</span><span class="mi">2</span>
<span class="n">one</span><span class="p">,</span><span class="mi">1</span>
<span class="n">three</span><span class="p">,</span><span class="mi">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To store an object in an unordered associative container requires both a
key equality function and a hash function. The default function objects in
the standard containers support a few basic types including integer types,
floating point types, pointer types, and the standard strings. Since
Boost.Unordered uses <a href="../../../container_hash/index.html" target="_blank" rel="noopener">boost::hash</a> it also supports some other types,
including standard containers. To use any types not supported by these methods
you have to extend Boost.Hash to support the type or use
your own custom equality predicates and hash functions. See the
<a href="#hash_equality">Equality Predicates and Hash Functions</a> section
for more details.</p>
</div>
<div class="paragraph">
<p>There are other differences, which are listed in the
<a href="#comparison">Comparison with Associative Containers</a> section.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buckets"><a class="link" href="#buckets">The Data Structure</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The containers are made up of a number of 'buckets', each of which can contain
any number of elements. For example, the following diagram shows an <a href="#unordered_set">unordered_set</a> with 7 buckets containing 5 elements, <code>A</code>,
<code>B</code>, <code>C</code>, <code>D</code> and <code>E</code> (this is just for illustration, containers will typically
have more buckets).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../diagrams/buckets.png" alt="buckets">
</div>
</div>
<div class="paragraph">
<p>In order to decide which bucket to place an element in, the container applies
the hash function, <code>Hash</code>, to the element&#8217;s key (for <code>unordered_set</code> and
<code>unordered_multiset</code> the key is the whole element, but is referred to as the key
so that the same terminology can be used for sets and maps). This returns a
value of type <code>std::size_t</code>. <code>std::size_t</code> has a much greater range of values
then the number of buckets, so the container applies another transformation to
that value to choose a bucket to place the element in.</p>
</div>
<div class="paragraph">
<p>Retrieving the elements for a given key is simple. The same process is applied
to the key to find the correct bucket. Then the key is compared with the
elements in the bucket to find any elements that match (using the equality
predicate <code>Pred</code>). If the hash function has worked well the elements will be
evenly distributed amongst the buckets so only a small number of elements will
need to be examined.</p>
</div>
<div class="paragraph">
<p>There is <a href="#hash_equality">more information on hash functions and
equality predicates in the next section</a>.</p>
</div>
<div class="paragraph">
<p>You can see in the diagram that <code>A</code> &amp; <code>D</code> have been placed in the same bucket.
When looking for elements in this bucket up to 2 comparisons are made, making
the search slower. This is known as a collision. To keep things fast we try to
keep collisions to a minimum.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 1. Methods for Accessing Buckets</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-middle">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type max_bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">An upper bound on the number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_size(size_type n) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of elements in bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket(key_type const&amp; k) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the index of the bucket which would contain <code>k</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator begin(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle" rowspan="6"><p class="tableblock">Return begin and end iterators for bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator end(size_type n)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator begin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator end(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cbegin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cend(size_type n) const</code></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="buckets_controlling_the_number_of_buckets"><a class="link" href="#buckets_controlling_the_number_of_buckets">Controlling the number of buckets</a></h3>
<div class="paragraph">
<p>As more elements are added to an unordered associative container, the number
of elements in the buckets will increase causing performance to degrade.
To combat this the containers increase the bucket count as elements are inserted.
You can also tell the container to change the bucket count (if required) by
calling <code>rehash</code>.</p>
</div>
<div class="paragraph">
<p>The standard leaves a lot of freedom to the implementer to decide how the
number of buckets is chosen, but it does make some requirements based on the
container&#8217;s 'load factor', the average number of elements per bucket.
Containers also have a 'maximum load factor' which they should try to keep the
load factor below.</p>
</div>
<div class="paragraph">
<p>You can&#8217;t control the bucket count directly but there are two ways to
influence it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify the minimum number of buckets when constructing a container or when calling <code>rehash</code>.</p>
</li>
<li>
<p>Suggest a maximum load factor by calling <code>max_load_factor</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>max_load_factor</code> doesn&#8217;t let you set the maximum load factor yourself, it just
lets you give a <em>hint</em>. And even then, the standard doesn&#8217;t actually
require the container to pay much attention to this value. The only time the
load factor is <em>required</em> to be less than the maximum is following a call to
<code>rehash</code>. But most implementations will try to keep the number of elements
below the max load factor, and set the maximum load factor to be the same as
or close to the hint - unless your hint is unreasonably small or large.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 2. Methods for Controlling Bucket Size</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-middle">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(InputIterator i, InputIterator j, size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets and insert elements from the range <code>[i, j)</code> (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The average number of elements per bucket.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the current maximum load factor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor(float z)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rehash(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="buckets_iterator_invalidation"><a class="link" href="#buckets_iterator_invalidation">Iterator Invalidation</a></h3>
<div class="paragraph">
<p>It is not specified how member functions other than <code>rehash</code> and <code>reserve</code> affect
the bucket count, although <code>insert</code> is only allowed to invalidate iterators
when the insertion causes the load factor to be greater than or equal to the
maximum load factor. For most implementations this means that <code>insert</code> will only
change the number of buckets when this happens. While iterators can be
invalidated by calls to <code>insert</code>, <code>rehash</code> and <code>reserve</code>, pointers and references to the
container&#8217;s elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>In a similar manner to using <code>reserve</code> for <code>vector</code>s, it can be a good idea
to call <code>reserve</code> before inserting a large number of elements. This will get
the expensive rehashing out of the way and let you store iterators, safe in
the knowledge that they won&#8217;t be invalidated. If you are inserting <code>n</code>
elements into container <code>x</code>, you could first call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">x</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Note</dt>
<dd>
<p><code>reserve(n)</code> reserves space for at least <code>n</code> elements, allocating enough buckets
so as to not exceed the maximum load factor.</p>
<div class="paragraph">
<p>Because the maximum load factor is defined as the number of elements divided by the total
number of available buckets, this function is logically equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">x</span><span class="p">.</span><span class="n">rehash</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">x</span><span class="p">.</span><span class="n">max_load_factor</span><span class="p">()))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#unordered_map_rehash">reference for more details</a> on the <code>rehash</code> function.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hash_equality"><a class="link" href="#hash_equality">Equality Predicates and Hash Functions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>While the associative containers use an ordering relation to specify how the
elements are stored, the unordered associative containers use an equality
predicate and a hash function. For example, <a href="#unordered_map">boost::unordered_map</a>
is declared as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
    <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">unordered_map</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The hash function comes first as you might want to change the hash function
but not the equality predicate. For example, if you wanted to use the
<a href="http://www.isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="noopener">FNV-1 hash</a> you could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hash</span><span class="o">::</span><span class="n">fnv_1</span><span class="o">&gt;</span>
    <span class="n">dictionary</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is an <a href="../../examples/fnv1.hpp" target="_blank" rel="noopener">implementation of FNV-1</a> in the examples directory.</p>
</div>
<div class="paragraph">
<p>If you wish to use a different equality function, you will also need to use a matching hash function. For example, to implement a case insensitive dictionary you need to define a case insensitive equality predicate and hash function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">iequal_to</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">algorithm</span><span class="o">::</span><span class="n">iequals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">ihash</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">locale</span> <span class="n">locale</span><span class="p">;</span>

        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="n">it</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">locale</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which you can then use in a case insensitive dictionary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ihash</span><span class="p">,</span> <span class="n">iequal_to</span><span class="o">&gt;</span>
    <span class="n">idictionary</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simplified version of the example at
<a href="../../examples/case_insensitive.hpp" target="_blank" rel="noopener">/libs/unordered/examples/case_insensitive.hpp</a> which supports other locales and string types.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Be careful when using the equality (<code>==</code>) operator with custom equality
predicates, especially if you&#8217;re using a function pointer. If you compare two
containers with different equality predicates then the result is undefined.
For most stateless function objects this is impossible - since you can only
compare objects with the same equality predicate you know the equality
predicates must be equal. But if you&#8217;re using function pointers or a stateful
equality predicate (e.g. <code>boost::function</code>) then you can get into trouble.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="hash_equality_custom_types"><a class="link" href="#hash_equality_custom_types">Custom Types</a></h3>
<div class="paragraph">
<p>Similarly, a custom hash function can be used for custom types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">point_hash</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">boost</span><span class="o">::</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">point</span><span class="p">,</span> <span class="n">point_hash</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the default hash function is <a href="../../../container_hash/index.html" target="_blank" rel="noopener">Boost.Hash</a>,
we can extend it to support the type so that the hash function doesn&#8217;t need to be explicitly given:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">hash_value</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Now the default function objects work.</span>
<span class="n">boost</span><span class="o">::</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="../../../container_hash/index.html" target="_blank" rel="noopener">Boost.Hash documentation</a> for more detail on how to
do this. Remember that it relies on extensions to the standard - so it
won&#8217;t work for other implementations of the unordered associative containers,
you&#8217;ll need to explicitly use Boost.Hash.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 3 Methods for accessing the hash and equality functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-middle">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasher hash_function() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the container&#8217;s hash function.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>key_equal key_eq() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the container&#8217;s key equality function..</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="comparison"><a class="link" href="#comparison">Comparison with Associative Containers</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 4 Interface differences</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Associative Containers</th>
<th class="tableblock halign-left valign-top">Unordered Associative Containers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameterized by an ordering relation <code>Compare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameterized by a function object <code>Hash</code> and an equivalence relation <code>Pred</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys can be compared using <code>key_compare</code> which is accessed by member function <code>key_comp()</code>, values can be compared using <code>value_compare</code> which is accessed by member function <code>value_comp()</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys can be hashed using <code>hasher</code> which is accessed by member function <code>hash_function()</code>, and checked for equality using <code>key_equal</code> which is accessed by member function <code>key_eq()</code>. There is no function object for compared or hashing values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructors have optional extra parameters for the comparison object.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructors have optional extra parameters for the initial minimum number of buckets, a hash function and an equality object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys <code>k1</code>, <code>k2</code> are considered equivalent if <code>!Compare(k1, k2) &amp;&amp; !Compare(k2, k1)</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys <code>k1</code>, <code>k2</code> are considered equivalent if <code>Pred(k1, k2)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Member function <code>lower_bound(k)</code> and <code>upper_bound(k)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No equivalent. Since the elements aren&#8217;t ordered <code>lower_bound</code> and <code>upper_bound</code> would be meaningless.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code> returns an empty range at the position that <code>k</code> would be inserted if <code>k</code> isn&#8217;t present in the container.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code> returns a range at the end of the container if <code>k</code> isn&#8217;t present in the container. It can&#8217;t return a positioned range as <code>k</code> could be inserted into multiple place. To find out the bucket that <code>k</code> would be inserted into use <code>bucket(k)</code>. But remember that an insert can cause the container to rehash - meaning that the element can be inserted into a different bucket.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iterator</code>, <code>const_iterator</code> are of the bidirectional category.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iterator</code>, <code>const_iterator</code> are of at least the forward category.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators, pointers and references to the container&#8217;s elements are never invalidated.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#buckets_iterator_invalidation">Iterators can be invalidated by calls to insert or rehash</a>. Pointers and references to the container&#8217;s elements are never invalidated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators iterate through the container in the order defined by the comparison object.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators iterate through the container in an arbitrary order, that can change as elements are inserted, although equivalent elements are always adjacent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">No equivalent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local iterators can be used to iterate through individual buckets. (The order of local iterators and iterators aren&#8217;t required to have any correspondence.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can be compared using the <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> operators.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can be compared using the <code>==</code> and <code>!=</code> operators.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When inserting with a hint, implementations are permitted to ignore the hint.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>erase</code> never throws an exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The containers' hash or predicate function can throw exceptions from <code>erase</code>.</p></td>
</tr>
</tbody>
</table>
<hr>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 5 Complexity Guarantees</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operation</th>
<th class="tableblock halign-left valign-top">Associative Containers</th>
<th class="tableblock halign-left valign-top">Unordered Associative Containers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Construction of empty container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<em>n</em>) where <em>n</em> is the minimum number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Construction of container from a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<em>N log N</em>), O(<em>N</em>) if the range is sorted with <code>value_comp()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case O(<em>N</em>), worst case O(<em>N<sup>2</sup></em>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Insert a single element</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case constant, worst case linear</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Insert a single element with a hint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amortized constant if <code>t</code> elements inserted right after hint, logarithmic otherwise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case constant, worst case linear (ie. the same as a normal insert).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inserting a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N</em> log(<code>size()</code> + <em>N</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case O(<em>N</em>), worst case O(<em>N</em> * <code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase by key, <code>k</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <code>count(k)</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<code>count(k)</code>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase a single element by iterator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amortized constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <em>N</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<em>N</em>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clearing the container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<code>size()</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Find</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <code>count(k)</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<code>count(k)</code>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lower_bound</code>,<code>upper_bound</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="compliance"><a class="link" href="#compliance">Standard Compliance</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The intent of Boost.Unordered is to implement a close (but imperfect)
implementation of the C++17 standard, that will work with C++98 upwards.
The wide compatibility does mean some comprimises have to be made.
With a compiler and library that fully support C++11, the differences should
be minor.</p>
</div>
<div class="sect2">
<h3 id="compliance_move_emulation"><a class="link" href="#compliance_move_emulation">Move emulation</a></h3>
<div class="paragraph">
<p>Support for move semantics is implemented using Boost.Move. If rvalue
references are available it will use them, but if not it uses a close,
but imperfect emulation. On such compilers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Non-copyable objects can be stored in the containers.
They can be constructed in place using <code>emplace</code>, or if they support
Boost.Move, moved into place.</p>
</li>
<li>
<p>The containers themselves are not movable.</p>
</li>
<li>
<p>Argument forwarding is not perfect.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="compliance_use_of_allocators"><a class="link" href="#compliance_use_of_allocators">Use of allocators</a></h3>
<div class="paragraph">
<p>C++11 introduced a new allocator system. It&#8217;s backwards compatible due to
the lax requirements for allocators in the old standard, but might need
some changes for allocators which worked with the old versions of the
unordered containers.
It uses a traits class, <code>allocator_traits</code> to handle the allocator
adding extra functionality, and making some methods and types optional.
During development a stable release of
<code>allocator_traits</code> wasn&#8217;t available so an internal partial implementation
is always used in this version. Hopefully a future version will use the
standard implementation where available.</p>
</div>
<div class="paragraph">
<p>The member functions <code>construct</code>, <code>destroy</code> and <code>max_size</code> are now
optional, if they&#8217;re not available a fallback is used.
A full implementation of <code>allocator_traits</code> requires sophisticated
member function detection so that the fallback is used whenever the
member function call is not well formed.
This requires support for SFINAE expressions, which are available on
GCC from version 4.4 and Clang.</p>
</div>
<div class="paragraph">
<p>On other compilers, there&#8217;s just a test to see if the allocator has
a member, but no check that it can be called. So rather than using a
fallback there will just be a compile error.</p>
</div>
<div class="paragraph">
<p><code>propagate_on_container_copy_assignment</code>,
<code>propagate_on_container_move_assignment</code>,
<code>propagate_on_container_swap</code> and
<code>select_on_container_copy_construction</code> are also supported.
Due to imperfect move emulation, some assignments might check
<code>propagate_on_container_copy_assignment</code> on some compilers and
<code>propagate_on_container_move_assignment</code> on others.</p>
</div>
</div>
<div class="sect2">
<h3 id="compliance_constructiondestruction_using_allocators"><a class="link" href="#compliance_constructiondestruction_using_allocators">Construction/Destruction using allocators</a></h3>
<div class="paragraph">
<p>The following support is required for full use of C++11 style
construction/destruction:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Variadic templates.</p>
</li>
<li>
<p>Piecewise construction of <code>std::pair</code>.</p>
</li>
<li>
<p>Either <code>std::allocator_traits</code> or expression SFINAE.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is detected using Boost.Config. The macro
<code>BOOST_UNORDERED_CXX11_CONSTRUCTION</code> will be set to 1 if it is found, or 0
otherwise.</p>
</div>
<div class="paragraph">
<p>When this is the case <code>allocator_traits::construct</code> and
<code>allocator_traits::destroy</code> will always be used, apart from when piecewise
constructing a <code>std::pair</code> using <code>boost::tuple</code> (see <a href="#compliance_pairs">below</a>), but that should be easily avoided.</p>
</div>
<div class="paragraph">
<p>When support is not available <code>allocator_traits::construct</code> and
<code>allocator_traits::destroy</code> are never called.</p>
</div>
</div>
<div class="sect2">
<h3 id="compliance_pointer_traits"><a class="link" href="#compliance_pointer_traits">Pointer Traits</a></h3>
<div class="paragraph">
<p><code>pointer_traits</code> aren&#8217;t used. Instead, pointer types are obtained from
rebound allocators, this can cause problems if the allocator can&#8217;t be
used with incomplete types. If <code>const_pointer</code> is not defined in the
allocator, <code>boost::pointer_to_other&lt;pointer, const value_type&gt;::type</code>
is used to obtain a const pointer.</p>
</div>
</div>
<div class="sect2">
<h3 id="compliance_pairs"><a class="link" href="#compliance_pairs">Pairs</a></h3>
<div class="paragraph">
<p>Since the containers use <code>std::pair</code> they&#8217;re limited to the version
from the current standard library. But since C++11 <code>std::pair</code>'s
<code>piecewise_construct</code> based constructor is very useful, <code>emplace</code>
emulates it with a <code>piecewise_construct</code> in the <code>boost::unordered</code>
namespace. So for example, the following will work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>

<span class="n">x</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">unordered</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="s">"key"</span><span class="p">),</span> <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Older drafts of the standard also supported variadic constructors
for <code>std::pair</code>, where the first argument would be used for the
first part of the pair, and the remaining for the second part.</p>
</div>
</div>
<div class="sect2">
<h3 id="compliance_miscellaneous"><a class="link" href="#compliance_miscellaneous">Miscellaneous</a></h3>
<div class="paragraph">
<p>When swapping, <code>Pred</code> and <code>Hash</code> are not currently swapped by calling
<code>swap</code>, their copy constructors are used. As a consequence when swapping
an exception may be thrown from their copy constructor.</p>
</div>
<div class="paragraph">
<p>Variadic constructor arguments for <code>emplace</code> are only used when both
rvalue references and variadic template parameters are available.
Otherwise <code>emplace</code> can only take up to 10 constructors arguments.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale"><a class="link" href="#rationale">Implementation Rationale</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The intent of this library is to implement the unordered
containers in the standard, so the interface was fixed. But there are
still some implementation decisions to make. The priorities are
conformance to the standard and portability.</p>
</div>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Wikipedia article on hash tables</a>
has a good summary of the implementation issues for hash tables in general.</p>
</div>
<div class="sect2">
<h3 id="rationale_data_structure"><a class="link" href="#rationale_data_structure">Data Structure</a></h3>
<div class="paragraph">
<p>By specifying an interface for accessing the buckets of the container the
standard pretty much requires that the hash table uses chained addressing.</p>
</div>
<div class="paragraph">
<p>It would be conceivable to write a hash table that uses another method. For
example, it could use open addressing, and use the lookup chain to act as a
bucket but there are some serious problems with this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The standard requires that pointers to elements aren&#8217;t invalidated, so
the elements can&#8217;t be stored in one array, but will need a layer of
indirection instead - losing the efficiency and most of the memory gain,
the main advantages of open addressing.</p>
</li>
<li>
<p>Local iterators would be very inefficient and may not be able to
meet the complexity requirements.</p>
</li>
<li>
<p>There are also the restrictions on when iterators can be invalidated. Since
open addressing degrades badly when there are a high number of collisions the
restrictions could prevent a rehash when it&#8217;s really needed. The maximum load
factor could be set to a fairly low value to work around this - but the
standard requires that it is initially set to 1.0.</p>
</li>
<li>
<p>And since the standard is written with a eye towards chained
addressing, users will be surprised if the performance doesn&#8217;t reflect that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So chained addressing is used.</p>
</div>
</div>
<div class="sect2">
<h3 id="rationale_number_of_buckets"><a class="link" href="#rationale_number_of_buckets">Number of Buckets</a></h3>
<div class="paragraph">
<p>There are two popular methods for choosing the number of buckets in a hash
table. One is to have a prime number of buckets, another is to use a power
of 2.</p>
</div>
<div class="paragraph">
<p>Using a prime number of buckets, and choosing a bucket by using the modulus
of the hash function&#8217;s result will usually give a good result. The downside
is that the required modulus operation is fairly expensive. This is what the
containers used to do in most cases.</p>
</div>
<div class="paragraph">
<p>Using a power of 2 allows for much quicker selection of the bucket to use,
but at the expense of losing the upper bits of the hash value. For some
specially designed hash functions it is possible to do this and still get a
good result but as the containers can take arbitrary hash functions this can&#8217;t
be relied on.</p>
</div>
<div class="paragraph">
<p>To avoid this a transformation could be applied to the hash function, for an
example see
<a href="http://web.archive.org/web/20121102023700/http://www.concentric.net/~Ttwang/tech/inthash.htm" target="_blank" rel="noopener">Thomas Wang&#8217;s article on integer hash functions</a>.
Unfortunately, a transformation like Wang&#8217;s requires knowledge of the number
of bits in the hash value, so it was only used when <code>size_t</code> was 64 bit.</p>
</div>
<div class="paragraph">
<p>Since release 1.79.0, <a href="https://en.wikipedia.org/wiki/Hash_function#Fibonacci_hashing">Fibonacci hashing</a>
is used instead. With this implementation, the bucket number is determined
by using <code>(h * m) &gt;&gt; (w - k)</code>, where <code>h</code> is the hash value, <code>m</code> is the golden
ratio multiplied by <code>2^w</code>, <code>w</code> is the word size (32 or 64), and <code>2^k</code> is the
number of buckets. This provides a good compromise between speed and
distribution.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference"><a class="link" href="#reference">Reference</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="unordered_map"><a class="link" href="#unordered_map">Class template unordered_map</a></h3>
<div class="paragraph">
<p><code>boost::unordered_map</code> — An unordered associative container that associates unique keys with another value.</p>
</div>
<div class="sect3">
<h4 id="unordered_map_synopsis"><a class="link" href="#unordered_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_map_default_constructor">unordered_map</a>();
    explicit <a href="#unordered_map_bucket_count_constructor">unordered_map</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor">unordered_map</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_copy_constructor">unordered_map</a>(const unordered_map&amp; other);
    <a href="#unordered_map_move_constructor">unordered_map</a>(unordered_map&amp;&amp; other);
    explicit <a href="#unordered_map_allocator_constructor">unordered_map</a>(const Allocator&amp; a);
    <a href="#unordered_map_copy_constructor_with_allocator">unordered_map</a>(const unordered_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_move_constructor_with_allocator">unordered_map</a>(unordered_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_initializer_list_constructor">unordered_map</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_bucket_count_constructor_with_allocator">unordered_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator">unordered_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_map_destructor">~unordered_map</a>();
    unordered_map&amp; <a href="#unordered_map_copy_assignment">operator=</a>(const unordered_map&amp; other);
    unordered_map&amp; <a href="#unordered_map_move_assignment">operator=</a>(unordered_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_map&amp; <a href="#unordered_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator       <a href="#unordered_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_map_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);

    node_type <a href="#unordered_map_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_map_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_map_transparent_extract_by_key">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_map_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_map_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_map_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_map_transparent_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_map_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_map_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_map_swap">swap</a>(unordered_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_map_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(key_type&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_map_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_map_bucket">bucket</a>(const key_type&amp; k) const;
    local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_map_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_map_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_map_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_map_reserve">reserve</a>(size_type n);
  };
}

// Equality Comparisons
template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_map_operator_2">operator==</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_map_operator_3">operator!=</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

// swap
template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void <a href="#unordered_map_swap_2">swap</a>(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));

template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_map&lt;K, T, H, P, A&gt;::size_type
     <a href="#unordered_map_erase_if">erase_if</a>(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_description"><a class="link" href="#unordered_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_typedefs"><a class="link" href="#unordered_map_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_map for details.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Structure returned by inserting node_type.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_constructors"><a class="link" href="#unordered_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_map_default_constructor"><a class="link" href="#unordered_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor"><a class="link" href="#unordered_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor"><a class="link" href="#unordered_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_constructor"><a class="link" href="#unordered_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_constructor"><a class="link" href="#unordered_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_allocator_constructor"><a class="link" href="#unordered_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_constructor_with_allocator"><a class="link" href="#unordered_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_constructor_with_allocator"><a class="link" href="#unordered_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor"><a class="link" href="#unordered_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_destructor"><a class="link" href="#unordered_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_assignment"><a class="link" href="#unordered_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_map_copy_assignment"><a class="link" href="#unordered_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_assignment"><a class="link" href="#unordered_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_assignment"><a class="link" href="#unordered_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_iterators"><a class="link" href="#unordered_map_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_map_begin"><a class="link" href="#unordered_map_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_end"><a class="link" href="#unordered_map_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cbegin"><a class="link" href="#unordered_map_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cend"><a class="link" href="#unordered_map_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_size_and_capacity"><a class="link" href="#unordered_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_map_empty"><a class="link" href="#unordered_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_size"><a class="link" href="#unordered_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_size"><a class="link" href="#unordered_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_modifiers"><a class="link" href="#unordered_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_map_emplace"><a class="link" href="#unordered_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_hint"><a class="link" href="#unordered_map_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_insert"><a class="link" href="#unordered_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_insert"><a class="link" href="#unordered_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_insert"><a class="link" href="#unordered_map_emplace_insert">Emplace Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_insert_with_hint"><a class="link" href="#unordered_map_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_insert_with_hint"><a class="link" href="#unordered_map_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_insert_with_hint"><a class="link" href="#unordered_map_emplace_insert_with_hint">Emplace Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_iterator_range"><a class="link" href="#unordered_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_initializer_list"><a class="link" href="#unordered_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_try_emplace"><a class="link" href="#unordered_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace">emplace</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace">emplace</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.</p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_try_emplace_with_hint"><a class="link" href="#unordered_map_try_emplace_with_hint">try_emplace with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace_hint">emplace_hint</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace_hint">emplace_hint</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.</p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_or_assign"><a class="link" href="#unordered_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_or_assign_with_hint"><a class="link" href="#unordered_map_insert_or_assign_with_hint">insert_or_assign with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_extract_by_iterator"><a class="link" href="#unordered_map_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_extract_by_key"><a class="link" href="#unordered_map_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_transparent_extract_by_key"><a class="link" href="#unordered_map_transparent_extract_by_key">Transparent Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_with_node_handle"><a class="link" href="#unordered_map_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_with_hint_and_node_handle"><a class="link" href="#unordered_map_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_by_position"><a class="link" href="#unordered_map_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_by_key"><a class="link" href="#unordered_map_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_transparent_erase_by_key"><a class="link" href="#unordered_map_transparent_erase_by_key">Transparent Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_range"><a class="link" href="#unordered_map_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_quick_erase"><a class="link" href="#unordered_map_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_return_void"><a class="link" href="#unordered_map_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_swap"><a class="link" href="#unordered_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_clear"><a class="link" href="#unordered_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_merge"><a class="link" href="#unordered_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_observers"><a class="link" href="#unordered_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_map_get_allocator"><a class="link" href="#unordered_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_hash_function"><a class="link" href="#unordered_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_key_eq"><a class="link" href="#unordered_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_lookup"><a class="link" href="#unordered_map_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_map_find"><a class="link" href="#unordered_map_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_count"><a class="link" href="#unordered_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_contains"><a class="link" href="#unordered_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_equal_range"><a class="link" href="#unordered_map_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_operator"><a class="link" href="#unordered_map_operator">operator[]</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an elements with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_at"><a class="link" href="#unordered_map_at">at</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket_interface"><a class="link" href="#unordered_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_map_bucket_count"><a class="link" href="#unordered_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_bucket_count"><a class="link" href="#unordered_map_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_size"><a class="link" href="#unordered_map_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket"><a class="link" href="#unordered_map_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_begin_2"><a class="link" href="#unordered_map_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_end_2"><a class="link" href="#unordered_map_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cbegin_2"><a class="link" href="#unordered_map_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cend_2"><a class="link" href="#unordered_map_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_hash_policy"><a class="link" href="#unordered_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_map_load_factor"><a class="link" href="#unordered_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_load_factor"><a class="link" href="#unordered_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_set_max_load_factor"><a class="link" href="#unordered_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_rehash"><a class="link" href="#unordered_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_reserve"><a class="link" href="#unordered_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_equality_comparisons"><a class="link" href="#unordered_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_map_operator_2"><a class="link" href="#unordered_map_operator_2">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_operator_3"><a class="link" href="#unordered_map_operator_3">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_swap_2"><a class="link" href="#unordered_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_erase_if"><a class="link" href="#unordered_map_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap"><a class="link" href="#unordered_multimap">Class template unordered_multimap</a></h3>
<div class="paragraph">
<p><code>boost::unordered_multimap</code> — An unordered associative container that associates keys with another value. The same key can be stored multiple times.</p>
</div>
<div class="sect3">
<h4 id="unordered_multimap_synopsis"><a class="link" href="#unordered_multimap_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_multimap {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multimap_default_constructor">unordered_multimap</a>();
    explicit <a href="#unordered_multimap_bucket_count_constructor">unordered_multimap</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor">unordered_multimap</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_copy_constructor">unordered_multimap</a>(const unordered_multimap&amp; other);
    <a href="#unordered_multimap_move_constructor">unordered_multimap</a>(unordered_multimap&amp;&amp; other);
    explicit <a href="#unordered_multimap_allocator_constructor">unordered_multimap</a>(const Allocator&amp; a);
    <a href="#unordered_multimap_copy_constructor_with_allocator">unordered_multimap</a>(const unordered_multimap&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_move_constructor_with_allocator">unordered_multimap</a>(unordered_multimap&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_bucket_count_constructor_with_allocator">unordered_multimap</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator">unordered_multimap</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multimap_destructor">~unordered_multimap</a>();
    unordered_multimap&amp; <a href="#unordered_multimap_copy_assignment">operator=</a>(const unordered_multimap&amp; other);
    unordered_multimap&amp; <a href="#unordered_multimap_move_assignment">operator=</a>(unordered_multimap&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multimap&amp; <a href="#unordered_multimap_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multimap_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multimap_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multimap_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multimap_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multimap_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multimap_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multimap_size">size</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multimap_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator <a href="#unordered_multimap_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multimap_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multimap_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multimap_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multimap_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multimap_transparent_extract_by_key">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multimap_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multimap_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multimap_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multimap_transparent_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_multimap_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multimap_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multimap_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multimap_swap">swap</a>(unordered_multimap&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multimap_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multimap_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multimap_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_multimap_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multimap_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_multimap_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multimap_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multimap_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multimap_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multimap_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multimap_bucket">bucket</a>(const key_type&amp; k) const;
    local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multimap_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multimap_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multimap_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multimap_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multimap_reserve">reserve</a>(size_type n);
  };
}

// Equality Comparisons
template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_multimap_operator">operator==</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_multimap_operator_2">operator!=</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

// swap
template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
  void <a href="#unordered_multimap_swap_2">swap</a>(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));

template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
  typename unordered_multimap&lt;K, T, H, P, A&gt;::size_type
    <a href="#unordered_multimap_erase_if">erase_if</a>(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_description"><a class="link" href="#unordered_multimap_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_typedefs"><a class="link" href="#unordered_multimap_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_map for details.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_constructors"><a class="link" href="#unordered_multimap_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_default_constructor"><a class="link" href="#unordered_multimap_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor"><a class="link" href="#unordered_multimap_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor"><a class="link" href="#unordered_multimap_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
<span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_constructor"><a class="link" href="#unordered_multimap_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_constructor"><a class="link" href="#unordered_multimap_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_allocator_constructor"><a class="link" href="#unordered_multimap_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_constructor_with_allocator"><a class="link" href="#unordered_multimap_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_constructor_with_allocator"><a class="link" href="#unordered_multimap_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor"><a class="link" href="#unordered_multimap_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_multimap_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_destructor"><a class="link" href="#unordered_multimap_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_multimap</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_assignment"><a class="link" href="#unordered_multimap_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_copy_assignment"><a class="link" href="#unordered_multimap_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_assignment"><a class="link" href="#unordered_multimap_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_assignment"><a class="link" href="#unordered_multimap_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iterators"><a class="link" href="#unordered_multimap_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_begin"><a class="link" href="#unordered_multimap_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_end"><a class="link" href="#unordered_multimap_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cbegin"><a class="link" href="#unordered_multimap_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cend"><a class="link" href="#unordered_multimap_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_size_and_capacity"><a class="link" href="#unordered_multimap_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_empty"><a class="link" href="#unordered_multimap_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_size"><a class="link" href="#unordered_multimap_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_size"><a class="link" href="#unordered_multimap_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_modifiers"><a class="link" href="#unordered_multimap_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_emplace"><a class="link" href="#unordered_multimap_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_hint"><a class="link" href="#unordered_multimap_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_insert"><a class="link" href="#unordered_multimap_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_insert"><a class="link" href="#unordered_multimap_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_insert"><a class="link" href="#unordered_multimap_emplace_insert">Emplace Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_insert_with_hint"><a class="link" href="#unordered_multimap_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_insert_with_hint"><a class="link" href="#unordered_multimap_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_insert_with_hint"><a class="link" href="#unordered_multimap_emplace_insert_with_hint">Emplace Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_iterator_range"><a class="link" href="#unordered_multimap_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_initializer_list"><a class="link" href="#unordered_multimap_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_extract_by_iterator"><a class="link" href="#unordered_multimap_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_extract_by_key"><a class="link" href="#unordered_multimap_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_transparent_extract_by_key"><a class="link" href="#unordered_multimap_transparent_extract_by_key">Transparent Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_with_node_handle"><a class="link" href="#unordered_multimap_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_with_hint_and_node_handle"><a class="link" href="#unordered_multimap_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_by_position"><a class="link" href="#unordered_multimap_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_by_key"><a class="link" href="#unordered_multimap_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_transparent_erase_by_key"><a class="link" href="#unordered_multimap_transparent_erase_by_key">Transparent Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_range"><a class="link" href="#unordered_multimap_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_quick_erase"><a class="link" href="#unordered_multimap_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_return_void"><a class="link" href="#unordered_multimap_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_swap"><a class="link" href="#unordered_multimap_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_clear"><a class="link" href="#unordered_multimap_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_merge"><a class="link" href="#unordered_multimap_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_observers"><a class="link" href="#unordered_multimap_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_get_allocator"><a class="link" href="#unordered_multimap_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_hash_function"><a class="link" href="#unordered_multimap_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_key_eq"><a class="link" href="#unordered_multimap_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_lookup"><a class="link" href="#unordered_multimap_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_find"><a class="link" href="#unordered_multimap_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_count"><a class="link" href="#unordered_multimap_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_contains"><a class="link" href="#unordered_multimap_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_equal_range"><a class="link" href="#unordered_multimap_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket_interface"><a class="link" href="#unordered_multimap_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count"><a class="link" href="#unordered_multimap_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_bucket_count"><a class="link" href="#unordered_multimap_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_size"><a class="link" href="#unordered_multimap_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket"><a class="link" href="#unordered_multimap_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_begin_2"><a class="link" href="#unordered_multimap_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_end_2"><a class="link" href="#unordered_multimap_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cbegin_2"><a class="link" href="#unordered_multimap_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cend_2"><a class="link" href="#unordered_multimap_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_hash_policy"><a class="link" href="#unordered_multimap_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_load_factor"><a class="link" href="#unordered_multimap_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_load_factor"><a class="link" href="#unordered_multimap_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_set_max_load_factor"><a class="link" href="#unordered_multimap_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_rehash"><a class="link" href="#unordered_multimap_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_reserve"><a class="link" href="#unordered_multimap_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_equality_comparisons"><a class="link" href="#unordered_multimap_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_operator"><a class="link" href="#unordered_multimap_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_operator_2"><a class="link" href="#unordered_multimap_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_swap_2"><a class="link" href="#unordered_multimap_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_erase_if"><a class="link" href="#unordered_multimap_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set"><a class="link" href="#unordered_set">Class template unordered_set</a></h3>
<div class="paragraph">
<p><code>boost::unordered_set</code> — An unordered associative container that stores unique values.</p>
</div>
<div class="sect3">
<h4 id="unordered_set_synopsis"><a class="link" href="#unordered_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_set_default_constructor">unordered_set</a>();
    explicit <a href="#unordered_set_bucket_count_constructor">unordered_set</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor">unordered_set</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_copy_constructor">unordered_set</a>(const unordered_set&amp; other);
    <a href="#unordered_set_move_constructor">unordered_set</a>(unordered_set&amp;&amp; other);
    explicit <a href="#unordered_set_allocator_constructor">unordered_set</a>(const Allocator&amp; a);
    <a href="#unordered_set_copy_constructor_with_allocator">unordered_set</a>(const unordered_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_move_constructor_with_allocator">unordered_set</a>(unordered_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_initializer_list_constructor">unordered_set</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>,
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_bucket_count_constructor_with_allocator">unordered_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator">unordered_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_set_destructor">~unordered_set</a>();
    unordered_set&amp; <a href="#unordered_set_copy_assignment">operator=</a>(const unordered_set&amp; other);
    unordered_set&amp; <a href="#unordered_set_move_assignment">operator=</a>(unordered_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_set&amp; <a href="#unordered_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    iterator <a href="#unordered_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    node_type <a href="#unordered_set_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_set_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_set_transparent_extract_by_value">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_set_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_set_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_set_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_set_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_set_transparent_erase_by_value">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_set_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_set_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_set_swap">swap</a>(unordered_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_set_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_set_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_set_bucket">bucket</a>(const key_type&amp; k) const;
    local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_set_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_set_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_set_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_set_reserve">reserve</a>(size_type n);
  };
}

// Equality Comparisons
template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_set_operator">operator==</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_set_operator_2">operator!=</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

// swap
template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  void <a href="#unordered_set_swap_2">swap</a>(unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
            unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));

template&lt;class K, class H, class P, class A, class Predicate&gt;
  typename unordered_set&lt;K, H, P, A&gt;::size_type
    <a href="#unordered_set_erase_if">erase_if</a>(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_description"><a class="link" href="#unordered_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_typedefs"><a class="link" href="#unordered_set_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_set for details.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Structure returned by inserting node_type.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_constructors"><a class="link" href="#unordered_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_set_default_constructor"><a class="link" href="#unordered_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor"><a class="link" href="#unordered_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor"><a class="link" href="#unordered_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_constructor"><a class="link" href="#unordered_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_constructor"><a class="link" href="#unordered_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_allocator_constructor"><a class="link" href="#unordered_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_constructor_with_allocator"><a class="link" href="#unordered_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_constructor_with_allocator"><a class="link" href="#unordered_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor"><a class="link" href="#unordered_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_destructor"><a class="link" href="#unordered_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_assignment"><a class="link" href="#unordered_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_set_copy_assignment"><a class="link" href="#unordered_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_assignment"><a class="link" href="#unordered_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_assignment"><a class="link" href="#unordered_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_iterators"><a class="link" href="#unordered_set_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_set_begin"><a class="link" href="#unordered_set_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_end"><a class="link" href="#unordered_set_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cbegin"><a class="link" href="#unordered_set_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cend"><a class="link" href="#unordered_set_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_size_and_capacity"><a class="link" href="#unordered_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_set_empty"><a class="link" href="#unordered_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_size"><a class="link" href="#unordered_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_size"><a class="link" href="#unordered_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_modifiers"><a class="link" href="#unordered_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_set_emplace"><a class="link" href="#unordered_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_emplace_hint"><a class="link" href="#unordered_set_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_insert"><a class="link" href="#unordered_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_insert"><a class="link" href="#unordered_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_insert_with_hint"><a class="link" href="#unordered_set_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_insert_with_hint"><a class="link" href="#unordered_set_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_iterator_range"><a class="link" href="#unordered_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_initializer_list"><a class="link" href="#unordered_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_extract_by_iterator"><a class="link" href="#unordered_set_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_extract_by_value"><a class="link" href="#unordered_set_extract_by_value">Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_transparent_extract_by_value"><a class="link" href="#unordered_set_transparent_extract_by_value">Transparent Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_with_node_handle"><a class="link" href="#unordered_set_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>In C++17 this can be used to insert a node extracted from a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_with_hint_and_node_handle"><a class="link" href="#unordered_set_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multiset</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_by_position"><a class="link" href="#unordered_set_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_by_value"><a class="link" href="#unordered_set_erase_by_value">Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_transparent_erase_by_value"><a class="link" href="#unordered_set_transparent_erase_by_value">Transparent Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_range"><a class="link" href="#unordered_set_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_quick_erase"><a class="link" href="#unordered_set_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_return_void"><a class="link" href="#unordered_set_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_swap"><a class="link" href="#unordered_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_clear"><a class="link" href="#unordered_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_merge"><a class="link" href="#unordered_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_observers"><a class="link" href="#unordered_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_set_get_allocator"><a class="link" href="#unordered_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_hash_function"><a class="link" href="#unordered_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_key_eq"><a class="link" href="#unordered_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_lookup"><a class="link" href="#unordered_set_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_set_find"><a class="link" href="#unordered_set_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_count"><a class="link" href="#unordered_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_contains"><a class="link" href="#unordered_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_equal_range"><a class="link" href="#unordered_set_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket_interface"><a class="link" href="#unordered_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_set_bucket_count"><a class="link" href="#unordered_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_bucket_count"><a class="link" href="#unordered_set_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_size"><a class="link" href="#unordered_set_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket"><a class="link" href="#unordered_set_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_begin_2"><a class="link" href="#unordered_set_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_end_2"><a class="link" href="#unordered_set_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cbegin_2"><a class="link" href="#unordered_set_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cend_2"><a class="link" href="#unordered_set_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_hash_policy"><a class="link" href="#unordered_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_set_load_factor"><a class="link" href="#unordered_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_load_factor"><a class="link" href="#unordered_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_set_max_load_factor"><a class="link" href="#unordered_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_rehash"><a class="link" href="#unordered_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_reserve"><a class="link" href="#unordered_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_equality_comparisons"><a class="link" href="#unordered_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_set_operator"><a class="link" href="#unordered_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_operator_2"><a class="link" href="#unordered_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_swap_2"><a class="link" href="#unordered_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_erase_if"><a class="link" href="#unordered_set_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset"><a class="link" href="#unordered_multiset">Class template unordered_multiset</a></h3>
<div class="paragraph">
<p><code>boost::unordered_multiset</code> — An unordered associative container that stores values. The same key can be stored multiple times.</p>
</div>
<div class="sect3">
<h4 id="unordered_multiset_synopsis"><a class="link" href="#unordered_multiset_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_multiset {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multiset_default_constructor">unordered_multiset</a>();
    explicit <a href="#unordered_multiset_bucket_count_constructor">unordered_multiset</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor">unordered_multiset</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_copy_constructor">unordered_multiset</a>(const unordered_multiset&amp; other);
    <a href="#unordered_multiset_move_constructor">unordered_multiset</a>(unordered_multiset&amp;&amp; other);
    explicit <a href="#unordered_multiset_allocator_constructor">unordered_multiset</a>(const Allocator&amp; a);
    <a href="#unordered_multiset_copy_constructor_with_allocator">unordered_multiset</a>(const unordered_multiset&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_move_constructor_with_allocator">unordered_multiset</a>(unordered_multiset&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_bucket_count_constructor_with_allocator">unordered_multiset</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator">unordered_multiset</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multiset_destructor">~unordered_multiset()</a>;
    unordered_multiset&amp; <a href="#unordered_multiset_copy_assignment">operator=</a>(const unordered_multiset&amp; other);
    unordered_multiset&amp; <a href="#unordered_multiset_move_assignment">operator=</a>(unordered_multiset&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multiset&amp; <a href="#unordered_multiset_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multiset_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multiset_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multiset_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multiset_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multiset_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multiset_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multiset_size">size</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multiset_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert">insert</a>(value_type&amp;&amp; obj);
    iterator <a href="#unordered_multiset_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multiset_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multiset_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multiset_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multiset_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multiset_transparent_extract_by_value">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multiset_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multiset_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multiset_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multiset_transparent_erase_by_value">erase</a>(K&amp;&amp; x);
    iterator  <a href="#unordered_multiset_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multiset_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multiset_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multiset_swap">swap</a>(unordered_multiset&amp;)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multiset_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multiset_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multiset_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_multiset_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multiset_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multiset_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                          CompatiblePredicate const&amp;);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator  <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                           CompatiblePredicate const&amp;) const;
    size_type        <a href="#unordered_multiset_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multiset_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multiset_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multiset_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multiset_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multiset_bucket">bucket</a>(const key_type&amp; k) const;
    local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multiset_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multiset_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multiset_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multiset_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multiset_reserve">reserve</a>(size_type n);
  };
}

// Equality Comparisons
template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_multiset_operator">operator==</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  bool <a href="#unordered_multiset_operator_2">operator!=</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                  const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

// swap
template&lt;class Key, class Hash, class Pred, class Alloc&gt;
  void <a href="#unordered_multiset_swap_2">swap</a>(unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
            unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
    noexcept(noexcept(x.swap(y)));

template&lt;class K, class H, class P, class A, class Predicate&gt;
  typename unordered_multiset&lt;K, H, P, A&gt;::size_type
    <a href="#unordered_multiset_erase_if">erase_if</a>(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_description"><a class="link" href="#unordered_multiset_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_typedefs"><a class="link" href="#unordered_multiset_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_set for details.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_constructors"><a class="link" href="#unordered_multiset_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_default_constructor"><a class="link" href="#unordered_multiset_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor"><a class="link" href="#unordered_multiset_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor"><a class="link" href="#unordered_multiset_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_constructor"><a class="link" href="#unordered_multiset_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_constructor"><a class="link" href="#unordered_multiset_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_allocator_constructor"><a class="link" href="#unordered_multiset_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_constructor_with_allocator"><a class="link" href="#unordered_multiset_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_constructor_with_allocator"><a class="link" href="#unordered_multiset_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor"><a class="link" href="#unordered_multiset_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_multiset_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_destructor"><a class="link" href="#unordered_multiset_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_multiset</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_assignment"><a class="link" href="#unordered_multiset_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_copy_assignment"><a class="link" href="#unordered_multiset_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_assignment"><a class="link" href="#unordered_multiset_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_assignment"><a class="link" href="#unordered_multiset_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iterators"><a class="link" href="#unordered_multiset_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_begin"><a class="link" href="#unordered_multiset_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_end"><a class="link" href="#unordered_multiset_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cbegin"><a class="link" href="#unordered_multiset_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cend"><a class="link" href="#unordered_multiset_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_size_and_capacity"><a class="link" href="#unordered_multiset_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_empty"><a class="link" href="#unordered_multiset_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_size"><a class="link" href="#unordered_multiset_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_size"><a class="link" href="#unordered_multiset_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_modifiers"><a class="link" href="#unordered_multiset_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_emplace"><a class="link" href="#unordered_multiset_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_emplace_hint"><a class="link" href="#unordered_multiset_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_insert"><a class="link" href="#unordered_multiset_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_insert"><a class="link" href="#unordered_multiset_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_insert_with_hint"><a class="link" href="#unordered_multiset_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_insert_with_hint"><a class="link" href="#unordered_multiset_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_iterator_range"><a class="link" href="#unordered_multiset_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_initializer_list"><a class="link" href="#unordered_multiset_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_extract_by_iterator"><a class="link" href="#unordered_multiset_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_extract_by_value"><a class="link" href="#unordered_multiset_extract_by_value">Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_transparent_extract_by_value"><a class="link" href="#unordered_multiset_transparent_extract_by_value">Transparent Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.[horizontal]</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_with_node_handle"><a class="link" href="#unordered_multiset_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_with_hint_and_node_handle"><a class="link" href="#unordered_multiset_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_by_position"><a class="link" href="#unordered_multiset_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_by_value"><a class="link" href="#unordered_multiset_erase_by_value">Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_transparent_erase_by_value"><a class="link" href="#unordered_multiset_transparent_erase_by_value">Transparent Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_range"><a class="link" href="#unordered_multiset_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_quick_erase"><a class="link" href="#unordered_multiset_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_return_void"><a class="link" href="#unordered_multiset_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_swap"><a class="link" href="#unordered_multiset_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_clear"><a class="link" href="#unordered_multiset_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_merge"><a class="link" href="#unordered_multiset_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_observers"><a class="link" href="#unordered_multiset_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_get_allocator"><a class="link" href="#unordered_multiset_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_hash_function"><a class="link" href="#unordered_multiset_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_key_eq"><a class="link" href="#unordered_multiset_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_lookup"><a class="link" href="#unordered_multiset_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_find"><a class="link" href="#unordered_multiset_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span>  <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
                       <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_count"><a class="link" href="#unordered_multiset_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_contains"><a class="link" href="#unordered_multiset_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_equal_range"><a class="link" href="#unordered_multiset_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket_interface"><a class="link" href="#unordered_multiset_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count"><a class="link" href="#unordered_multiset_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_bucket_count"><a class="link" href="#unordered_multiset_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_size"><a class="link" href="#unordered_multiset_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket"><a class="link" href="#unordered_multiset_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_begin_2"><a class="link" href="#unordered_multiset_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_end_2"><a class="link" href="#unordered_multiset_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cbegin_2"><a class="link" href="#unordered_multiset_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cend_2"><a class="link" href="#unordered_multiset_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_hash_policy"><a class="link" href="#unordered_multiset_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_load_factor"><a class="link" href="#unordered_multiset_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_load_factor"><a class="link" href="#unordered_multiset_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_set_max_load_factor"><a class="link" href="#unordered_multiset_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_rehash"><a class="link" href="#unordered_multiset_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_reserve"><a class="link" href="#unordered_multiset_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_equality_comparisons"><a class="link" href="#unordered_multiset_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_operator"><a class="link" href="#unordered_multiset_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_operator_2"><a class="link" href="#unordered_multiset_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_swap_2"><a class="link" href="#unordered_multiset_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_erase_if"><a class="link" href="#unordered_multiset_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="changes"><a class="link" href="#changes">Change Log</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="changes_release_1_79_0"><a class="link" href="#changes_release_1_79_0">Release 1.79.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Improved C++20 support:</p>
<div class="ulist">
<ul>
<li>
<p>All containers have been updated to support
heterogeneous <code>count</code>, <code>equal_range</code> and <code>find</code>.</p>
</li>
<li>
<p>All containers now implement the member function <code>contains</code>.</p>
</li>
<li>
<p><code>erase_if</code> has been implemented for all containers.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Improved C++23 support:</p>
<div class="ulist">
<ul>
<li>
<p>All containers have been updated to support
heterogeneous <code>erase</code> and <code>extract</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Changed behavior of <code>reserve</code> to eagerly
allocate (<a href="https://github.com/boostorg/unordered/pull/59" target="_blank" rel="noopener">PR#59</a>).</p>
</li>
<li>
<p>Various warning fixes in the test suite.</p>
</li>
<li>
<p>Update code to internally use <code>boost::allocator_traits</code>.</p>
</li>
<li>
<p>Switch to Fibonacci hashing.</p>
</li>
<li>
<p>Update documentation to be written in AsciiDoc instead of QuickBook.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_67_0"><a class="link" href="#changes_release_1_67_0">Release 1.67.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Improved C++17 support:</p>
<div class="ulist">
<ul>
<li>
<p>Add template deduction guides from the standard.</p>
</li>
<li>
<p>Use a simple implementation of <code>optional</code> in node handles, so
that they&#8217;re closer to the standard.</p>
</li>
<li>
<p>Add missing <code>noexcept</code> specifications to <code>swap</code>, <code>operator=</code>
and node handles, and change the implementation to match.
Using <code>std::allocator_traits::is_always_equal</code>, or our own
implementation when not available, and
<code>boost::is_nothrow_swappable</code> in the implementation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Improved C++20 support:</p>
<div class="ulist">
<ul>
<li>
<p>Use <code>boost::to_address</code>, which has the proposed C++20 semantics,
rather than the old custom implementation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Add <code>element_type</code> to iterators, so that <code>std::pointer_traits</code>
will work.</p>
</li>
<li>
<p>Use <code>std::piecewise_construct</code> on recent versions of Visual C++,
and other uses of the Dinkumware standard library,
now using Boost.Predef to check compiler and library versions.</p>
</li>
<li>
<p>Use <code>std::iterator_traits</code> rather than the boost iterator traits
in order to remove dependency on Boost.Iterator.</p>
</li>
<li>
<p>Remove iterators' inheritance from <code>std::iterator</code>, which is
deprecated in C++17, thanks to Daniela Engert
(<a href="https://github.com/boostorg/unordered/pull/7" target="_blank" rel="noopener">PR#7</a>).</p>
</li>
<li>
<p>Stop using <code>BOOST_DEDUCED_TYPENAME</code>.</p>
</li>
<li>
<p>Update some Boost include paths.</p>
</li>
<li>
<p>Rename some internal methods, and variables.</p>
</li>
<li>
<p>Various testing improvements.</p>
</li>
<li>
<p>Miscellaneous internal changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_66_0"><a class="link" href="#changes_release_1_66_0">Release 1.66.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Simpler move construction implementation.</p>
</li>
<li>
<p>Documentation fixes (<a href="https://github.com/boostorg/unordered/pull/6" target="_blank" rel="noopener">GitHub #6</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_65_0"><a class="link" href="#changes_release_1_65_0">Release 1.65.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Add deprecated attributes to <code>quick_erase</code> and <code>erase_return_void</code>.
I really will remove them in a future version this time.</p>
</li>
<li>
<p>Small standards compliance fixes:</p>
<div class="ulist">
<ul>
<li>
<p><code>noexpect</code> specs for <code>swap</code> free functions.</p>
</li>
<li>
<p>Add missing <code>insert(P&amp;&amp;)</code> methods.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_64_0"><a class="link" href="#changes_release_1_64_0">Release 1.64.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Initial support for new C++17 member functions:
<code>insert_or_assign</code> and <code>try_emplace</code> in <code>unordered_map</code>,</p>
</li>
<li>
<p>Initial support for <code>merge</code> and <code>extract</code>.
Does not include transferring nodes between
<code>unordered_map</code> and <code>unordered_multimap</code> or between <code>unordered_set</code> and
<code>unordered_multiset</code> yet. That will hopefully be in the next version of
Boost.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_63_0"><a class="link" href="#changes_release_1_63_0">Release 1.63.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Check hint iterator in <code>insert</code>/<code>emplace_hint</code>.</p>
</li>
<li>
<p>Fix some warnings, mostly in the tests.</p>
</li>
<li>
<p>Manually write out <code>emplace_args</code> for small numbers of arguments -
should make template error messages a little more bearable.</p>
</li>
<li>
<p>Remove superfluous use of <code>boost::forward</code> in emplace arguments,
which fixes emplacing string literals in old versions of Visual C++.</p>
</li>
<li>
<p>Fix an exception safety issue in assignment. If bucket allocation
throws an exception, it can overwrite the hash and equality functions while
leaving the existing elements in place. This would mean that the function
objects wouldn&#8217;t match the container elements, so elements might be in the
wrong bucket and equivalent elements would be incorrectly handled.</p>
</li>
<li>
<p>Various reference documentation improvements.</p>
</li>
<li>
<p>Better allocator support (<a href="https://svn.boost.org/trac/boost/ticket/12459" target="_blank" rel="noopener">#12459</a>).</p>
</li>
<li>
<p>Make the no argument constructors implicit.</p>
</li>
<li>
<p>Implement missing allocator aware constructors.</p>
</li>
<li>
<p>Fix assigning the hash/key equality functions for empty containers.</p>
</li>
<li>
<p>Remove unary/binary_function from the examples in the documentation.
They are removed in C++17.</p>
</li>
<li>
<p>Support 10 constructor arguments in emplace. It was meant to support up to 10
arguments, but an off by one error in the preprocessor code meant it only
supported up to 9.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_62_0"><a class="link" href="#changes_release_1_62_0">Release 1.62.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove use of deprecated <code>boost::iterator</code>.</p>
</li>
<li>
<p>Remove <code>BOOST_NO_STD_DISTANCE</code> workaround.</p>
</li>
<li>
<p>Remove <code>BOOST_UNORDERED_DEPRECATED_EQUALITY</code> warning.</p>
</li>
<li>
<p>Simpler implementation of assignment, fixes an exception safety issue
for <code>unordered_multiset</code> and <code>unordered_multimap</code>. Might be a little slower.</p>
</li>
<li>
<p>Stop using return value SFINAE which some older compilers have issues
with.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_58_0"><a class="link" href="#changes_release_1_58_0">Release 1.58.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove unnecessary template parameter from const iterators.</p>
</li>
<li>
<p>Rename private <code>iterator</code> typedef in some iterator classes, as it
confuses some traits classes.</p>
</li>
<li>
<p>Fix move assignment with stateful, propagate_on_container_move_assign
allocators (<a href="https://svn.boost.org/trac/boost/ticket/10777" target="_blank" rel="noopener">#10777</a>).</p>
</li>
<li>
<p>Fix rare exception safety issue in move assignment.</p>
</li>
<li>
<p>Fix potential overflow when calculating number of buckets to allocate
(<a href="https://github.com/boostorg/unordered/pull/4" target="_blank" rel="noopener">GitHub #4</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_57_0"><a class="link" href="#changes_release_1_57_0">Release 1.57.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix the <code>pointer</code> typedef in iterators (<a href="https://svn.boost.org/trac/boost/ticket/10672" target="_blank" rel="noopener">#10672</a>).</p>
</li>
<li>
<p>Fix Coverity warning
(<a href="https://github.com/boostorg/unordered/pull/2" target="_blank" rel="noopener">GitHub #2</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_56_0"><a class="link" href="#changes_release_1_56_0">Release 1.56.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix some shadowed variable warnings (<a href="https://svn.boost.org/trac/boost/ticket/9377" target="_blank" rel="noopener">#9377</a>).</p>
</li>
<li>
<p>Fix allocator use in documentation (<a href="https://svn.boost.org/trac/boost/ticket/9719" target="_blank" rel="noopener">#9719</a>).</p>
</li>
<li>
<p>Always use prime number of buckets for integers. Fixes performance
regression when inserting consecutive integers, although makes other
uses slower (<a href="https://svn.boost.org/trac/boost/ticket/9282" target="_blank" rel="noopener">#9282</a>).</p>
</li>
<li>
<p>Only construct elements using allocators, as specified in C++11 standard.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_55_0"><a class="link" href="#changes_release_1_55_0">Release 1.55.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Avoid some warnings (<a href="https://svn.boost.org/trac/boost/ticket/8851" target="_blank" rel="noopener">#8851</a>, <a href="https://svn.boost.org/trac/boost/ticket/8874" target="_blank" rel="noopener">#8874</a>).</p>
</li>
<li>
<p>Avoid exposing some detail functions via. ADL on the iterators.</p>
</li>
<li>
<p>Follow the standard by only using the allocators' construct and destroy
methods to construct and destroy stored elements. Don&#8217;t use them for internal
data like pointers.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_54_0"><a class="link" href="#changes_release_1_54_0">Release 1.54.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Mark methods specified in standard as <code>noexpect</code>. More to come in the next
release.</p>
</li>
<li>
<p>If the hash function and equality predicate are known to both have nothrow
move assignment or construction then use them.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_53_0"><a class="link" href="#changes_release_1_53_0">Release 1.53.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove support for the old pre-standard variadic pair constructors, and
equality implementation. Both have been deprecated since Boost 1.48.</p>
</li>
<li>
<p>Remove use of deprecated config macros.</p>
</li>
<li>
<p>More internal implementation changes, including a much simpler
implementation of <code>erase</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_52_0"><a class="link" href="#changes_release_1_52_0">Release 1.52.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Faster assign, which assigns to existing nodes where possible, rather than
creating entirely new nodes and copy constructing.</p>
</li>
<li>
<p>Fixed bug in <code>erase_range</code> (<a href="https://svn.boost.org/trac/boost/ticket/7471" target="_blank" rel="noopener">#7471</a>).</p>
</li>
<li>
<p>Reverted some of the internal changes to how nodes are created, especially
for C++11 compilers. 'construct' and 'destroy' should work a little better
for C++11 allocators.</p>
</li>
<li>
<p>Simplified the implementation a bit. Hopefully more robust.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_51_0"><a class="link" href="#changes_release_1_51_0">Release 1.51.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix construction/destruction issue when using a C++11 compiler with a
C++03 allocator (<a href="https://svn.boost.org/trac/boost/ticket/7100" target="_blank" rel="noopener">#7100</a>).</p>
</li>
<li>
<p>Remove a <code>try..catch</code> to support compiling without exceptions.</p>
</li>
<li>
<p>Adjust SFINAE use to try to support g++ 3.4 (<a href="https://svn.boost.org/trac/boost/ticket/7175" target="_blank" rel="noopener">#7175</a>).</p>
</li>
<li>
<p>Updated to use the new config macros.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_50_0"><a class="link" href="#changes_release_1_50_0">Release 1.50.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix equality for <code>unordered_multiset</code> and <code>unordered_multimap</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6857" target="_blank" rel="noopener">Ticket 6857</a>:
Implement <code>reserve</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6771" target="_blank" rel="noopener">Ticket 6771</a>:
Avoid gcc&#8217;s <code>-Wfloat-equal</code> warning.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6784" target="_blank" rel="noopener">Ticket 6784</a>:
Fix some Sun specific code.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6190" target="_blank" rel="noopener">Ticket 6190</a>:
Avoid gcc&#8217;s <code>-Wshadow</code> warning.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6905" target="_blank" rel="noopener">Ticket 6905</a>:
Make namespaces in macros compatible with <code>bcp</code> custom namespaces.
Fixed by Luke Elliott.</p>
</li>
<li>
<p>Remove some of the smaller prime number of buckets, as they may make
collisions quite probable (e.g. multiples of 5 are very common because
we used base 10).</p>
</li>
<li>
<p>On old versions of Visual C++, use the container library&#8217;s implementation
of <code>allocator_traits</code>, as it&#8217;s more likely to work.</p>
</li>
<li>
<p>On machines with 64 bit std::size_t, use power of 2 buckets, with Thomas
Wang&#8217;s hash function to pick which one to use. As modulus is very slow
for 64 bit values.</p>
</li>
<li>
<p>Some internal changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_49_0"><a class="link" href="#changes_release_1_49_0">Release 1.49.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix warning due to accidental odd assignment.</p>
</li>
<li>
<p>Slightly better error messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_48_0_major_update"><a class="link" href="#changes_release_1_48_0_major_update">Release 1.48.0 - Major update</a></h3>
<div class="paragraph">
<p>This is major change which has been converted to use Boost.Move&#8217;s move
emulation, and be more compliant with the C++11 standard. See the
<a href="#compliance">compliance section</a> for details.</p>
</div>
<div class="paragraph">
<p>The container now meets C++11&#8217;s complexity requirements, but to do so
uses a little more memory. This means that <code>quick_erase</code> and
<code>erase_return_void</code> are no longer required, they&#8217;ll be removed in a
future version.</p>
</div>
<div class="paragraph">
<p>C++11 support has resulted in some breaking changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Equality comparison has been changed to the C++11 specification.
In a container with equivalent keys, elements in a group with equal
keys used to have to be in the same order to be considered equal,
now they can be a permutation of each other. To use the old
behavior define the macro <code>BOOST_UNORDERED_DEPRECATED_EQUALITY</code>.</p>
</li>
<li>
<p>The behaviour of swap is different when the two containers to be
swapped has unequal allocators. It used to allocate new nodes using
the appropriate allocators, it now swaps the allocators if
the allocator has a member structure <code>propagate_on_container_swap</code>,
such that <code>propagate_on_container_swap::value</code> is true.</p>
</li>
<li>
<p>Allocator&#8217;s <code>construct</code> and <code>destroy</code> functions are called with raw
pointers, rather than the allocator&#8217;s <code>pointer</code> type.</p>
</li>
<li>
<p><code>emplace</code> used to emulate the variadic pair constructors that
appeared in early C++0x drafts. Since they were removed it no
longer does so. It does emulate the new <code>piecewise_construct</code>
pair constructors - only you need to use
<code>boost::piecewise_construct</code>. To use the old emulation of
the variadic constructors define
<code>BOOST_UNORDERED_DEPRECATED_PAIR_CONSTRUCT</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_45_0"><a class="link" href="#changes_release_1_45_0">Release 1.45.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix a bug when inserting into an <code>unordered_map</code> or <code>unordered_set</code> using
iterators which returns <code>value_type</code> by copy.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_43_0"><a class="link" href="#changes_release_1_43_0">Release 1.43.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3966" target="_blank" rel="noopener">Ticket 3966</a>:
<code>erase_return_void</code> is now <code>quick_erase</code>, which is the
<a href="http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#579" target="_blank" rel="noopener">
current forerunner for resolving the slow erase by iterator</a>, although
there&#8217;s a strong possibility that this may change in the future. The old
method name remains for backwards compatibility but is considered deprecated
and will be removed in a future release.</p>
</li>
<li>
<p>Use Boost.Exception.</p>
</li>
<li>
<p>Stop using deprecated <code>BOOST_HAS_*</code> macros.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_42_0"><a class="link" href="#changes_release_1_42_0">Release 1.42.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Support instantiating the containers with incomplete value types.</p>
</li>
<li>
<p>Reduced the number of warnings (mostly in tests).</p>
</li>
<li>
<p>Improved codegear compatibility.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3693" target="_blank" rel="noopener">Ticket 3693</a>:
Add <code>erase_return_void</code> as a temporary workaround for the current
<code>erase</code> which can be inefficient because it has to find the next
element to return an iterator.</p>
</li>
<li>
<p>Add templated find overload for compatible keys.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3773" target="_blank" rel="noopener">Ticket 3773</a>:
Add missing <code>std</code> qualifier to <code>ptrdiff_t</code>.</p>
</li>
<li>
<p>Some code formatting changes to fit almost all lines into 80 characters.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_41_0_major_update"><a class="link" href="#changes_release_1_41_0_major_update">Release 1.41.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>The original version made heavy use of macros to sidestep some of the older
compilers' poor template support. But since I no longer support those
compilers and the macro use was starting to become a maintenance burden it
has been rewritten to use templates instead of macros for the implementation
classes.</p>
</li>
<li>
<p>The container object is now smaller thanks to using <code>boost::compressed_pair</code>
for EBO and a slightly different function buffer - now using a bool instead
of a member pointer.</p>
</li>
<li>
<p>Buckets are allocated lazily which means that constructing an empty container
will not allocate any memory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_40_0"><a class="link" href="#changes_release_1_40_0">Release 1.40.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2975" target="_blank" rel="noopener">Ticket 2975</a>:
Store the prime list as a preprocessor sequence - so that it will always get
the length right if it changes again in the future.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/1978" target="_blank" rel="noopener">Ticket 1978</a>:
Implement <code>emplace</code> for all compilers.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2908" target="_blank" rel="noopener">Ticket 2908</a>,
<a href="https://svn.boost.org/trac/boost/ticket/3096" target="_blank" rel="noopener">Ticket 3096</a>:
Some workarounds for old versions of borland, including adding explicit
destructors to all containers.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3082" target="_blank" rel="noopener">Ticket 3082</a>:
Disable incorrect Visual C++ warnings.</p>
</li>
<li>
<p>Better configuration for C++0x features when the headers aren&#8217;t available.</p>
</li>
<li>
<p>Create less buckets by default.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_39_0"><a class="link" href="#changes_release_1_39_0">Release 1.39.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2756" target="_blank" rel="noopener">Ticket 2756</a>: Avoid a warning
on Visual C++ 2009.</p>
</li>
<li>
<p>Some other minor internal changes to the implementation, tests and
documentation.</p>
</li>
<li>
<p>Avoid an unnecessary copy in <code>operator[]</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2975" target="_blank" rel="noopener">Ticket 2975</a>: Fix length of
prime number list.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_38_0"><a class="link" href="#changes_release_1_38_0">Release 1.38.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Use <a href="../../../core/swap.html" target="_blank" rel="noopener"><code>boost::swap</code></a>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2237" target="_blank" rel="noopener">Ticket 2237</a>:
Document that the equality and inequality operators are undefined for two
objects if their equality predicates aren&#8217;t equivalent. Thanks to Daniel
Krügler.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/1710" target="_blank" rel="noopener">Ticket 1710</a>:
Use a larger prime number list. Thanks to Thorsten Ottosen and Hervé
Brönnimann.</p>
</li>
<li>
<p>Use
<a href="../../../type_traits/index.html" target="_blank" rel="noopener">aligned storage</a> to store the types.
This changes the way the allocator is used to construct nodes. It used to
construct the node with two calls to the allocator&#8217;s <code>construct</code>
method - once for the pointers and once for the value. It now constructs
the node with a single call to construct and then constructs the value using
in place construction.</p>
</li>
<li>
<p>Add support for C++0x initializer lists where they&#8217;re available (currently
only g++ 4.4 in C++0x mode).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_37_0"><a class="link" href="#changes_release_1_37_0">Release 1.37.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Rename overload of <code>emplace</code> with hint, to <code>emplace_hint</code> as specified in
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2691.pdf" target="_blank" rel="noopener">n2691</a>.</p>
</li>
<li>
<p>Provide forwarding headers at <code>&lt;boost/unordered/unordered_map_fwd.hpp&gt;</code> and
<code>&lt;boost/unordered/unordered_set_fwd.hpp&gt;</code>.</p>
</li>
<li>
<p>Move all the implementation inside <code>boost/unordered</code>, to assist
modularization and hopefully make it easier to track Release subversion.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_36_0"><a class="link" href="#changes_release_1_36_0">Release 1.36.0</a></h3>
<div class="paragraph">
<p>First official release.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rearrange the internals.</p>
</li>
<li>
<p>Move semantics - full support when rvalue references are available, emulated
using a cut down version of the Adobe move library when they are not.</p>
</li>
<li>
<p>Emplace support when rvalue references and variadic template are available.</p>
</li>
<li>
<p>More efficient node allocation when rvalue references and variadic template
are available.</p>
</li>
<li>
<p>Added equality operators.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_boost_1_35_0_add_on_31st_march_2008"><a class="link" href="#changes_boost_1_35_0_add_on_31st_march_2008">Boost 1.35.0 Add-on - 31st March 2008</a></h3>
<div class="paragraph">
<p>Unofficial release uploaded to vault, to be used with Boost 1.35.0. Incorporated
many of the suggestions from the review.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Improved portability thanks to Boost regression testing.</p>
</li>
<li>
<p>Fix lots of typos, and clearer text in the documentation.</p>
</li>
<li>
<p>Fix floating point to <code>std::size_t</code> conversion when calculating sizes from
the max load factor, and use <code>double</code> in the calculation for greater accuracy.</p>
</li>
<li>
<p>Fix some errors in the examples.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_review_version"><a class="link" href="#changes_review_version">Review Version</a></h3>
<div class="paragraph">
<p>Initial review version, for the review conducted from 7th December 2007 to
16th December 2007.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bibliography"><a class="link" href="#bibliography">Bibliography</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><em>C/C++ Users Journal</em>. February, 2006. Pete Becker. <a href="http://www.ddj.com/cpp/184402066" target="_blank" rel="noopener">STL and TR1: Part III - Unordered containers</a>.<br>
An introducation to the standard unordered containers.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright"><a class="link" href="#copyright">Copyright and License</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Daniel James</strong></p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2003, 2004 Jeremy B. Maitin-Shepard</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2005-2008 Daniel James</p>
</div>
<div class="paragraph">
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" class="bare">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div>
</div>
</div>
</div>
</body>
</html>