<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="Klemens Morgenstern">
<title>Documentation boost.cobalt</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Documentation boost.cobalt</h1>
<div class="details">
<span id="author" class="author">Klemens Morgenstern</span><br>
<span id="email" class="email"><a href="mailto:klemens.morgenstern@gmx.net">klemens.morgenstern@gmx.net</a></span><br>
<span id="revnumber">version 0.1,</span>
<span id="revdate">29.01.2023</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview">Overview</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#coroutine_primer">Coroutine Primer</a>
<ul class="sectlevel2">
<li><a href="#async_programming">Async programming</a></li>
<li><a href="#coroutines">Coroutines</a>
<ul class="sectlevel3">
<li><a href="#co_return"><code>co_return</code></a></li>
<li><a href="#co_await"><code>co_await</code></a></li>
<li><a href="#co_yield"><code>co_yield</code></a></li>
</ul>
</li>
<li><a href="#awaitables">Awaitables</a></li>
<li><a href="#event-loops">Event Loops</a></li>
</ul>
</li>
<li><a href="#tour">Tour</a>
<ul class="sectlevel2">
<li><a href="#entry_into_an_cobalt_environment">Entry into an cobalt environment</a></li>
<li><a href="#promises">Promises</a></li>
<li><a href="#tasks">Tasks</a></li>
<li><a href="#tour-generator">Generator</a></li>
<li><a href="#tour-join">join</a></li>
<li><a href="#tour-race">race</a></li>
</ul>
</li>
<li><a href="#tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#delay">delay</a></li>
<li><a href="#echo_server">echo server</a></li>
<li><a href="#price_ticker">price ticker</a></li>
<li><a href="#delay_op">delay op</a></li>
<li><a href="#generator_with_push_value">Generator with push value</a></li>
<li><a href="#advanced_examples">Advanced examples</a></li>
</ul>
</li>
<li><a href="#design">Design</a>
<ul class="sectlevel2">
<li><a href="#design:concepts">Concepts</a></li>
<li><a href="#executors">Executors</a>
<ul class="sectlevel3">
<li><a href="#using_strands">Using Strands</a></li>
</ul>
</li>
<li><a href="#polymorphic_memory_resource">polymorphic memory resource</a></li>
<li><a href="#cancellation">cancellation</a></li>
<li><a href="#design:promise">Promise</a></li>
<li><a href="#design:race">Select</a></li>
<li><a href="#design:interrupt_await">interrupt_await</a></li>
<li><a href="#associators">Associators</a></li>
<li><a href="#threading">Threading</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#main">cobalt/main.hpp</a>
<ul class="sectlevel3">
<li><a href="#executor">Executor</a></li>
<li><a href="#memory_resource">Memory Resource</a></li>
<li><a href="#main-promise">Promise</a></li>
<li><a href="#specification">Specification</a></li>
</ul>
</li>
<li><a href="#promise">cobalt/promise.hpp</a>
<ul class="sectlevel3">
<li><a href="#executor_2">Executor</a></li>
<li><a href="#memory_resource_2">Memory Resource</a></li>
<li><a href="#promise-outline">Outline</a></li>
<li><a href="#promise-promise">Promise</a></li>
</ul>
</li>
<li><a href="#generator">cobalt/generator.hpp</a>
<ul class="sectlevel3">
<li><a href="#initial">Lazy</a></li>
<li><a href="#generator-executor">Executor</a></li>
<li><a href="#generator-allocator">Memory Resource</a></li>
<li><a href="#generator-outline">Outline</a></li>
<li><a href="#generator-promise">Promise</a></li>
</ul>
</li>
<li><a href="#task">cobalt/task.hpp</a>
<ul class="sectlevel3">
<li><a href="#executor_3">Executor</a></li>
<li><a href="#memory_resource_3">Memory Resource</a></li>
<li><a href="#task-outline">Outline</a></li>
<li><a href="#task-task">Promise</a></li>
<li><a href="#use_task">use_task</a></li>
</ul>
</li>
<li><a href="#detached">cobalt/detached.hpp</a>
<ul class="sectlevel3">
<li><a href="#executor_4">Executor</a></li>
<li><a href="#memory_resource_4">Memory Resource</a></li>
<li><a href="#detached-outline">Outline</a></li>
<li><a href="#detached-detached">Promise</a></li>
</ul>
</li>
<li><a href="#cobalt_operation">cobalt/op.hpp</a>
<ul class="sectlevel3">
<li><a href="#use_op">use_op</a></li>
<li><a href="#op">Hand coded Operations</a></li>
</ul>
</li>
<li><a href="#concepts">cobalt/concepts.hpp</a>
<ul class="sectlevel3">
<li><a href="#awaitable">Awaitable</a></li>
<li><a href="#enable_awaitables">Enable awaitables</a></li>
</ul>
</li>
<li><a href="#this_coro">cobalt/this_coro.hpp</a>
<ul class="sectlevel3">
<li><a href="#enable_await_allocator">Await Allocator</a></li>
<li><a href="#enable_await_executor">Await Executor</a></li>
<li><a href="#promise_memory_resource_base">Memory resource base</a></li>
<li><a href="#promise_throw_if_cancelled_base">Throw if cancelled</a></li>
<li><a href="#promise_cancellation_base">Cancellation state</a></li>
</ul>
</li>
<li><a href="#this_thread">cobalt/this_thread.hpp</a></li>
<li><a href="#channel">cobalt/channel.hpp</a>
<ul class="sectlevel3">
<li><a href="#outline">Outline</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#with">cobalt/with.hpp</a></li>
<li><a href="#race">cobalt/race.hpp</a>
<ul class="sectlevel3">
<li><a href="#interrupt_await">Interrupt Wait</a></li>
<li><a href="#left_race"><code>left_race</code></a></li>
<li><a href="#race-outline">Outline</a></li>
</ul>
</li>
<li><a href="#gather">cobalt/gather.hpp</a>
<ul class="sectlevel3">
<li><a href="#gather-outline">Outline</a></li>
</ul>
</li>
<li><a href="#join">cobalt/join.hpp</a>
<ul class="sectlevel3">
<li><a href="#join-outline">Outline</a></li>
</ul>
</li>
<li><a href="#wait_group">cobalt/wait_group.hpp</a></li>
<li><a href="#spawn">cobalt/spawn.hpp</a>
<ul class="sectlevel3">
<li><a href="#example_2">Example</a></li>
</ul>
</li>
<li><a href="#run">cobalt/run.hpp</a>
<ul class="sectlevel3">
<li><a href="#run-outline">Outline</a></li>
<li><a href="#run-example">Example</a></li>
</ul>
</li>
<li><a href="#thread">cobalt/thread.hpp</a>
<ul class="sectlevel3">
<li><a href="#executor_5">Executor</a></li>
<li><a href="#memory_resource_5">Memory Resource</a></li>
<li><a href="#thread-outline">Outline</a></li>
<li><a href="#thread-promise">Promise</a></li>
</ul>
</li>
<li><a href="#result">cobalt/result.hpp</a></li>
<li><a href="#async_for">cobalt/async_for.hpp</a></li>
<li><a href="#error">cobalt/error.hpp</a></li>
<li><a href="#config">cobalt/config.hpp</a>
<ul class="sectlevel3">
<li><a href="#executor_type">executor_type</a></li>
<li><a href="#pmr">pmr</a></li>
</ul>
</li>
<li><a href="#leaf">cobalt/leaf.hpp</a></li>
</ul>
</li>
<li><a href="#in_depth">In-Depth</a>
<ul class="sectlevel2">
<li><a href="#custom_executors">Custom Executors</a>
<ul class="sectlevel3">
<li><a href="#definition">Definition</a>
<ul class="sectlevel4">
<li><a href="#execute"><code>execute</code></a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#properties_of_the_asioany_io_executor">Properties of the <code>asio::any_io_executor</code></a></li>
<li><a href="#the_blocking_property">The <code>blocking</code> property</a></li>
<li><a href="#the_relationship_property">The <code>relationship</code> property</a></li>
<li><a href="#the_outstanding_work_t_property">The <code>outstanding_work_t</code> property</a></li>
</ul>
</li>
<li><a href="#a_minimal_executor">A minimal executor</a></li>
<li><a href="#adding_a_work_guard">Adding a work guard.</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
</li>
<li><a href="#stackless">Stackless</a></li>
<li><a href="#lazy_eager">Lazy &amp; eager</a></li>
</ul>
</li>
<li><a href="#benchmarks">Benchmarks</a>
<ul class="sectlevel2">
<li><a href="#posting_to_an_executor">Posting to an executor</a></li>
<li><a href="#running_noop_coroutine_in_parallel">Running noop coroutine in parallel</a></li>
<li><a href="#immediate">Immediate</a></li>
<li><a href="#channels">Channels</a></li>
<li><a href="#operation_allocations">Operation Allocations</a></li>
</ul>
</li>
<li><a href="#requirements">Requirements</a>
<ul class="sectlevel2">
<li><a href="#libraries">Libraries</a></li>
<li><a href="#compiler">Compiler</a></li>
</ul>
</li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here&#8217;s a list of relevant features in cobalt:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Coroutine types</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#promise">promise</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An eager coroutine returning a single result- consider it the default</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#generator">generator</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An eager coroutine that can yield multiple values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#task">task</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A lazy version of <a href="#promise">promise</a> that can be spawned onto other executors.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#detached">detached</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A coroutine similar to promise, without a handle</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Synchronization Functions</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#race">race</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A function that waits for one coroutine out of a set that is ready in a pseudo-random way, to avoid starvation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#join">join</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A function that waits for a set of coroutines and returns all of them as value or throws an exception if any awaitable does so.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#gather">gather</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A function that waits for a set of coroutines and returns all of them as <code>result</code>, capturing all exceptions individually.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#left_race">left_race</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A deterministic <code>race</code> that evaluates left-to-right.</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Utilities</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#channel">channel</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A thread-local utility to send values between coroutines.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#with">with</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An async RAII helper, that allows async teardown when exceptions occur</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Reading guide</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 42.8571%;">
<col style="width: 42.8572%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#coroutine_primer">Coroutine Primer</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A short introduction to C++ coroutines</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read if you&#8217;ve never used coroutines before</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tour">Tour</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An abbreviated high level view of the features and concepts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read if you&#8217;re familiar with asio &amp; coroutines and want a rough idea what this library offers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tutorial">Tutorial</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low level view of usages</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read if you want to get coding quickly</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#reference">Reference</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">API reference</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Look up details while coding</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#technical_background">[technical_background]</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Some implementation details</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read if you&#8217;re not confused enough</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="motivation">Motivation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many languages programming languages
like node.js and python provide easy to use single-threaded concurrency frameworks.
While more complex than synchronous code,
single threaded asynchronicity avoids many of the pitfalls &amp; overhead of multi-threading.</p>
</div>
<div class="paragraph">
<p>That is, one coroutine can work, while others wait for events (e.g. a response from a server).
This allows to write applications that <strong>do multiple things simultaneously</strong> on a <strong>single thread</strong>.</p>
</div>
<div class="paragraph">
<p>This library is meant to provide this to C++: <strong>simple single threaded asynchronicity</strong>
akin to node.js and asyncio in python that works with existing libraries like
<code>boost.beast</code>, <code>boost.mysql</code> or <code>boost.redis</code>.
It based on <code>boost.asio</code>.</p>
</div>
<div class="paragraph">
<p>It takes a collection of concepts from other languages and provides them based on  C++20 coroutines.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>easy asynchronous base functions, such as an async <a href="#main">main</a> &amp; <a href="#thread">threads</a></p>
</li>
<li>
<p><a href="#promise">promise</a> &amp; <a href="#generator">generator</a> types</p>
</li>
<li>
<p><a href="#op">operation wrappers</a></p>
</li>
<li>
<p>an <a href="#with">async scope</a></p>
</li>
<li>
<p><a href="#race">race</a></p>
</li>
<li>
<p><a href="#channel">channel</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unlike <code>asio::awaitable</code> and <code>asio::experimental::coro</code>, <code>cobalt</code> coroutines are open.
That is, an <code>asio::awaitable</code> can only await and be awaited by other <code>asio::awaitable</code>
and does not provide coroutine specific synchronization mechanisms.</p>
</div>
<div class="paragraph">
<p><code>cobalt</code> on the other hand provides a coroutine specific <code>channel</code>
and different wait types (<code>race</code>, <code>gather</code> etc.) that are optimized
to work with coroutines and awaitables.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coroutine_primer">Coroutine Primer</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="async_programming">Async programming</h3>
<div class="paragraph">
<p>Asynchronous programming generally refers to a style of programming
that allows tasks to be run in the background, while the other works is performed.</p>
</div>
<div class="paragraph">
<p>Imagine if you will a get-request function that performs a
full http request including connecting &amp; ssl handshakes etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">http_get</span><span class="p">(</span><span class="n">std</span><span class="o">:</span><span class="n">string_view</span> <span class="n">url</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">http_get</span><span class="p">(</span><span class="s">"https://boost.org"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code would be traditional synchronous programming. If we want to perform
two requests in parallel we would need to create another thread to run another thread
with synchronous code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">http_get</span><span class="p">(</span><span class="n">std</span><span class="o">:</span><span class="n">string_view</span> <span class="n">url</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">other_res</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thr</span><span class="p">{[</span><span class="o">&amp;</span><span class="p">]{</span> <span class="n">other_res</span> <span class="o">=</span> <span class="n">http_get</span><span class="p">(</span><span class="s">"https://cppalliance.org"</span><span class="p">);</span> <span class="p">}};</span>
    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">http_get</span><span class="p">(</span><span class="s">"https://boost.org"</span><span class="p">);</span>
    <span class="n">thr</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">other_res</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This works, but our program will spend most of the time waiting for input.
Operating systems provide APIs that allow IO to be performed asynchronously,
and libraries such as <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio.html">boost.asio</a>
provide portable ways to manage asynchronous operations.
Asio itself does not dictate a way to handle the completions.
This library (boost.cobalt) provides a way to manage this all through coroutines/awaitables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">http_cobalt_get</span><span class="p">(</span><span class="n">std</span><span class="o">:</span><span class="n">string_view</span> <span class="n">url</span><span class="p">);</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="p">[</span><span class="n">res</span><span class="p">,</span> <span class="n">other_res</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">cobalt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span>
                <span class="n">http_cobalt_get</span><span class="p">((</span><span class="s">"https://boost.org"</span><span class="p">),</span>
                <span class="n">http_cobalt_get</span><span class="p">((</span><span class="s">"https://cppalliance.org"</span><span class="p">)</span>
            <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">other_res</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above code the asynchronous function to perform the request
takes advantage of the operating system APIs so that the actual IO doesn&#8217;t block.
This means that while we&#8217;re waiting for both functions to complete,
the operations are interleaved and non-blocking.
At the same time cobalt provides the coroutine primitives that keep us out of callback hell.</p>
</div>
</div>
<div class="sect2">
<h3 id="coroutines">Coroutines</h3>
<div class="paragraph">
<p>Coroutines are resumable functions.
Resumable means that a function can suspend,
i.e. pass the control back to the caller multiple times.</p>
</div>
<div class="paragraph">
<p>A regular function yields control back to the caller with the <code>return</code> function, where it also returns the value.</p>
</div>
<div class="paragraph">
<p>A coroutine on the other hand might yield control to the caller and get resumed multiple times.</p>
</div>
<div class="paragraph">
<p>A coroutine has three control keywords akin to co_return
(of which only <code>co_return</code> has to be supported).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>co_return</code></p>
</li>
<li>
<p><code>co_yield</code></p>
</li>
<li>
<p><code>co_await</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="co_return"><code>co_return</code></h4>
<div class="paragraph">
<p>This is similar to <code>return</code>, but marks the function as a coroutine.</p>
</div>
</div>
<div class="sect3">
<h4 id="co_await"><code>co_await</code></h4>
<div class="paragraph">
<p>The <code>co_await</code> expression suspends for an <a href="#awaitable">Awaitable</a>,
i.e. stops execution until the <code>awaitable</code> resumes it.</p>
</div>
<div class="paragraph">
<p>E.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">);</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>co_await</code> expression can yield a value, depending on what it is awaiting.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read_some</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">res</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">read_some</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In <code>cobalt</code> most coroutine primitives are also <a href="#awaitables">Awaitables</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="co_yield"><code>co_yield</code></h4>
<div class="paragraph">
<p>The <code>co_yield</code> expression is similar to the <code>co_await</code>,
but it yields control to the caller and carries a value.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iota</span><span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span>
    <span class="k">co_yield</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>

  <span class="k">co_return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>co_yield</code> expression can also produce a value,
which allows the user of yielding coroutine to push values into it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iota</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">more</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">do</span>
  <span class="p">{</span>
    <span class="n">more</span> <span class="o">=</span> <span class="k">co_yield</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">while</span><span class="p">(</span><span class="n">more</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Stackless</div>
<div class="paragraph">
<p>C++ coroutine are stack-less, which means they only allocate their own function frame.</p>
</div>
<div class="paragraph">
<p>See <a href="#stackless">Stackless</a> for more details.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="awaitables">Awaitables</h3>
<div class="paragraph">
<p>Awaitables are types that can be used in a <code>co_await</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">awaitable_prototype</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">();</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="n"><em>see_below</em></span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="n"><em>return_type</em></span>  <span class="n">await_resume</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Type will be implicitly converted into an awaitable if there is an <code>operator co_await</code> call available.
This documentation will use <code>awaitable</code> to include these types,
and "actual_awaitable" to refer to type conforming to the above prototype.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: mmdc failed:
Error: Failed to launch the browser process!
/root/.cache/puppeteer/chrome/linux-1108766/chrome-linux/chrome: error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory


TROUBLESHOOTING: https://pptr.dev/troubleshooting

    at Interface.onClose (file:///root/.nvm/versions/node/v18.18.1/lib/node_modules/@mermaid-js/mermaid-cli/node_modules/@puppeteer/browsers/lib/esm/launch.js:253:24)
    at Interface.emit (node:events:529:35)
    at Interface.close (node:internal/readline/interface:534:10)
    at Socket.onend (node:internal/readline/interface:260:10)
    at Socket.emit (node:events:529:35)
    at endReadableNT (node:internal/streams/readable:1368:12)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)


flowchart TD
    aw{await_ready?}
    aw ----&gt;|true| ar[await_resume]
    aw --&gt;|false| as[await_suspend]
    as --&gt;|Resume| ar</pre>
</div>
</div>
<div class="paragraph">
<p>In a <code>co_await</code> expression the waiting coroutine will first invoke
<code>await_ready</code> to check if the coroutine needs to suspend.
When ready, it goes directly to <code>await_resume</code> to get the value,
as there is no suspension needed.
Otherwise, it will suspend itself and call <code>await_suspend</code> with a
<code>std::coroutine_handle</code> to its own promise.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>std::coroutine_handle&lt;void&gt;</code> can be used for type erasure.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <em>return_type</em> is the result type of the <code>co_await expression</code>, e.g. <code>int</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">awaitable_with_int_result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The return type of the <code>await_suspend</code> can be three things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void</code></p>
</li>
<li>
<p><code>bool</code></p>
</li>
<li>
<p><code>std::coroutine_handle&lt;U&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If it is void the awaiting coroutine remains suspended. If it is <code>bool</code>,
the value will be checked, and if false, the awaiting coroutine will resume right away.</p>
</div>
<div class="paragraph">
<p>If a <code>std::coroutine_handle</code> is returned, this coroutine will be resumed.
The latter allows <code>await_suspend</code> to return the handle passed in,
being effectively the same as returning <code>false</code>.</p>
</div>
<div class="paragraph">
<p>If the awaiting coroutine gets re-resumed right away, i.e. after calling await_resume,
it is referred to as "immediate completion" within this library.
This is not to be confused with a non-suspending awaitable, i.e. one that returns <code>true</code> from <code>await_ready</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="event-loops">Event Loops</h3>
<div class="paragraph">
<p>Since the coroutines in <code>cobalt</code> can <code>co_await</code> events, they need to be run on an event-loop.
That is another piece of code is responsible for tracking outstanding event and resume a resuming coroutines that are awaiting them.
This pattern is very common and is used in a similar way by node.js or python&#8217;s <code>asyncio</code>.</p>
</div>
<div class="paragraph">
<p><code>cobalt</code> uses an <a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/reference/io_context.html"><code>asio::io_context</code></a>
as its default event loop. That is, the classes <a href="#thread">thread</a>, <a href="#main">main</a> and the <a href="#run">run</a> function
are using it internally.</p>
</div>
<div class="paragraph">
<p>You can use any event loop that can produce an <a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/reference/any_io_executor.html"><code>asio::any_io_executor</code></a>
with the library. The easiest way to achieve this is by using <a href="#spawn">spawn</a>.</p>
</div>
<div class="paragraph">
<p>The event loop is accessed through an executor (following the asio terminology) and can be manually set using <a href="#this_thread">set_executor</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tour">Tour</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="entry_into_an_cobalt_environment">Entry into an cobalt environment</h3>
<div class="paragraph">
<p>In order to use <a href="#awaitable">awaitables</a> we need to be able to <code>co_await</code> them, i.e. be within a coroutine.</p>
</div>
<div class="paragraph">
<p>We got four ways to achieve this:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#main">cobalt/main.hpp</a></dt>
<dd>
<p>replace <code>int main</code> with a coroutine</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// co_await things here</span>
    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#thread">cobalt/thread.hpp</a></dt>
<dd>
<p>create a thread for the asynchronous environments</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">my_thread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// co_await things here</span>
    <span class="k">co_return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">my_thread</span><span class="p">();</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#task">cobalt/task.hpp</a></dt>
<dd>
<p>create a task and run or spawn it</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">my_thread</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// co_await things here</span>
   <span class="k">co_return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">cobalt</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">my_task</span><span class="p">());</span> <span class="c1">// sync</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ctx</span><span class="p">;</span>
    <span class="n">cobalt</span><span class="o">::</span><span class="n">spawn</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">my_task</span><span class="p">(),</span> <span class="n">asio</span><span class="o">::</span><span class="n">detached</span><span class="p">);</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promises">Promises</h3>
<div class="paragraph">
<p><a href="#promise">Promises</a> are the recommended default coroutine type.
They&#8217;re eager and thus easily usable for ad-hoc concurrecy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_promise</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">co_await</span> <span class="n">do_the_thing</span><span class="p">();</span>
   <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// start the promise here</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">my_promise</span><span class="p">();</span>
    <span class="c1">// do something else here</span>
    <span class="k">co_await</span> <span class="n">do_the_other_thing</span><span class="p">();</span>
    <span class="c1">// wait for the promise to complete</span>
    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">co_wait</span> <span class="n">p</span><span class="p">;</span>

    <span class="k">co_return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tasks">Tasks</h3>
<div class="paragraph">
<p><a href="#task">Tasks</a> are lazy, which means they won&#8217;t do anything before awaited or spwaned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_task</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">co_await</span> <span class="n">do_the_thing</span><span class="p">();</span>
   <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// create the task here</span>
    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">my_task</span><span class="p">();</span>
    <span class="c1">// do something else here first</span>
    <span class="k">co_await</span> <span class="n">do_the_other_thing</span><span class="p">();</span>
    <span class="c1">// start and wait for the task to complete</span>
    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">co_wait</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">co_return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tour-generator">Generator</h3>
<div class="paragraph">
<p>A <a href="#generator">generator</a> is the only type in cobalt that can <code>co_yield</code> values.</p>
</div>
<div class="paragraph">
<p><a href="#generator">Generator</a> are eager by default. Unlike <a href="https://en.cppreference.com/w/cpp/coroutine/generator">std::generator</a>
the <code>cobalt::generator</code> can <code>co_await</code> and thus is asynchronous.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_generator</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">co_yield</span> <span class="n">i</span><span class="p">;</span>
   <span class="k">co_return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// create the generator</span>
    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">my_generator</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Generator %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">);</span>
    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Values can be pushed into the generator, that will be returned from the <code>co_yield</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_eager_push_generator</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
       <span class="n">value</span> <span class="o">=</span> <span class="k">co_yield</span> <span class="n">value</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">;</span>
   <span class="k">co_return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">quiet_NaN</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// create the generator</span>
    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">my_generator</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="c1">// result of 5</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.4</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <span class="c1">// result of 4</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// result of 3</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// result of 2</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// result of 1</span>

    <span class="c1">// we let the coroutine go out of scope while suspended</span>
    <span class="c1">// no need for another co_await of `g`</span>

    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A coroutine can also be made lazy using <a href="#initial"><code>this_coro::initial</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_eager_push_generator</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">this_coro</span><span class="o">::</span><span class="n">initial</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="k">co_yield</span> <span class="n">value</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">;</span>
    <span class="k">co_return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">quiet_NaN</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// create the generator</span>
    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">my_generator</span><span class="p">();</span> <span class="c1">// lazy, so the generator waits for the first pushed value</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="c1">// result of 5</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.4</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span> <span class="c1">// result of 4</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <span class="c1">// result of 3</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// result of 2</span>
    <span class="n">assert</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">==</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// result of 1</span>

    <span class="c1">// we let the coroutine go out of scope while suspended</span>
    <span class="c1">// no need for another co_await of `g`</span>

    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tour-join">join</h3>
<div class="paragraph">
<p>If multiple <a href="#awaitable">awaitables</a> work in parallel they can be awaited simultaneously with
<a href="#join">join</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_work</span><span class="p">();</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">more_work</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">some_work</span><span class="p">(),</span> <span class="n">more_work</span><span class="p">());</span>
    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tour-race">race</h3>
<div class="paragraph">
<p>If multiple <a href="#awaitable">awaitables</a> work in parallel,
but we want to be notified if either completes, we shall use <a href="#race">race</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_data_source</span><span class="p">();</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">another_data_source</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">g1</span> <span class="o">=</span> <span class="n">some_data_source</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">another_data_source</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">res1</span>    <span class="o">=</span> <span class="k">co_await</span> <span class="n">g1</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">res2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">g2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %f"</span><span class="p">,</span> <span class="n">res1</span> <span class="o">*</span> <span class="n">res2</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">g1</span> <span class="o">&amp;&amp;</span> <span class="n">g2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">variant2</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">nx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">race</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res1</span> <span class="o">=</span> <span class="n">variant2</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nx</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res2</span> <span class="o">=</span> <span class="n">variant2</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nx</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"New result: %f"</span><span class="p">,</span> <span class="n">res1</span> <span class="o">*</span> <span class="n">res2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>race</code> in this context will not cause any data loss.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="delay">delay</h3>
<div class="paragraph">
<p>Let&#8217;s start with the simplest example possible: a simple delay.</p>
</div>
<div class="listingblock">
<div class="title">example/delay.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">asio</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <i class="conum" data-value="2"></i><b>(2)</b>
                         <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))};</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span> <i class="conum" data-value="5"></i><b>(5)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <a href="#main">co_main</a> function defines an implicit <code>main</code> when used
and is the easiest way to set up an environment to run asynchronous code.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Take the executor from the current coroutine promise.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Use an argument to set the timeout</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Perform the wait by using <a href="#use_op">cobalt::use_op</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Return a value that gets returned from the implicit main.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this example we use the <a href="#main">cobalt/main.hpp</a> header, which provides us with a main coroutine if <code>co_main</code>
is defined as above. This has a few advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The environment get set up correctly (<code>executor</code> &amp; <code>memory</code>)</p>
</li>
<li>
<p>asio is signaled that the context is single threaded</p>
</li>
<li>
<p>an <code>asio::signal_set</code> with <code>SIGINT</code> &amp; <code>SIGTERM</code> is automatically connected to cancellations (i.e. <code>Ctrl+C</code> causes cancellations)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This coroutine then has an executor in its promise (the promise the C++ name for a coroutine state.
Not to be confused with <a href="#promise">cobalt/promise.hpp</a>) which we can obtain through the dummy-<a href="#awaitable">awaitable</a>s in
the <a href="#this_coro">this_coro</a> namespace.</p>
</div>
<div class="paragraph">
<p>We can then construct a timer and initiate the <code>async_wait</code> with <a href="#use_op">use_op</a>.
<code>cobalt</code> provides multiple ways to <code>co_await</code> to interact with asio, of which <a href="#use_op">use_op</a> is the easiest.</p>
</div>
</div>
<div class="sect2">
<h3 id="echo_server">echo server</h3>
<div class="paragraph">
<p>We&#8217;ll be using the <code>use_op</code> (<a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/overview/model/completion_tokens.html">asio completion</a>) token everywhere,
so we&#8217;re using a <a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.default_completion_tokens">default completion token</a>, so that we can skip the last parameters.</p>
</div>
<div class="listingblock">
<div class="title">example/echo_server.cpp declarations</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">namespace</span> <span class="n">cobalt</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">cobalt</span><span class="p">;</span>
<span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="p">;</span>
<span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detached</span><span class="p">;</span>
<span class="k">using</span> <span class="n">tcp_acceptor</span> <span class="o">=</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">use_op_t</span><span class="o">::</span><span class="n">as_default_on_t</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">::</span><span class="n">acceptor</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">tcp_socket</span>   <span class="o">=</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">use_op_t</span><span class="o">::</span><span class="n">as_default_on_t</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">this_coro</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re writing the echo function as a <a href="#promise">promise</a> coroutine.
It&#8217;s an eager coroutine and recommended as the default;
in case a lazy coro is needed, <a href="#task">task</a> is available.</p>
</div>
<div class="listingblock">
<div class="title">example/echo_server.cpp echo function</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">echo</span><span class="p">(</span><span class="n">tcp_socket</span> <span class="n">socket</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">try</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">socket</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">socket</span><span class="p">.</span><span class="n">async_read_some</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">));</span> <i class="conum" data-value="3"></i><b>(3)</b>
      <span class="k">co_await</span> <span class="n">async_write</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"echo: exception: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When using the use_op completion token, I/O errors are translated into C++ exceptions. Additionally,
if the coroutine gets cancelled (e.g. because the user hit Ctrl-C),
an exception will be raised, too. Under these conditions, we print the error and exit the loop.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We run the loop until we get cancelled (exception) or the user closes the connection.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Read as much as is available.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Write all the read bytes.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that promise is eager. Calling <code>echo</code> will immediately execute code until <code>async_read_some</code>
and then return control to the caller.</p>
</div>
<div class="paragraph">
<p>Next, we also need an acceptor function. Here, we&#8217;re using a <a href="#generator">generator</a> to manage the acceptor state.
This is a coroutine that can be co_awaited multiple times, until a <code>co_return</code> expression is reached.</p>
</div>
<div class="listingblock">
<div class="title">example/echo_server.cpp listen function</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">tcp_socket</span><span class="o">&gt;</span> <span class="n">listen</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">tcp_acceptor</span> <span class="n">acceptor</span><span class="p">({</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">},</span> <span class="p">{</span><span class="n">tcp</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="mi">55555</span><span class="p">});</span>
  <span class="k">for</span> <span class="p">(;;)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="n">tcp_socket</span> <span class="n">sock</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">acceptor</span><span class="p">.</span><span class="n">async_accept</span><span class="p">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">co_yield</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">}</span>
  <span class="k">co_return</span> <span class="n">tcp_socket</span><span class="p">{</span><span class="n">acceptor</span><span class="p">.</span><span class="n">get_executor</span><span class="p">()};</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Cancellation will also lead to an exception here being thrown from the <code>co_await</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Asynchronously accept the connection</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Yield it to the awaiting coroutine</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>co_return</code> a value for C++ conformance.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With those two functions we can now write the server:</p>
</div>
<div class="listingblock">
<div class="title">example/echo_server.cpp run_server function</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">run_server</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">wait_group</span> <span class="o">&amp;</span> <span class="n">workers</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">l</span> <span class="o">=</span> <span class="n">listen</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">workers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">10u</span><span class="p">)</span>
      <span class="k">co_await</span> <span class="n">workers</span><span class="p">.</span><span class="n">wait_one</span><span class="p">();</span>  <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">else</span>
      <span class="n">workers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">echo</span><span class="p">(</span><span class="k">co_await</span> <span class="n">l</span><span class="p">));</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Construct the listener generator coroutine. When the object is destroyed,
the coroutine will be cancelled, performing all required cleanup.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When we have more than 10 workers, we wait for one to finish</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Accept a new connection &amp; launch it.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <a href="#wait_group">wait_group</a> is used to manage the running echo functions.
This class will cancel &amp; await the running <code>echo</code> coroutines.</p>
</div>
<div class="paragraph">
<p>We do not need to do the same for the <code>listener</code>, because it will just stop on its own, when <code>l</code> gets destroyed.
The destructor of a generator will cancel it.</p>
</div>
<div class="paragraph">
<p>Since the <code>promise</code> is eager, just calling it is enough to launch.
We then put those promises into a <a href="#wait_group">wait_group</a> which will allow us to tear down all the workers on scope exit.</p>
</div>
<div class="listingblock">
<div class="title">example/echo_server.cpp co_main function</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">with</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">wait_group</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">run_server</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_return</span> <span class="mi">0u</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run <code>run_server</code> with an async scope.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <a href="#with">with</a> function shown above, will run a function with a resource such as <a href="#wait_group">wait_group</a>.
On scope exit <code>with</code> will invoke &amp; <code>co_await</code> an asynchronous teardown function.
This will cause all connections to be properly shutdown before <code>co_main</code> exists.</p>
</div>
</div>
<div class="sect2">
<h3 id="price_ticker">price ticker</h3>
<div class="paragraph">
<p>To demonstrate <code>channels</code> and other tools, we need a certain complexity.
For that purpose our project is a price ticker, that connects to
<a href="https://blockchain.info" class="bare">https://blockchain.info</a>. A user can then connection to localhost
to query a given currency pair, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash">wscat <span class="nt">-c</span> localhost:8080/btc/usd</code></pre>
</div>
</div>
<div class="paragraph">
<p>First we do the same declarations as echo-server.</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp declarations</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">using</span> <span class="n">executor_type</span> <span class="o">=</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">use_op_t</span><span class="o">::</span><span class="n">executor_with_default</span><span class="o">&lt;</span><span class="n">cobalt</span><span class="o">::</span><span class="n">executor</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">socket_type</span>   <span class="o">=</span> <span class="k">typename</span> <span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span><span class="o">::</span><span class="n">rebind_executor</span><span class="o">&lt;</span><span class="n">executor_type</span><span class="o">&gt;::</span><span class="n">other</span><span class="p">;</span>
<span class="k">using</span> <span class="n">acceptor_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">acceptor</span><span class="o">::</span><span class="n">rebind_executor</span><span class="o">&lt;</span><span class="n">executor_type</span><span class="o">&gt;::</span><span class="n">other</span><span class="p">;</span>
<span class="k">using</span> <span class="n">websocket_type</span> <span class="o">=</span> <span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">ssl</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">socket_type</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">http</span> <span class="o">=</span> <span class="n">beast</span><span class="o">::</span><span class="n">http</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to write a function to connect an ssl-stream,
to connect upstream:</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp connect</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">ssl</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">socket_type</span><span class="o">&gt;&gt;</span> <span class="n">connect</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">host</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">ssl</span><span class="o">::</span><span class="n">context</span> <span class="o">&amp;</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span> <span class="n">res</span><span class="p">{</span><span class="n">cobalt</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_executor</span><span class="p">()};</span>
    <span class="k">auto</span> <span class="n">ep</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">res</span><span class="p">.</span><span class="n">async_resolve</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="s">"https"</span><span class="p">,</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="n">asio</span><span class="o">::</span><span class="n">ssl</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">socket_type</span><span class="o">&gt;</span> <span class="n">sock</span><span class="p">{</span><span class="n">cobalt</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_executor</span><span class="p">(),</span> <span class="n">ctx</span><span class="p">};</span>
    <span class="k">co_await</span> <span class="n">sock</span><span class="p">.</span><span class="n">next_layer</span><span class="p">().</span><span class="n">async_connect</span><span class="p">(</span><span class="o">*</span><span class="n">ep</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">co_await</span> <span class="n">sock</span><span class="p">.</span><span class="n">async_handshake</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">ssl</span><span class="o">::</span><span class="n">stream_base</span><span class="o">::</span><span class="n">client</span><span class="p">);</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="k">co_return</span> <span class="n">sock</span><span class="p">;</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lookup the host</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Connect to the endpoint</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Do the ssl handshake</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Return the socket to the caller</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we&#8217;ll need a function to do the websocket upgrade
on an existing ssl-stream.</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp connect_to_blockchain_info</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">connect_to_blockchain_info</span><span class="p">(</span><span class="n">websocket_type</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
 <span class="n">ws</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">stream_base</span><span class="o">::</span><span class="n">decorator</span><span class="p">(</span>
     <span class="p">[](</span><span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">request_type</span><span class="o">&amp;</span> <span class="n">req</span><span class="p">)</span>
     <span class="p">{</span>
       <span class="n">req</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">http</span><span class="o">::</span><span class="n">field</span><span class="o">::</span><span class="n">user_agent</span><span class="p">,</span>
               <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">BOOST_BEAST_VERSION_STRING</span><span class="p">)</span> <span class="o">+</span> <span class="s">" cobalt-ticker"</span><span class="p">);</span>
       <span class="n">req</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">http</span><span class="o">::</span><span class="n">field</span><span class="o">::</span><span class="n">origin</span><span class="p">,</span>
               <span class="s">"https://exchange.blockchain.com"</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
     <span class="p">}));</span>

 <span class="k">co_await</span> <span class="n">ws</span><span class="p">.</span><span class="n">async_handshake</span><span class="p">(</span><span class="s">"ws.blockchain.info"</span><span class="p">,</span> <span class="s">"/mercury-gateway/v1/ws"</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>blockchain.info</code> requires this header to be set.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Perform the websocket handshake.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the websocket is connected, we want to continuously receive json messages,
for which a generator is a good choice.</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp json_read</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">json</span><span class="o">::</span><span class="n">object</span><span class="o">&gt;</span> <span class="n">json_reader</span><span class="p">(</span><span class="n">websocket_type</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">)</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">beast</span><span class="o">::</span><span class="n">flat_buffer</span> <span class="n">buf</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ws</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">ws</span><span class="p">.</span><span class="n">async_read</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="n">json</span><span class="o">::</span><span class="n">string_view</span> <span class="n">data</span><span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">cdata</span><span class="p">().</span><span class="n">data</span><span class="p">()),</span> <span class="n">sz</span><span class="p">};</span>
        <span class="k">auto</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">json</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">co_yield</span> <span class="n">obj</span><span class="p">.</span><span class="n">as_object</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="n">buf</span><span class="p">.</span><span class="n">consume</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">co_return</span> <span class="p">{};</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error reading: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Keep running as long as the socket is open</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Read a frame from the websocket</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Parse &amp; <code>co_yield</code> it as an object.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This then needs to be connected to subscriber, for which we&#8217;ll utilize channels to pass raw json.
To make life-time management easy, the subscriber will hold a <code>shared_ptr</code>, and the producer a <code>weak_ptr</code>.</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp subscription types</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">using</span> <span class="n">subscription</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="n">json</span><span class="o">::</span><span class="n">object</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">subscription_channel</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="n">json</span><span class="o">::</span><span class="n">object</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">subscription_map</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">subscription_channel</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main function running the blockchain connector, operates on two inputs:
data coming from the websocket and a channel to handle new subscriptions.</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp run blockchain_info</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">run_blockchain_info</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="n">subscription</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">subc</span><span class="p">)</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">ssl</span><span class="o">::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">{</span><span class="n">asio</span><span class="o">::</span><span class="n">ssl</span><span class="o">::</span><span class="n">context_base</span><span class="o">::</span><span class="n">tls_client</span><span class="p">};</span>
    <span class="n">websocket_type</span> <span class="n">ws</span><span class="p">{</span><span class="k">co_await</span> <span class="n">connect</span><span class="p">(</span><span class="s">"blockchain.info"</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)};</span>
    <span class="k">co_await</span> <span class="n">connect_to_blockchain_info</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="n">subscription_map</span> <span class="n">subs</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">unconfirmed</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">json_reader</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">while</span> <span class="p">(</span><span class="n">ws</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="k">auto</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">race</span><span class="p">(</span><span class="n">rd</span><span class="p">,</span> <span class="n">subc</span><span class="p">.</span><span class="n">read</span><span class="p">());</span> <span class="n">msg</span><span class="p">.</span><span class="n">index</span><span class="p">())</span> <i class="conum" data-value="4"></i><b>(4)</b>
      <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <i class="conum" data-value="5"></i><b>(5)</b>
          <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ms</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
              <span class="n">ms</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">"event"</span><span class="p">)</span> <span class="o">==</span> <span class="s">"rejected"</span><span class="p">)</span> <span class="c1">// invalid sub, cancel however subbed</span>
            <span class="k">co_await</span> <span class="n">handle_rejections</span><span class="p">(</span><span class="n">unconfirmed</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span> <span class="n">ms</span><span class="p">);</span>
          <span class="k">else</span>
            <span class="k">co_await</span> <span class="n">handle_update</span><span class="p">(</span><span class="n">unconfirmed</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">ws</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">// </span><i class="conum" data-value="6"></i><b>(6)</b>
            <span class="k">co_await</span> <span class="n">handle_new_subscription</span><span class="p">(</span>
                <span class="n">unconfirmed</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">)),</span> <span class="n">ws</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="p">[</span><span class="n">k</span> <span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">:</span> <span class="n">subs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span>
            <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Exception: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initialize the connection</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Instantiate the json_reader</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Run as long as the websocket is open</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Select, i.e. wait for either a new json message or subscription</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>When it&#8217;s a json handle an update or a rejection</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Handle new subscription messages</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>handle_*</code> function&#8217;s contents are not as important for the <code>cobalt</code> functionality,
so it&#8217;s skipped in this tutorial.</p>
</div>
<div class="paragraph">
<p>The <code>handle_new_subscription</code> function sends a message to the <code>blockchain.info</code>,
which will send a confirmation or rejection back.
The <code>handle_rejection</code> and <code>handle_update</code> will take the json values
and forward them to the subscription channel.</p>
</div>
<div class="paragraph">
<p>On the consumer side, our server will just forward data to the client.
If the client inputs data, we&#8217;ll close the websocket immediately.
We&#8217;re using <code>as_tuple</code> to ignore potential errors.</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp read and close</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">read_and_close</span><span class="p">(</span><span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">socket_type</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">st</span><span class="p">,</span> <span class="n">beast</span><span class="o">::</span><span class="n">flat_buffer</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
    <span class="k">co_await</span> <span class="n">st</span><span class="p">.</span><span class="n">async_read</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">as_tuple</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">));</span>
    <span class="k">co_await</span> <span class="n">st</span><span class="p">.</span><span class="n">async_close</span><span class="p">(</span><span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">close_code</span><span class="o">::</span><span class="n">going_away</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">as_tuple</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">));</span>
    <span class="n">st</span><span class="p">.</span><span class="n">next_layer</span><span class="p">().</span><span class="n">close</span><span class="p">(</span><span class="n">ec</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we&#8217;re running the session that the users sends</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp run_session</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">run_session</span><span class="p">(</span><span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">socket_type</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">,</span>
                                 <span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="n">subscription</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">subc</span><span class="p">)</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">http</span><span class="o">::</span><span class="n">request</span><span class="o">&lt;</span><span class="n">http</span><span class="o">::</span><span class="n">empty_body</span><span class="o">&gt;</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">beast</span><span class="o">::</span><span class="n">flat_buffer</span> <span class="n">buf</span><span class="p">;</span>
    <span class="k">co_await</span> <span class="n">http</span><span class="o">::</span><span class="n">async_read</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">next_layer</span><span class="p">(),</span> <span class="n">buf</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="c1">// check the target</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">urls</span><span class="o">::</span><span class="n">parse_uri_reference</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">target</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">has_error</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">segments</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2u</span><span class="p">))</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="p">{</span>
        <span class="n">http</span><span class="o">::</span><span class="n">response</span><span class="o">&lt;</span><span class="n">http</span><span class="o">::</span><span class="n">string_body</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">{</span><span class="n">http</span><span class="o">::</span><span class="n">status</span><span class="o">::</span><span class="n">bad_request</span><span class="p">,</span> <span class="mi">11</span><span class="p">};</span>
        <span class="n">res</span><span class="p">.</span><span class="n">body</span><span class="p">()</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">has_error</span><span class="p">()</span> <span class="o">?</span> <span class="n">r</span><span class="p">.</span><span class="n">error</span><span class="p">().</span><span class="n">message</span><span class="p">()</span> <span class="o">:</span>
                    <span class="s">"url needs two segments, e.g. /btc/usd"</span><span class="p">;</span>
        <span class="k">co_await</span> <span class="n">http</span><span class="o">::</span><span class="n">async_write</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">next_layer</span><span class="p">(),</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">st</span><span class="p">.</span><span class="n">next_layer</span><span class="p">().</span><span class="n">close</span><span class="p">();</span>
        <span class="k">co_return</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="k">co_await</span> <span class="n">st</span><span class="p">.</span><span class="n">async_accept</span><span class="p">(</span><span class="n">req</span><span class="p">);</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="k">auto</span> <span class="n">sym</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">segments</span><span class="p">().</span><span class="n">front</span><span class="p">())</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span>
               <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">segments</span><span class="p">().</span><span class="n">back</span><span class="p">());</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">algorithm</span><span class="o">::</span><span class="n">to_upper</span><span class="p">(</span><span class="n">sym</span><span class="p">);</span>
    <span class="c1">// close when data gets sent</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">read_and_close</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span> <i class="conum" data-value="4"></i><b>(4)</b>

    <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="n">json</span><span class="o">::</span><span class="n">object</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1u</span><span class="p">);</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="k">co_await</span> <span class="n">subc</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">subscription</span><span class="p">{</span><span class="n">sym</span><span class="p">,</span> <span class="n">ptr</span><span class="p">});</span> <i class="conum" data-value="6"></i><b>(6)</b>

    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">is_open</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <i class="conum" data-value="7"></i><b>(7)</b>
    <span class="p">{</span>
      <span class="k">auto</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">json</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="k">co_await</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">());</span>
      <span class="k">co_await</span> <span class="n">st</span><span class="p">.</span><span class="n">async_write</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">bb</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">co_await</span> <span class="n">st</span><span class="p">.</span><span class="n">async_close</span><span class="p">(</span><span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">close_code</span><span class="o">::</span><span class="n">going_away</span><span class="p">,</span>
                            <span class="n">asio</span><span class="o">::</span><span class="n">as_tuple</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">));</span> <i class="conum" data-value="8"></i><b>(8)</b>
    <span class="n">st</span><span class="p">.</span><span class="n">next_layer</span><span class="p">().</span><span class="n">close</span><span class="p">();</span>
    <span class="k">co_await</span> <span class="n">p</span><span class="p">;</span> <i class="conum" data-value="9"></i><b>(9)</b>

<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Session ended with exception: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Read the http request, because we want the path</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Check the path, e.g. <code>/btc/usd</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Accept the websocket</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Start reading &amp; close if the consumer sends something</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Create the channel to receive updates</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Send a subscription requests to <code>run_blockchain_info</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>While the channel &amp; websocket are open, we&#8217;re forwarding data.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Close the socket &amp; ignore the error</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Since the websocket is surely closed by now, wait for the read_and_close to close.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With <code>run_session</code> and <code>run_blockchain_info</code> written, we can not move on to main:</p>
</div>
<div class="listingblock">
<div class="title">example/ticker.cpp main</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">acceptor_type</span> <span class="n">acc</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span>
                      <span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">endpoint</span> <span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="mi">8080</span><span class="p">)};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Listening on localhost:8080"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// allow 10 ongoing sessions</span>
    <span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="n">subscription</span><span class="o">&gt;</span> <span class="n">sub_manager</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="k">co_await</span> <span class="n">join</span><span class="p">(</span> <i class="conum" data-value="2"></i><b>(2)</b>
      <span class="n">run_blockchain_info</span><span class="p">(</span><span class="n">sub_manager</span><span class="p">),</span>
      <span class="n">cobalt</span><span class="o">::</span><span class="n">with</span><span class="p">(</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="n">cobalt</span><span class="o">::</span><span class="n">wait_group</span><span class="p">(</span>
            <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span>
            <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cobalt</span><span class="o">::</span><span class="n">wait_group</span> <span class="o">&amp;</span> <span class="n">sessions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
        <span class="p">{</span>
          <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">cancelled</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
          <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sessions</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
              <span class="k">co_await</span> <span class="n">sessions</span><span class="p">.</span><span class="n">wait_one</span><span class="p">();</span>

            <span class="k">auto</span> <span class="n">conn</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">acc</span><span class="p">.</span><span class="n">async_accept</span><span class="p">();</span> <i class="conum" data-value="6"></i><b>(6)</b>
            <span class="n">sessions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <i class="conum" data-value="7"></i><b>(7)</b>
                <span class="n">run_session</span><span class="p">(</span>
                    <span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">socket_type</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">conn</span><span class="p">)},</span>
                    <span class="n">sub_manager</span><span class="p">));</span>
          <span class="p">}</span>
        <span class="p">})</span>
      <span class="p">);</span>

    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create the channel to manage subscriptions</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use <code>join</code> to run both tasks in parallel.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Use an cobalt scope to provide a <code>wait_group</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Run until cancelled.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>When we&#8217;ve reached the <code>limit</code> we wait for one task to complete.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Wait for a new connection.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Insert the session into the <code>wait_group</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Main is using <code>join</code> because one task failing should cancel the other one.</p>
</div>
</div>
<div class="sect2">
<h3 id="delay_op">delay op</h3>
<div class="paragraph">
<p>We&#8217;ve used the <code>use_op</code> so far, to use an implicit operation based on asio&#8217;s completion token mechanic.</p>
</div>
<div class="paragraph">
<p>We can however implement our own ops, that can also utilize the <code>await_ready</code> optimization.
Unlike immediate completion, the coroutine will never suspend when <code>await_ready</code> returns true.</p>
</div>
<div class="paragraph">
<p>To leverage this coroutine feature, <code>cobalt</code> provides an easy way to create a skipable operation:</p>
</div>
<div class="listingblock">
<div class="title">example/delay_op.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">wait_op</span> <span class="k">final</span> <span class="o">:</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">op</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="o">&amp;</span> <span class="n">tim</span><span class="p">;</span>
  <span class="n">wait_op</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="o">&amp;</span> <span class="n">tim</span><span class="p">)</span> <span class="o">:</span> <span class="n">tim</span><span class="p">(</span><span class="n">tim</span><span class="p">)</span> <span class="p">{}</span>
  <span class="kt">void</span> <span class="n">ready</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">handler</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="n">h</span> <span class="p">)</span> <span class="k">override</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tim</span><span class="p">.</span><span class="n">expiry</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">())</span>
      <span class="n">h</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">{});</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">initiate</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">completion_handler</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="n">complete</span><span class="p">)</span> <span class="k">override</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">{</span>
    <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">complete</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span>


<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">asio</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span>
                         <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))};</span>
  <span class="k">co_await</span> <span class="n">wait_op</span><span class="p">(</span><span class="n">tim</span><span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare the op. We inherit <code>op</code> to make it awaitable.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The pre-suspend check is implemented here</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Do the wait if we need to</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Use the <a href="#op">op</a> just like any other awaitable.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This way we can minimize the amounts of coroutine suspensions.</p>
</div>
<div class="paragraph">
<p>While the above is used with asio, you can also use these handlers
with any other callback based code.</p>
</div>
</div>
<div class="sect2">
<h3 id="generator_with_push_value">Generator with push value</h3>
<div class="paragraph">
<p>Coroutines with push values are not as common,
but can simplify certain issues significantly.</p>
</div>
<div class="paragraph">
<p>Since we&#8217;ve already got a json_reader in the previous example,
here&#8217;s how we can write a json_writer that gets values pushed in.</p>
</div>
<div class="paragraph">
<p>The advantage of using a generator is the internal state management.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">json</span><span class="o">::</span><span class="n">object</span><span class="o">&gt;</span>
    <span class="n">json_writer</span><span class="p">(</span><span class="n">websocket_type</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">)</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="n">json</span><span class="o">::</span><span class="n">serializer</span> <span class="n">ser</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">ws</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="k">co_yield</span> <span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">{};</span> <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ser</span><span class="p">.</span><span class="n">done</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">ser</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
            <span class="k">co_await</span> <span class="n">ws</span><span class="p">.</span><span class="n">cobalt_write</span><span class="p">({</span><span class="n">sv</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">sv</span><span class="p">.</span><span class="n">size</span><span class="p">()});</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">co_return</span> <span class="p">{};</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">co_return</span> <span class="n">e</span><span class="p">.</span><span class="n">code</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error reading: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Keep running as long as the socket is open</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>co_yield</code> the current error and retrieve a new value.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Write a frame to the websocket</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can use the generator like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">json_writer</span><span class="p">(</span><span class="n">my_ws</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">json</span><span class="o">::</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">to_write</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span> <span class="n">tw</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">to_write</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ec</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tw</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ec</span><span class="p">;</span> <span class="c1">// yield error</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced_examples">Advanced examples</h3>
<div class="paragraph">
<p>More examples are provided in the repository as code only. All examples are listed below.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. All examples</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/http.cpp">example/http.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An http client that performs a single http get request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/outcome.cpp">example/outcome.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Using the <code>boost.outcome</code> coroutine types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/python.cpp">example/python.cpp</a> &amp; <a href="https://github.com/boostorg/cobalt/tree/master/example/python.py">example/python.py</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Using nanobind to integrate cobalt with python.
It uses python&#8217;s asyncio as executor and allows C++ to co_await python functions et vice versa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/signals.cpp">example/signals.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adopting <code>boost.signals2</code> into an awaitable type (single threaded).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/spsc.cpp">example/spsc.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creating a <code>boost.lockfree</code> based &amp; awaitable <code>spsc_queue</code> (multi threaded).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/thread.cpp">example/thread.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Using worker threads with <code>asio&#8217;s `concurrent_channel</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/thread_pool.cpp">example/thread_pool.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Using an <code>asio::thread_pool</code> and spawning <a href="#task">tasks</a> onto them.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/delay.cpp">example/delay.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The example used by the <a href="#delay">delay</a> section</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/delay_op.cpp">example/delay_op.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The example used by the <a href="#delay_op">delay op</a> section</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/echo_server.cpp">example/echo_server.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The example used by the <a href="#echo_server">echo server</a> section</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/ticker.cpp">example/ticker.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The example used by the <a href="#price_ticker">price ticker</a> section</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/boostorg/cobalt/tree/master/example/channel.cpp">example/channel.cpp</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The example used by the <a href="#channel">channel</a> reference</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="design">Design</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="design:concepts">Concepts</h3>
<div class="paragraph">
<p>This library has two fundamental concepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#awaitable">awaitable</a></p>
</li>
<li>
<p>coroutine</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <a href="#awaitable">awaitable</a> is an expression that can be used with <code>co_await</code>
from within a coroutine, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="nf">delay</span><span class="p">(</span><span class="mx">50ms</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, a coroutine promise can define an <code>await_transform</code>,
i.e. what is actually valid to use with <code>co_await</code> expression depends on the coroutine.</p>
</div>
<div class="paragraph">
<p>Thus, we should redefine what an <a href="#awaitable">awaitable</a> is:
An <strong>awaitable</strong> is a type that can be <code>co_await</code>-ed from within a coroutine,
which promise does not define <code>await_transform</code>.</p>
</div>
<div class="paragraph">
<p>A <code>pseudo-keyword</code> is a type that can be used in a coroutines that is adds special
functionality for it due to its promise <code>await_transform</code>.</p>
</div>
<div class="paragraph">
<p>All the verbs in the <a href="#this_coro">this_coro</a> namespace are such pseudo-keywords.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">exec</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This library exposes a set of <code>enable_*</code> base classes for promises,
to make the creation of custom coroutines easy.
This includes the <a href="#enable_awaitables">enable_awaitables</a>, which provides an <code>await_transform</code>
that just forward <a href="#awaitable">awaitables</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A coroutine in the context of this documentation refers
to an asynchronous coroutine, i.e. synchronous coroutines like
<a href="https://en.cppreference.com/w/cpp/coroutine/generator">std::generator</a>
are not considered.</p>
</div>
<div class="paragraph">
<p>All coroutines except <a href="#main">main</a> are also actual <a href="#awaitable">awaitables</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="executors">Executors</h3>
<div class="paragraph">
<p>Since everything is asynchronous the library needs to use an event-loop.
Because everything is single-threaded, it can be assumed that there is exactly one executor
per thread, which will suffice for 97% of use-cases.
Therefore, there is a <code>thread_local</code> executor that gets used as default
by the coroutine objects (although stored by copy in the coroutine promise).</p>
</div>
<div class="paragraph">
<p>Likewise, there is one <code>executor</code> type used by the library,
which defaults to <code>asio::any_io_executor</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you write your own coroutine, it should hold a copy of the executor,
and have a <code>get_executor</code> function returning it by const reference.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using_strands">Using Strands</h4>
<div class="paragraph">
<p>While strands can be used, they are not compatible with the <code>thread_local</code> executor.
This is because they might switch threads, thus they can&#8217;t be <code>thread_local</code>.</p>
</div>
<div class="paragraph">
<p>If you wish to use strands (e.g. through a <a href="#spawn">spawn</a>)
the executor for any <a href="#promise">promise</a>, <a href="#generator">generator</a> or <a href="#channel">channel</a>
must be assigned manually.</p>
</div>
<div class="paragraph">
<p>In the case of a <a href="#channel">channel</a> this is a constructor argument,
but for the other coroutine types, <code>asio::executor_arg</code> needs to be used.
This is done by having <code>asio::executor_arg_t</code> (somewhere) in the argument
list directly followed by the executor to be used in the argument list of the coroutine, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">example_with_executor</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_arg</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span><span class="p">,</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">executor</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This way the coroutine-promise can pick up the executor from the third argument,
instead of defaulting to the thread_local one.</p>
</div>
<div class="paragraph">
<p>The arguments can of course be defaulted, to make them less inconvenient,
if they are sometimes with a thread_local executor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">example_with_executor</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_arg</span><span class="p">,</span>
                                           <span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">executor_arg</span><span class="p">,</span>
                                           <span class="n">cobalt</span><span class="o">::</span><span class="n">executor</span> <span class="o">=</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_executor</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If this gets omitted on a strand an exception of type <code>asio::bad_allocator</code> is thrown,
or - worse - the wrong executor is used.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="polymorphic_memory_resource">polymorphic memory resource</h3>
<div class="paragraph">
<p>Similarly, the library uses a thread_local <code>pmr::memory_resource</code> to allocate
coroutine frames &amp; to use as allocator on asynchronous operations.</p>
</div>
<div class="paragraph">
<p>The reason is, that users may want to customize allocations,
e.g. to avoid locks, limit memory usage or monitor usage.
<code>pmr</code> allows us to achieve this without introducing unnecessary template parameters,
i.e. no <code>promise&lt;T, Allocator&gt;</code> complexity.
Using <code>pmr</code> however does introduce some minimal overheads,
so a user has the option to disable by defining <code>BOOST_COBALT_NO_PMR</code>.</p>
</div>
<div class="paragraph">
<p><a href="#op">op</a> uses an internal resource optimized for asio&#8217;s allocator usages
and <a href="#gather">gather</a>, <a href="#race">race</a> and <a href="#join">join</a> use a monotonic resource to miminize allocations.
Both still work with <code>BOOST_COBALT_NO_PMR</code> defined, in which case they&#8217;ll use <code>new/delete</code> as upstream allocations.</p>
</div>
<div class="paragraph">
<p><a href="#main">main</a> and <a href="#thread">thread</a> single <code>pmr::unsynchronized_pool_resource</code> per thread with PMR enabled.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you write your own coroutine, it should have a get_allocator function
returning a <code>pmr::polymorphic_allocator&lt;void&gt;</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cancellation">cancellation</h3>
<div class="paragraph">
<p>cobalt uses implicit cancellation based on <code>asio::cancellation_signal</code>.
This is mostly used implicitly (e.g. with <a href="#race">race</a>),
so that there is very little explicit use in the examples.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you write custom coroutine it must return a <code>cancellation_slot</code> from a
<code>get_cancellation_slot</code> function in order to be able to cancel other operations.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you write a custom awaitable, it can use that function in await_suspend to receive cancellation signals.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="design:promise">Promise</h3>
<div class="paragraph">
<p>The main coroutine type is a <code>promise</code>, which is eager.
The reason to default to this, is that the compiler can optimize out
promises that do not suspend, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">noop</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_return</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Awaiting the above operation is in theory a noop,
but practically speaking, compilers aren&#8217;t there as of 2023.</p>
</div>
</div>
<div class="sect2">
<h3 id="design:race">Select</h3>
<div class="paragraph">
<p>The most important synchronization mechanism is the <code>race</code> function.</p>
</div>
<div class="paragraph">
<p>It awaits multiple <a href="#awaitable">awaitable</a>s in a pseudo-random order
and will return the result of the first one completion, before disregarding the rest.</p>
</div>
<div class="paragraph">
<p>That is, it initiates the <code>co_await</code> in a pseudo-random order and stops once one
awaitable is found to be ready or completed immediately.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gen1</span><span class="p">();</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">gen2</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">g1</span> <span class="o">=</span> <span class="n">gen1</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">gen2</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">cancelled</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">);</span> <span class="n">v</span><span class="p">.</span><span class="n">index</span><span class="p">())</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Got int %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Got double %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>race</code> must however internally wait  for all awaitable to complete
once it initiates to <code>co_await</code>.
Therefor, once the first <a href="#awaitable">awaitable</a> completes,
it tries to <a href="#interrupt_await">interrupt</a> the rest, and if that fails cancels them.</p>
</div>
<div class="paragraph">
<p><code>race</code> is the preferred way to trigger cancellations, e.g:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">timeout</span><span class="p">();</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">work</span><span class="p">();</span>

<span class="n">race</span><span class="p">(</span><span class="n">timeout</span><span class="p">(),</span> <span class="n">work</span><span class="p">());</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="design:interrupt_await">interrupt_await</h3>
<div class="paragraph">
<p>If it naively cancelled it would however lose data.
Thus, the concept of  <code>interrupt_await</code> is introduced,
which tells the awaitable (that supports it)
to immediately resume the awaiter and return or throw an ignored value.</p>
</div>
<div class="listingblock">
<div class="title">Example of an interruptible awaitable</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">awaitable</span>
<span class="p">{</span>
   <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

   <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Promise</span><span class="p">&gt;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">);</span>

   <span class="n">T</span> <span class="n">await_resume</span><span class="p">();</span>

   <span class="kt">void</span> <span class="n">interrupt_await</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>interrupt_await</code> doesn&#8217;t result in immediate resumption (of <code>h</code>),
<code>race</code> will send a cancel signal.</p>
</div>
<div class="paragraph">
<p><code>race</code> applies these with the correct reference qualification:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="n">gen1</span><span class="p">();</span>
<span class="n">race</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">gen2</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above will call a <code>interrupt_await() &amp;</code> function for <code>g1</code> and <code>interrupt_await() &amp;&amp;</code> for <code>g2</code> if available.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Generally speaking, the coroutines in <code>cobalt</code> support lvalue interruption, i.e. <code>interrupt_await() &amp;</code>.
<a href="#channel">channel</a> operations are unqualified, i.e. work in both cases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#join">join</a> and <a href="#gather">gather</a> will forward interruptions,
i.e. this will only interrupt <code>g1</code> and <code>g2</code> if <code>gen2()</code> completes first:</p>
</div>
</div>
<div class="sect2">
<h3 id="associators">Associators</h3>
<div class="paragraph">
<p><code>cobalt</code> uses the <code>associator</code> concept of asio, but simplifies it.
That is, it has three associators that are member functions of an awaiting promise.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>const executor_type &amp; get_executor()</code> (always <code>executor</code>, must return by const ref)</p>
</li>
<li>
<p><code>allocator_type get_allocator()</code> (always <code>pmr::polymorphic_allocator&lt;void&gt;</code>)</p>
</li>
<li>
<p><code>cancellation_slot_type get_cancellation_slot()</code> (must have the same IF as <code>asio::cancellation_slot</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>cobalt</code> uses concepts to check if those are present in its <code>await_suspend</code> functions.</p>
</div>
<div class="paragraph">
<p>That way custom coroutines can support cancellation, executors and allocators.</p>
</div>
<div class="paragraph">
<p>In a custom awaitable you can obtain them like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_awaitable</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">();</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">corutine_handle</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="k">requires</span>  <span class="p">(</span><span class="n">Promise</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">get_executor</span><span class="p">();})</span>
            <span class="n">handle_executor</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">get_executor</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="k">requires</span> <span class="p">(</span><span class="n">Promise</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="n">p</span><span class="p">.</span><span class="n">get_cancellation_slot</span><span class="p">();})</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">cl</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">get_cancellation_slot</span><span class="p">()).</span><span class="n">is_connected</span><span class="p">())</span>
                <span class="n">cl</span><span class="p">.</span><span class="n">emplace</span><span class="o">&lt;</span><span class="n">my_cancellation</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">await_resume</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Cancellation gets connected in a <code>co_await</code> expression (if supported by the coroutine &amp; awaitable),
including synchronization mechanism like <a href="#race">race</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="threading">Threading</h3>
<div class="paragraph">
<p>This library is single-threaded by design, because this simplifies resumption
and thus more performant handling of synchronizations like <a href="#race">race</a>.
<a href="#race">race</a> would need to lock every raceed awaitable to avoid data loss
which would need to be blocking and get worse with every additional element.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
you can&#8217;t have any coroutines be resumed on a different thread than created on,
except for a <a href="#task">task</a> (e.g. using <a href="#spawn">spawn</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main technical reason is that the most efficient way of switching coroutines is by returning the handle
of the new coroutine from <code>await_suspend</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_awaitable</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">await_resume</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the awaiting coroutine will be suspended before await_suspend is called,
and the coroutine returned is resumed. This of course doesn&#8217;t work if we need to go through an executor.</p>
</div>
<div class="paragraph">
<p>This doesn&#8217;t only apply to awaited coroutines, but channels, too.
The channels in this library use an intrusive list of awaitables
and may return the handle of reading (and thus suspended) coroutine
from a write_operation&#8217;s <code>await_suspend</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="main">cobalt/main.hpp</h3>
<div class="paragraph">
<p>The easiest way to get started with an cobalt application is to use the <code>co_main</code> function with the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Declaring <code>co_main</code> will add a <code>main</code> function that performs all the necessary steps to run a coroutine on an event loop.
This allows us to write very simple asynchronous programs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">exec</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">;</span>             <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="n">exec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">)};</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>                      <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>get the executor <code>main</code> running on</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use it with an asio object</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>co_await</code> an cobalt operation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main promise will create an <code>asio::signal_set</code> and uses it for cancellation.
<code>SIGINT</code> becomes total , while <code>SIGTERM</code> becomes terminal cancellation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The cancellation will not be forwarded to detached coroutines.
The user will need to take care to end then on cancellation,
since the program otherwise doesn&#8217;t allow graceful termination.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="executor">Executor</h4>
<div id="main-executor" class="paragraph">
<p>It will also create an <code>asio::io_context</code> to run on, which you can get through the <code>this_coro::executor</code>.
It will be assigned to the <code>cobalt::this_thread::get_executor()</code> .</p>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource">Memory Resource</h4>
<div id="main-allocator" class="paragraph">
<p>It also creates a memory resource that will be used as a default for internal memory allocations.
It will be assigned to the <code>thread_local</code> to the  <code>cobalt::this_thread::get_default_resource()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="main-promise">Promise</h4>
<div class="paragraph">
<p>Every coroutine has an internal state, called <code>promise</code> (not to be confused with the <code>cobalt::promise</code>).
Depending on the coroutine properties different things can be <code>co_await</code>-ed, like we used in the example above.</p>
</div>
<div class="paragraph">
<p>They are implemented through inheritance, and shared among different promise types</p>
</div>
<div class="paragraph">
<p>The main promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="specification">Specification</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>declaring <code>co_main</code> will implicitly declare a <code>main</code> function</p>
</li>
<li>
<p><code>main</code> is only present when <code>co_main</code> is defined.</p>
</li>
<li>
<p><code>SIGINT</code> and <code>SIGTERM</code> will cause cancellation of the internal task.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise">cobalt/promise.hpp</h3>
<div class="paragraph">
<p>A promise is an eager coroutine that can <code>co_await</code> and <code>co_return</code> values. That is, it cannot use <code>co_yield</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="n">ms</span><span class="p">};</span>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Promises are by default attached.
This means, that a cancellation is sent when the <code>promise</code> handles goes out of scope.</p>
</div>
<div class="paragraph">
<p>A promise can be detached by calling <code>detach</code> or by using the prefix <code>+</code> operator.
This is a runtime alternative to using <a href="#detached">detached</a>.
A detached promise will not send a cancellation on destruction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">my_task</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="o">+</span><span class="n">my_task</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>By using <code>+</code> the task gets detached. Without it, the compiler would generate a <code>nodiscard</code> warning.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="executor_2">Executor</h4>
<div id="promise-executor" class="paragraph">
<p>The executor is taken from the <code>thread_local</code> <a href="#this_thread">get_executor</a> function, unless a <code>asio::executor_arg</code> is used
in any position followed by the executor argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec_to_use</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_2">Memory Resource</h4>
<div id="promise-allocator" class="paragraph">
<p>The memory resource is taken from the <code>thread_local</code> <a href="#this_thread">get_default_resource</a> function,
unless a <code>std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promise-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Return</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">promise</span>
<span class="p">{</span>
    <span class="n">promise</span><span class="p">(</span><span class="n">promise</span> <span class="o">&amp;&amp;</span><span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">promise</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">promise</span> <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="c1">// enable `co_await`. </span><i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span>

    <span class="c1">// Ignore the return value, i.e. detach it. </span><i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kt">void</span> <span class="k">operator</span> <span class="o">+</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>

    <span class="c1">// Cancel the promise.</span>
    <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>

    <span class="c1">// Check if the result is ready</span>
    <span class="kt">bool</span> <span class="n">ready</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// Check if the promise can be awaited.</span>
    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="c1">// Detach or attach</span>
    <span class="kt">bool</span> <span class="n">attached</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">detach</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">attach</span><span class="p">();</span>
    <span class="c1">// Get the return value. If !ready() this function has undefined behaviour.</span>
    <span class="n">Return</span> <span class="n">get</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Supports <a href="#interrupt_await">Interrupt Wait</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This allows to create promise running in parallel with a simple <code>+my_task()</code> expression.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This allows code like <code>while (p) co_await p;</code></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="promise-promise">Promise</h4>
<div class="paragraph">
<p>The coroutine promise (<code>promise::promise_type</code>) has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generator">cobalt/generator.hpp</h3>
<div class="paragraph">
<p>A generator is an eager coroutine that can <code>co_await</code> and <code>co_yield</code> values to the caller.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">co_yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro 3</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">example</span><span class="p">();</span> <span class="c1">// call and let it run until the first co_yield</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will generate the following output</p>
</div>
<div class="literalblock">
<div class="content">
<pre>In main 0
In coro 1
In main 1
In main 2
In coro 3
In main 4</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: mmdc failed:
Error: Failed to launch the browser process!
/root/.cache/puppeteer/chrome/linux-1108766/chrome-linux/chrome: error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory


TROUBLESHOOTING: https://pptr.dev/troubleshooting

    at Interface.onClose (file:///root/.nvm/versions/node/v18.18.1/lib/node_modules/@mermaid-js/mermaid-cli/node_modules/@puppeteer/browsers/lib/esm/launch.js:253:24)
    at Interface.emit (node:events:529:35)
    at Interface.close (node:internal/readline/interface:534:10)
    at Socket.onend (node:internal/readline/interface:260:10)
    at Socket.emit (node:events:529:35)
    at endReadableNT (node:internal/streams/readable:1368:12)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)


sequenceDiagram
    participant main;
    Note left of main: "In main 0"
    main-&gt;&gt;+example: example()
    Note right of example: "In coro 1"
    example--&gt;&gt;main: co_yield 2
    Note left of main: "In main 2"
    main--&gt;&gt;+example: co_await f
    Note right of example: "In coro 3"
    example-&gt;&gt;main: co_return 3
    Note left of main: "In main 4"</pre>
</div>
</div>
<div class="paragraph">
<p>Values can be pushed into the generator, when <code>Push</code> (the second template parameter) is set to non-void:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span>  <span class="k">co_yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">example</span><span class="p">();</span> <span class="c1">// call and let it run until the first co_yield</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The pushed value gets passed through <code>operator()</code> to the result of <code>co_yield</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Which will generate the following output</p>
</div>
<div class="literalblock">
<div class="content">
<pre>In main 0
In coro 1
In main 2
In coro 3</pre>
</div>
</div>
<div class="sect3">
<h4 id="initial">Lazy</h4>
<div class="paragraph">
<p>A generator can be turned lazy by awaiting initial.
This <code>co_await</code> expression will produce the <code>Push</code> value.
This means the generator will wait until it&#8217;s awaited for the first time,
and then process the newly pushed value and resume at the next co_yield.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">initial</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">co_yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">example</span><span class="p">();</span> <span class="c1">// call and let it run until the first co_yield</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// &lt; this is now before the co_await initial</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will generate the following output</p>
</div>
<div class="literalblock">
<div class="content">
<pre>In main 0
In main 1
In coro 1
In main 2
In coro 3
In main 4</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: mmdc failed:
Error: Failed to launch the browser process!
/root/.cache/puppeteer/chrome/linux-1108766/chrome-linux/chrome: error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory


TROUBLESHOOTING: https://pptr.dev/troubleshooting

    at Interface.onClose (file:///root/.nvm/versions/node/v18.18.1/lib/node_modules/@mermaid-js/mermaid-cli/node_modules/@puppeteer/browsers/lib/esm/launch.js:253:24)
    at Interface.emit (node:events:529:35)
    at Interface.close (node:internal/readline/interface:534:10)
    at Socket.onend (node:internal/readline/interface:260:10)
    at Socket.emit (node:events:529:35)
    at endReadableNT (node:internal/streams/readable:1368:12)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)


sequenceDiagram
    participant main;
    Note left of main: "In main 0"
    main-&gt;&gt;+example: example()
    Note right of example: "In coro 1"
    example--&gt;&gt;main: co_yield 2
    Note left of main: "In main 2"
    main--&gt;&gt;+example: co_await f
    Note right of example: "In coro 3"
    example-&gt;&gt;main: co_return 3
    Note left of main: "In main 4"</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="generator-executor">Executor</h4>
<div class="paragraph">
<p>The executor is taken from the <code>thread_local</code> <a href="#this_thread">get_executor</a> function, unless a <code>asio::executor_arg</code> is used
in any position followed by the executor argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec_to_use</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="generator-allocator">Memory Resource</h4>
<div class="paragraph">
<p>The memory resource is taken from the <code>thread_local</code> <a href="#this_thread">get_default_resource</a> function,
unless a <code>std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="generator-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Yield</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Push</span> <span class="o">=</span> <span class="kt">void</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">generator</span>
<span class="p">{</span>
  <span class="c1">// Movable</span>

  <span class="n">generator</span><span class="p">(</span><span class="n">generator</span> <span class="o">&amp;&amp;</span><span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">generator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">generator</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// True until it co_returns &amp; is co_awaited after </span><i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Cancel the generator. </span><i class="conum" data-value="3"></i><b>(3)</b>
  <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>

  <span class="c1">// Check if a value is available</span>
  <span class="kt">bool</span> <span class="n">ready</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Get the returned value. If !ready() this function has undefined behaviour.</span>
  <span class="n">Yield</span> <span class="n">get</span><span class="p">();</span>

  <span class="c1">// Cancel &amp; detach the generator.</span>
  <span class="o">~</span><span class="n">generator</span><span class="p">();</span>

  <span class="c1">// an awaitable that results in value of <code>Yield</code>.</span>
  <span class="k">using</span> <span class="n"><em>generator_awaitable</em></span> <span class="o">=</span> <span class="n"><em>unspecified</em></span><span class="p">;</span>

  <span class="c1">// Present when <code>Push</code> != <code>void</code></span>
  <span class="n"><em>generator_awaitable</em></span> <span class="k">operator</span><span class="p">()(</span>      <span class="n">Push</span> <span class="o">&amp;&amp;</span> <span class="n">push</span><span class="p">);</span>
  <span class="n"><em>generator_awaitable</em></span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Push</span> <span class="o">&amp;</span>  <span class="n">push</span><span class="p">);</span>

  <span class="c1">// Present when <code>Push</code> == <code>void</code>, i.e. can <code>co_await</code> the generator directly.</span>
  <span class="n"><em>generator_awaitable</em></span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This allows code like <code>while (gen) co_await gen:</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Supports <a href="#interrupt_await">Interrupt Wait</a></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A cancelled generator maybe be resumable</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="generator-promise">Promise</h4>
<div class="paragraph">
<p>The generator promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="task">cobalt/task.hpp</h3>
<div class="paragraph">
<p>A task is a lazy coroutine that can <code>co_await</code> and <code>co_return</code> values. That is, it cannot use <code>co_yield</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="n">ms</span><span class="p">};</span>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike a <a href="#promise">promise</a>, a task can be awaited or spawned on another executor than it was created on.</p>
</div>
<div class="sect3">
<h4 id="executor_3">Executor</h4>
<div id="task-executor" class="paragraph">
<p>Since a <code>task</code> it lazy, it does not need to have an executor on construction.
It rather attempts to take it from the caller or awaiter if present.
Otherwise, it&#8217;ll default to the thread_local executor.</p>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_3">Memory Resource</h4>
<div id="task-allocator" class="paragraph">
<p>The memory resource is <strong>NOT</strong> taken from the <code>thread_local</code> <a href="#this_thread">get_default_resource</a> function,
but <code>pmr::get_default_resource(),
unless a `std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="task-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Return</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">task</span>
<span class="p">{</span>
    <span class="n">task</span><span class="p">(</span><span class="n">task</span> <span class="o">&amp;&amp;</span><span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">task</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">// enable `co_await`</span>
    <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Tasks can be used synchronously from a sync function by calling <code>run(my_task())</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="task-task">Promise</h4>
<div class="paragraph">
<p>The task promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="use_task">use_task</h4>
<div class="paragraph">
<p>The <code>use_task</code> completion token can be used to create a task from an <code>cobalt_</code> function.
This is less efficient than <a href="#use_op">use_op</a> as it needs to allocate a coroutine frame,
but has a simpler return type and supports <a href="#interrupt_await">Interrupt Wait</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="detached">cobalt/detached.hpp</h3>
<div class="paragraph">
<p>A detached is an eager coroutine that can <code>co_await</code> but not <code>co_return</code> values.
That is, it cannot be resumed and is usually not awaited.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">detached</span> <span class="nf">delayed_print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="n">ms</span><span class="p">};</span>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">delayed_print</span><span class="p">();</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Detached is used to run coroutines in the background easily.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_task</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">my_task</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Spawn off the detached coro.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A detached can assign itself a new cancellation source like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_task</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_slot</span> <span class="n">sl</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">co_await</span> <span class="n">this_coro</span><span class="o">::</span><span class="n">reset_cancellation_source</span><span class="p">(</span><span class="n">sl</span><span class="p">);</span>
   <span class="c1">// do somework</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_signal</span> <span class="n">sig</span><span class="p">;</span>
  <span class="n">my_task</span><span class="p">(</span><span class="n">sig</span><span class="p">.</span><span class="n">slot</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="n">sig</span><span class="p">.</span><span class="n">emit</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="executor_4">Executor</h4>
<div id="detached-executor" class="paragraph">
<p>The executor is taken from the <code>thread_local</code> <a href="#this_thread">get_executor</a> function, unless a <code>asio::executor_arg</code> is used
in any position followed by the executor argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_gen</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec_to_use</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_4">Memory Resource</h4>
<div id="detached-allocator" class="paragraph">
<p>The memory resource is taken from the <code>thread_local</code> <a href="#this_thread">get_default_resource</a> function,
unless a <code>std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="detached-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">detached</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Supports <a href="#interrupt_await">Interrupt Wait</a></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="detached-detached">Promise</h4>
<div class="paragraph">
<p>The thread detached has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cobalt_operation">cobalt/op.hpp</h3>
<div class="paragraph">
<p>An operation in <code>cobalt</code> is an <a href="#awaitable">awaitable</a> wrapping an <code>asio</code> operation.</p>
</div>
<div class="sect3">
<h4 id="use_op">use_op</h4>
<div class="paragraph">
<p>The <code>use_op</code> token is the direct to create an op,
i.e. using <code>cobalt::use_op</code> as the completion token will create the required awaitable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">tim</span> <span class="o">=</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">.</span><span class="n">as_default_on</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">});</span>
<span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the completion signature the <code>co_await</code> expression may throw.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Signature</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Exception</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noexcept</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noexcept</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(T&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::tuple&lt;T&#8230;&#8203;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noexcept</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(system::error_code, T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>system::system_error</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(system::error_code, T&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::tuple&lt;T&#8230;&#8203;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>system::system_error</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(std::exception_ptr, T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>any exception</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(std::exception_ptr, T&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::tuple&lt;T&#8230;&#8203;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>any exception</em></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>use_op</code> will never complete immediately, i.e. <code>await_ready</code> will always return false, but always suspend the coroutine.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="op">Hand coded Operations</h4>
<div class="paragraph">
<p>Operations are a more advanced implementation of the <a href="#cobalt_operation">cobalt/op.hpp</a> feature.</p>
</div>
<div class="paragraph">
<p>This library makes it easy to create asynchronous operations with an early completion condition,
i.e. a condition that avoids suspension of coroutines altogether.</p>
</div>
<div class="paragraph">
<p>We can for example create a <code>wait_op</code> that does nothing if the timer is already expired.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">wait_op</span> <span class="o">:</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">op</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="o">&amp;</span> <span class="n">tim</span><span class="p">;</span>

  <span class="n">wait_op</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="o">&amp;</span> <span class="n">tim</span><span class="p">)</span> <span class="o">:</span> <span class="n">tim</span><span class="p">(</span><span class="n">tim</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">ready</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">handler</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tim</span><span class="p">.</span><span class="n">expiry</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">())</span>
        <span class="n">h</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">{});</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">initiate</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">completion_handler</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="n">complete</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">{</span>
    <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">complete</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inherit <code>op</code> with the matching signature <code>await_transform</code> picks it up</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Check if the operation is ready - called from <code>await_ready</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Initiate the operation if its not ready.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concepts">cobalt/concepts.hpp</h3>
<div class="sect3">
<h4 id="awaitable">Awaitable</h4>
<div class="paragraph">
<p>An awaitable is an expression that can be used with <code>co_await</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Awaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">awaitable_type</span> <span class="o">=</span> <span class="k">requires</span> <span class="p">(</span><span class="n">Awaitable</span> <span class="n">aw</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">{</span><span class="n">aw</span><span class="p">.</span><span class="n">await_ready</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">{</span><span class="n">aw</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">h</span><span class="p">)};</span>
    <span class="p">{</span><span class="n">aw</span><span class="p">.</span><span class="n">await_resume</span><span class="p">()};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Awaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">awaitable</span> <span class="o">=</span>
        <span class="n">awaitable_type</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="p">,</span> <span class="n">Promise</span><span class="o">&gt;</span>
    <span class="o">||</span> <span class="k">requires</span> <span class="p">(</span><span class="n">Awaitable</span> <span class="o">&amp;&amp;</span> <span class="n">aw</span><span class="p">)</span> <span class="p">{</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aw</span><span class="p">).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">awaitable_type</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span><span class="p">;}</span>
    <span class="o">||</span> <span class="k">requires</span> <span class="p">(</span><span class="n">Awaitable</span> <span class="o">&amp;&amp;</span> <span class="n">aw</span><span class="p">)</span> <span class="p">{</span> <span class="p">{</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aw</span><span class="p">))}</span> <span class="o">-&gt;</span> <span class="n">awaitable_type</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span><span class="p">;};</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<a href="#awaitable">awaitables</a> in this library require that the coroutine promise
return their executor by const reference if they provide one. Otherwise it&#8217;ll use <code>this_thread::get_executor()</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="enable_awaitables">Enable awaitables</h4>
<div class="paragraph">
<p>Inheriting <code>enable_awaitables</code> will enable a coroutine to co_await anything through <code>await_transform</code>
that would be <code>co_await</code>-able in the absence of any <code>await_transform</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="this_coro">cobalt/this_coro.hpp</h3>
<div class="paragraph">
<p>The <code>this_coro</code> namespace provides utilities to access the internal state of a coroutine promise.</p>
</div>
<div class="paragraph">
<p>Pseudo-awaitables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Awaitable type that returns the executor of the current coroutine.</span>
<span class="k">struct</span> <span class="nc">executor_t</span> <span class="p">{}</span>
<span class="k">constexpr</span> <span class="n">executor_t</span> <span class="n">executor</span><span class="p">;</span>

<span class="c1">// Awaitable type that returns the cancellation state of the current coroutine.</span>
<span class="k">struct</span> <span class="nc">cancellation_state_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">cancellation_state_t</span> <span class="n">cancellation_state</span><span class="p">;</span>

<span class="c1">// Reset the cancellation state with custom or default filters.</span>
<span class="k">constexpr</span> <span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_state</span><span class="p">();</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Filter</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_state</span><span class="p">(</span>
    <span class="n">Filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InFilter</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OutFilter</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_state</span><span class="p">(</span>
    <span class="n">InFilter</span> <span class="o">&amp;&amp;</span> <span class="n">in_filter</span><span class="p">,</span>
    <span class="n">OutFilter</span> <span class="o">&amp;&amp;</span> <span class="n">out_filter</span><span class="p">);</span>

<span class="c1">// get &amp; set the throw_if_cancelled setting.</span>
<span class="n"><em>unspecified</em></span> <span class="n">throw_if_cancelled</span><span class="p">();</span>
<span class="n"><em>unspecified</em></span> <span class="n">throw_if_cancelled</span><span class="p">(</span><span class="kt">bool</span> <span class="n">value</span><span class="p">);</span>

<span class="c1">// Set the cancellation source in a detached.</span>
<span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_source</span><span class="p">();</span>
<span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_source</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_slot</span> <span class="n">slot</span><span class="p">);</span>


<span class="c1">// get the allocator the promise</span>
<span class="k">struct</span> <span class="nc">allocator_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">allocator_t</span> <span class="n">allocator</span><span class="p">;</span>

<span class="c1">// get the current cancellation state-type</span>
<span class="k">struct</span> <span class="nc">cancelled_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">cancelled_t</span> <span class="n">cancelled</span><span class="p">;</span>

<span class="c1">// set the over-eager mode of a generator</span>
<span class="k">struct</span> <span class="nc">initial_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">initial_t</span> <span class="n">initial</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="enable_await_allocator">Await Allocator</h4>
<div class="paragraph">
<p>The allocator of a coroutine supporting <code>enable_await_allocator</code> can be obtained the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">allocator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to enable this for your own coroutine you can inherit <code>enable_await_allocator</code> with the CRTP pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_promise</span> <span class="o">:</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">enable_await_allocator</span><span class="o">&lt;</span><span class="n">my_promise</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">allocator_type</span> <span class="o">=</span> <span class="n">__your_allocator_type__</span><span class="p">;</span>
  <span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If available the allocator gets used by <a href="#use_op">use_op</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="enable_await_executor">Await Executor</h4>
<div class="paragraph">
<p>The allocator of a coroutine supporting <code>enable_await_executor</code> can be obtained the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to enable this for your own coroutine you can inherit <code>enable_await_executor</code> with the CRTP pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_promise</span> <span class="o">:</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">enable_await_executor</span><span class="o">&lt;</span><span class="n">my_promise</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">executor_type</span> <span class="o">=</span> <span class="n">__your_executor_type__</span><span class="p">;</span>
  <span class="n">executor_type</span> <span class="n">get_executor</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If available the executor gets used by <a href="#use_op">use_op</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="promise_memory_resource_base">Memory resource base</h4>
<div class="paragraph">
<p>The <code>promise_memory_resource_base</code> base of a promise will provide a <code>get_allocator</code> in the promise taken from
either the default resource or one passed following a <code>std::allocator_arg</code> argument.
Likewise, it will add <code>operator new</code> overloads so the coroutine uses the same memory resource for its frame allocation.</p>
</div>
</div>
<div class="sect3">
<h4 id="promise_throw_if_cancelled_base">Throw if cancelled</h4>
<div class="paragraph">
<p>The <code>promise_throw_if_cancelled_base</code> provides the basic options to allow operation to enable a coroutines
to turn throw an exception when another actual <a href="#awaitable">awaitable</a> is awaited.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">throw_if_cancelled</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promise_cancellation_base">Cancellation state</h4>
<div class="paragraph">
<p>The <code>promise_cancellation_base</code> provides the basic options to allow operation to enable a coroutines
to have a cancellation_state that is resettable by
<a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/reference/this_coro__reset_cancellation_state.html"><code>reset_cancellation_state</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">reset_cancellation_state</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience there is also a short-cut to check the current cancellation status:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">cancellation_state</span><span class="p">).</span><span class="n">cancelled</span><span class="p">();</span>
<span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">cancelled</span><span class="p">;</span> <span class="c1">// same as above</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="this_thread">cobalt/this_thread.hpp</h3>
<div class="paragraph">
<p>Since everything is single threaded this library provides an executor
&amp; default memory-resource for every thread.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">cobalt</span><span class="o">::</span><span class="n">this_thread</span>
<span class="p">{</span>

<span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">get_default_resource</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">set_default_resource</span><span class="p">(</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">get_allocator</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="k">typename</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="o">&amp;</span> <span class="n">get_executor</span><span class="p">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="kt">void</span> <span class="n">set_executor</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="5"></i><b>(5)</b>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the default resource - will be pmr::get_default_resource unless set</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set the default resource - returns the previously set one</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get an allocator wrapping (1)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Get the executor of the thread - throws if not set</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Set the executor of the current thread.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The coroutines will use these as defaults, but keep a copy just in case.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The only exception is the initialization of an cobalt-operation,
which will use the this_thread::executor to rethrow from.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="channel">cobalt/channel.hpp</h3>
<div class="paragraph">
<p>Channels can be used to exchange data between different coroutines
on a single thread.</p>
</div>
<div class="sect3">
<h4 id="outline">Outline</h4>
<div class="listingblock">
<div class="title">channel outline</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">channel</span>
<span class="p">{</span>
  <span class="c1">// create a channel with a buffer limit, executor &amp; resource.</span>
  <span class="k">explicit</span>
  <span class="n">channel</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">,</span>
          <span class="n">executor</span> <span class="n">executor</span> <span class="o">=</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_executor</span><span class="p">(),</span>
          <span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span> <span class="o">*</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_default_resource</span><span class="p">());</span>
  <span class="c1">// not movable.</span>
  <span class="n">channel</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">channel</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">executor_type</span> <span class="o">=</span> <span class="n">executor</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">executor_type</span> <span class="o">&amp;</span> <span class="n">get_executor</span><span class="p">();</span>

  <span class="c1">// Closes the channel</span>
  <span class="o">~</span><span class="n">channel</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">is_open</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// close the operation, will cancel all pending ops, too</span>
  <span class="kt">void</span> <span class="n">close</span><span class="p">();</span>

  <span class="c1">// an awaitable that yields T</span>
  <span class="k">using</span> <span class="n"><em>read_op</em></span> <span class="o">=</span> <span class="n"><em>unspecified</em></span><span class="p">;</span>

  <span class="c1">// an awaitable that yields void</span>
  <span class="k">using</span> <span class="n"><em>write_op</em></span> <span class="o">=</span> <span class="n"><em>unspecified</em></span><span class="p">;</span>

  <span class="c1">// read a value to a channel</span>
  <span class="n"><em>read_op</em></span>  <span class="n">read</span><span class="p">();</span>

  <span class="c1">// write a value to the channel</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span>  <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">);</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span>  <span class="o">&amp;</span>  <span class="n">value</span><span class="p">);</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span>      <span class="n">T</span> <span class="o">&amp;&amp;</span>  <span class="n">value</span><span class="p">);</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span>      <span class="n">T</span>  <span class="o">&amp;</span>  <span class="n">value</span><span class="p">);</span>

  <span class="c1">// write a value to the channel if T is void</span>

<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="description">Description</h4>
<div class="paragraph">
<p>Channels are a tool for two coroutines to communicate and synchronize.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ch</span><span class="p">{</span><span class="n">exec</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">};</span>

<span class="c1">// in coroutine </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="k">co_await</span> <span class="n">ch</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// in coroutine </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">ch</span><span class="p">.</span><span class="n">read</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Send a value to the channel - will block until it can be sent</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Read a value from the channel - will block until a value is awaitable.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Both operations maybe be blocking depending on the channel buffer size.</p>
</div>
<div class="paragraph">
<p>If the buffer size is zero, a <code>read</code> &amp; <code>write</code> will need to occur at the same time,
i.e. act as a rendezvous.</p>
</div>
<div class="paragraph">
<p>If the buffer is not full, the write operation will not suspend the coroutine;
likewise if the buffer is not empty, the read operation will not suspend.</p>
</div>
<div class="paragraph">
<p>If two operations complete at once (as is always the case with an empty buffer),
the second operation gets posted to the executor for later completion.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A channel type can be <code>void</code>, in which case <code>write</code> takes no parameter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The channel operations can be cancelled without losing data.
This makes them usable with <a href="#race">race</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">generator</span><span class="o">&lt;</span><span class="n">variant2</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">merge</span><span class="p">(</span>
    <span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">c1</span><span class="p">,</span>
    <span class="n">channel</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">c2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&amp;&amp;</span> <span class="n">c2</span><span class="p">)</span>
       <span class="k">co_yield</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example">Example</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">producer</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">co_await</span> <span class="n">chan</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

  <span class="n">chan</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">producer</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">co_await</span> <span class="n">c</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">co_await</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, a <code>channel_reader</code> is provided to make reading channels more convenient &amp; usable with
<a href="#async_for">BOOST_COBALT_FOR</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">cobalt</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">producer</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">BOOST_COBALT_FOR</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">channel_reader</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">co_await</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="with">cobalt/with.hpp</h3>
<div class="paragraph">
<p>The <code>with</code> facility provides a way to perform asynchronous tear-down of coroutines.
That is it like an asynchronous destructor call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_resource</span>
<span class="p">{</span>
  <span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">await_exit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">e</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">work</span><span class="p">(</span><span class="n">my_resource</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">);</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">outer</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">with</span><span class="p">(</span><span class="n">my_resource</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The teardown can either be done by providing an <code>await_exit</code> member function or a <code>tag_invoke</code> function
that returns an <a href="#awaitable">awaitable</a> or by providing the teardown as the third argument to <code>with</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">using</span> <span class="n">ws_stream</span> <span class="o">=</span> <span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">ws_stream</span><span class="o">&gt;</span> <span class="n">connect</span><span class="p">(</span><span class="n">urls</span><span class="o">::</span><span class="n">url</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>   <span class="n">disconnect</span><span class="p">(</span><span class="n">ws_stream</span> <span class="o">&amp;</span><span class="n">ws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="k">auto</span> <span class="nf">teardown</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">cobalt</span><span class="o">::</span><span class="n">with_exit_tag</span> <span class="o">&amp;</span> <span class="n">wet</span> <span class="p">,</span> <span class="n">ws_stream</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">disconnect</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">run_session</span><span class="p">(</span><span class="n">ws_stream</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">);</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">with</span><span class="p">(</span><span class="k">co_await</span> <span class="n">connect</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">run_session</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">teardown</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Implement websocket connect &amp; websocket initiation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Implement an orderly shutdown.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>std::exception_ptr</code> is null if the scope is exited without exception.
NOTE: It&#8217;s legal for the <code>exit</code> functions to take the <code>exception_ptr</code> by reference and modify it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="race">cobalt/race.hpp</h3>
<div class="paragraph">
<p>The <code>race</code> function can be used to <code>co_await</code> one <a href="#awaitable">awaitable</a> out of a set of them.</p>
</div>
<div class="paragraph">
<p>It can be called as a variadic function with multiple <a href="#awaitable">awaitable</a> or as on a range of <a href="#awaitable">awaitables</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task1</span><span class="p">();</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task2</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_wait</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">race</span><span class="p">(</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">aws</span> <span class="p">{</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">()};</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">race</span><span class="p">(</span><span class="n">aws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for a variadic set of <a href="#awaitable">awaitables</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>wait for a vector of <a href="#awaitable">awaitables</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first parameter so <code>race</code> can be a <a href="https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator::">uniform random bit generator</a>.</p>
</div>
<div class="listingblock">
<div class="title">Signatures of race</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">pvv</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">rdm</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="c1">// if everything returns void race returns the index</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r3</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">pvv</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r4</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">pvv</span><span class="p">);</span>

<span class="c1">// variant if not everything is void. void become monostate</span>
<span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">;</span>
<span class="n">variant2</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r5</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>
<span class="n">variant2</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r6</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>

<span class="c1">// a range returns a pair of the index and the result if non-void</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">piv</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r7</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">piv</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r8</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">race</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">piv</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="interrupt_await">Interrupt Wait</h4>
<div class="paragraph">
<p>When arguments are passed as rvalue reference, the race will attempt to use <code>.interrupt_await</code>
on the <a href="#awaitable">awaitable</a> to signal the awaitable to complete now and that the result will be ignored.
If supported, the <a href="#awaitable">Awaitable</a> must resume the awaiting coroutine before <code>interrupt_await</code> returns.
If the <code>race</code> doesn&#8217;t detect the function, it will send a cancellation.</p>
</div>
<div class="paragraph">
<p>This means that you can reuse race like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_wait</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">task1</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">task2</span><span class="p">();</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">race</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">race</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for the first task to complete</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Wait for the other task to complete</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is supported by <a href="#promise">promise</a>, <a href="#generator">generator</a> and <a href="#gather">gather</a>.</p>
</div>
<div class="paragraph">
<p>The <code>race</code> will invoke the functions of the <code>awaitable</code> as if used in a <code>co_await</code> expression
or not evaluate them at all.</p>
</div>
</div>
<div class="sect3">
<h4 id="left_race"><code>left_race</code></h4>
<div class="paragraph">
<p>The <code>left_race</code> functions are like <code>race</code> but follow a strict left-to-right scan.
This can lead to starvation issues, which is why this is not the recommended default, but can
be useful for prioritization if proper care is taken.</p>
</div>
</div>
<div class="sect3">
<h4 id="race-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Concept for the random number generator.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">G</span><span class="p">&gt;</span>
  <span class="k">concept</span> <span class="n">uniform_random_bit_generator</span> <span class="o">=</span>
    <span class="k">requires</span> <span class="p">(</span> <span class="n">G</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="p">{</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">unsigned_integral</span><span class="p">;</span> <span class="c1">// is an unsigned integer type</span>
      <span class="c1">// T	Returns the smallest value that G's operator() may return. The value is strictly less than G::max(). The function must be constexpr.</span>
      <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="c1">// T	Returns the largest value that G's operator() may return. The value is strictly greater than G::min(). The function must be constexpr.</span>
      <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="p">{</span><span class="n">g</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">());</span>


<span class="c1">// Variadic race with a custom random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span>
         <span class="n">uniform_random_bit_generator</span> <span class="n">URBG</span><span class="p">,</span> <span class="n">awaitable</span> <span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">race</span><span class="p">(</span><span class="n">URBG</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged race with a custom random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span>
         <span class="n">uniform_random_bit_generator</span> <span class="n">URBG</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span> <span class="n">PromiseRange</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">race</span><span class="p">(</span><span class="n">URBG</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Variadic race with the default random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">race</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged race with the default random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">race</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Variadic left race</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">left_race</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged left race</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">left_race</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Selecting an empty range will cause an exception to be thrown.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gather">cobalt/gather.hpp</h3>
<div class="paragraph">
<p>The <code>gather</code> function can be used to <code>co_await</code> multiple <a href="#awaitable">awaitables</a>
at once with cancellations being passed through.</p>
</div>
<div class="paragraph">
<p>The function will gather all completion and return them as <code>system::result</code>,
i.e. capture conceptions as values. One awaitable throwing an exception will not cancel the others.</p>
</div>
<div class="paragraph">
<p>It can be called as a variadic function with multiple <a href="#awaitable">Awaitable</a> or as on a range of <a href="#awaitable">awaitables</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task1</span><span class="p">();</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task2</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_gather</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">gather</span><span class="p">(</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">aws</span> <span class="p">{</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">()};</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">gather</span><span class="p">(</span><span class="n">aws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for a variadic set of <a href="#awaitable">awaitables</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Wait for a vector of <a href="#awaitable">awaitables</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>gather</code> will invoke the functions of the <code>awaitable</code> as if used in a <code>co_await</code> expression.</p>
</div>
<div class="listingblock">
<div class="title">Signatures of gather</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">pvv</span><span class="p">;</span>
<span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">r2</span> <span class="o">=</span>  <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">pvv</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">monostate</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">monostate</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">r3</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">piv</span><span class="p">;</span>
<span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">r4</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">piv</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="gather-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Variadic gather</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">gather</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged gather</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">gather</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="join">cobalt/join.hpp</h3>
<div class="paragraph">
<p>The <code>join</code> function can be used to <code>co_await</code> multiple <a href="#awaitable">awaitable</a> at once with properly connected cancellations.</p>
</div>
<div class="paragraph">
<p>The function will gather all completion and return them as values, unless an exception is thrown.
If an exception is thrown, all outstanding ops are cancelled (or interrupted if possible)
and the first exception gets rethrown.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>void</code> will be returned as <code>variant2::monostate</code> in the tuple, unless all awaitables yield void.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It can be called as a variadic function with multiple <a href="#awaitable">Awaitable</a> or as on a range of <a href="#awaitable">awaitables</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task1</span><span class="p">();</span>
<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task2</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_join</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cobalt</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">aws</span> <span class="p">{</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">()};</span>
  <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">aws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for a variadic set of <a href="#awaitable">awaitables</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Wait for a vector of <a href="#awaitable">awaitables</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>join</code> will invoke the functions of the <code>awaitable</code> as if used in a <code>co_await</code> expression.</p>
</div>
<div class="listingblock">
<div class="title">Signatures of join</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">;</span>
<span class="cm">/* void */</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">pvv</span><span class="p">;</span>
<span class="cm">/* void */</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">pvv</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">monostate</span><span class="p">,</span> <span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">piv</span><span class="p">;</span>
<span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">piv</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="join-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Variadic join</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">join</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged join</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">join</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Selecting an on empty range will cause an exception.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wait_group">cobalt/wait_group.hpp</h3>
<div class="paragraph">
<p>The <code>wait_group</code> function can be used to manage
multiple coroutines of type <code>promise&lt;void&gt;</code>.
It works out of the box with <a href="#with">cobalt/with.hpp</a>, by having the matching <code>await_exit</code> member.</p>
</div>
<div class="paragraph">
<p>Essentially, a <code>wait_group</code> is a dynamic list of
promises that has a  <code>race</code> function (<code>wait_one</code>),
a <code>gather</code> function (<code>wait_all</code>) and will clean up on scope exit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">wait_group</span>
<span class="p">{</span>
    <span class="c1">// create a wait_group</span>
    <span class="k">explicit</span>
    <span class="n">wait_group</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">normal_cancel</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">none</span><span class="p">,</span>
               <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">exception_cancel</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>

    <span class="c1">// insert a task into the group</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>

    <span class="c1">// the number of tasks in the group</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// remove completed tasks without waiting (i.e. zombie tasks)</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">reap</span><span class="p">();</span>
    <span class="c1">// cancel all tasks</span>
    <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>
    <span class="c1">// wait for one task to complete.</span>
    <span class="n"><em>wait_one_op</em></span> <span class="n">wait_one</span><span class="p">();</span>
    <span class="c1">// wait for all tasks to complete</span>
    <span class="n"><em>wait_op</em></span> <span class="n">wait</span><span class="p">();</span>
    <span class="c1">// wait for all tasks to complete</span>
    <span class="n"><em>wait_op</em></span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span>
    <span class="c1">// when used with <code>with</code> , this will receive the exception</span>
    <span class="c1">// and wait for the completion</span>
    <span class="c1">// if <code>ep</code> is set, this will use the <code>exception_cancel</code> level,</span>
    <span class="c1">// otherwise the <code>normal_cancel</code> to cancel all promises.</span>
    <span class="n"><em>wait_op</em></span> <span class="n">await_exit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">ep</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spawn">cobalt/spawn.hpp</h3>
<div class="paragraph">
<p>The <code>spawn</code> functions allow to run <a href="#task">task</a> on an asio <code>executor</code>/<code>execution_context</code>
and consume the result with a <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio/overview/model/completion_tokens.html">completion token</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">Context</span> <span class="o">&amp;</span> <span class="n">context</span><span class="p">,</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">CompletionToken</span><span class="o">&amp;&amp;</span> <span class="n">token</span><span class="p">);</span>
<span class="k">auto</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">Executor</span> <span class="n">executor</span><span class="p">,</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">CompletionToken</span><span class="o">&amp;&amp;</span> <span class="n">token</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spawn will dispatch its initiation and post the completion.
That makes it safe to use task to run the task on another executor
and consume the result on the current one with <a href="#use_op">use_op</a>.
That is, <code>spawn</code> can be used to cross threads.</p>
</div>
<div class="sect3">
<h4 id="example_2">Example</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">work</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ctx</span><span class="p">{</span><span class="n">BOOST_ASIO_CONCURRENCY_HINT_1</span><span class="p">};</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">spawn</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">work</span><span class="p">(),</span> <span class="n">asio</span><span class="o">::</span><span class="n">use_future</span><span class="p">);</span>
  <span class="n">ctx</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The caller needs to make sure that the executor is not running on multiple threads
concurrently, e,g, by using a single-threaded <code>asio::io_context</code> or a <code>strand</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="run">cobalt/run.hpp</h3>
<div class="paragraph">
<p>The <code>run</code> function is similar to <a href="#spawn">spawn</a> but running synchronously.
It will internally setup an execution context and the memory resources.</p>
</div>
<div class="paragraph">
<p>This can be useful when integrating a piece of cobalt code into a synchronous application.</p>
</div>
<div class="sect3">
<h4 id="run-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Run the task and return it's value or rethrow any exception.</span>
<span class="n">T</span> <span class="nf">run</span><span class="p">(</span><span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="run-example">Example</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">work</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">run</span><span class="p">(</span><span class="n">work</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="thread">cobalt/thread.hpp</h3>
<div class="paragraph">
<p>The thread type is another way to create an environment that is similar to <code>main</code>, but doesn&#8217;t use a <code>signal_set</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">my_thread</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">exec</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">;</span>             <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="n">exec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">)};</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>                      <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>get the executor <code>thread</code> running on</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use it with an asio object</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>co_await</code> an cobalt operation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use a thread you can use it like a <code>std::thread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">thr</span> <span class="o">=</span> <span class="n">my_thread</span><span class="p">();</span>
  <span class="n">thr</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A thread is also an <code>awaitable</code> (including cancellation).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">thr</span> <span class="o">=</span> <span class="n">my_thread</span><span class="p">();</span>
  <span class="k">co_await</span> <span class="n">thr</span><span class="p">;</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Destructing a detached thread will cause a hard stop (<code>io_context::stop</code>) and join the thread.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Nothing in this library, except for awaiting a <a href="#thread">cobalt/thread.hpp</a> and <a href="#spawn">cobalt/spawn.hpp</a>, is thread-safe.
If you need to transfer data across threads, you&#8217;ll need a thread-safe utility like <a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/reference/experimental__basic_concurrent_channel.html"><code>asio::concurrent_channel</code></a>.
You cannot share any cobalt primitives between threads,
with the sole exception of being able to <a href="#spawn">spawn</a> a <a href="#task">task</a> onto another thread&#8217;s executor.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="executor_5">Executor</h4>
<div id="thread-executor" class="paragraph">
<p>It will also create an <code>asio::io_context</code> to run on, which you can get through the <code>this_coro::executor</code>.
It will be assigned to the <code>cobalt::this_thread::get_executor()</code> .</p>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_5">Memory Resource</h4>
<div id="thread-allocator" class="paragraph">
<p>It also creates a memory resource that will be used as a default for internal memory allocations.
It will be assigned to the <code>thread_local</code> to the  <code>cobalt::this_thread::get_default_resource()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="thread-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">thread</span>
<span class="p">{</span>
  <span class="c1">// Send a cancellation signal</span>
  <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>


  <span class="c1">// Allow the thread to be awaited. NOOP if the thread is invalid.</span>
  <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="o">&amp;-&gt;</span> <span class="n">detail</span><span class="o">::</span><span class="n">thread_awaitable</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">-&gt;</span> <span class="n">detail</span><span class="o">::</span><span class="n">thread_awaitable</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="c1">// Stops the io_context &amp; joins the executor</span>
  <span class="o">~</span><span class="kr">thread</span><span class="p">();</span>
  <span class="c1">/// Move constructible</span>
  <span class="kr">thread</span><span class="p">(</span><span class="kr">thread</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">executor_type</span> <span class="o">=</span> <span class="n">executor</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span><span class="p">;</span>
  <span class="n">id</span> <span class="n">get_id</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="c1">// Add the functions similar to `std::thread`</span>
  <span class="kt">void</span> <span class="n">join</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">joinable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">detach</span><span class="p">();</span>

  <span class="n">executor_type</span> <span class="n">get_executor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Supports <a href="#interrupt_await">Interrupt Wait</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Always forward cancel</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="thread-promise">Promise</h4>
<div class="paragraph">
<p>The thread promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="result">cobalt/result.hpp</h3>
<div class="paragraph">
<p>Awaitables can be modified to return <code>system::result</code> or
<code>std::tuple</code> instead of using exceptions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// value only</span>
<span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">foo</span><span class="p">();</span>

<span class="c1">// as result</span>
<span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">as_result</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span>

<span class="c1">// as tuple</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">as_tuple</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Awaitables can also provide custom ways to handle results and tuples,
by providing <code>await_resume</code> overloads using <code>cobalt::as_result_tag</code> and <code>cobalt::as_tuple_tag</code>.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n"><em>your_result_type</em></span> <span class="nf">await_resume</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">as_result_tag</span><span class="p">);</span>
<span class="n"><em>your_tuple_type</em></span>  <span class="nf">await_resume</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">as_tuple_tag</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows an awaitable to provide other error types than <code>std::exception_ptr</code>,
for example <code>system::error_code</code>. This is done by <a href="#op">op</a> and <a href="#channel">channel</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// example of an op with result system::error_code, std::size_t</span>
<span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span>                 <span class="n">await_resume</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">as_result_tag</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">await_resume</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">as_tuple_tag</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Awaitables are still allowed to throw exceptions, e.g. for critical exceptions such as OOM.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="async_for">cobalt/async_for.hpp</h3>
<div class="paragraph">
<p>For types like generators a <code>BOOST_COBALT_FOR</code> macro is provided, to emulate an <code>for co_await</code> loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">();</span>

<span class="n">cobalt</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">BOOST_COBALT_FOR</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="p">,</span> <span class="n">gen</span><span class="p">())</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Generated value %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The requirement is that the <a href="#awaitable">awaitable</a> used in the for loop has an <code>operator bool</code> to check if it
can be awaited again. This is the case for <a href="#generator">generator</a> and <a href="#promise">promise</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="error">cobalt/error.hpp</h3>
<div class="paragraph">
<p>In order to make errors easier to manage, cobalt provides an <code>error_category</code> to be used with
<code>boost::system::error_code</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">error</span>
<span class="p">{</span>
  <span class="n">moved_from</span><span class="p">,</span>
  <span class="n">detached</span><span class="p">,</span>
  <span class="n">completed_unexpected</span><span class="p">,</span>
  <span class="n">wait_not_ready</span><span class="p">,</span>
  <span class="n">already_awaited</span><span class="p">,</span>
  <span class="n">allocation_failed</span>
<span class="p">};</span>

<span class="n">system</span><span class="o">::</span><span class="n">error_category</span> <span class="o">&amp;</span> <span class="n">cobalt_category</span><span class="p">();</span>
<span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">error</span> <span class="n">e</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="config">cobalt/config.hpp</h3>
<div class="paragraph">
<p>The config adder allows to config some implementation details of boost.cobalt.</p>
</div>
<div class="sect3">
<h4 id="executor_type">executor_type</h4>
<div class="paragraph">
<p>The executor type defaults to <code>boost::asio::any_io_executor</code>.</p>
</div>
<div class="paragraph">
<p>You can set it to <code>boost::asio::any_io_executor</code> by defining <code>BOOST_COBALT_CUSTOM_EXECUTOR</code>
and adding a <code>boost::cobalt::executor</code> type yourself.</p>
</div>
<div class="paragraph">
<p>Alternatively, <code>BOOST_COBALT_USE_IO_CONTEXT</code> can be defined
to set the executor to <code>boost::asio::io_context::executor_type</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pmr">pmr</h4>
<div class="paragraph">
<p>Boost.cobalt can be used with different pmr implementations, defaulting to <code>std::pmr</code>.</p>
</div>
<div class="paragraph">
<p>The following macros can be used to configure it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BOOST_COBALT_USE_STD_PMR</code></p>
</li>
<li>
<p><code>BOOST_COBALT_USE_BOOST_CONTAINER_PMR</code></p>
</li>
<li>
<p><code>BOOST_COBALT_USE_CUSTOM_PMR</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you define <code>BOOST_COBALT_USE_CUSTOM_PMR</code> you will need to provide a <code>boost::cobalt::pmr</code> namespace,
that is a drop-in replacement for <code>std::pmr</code>.</p>
</div>
<div class="paragraph">
<p>Alternatively, the <code>pmr</code> use can be disabled with</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BOOST_COBALT_NO_PMR</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this case, cobalt will use a non-pmr monotonic resource for the
synchronization functions (<a href="#race">race</a>, <a href="#gather">gather</a> and <a href="#join">join</a>).</p>
</div>
<div class="paragraph">
<p><code>use_op</code> uses a small-buffer-optimized resource which&#8217;s size can be set by defining
<code>BOOST_COBALT_SBO_BUFFER_SIZE</code> and defaults to 4096 bytes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="leaf">cobalt/leaf.hpp</h3>
<div class="paragraph">
<p>Async provides integration with boost.leaf.
It provides functions similar to leaf that take an <a href="#awaitable">awaitables</a>
instead of a function object and return an <a href="#awaitable">awaitable</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">awaitable</span> <span class="n">TryAwaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">H</span> <span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">try_catch</span><span class="p">(</span><span class="n">TryAwaitable</span> <span class="o">&amp;&amp;</span> <span class="n">try_coro</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">awaitable</span> <span class="n">TryAwaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">H</span> <span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">try_handle_all</span><span class="p">(</span><span class="n">TryAwaitable</span> <span class="o">&amp;&amp;</span> <span class="n">try_coro</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">awaitable</span> <span class="n">TryAwaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">H</span> <span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">try_handle_some</span><span class="p">(</span><span class="n">TryAwaitable</span> <span class="o">&amp;&amp;</span> <span class="n">try_coro</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the leaf documentation for details.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.boost.org/doc/libs/master/libs/leaf/doc/html/index.html#try_catch">try_catch</a></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/master/libs/leaf/doc/html/index.html#try_handle_all">try_handle_all</a></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/master/libs/leaf/doc/html/index.html#try_handle_some">try_handle_some</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="in_depth">In-Depth</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="custom_executors">Custom Executors</h3>
<div class="paragraph">
<p>One of the reasons cobalt defaults to <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio/reference/any_io_executor.html::"><code>asio::any_io_executor</code></a>
is that it is a type-erased executor, i.e. you can provide your own event-loop without needing to recompile <code>cobalt</code>.</p>
</div>
<div class="paragraph">
<p>However, during the development of the Executor TS, the executor concepts got a bit unintuitive, to put it mildly.</p>
</div>
<div class="paragraph">
<p>Ruben Perez wrote an excellent <a href="https://anarthal.github.io/cppblog/asio-props.html::">blog post</a>, which I am shamelessly going to draw from.</p>
</div>
<div class="sect3">
<h4 id="definition">Definition</h4>
<div class="paragraph">
<p>An executor is a type that points to the actual event loop and is (cheaply) copyable,
which supports properties (see below) is equality comparable and has an <code>execute</code> function.</p>
</div>
<div class="sect4">
<h5 id="execute"><code>execute</code></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">example_executor</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Fn</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">execute</span><span class="p">(</span><span class="n">Fn</span> <span class="o">&amp;&amp;</span> <span class="n">fn</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above function executes <code>fn</code> in accordance with its properties.</p>
</div>
</div>
<div class="sect4">
<h5 id="properties">Properties</h5>
<div class="paragraph">
<p>A property can be queried, preferred or required, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">example_executor</span>
<span class="p">{</span>
  <span class="c1">// get a property by querying it.</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">relationship_t</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">relationship_t</span><span class="p">)</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">relationship</span><span class="p">.</span><span class="n">fork</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// require an executor with a new property</span>
  <span class="n">never_blocking_executor</span> <span class="n">require</span><span class="p">(</span><span class="k">const</span> <span class="n">execution</span><span class="o">::</span><span class="n">blocking_t</span><span class="o">::</span><span class="n">never_t</span><span class="p">);</span>

  <span class="c1">// prefer an executor with a new property. the executor may or may not support it.</span>
  <span class="n">never_blocking_executor</span> <span class="n">prefer</span><span class="p">(</span><span class="k">const</span> <span class="n">execution</span><span class="o">::</span><span class="n">blocking_t</span><span class="o">::</span><span class="n">never_t</span><span class="p">);</span>
  <span class="c1">// not supported</span>
  <span class="n">example_executor</span> <span class="n">prefer</span><span class="p">(</span><span class="k">const</span> <span class="n">execution</span><span class="o">::</span><span class="n">blocking_t</span><span class="o">::</span><span class="n">always_t</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="properties_of_the_asioany_io_executor">Properties of the <code>asio::any_io_executor</code></h5>
<div class="paragraph">
<p>In order to wrap an executor in an <code>asio::any_io_executor</code> two properties are required:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>`execution::context_t</p>
</li>
<li>
<p><code>execution::blocking_t::never_t</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That means we need to either make them require-able (which makes no sense for context) or return the expected value
from <code>query</code>.</p>
</div>
<div class="paragraph">
<p>The <code>execution::context_t</code> query should return <code>asio::execution_context&amp;</code> like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">example_executor</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">execution_context</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">context_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The execution context is used to manage lifetimes of services that manage lifetimes io-objects,
such as asio&#8217;s timers &amp; sockets. That is to say, by providing this context, all of asio&#8217;s io works with it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>execution_context</code> must remain alive after the executor gets destroyed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following may be preferred:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>execution::blocking_t::possibly_t</code></p>
</li>
<li>
<p><code>execution::outstanding_work_t::tracked_t</code></p>
</li>
<li>
<p><code>execution::outstanding_work_t::untracked_t</code></p>
</li>
<li>
<p><code>execution::relationship_t::fork_t</code></p>
</li>
<li>
<p><code>execution::relationship_t::continuation_</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That means you might want to support them in your executor for optimizations.</p>
</div>
</div>
<div class="sect4">
<h5 id="the_blocking_property">The <code>blocking</code> property</h5>
<div class="paragraph">
<p>As we&#8217;ve seen before, this property controls whether the function passed to <code>execute()</code>
can be run immediately, as part of <code>execute()</code>, or must be queued for later execution.
Possible values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>asio::execution::blocking.never</code>: never run the function as part of <code>execute()</code>.
This is what <code>asio::post()</code> does.</p>
</li>
<li>
<p><code>asio::execution::blocking.possibly</code>: the function may or may not be run as part of <code>execute()</code>.
This is the default (what you get when calling <code>io_context::get_executor</code>).</p>
</li>
<li>
<p><code>asio::execution::blocking.always</code>: the function is always run as part of <code>execute()</code>.
This is not supported by <code>io_context::executor</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="the_relationship_property">The <code>relationship</code> property</h5>
<div class="paragraph">
<p><code>relationship</code> can take two values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>asio::execution::relationship.continuation</code>: indicates that the function passed to <code>execute()</code>
is a continuation of the function calling <code>execute()</code>.</p>
</li>
<li>
<p><code>asio::execution::relationship.fork</code>: the opposite of the above. This is the default
(what you get when calling <code>io_context::get_executor()</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Setting this property to <code>continuation</code> enables some optimizations
in how the function gets scheduled. It only has effect if the function
is queued (as opposed to run immediately). For <code>io_context</code>, when set, the function
is scheduled to run in a faster, thread-local queue, rather than the context-global one.</p>
</div>
</div>
<div class="sect4">
<h5 id="the_outstanding_work_t_property">The <code>outstanding_work_t</code> property</h5>
<div class="paragraph">
<p><code>outstanding_work</code> can take two values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>asio::execution::outstanding_work.tracked</code>: indicates that while the executor is alive, there&#8217;s still work to do.</p>
</li>
<li>
<p><code>asio::execution::outstanding_work.untracked</code>: the opposite of the above. This is the default
(what you get when calling <code>io_context::get_executor()</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Setting this property to <code>tracked</code> means that the event loop will not return as long as the <code>executor</code> is alive.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="a_minimal_executor">A minimal executor</h4>
<div class="paragraph">
<p>With this, let&#8217;s look at the interface of a minimal executor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">minimal_executor</span>
<span class="p">{</span>
  <span class="n">minimal_executor</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="n">asio</span><span class="o">::</span><span class="n">execution_context</span> <span class="o">&amp;</span><span class="n">query</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">context_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">static</span> <span class="k">constexpr</span> <span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">blocking_t</span>
  <span class="n">query</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">blocking_t</span><span class="p">)</span> <span class="k">noexcept</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">blocking</span><span class="p">.</span><span class="n">never</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">execute</span><span class="p">(</span><span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">minimal_executor</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">minimal_executor</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See <a href="https://github.com/boostorg/cobalt/tree/master/example/python.cpp">example/python.cpp</a>
for an implementation using python&#8217;s <code>asyncio</code> event-loop.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="adding_a_work_guard">Adding a work guard.</h4>
<div class="paragraph">
<p>Now, let&#8217;s add in a <code>require</code> function for the <code>outstanding_work</code> property, that uses multiple types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">untracked_executor</span> <span class="o">:</span> <span class="n">minimal_executor</span>
<span class="p">{</span>
  <span class="n">untracked_executor</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">constexpr</span>   <span class="n">tracked_executor</span> <span class="n">require</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span>  <span class="n">tracked_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="n">untracked_executor</span> <span class="n">require</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span><span class="n">untracked_t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">untracked_executor</span> <span class="o">:</span> <span class="n">minimal_executor</span>
<span class="p">{</span>
  <span class="n">untracked_executor</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">constexpr</span>   <span class="n">tracked_executor</span> <span class="n">require</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span>  <span class="n">tracked_t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;}</span>
  <span class="k">constexpr</span> <span class="n">untracked_executor</span> <span class="n">require</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span><span class="n">untracked_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it is not necessary to return a different type from the <code>require</code> function, it can also be done like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">trackable_executor</span> <span class="o">:</span> <span class="n">minimal_executor</span>
<span class="p">{</span>
  <span class="n">trackable_executor</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">constexpr</span> <span class="n">trackable_executor</span> <span class="n">require</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span>  <span class="n">tracked_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="n">trackable_executor</span> <span class="n">require</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span><span class="n">untracked_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we wanted to use <code>prefer</code> it would look as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">trackable_executor</span> <span class="o">:</span> <span class="n">minimal_executor</span>
<span class="p">{</span>
  <span class="n">trackable_executor</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">constexpr</span> <span class="n">trackable_executor</span> <span class="n">prefer</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span>  <span class="n">tracked_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="n">trackable_executor</span> <span class="n">prefer</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">outstanding_work</span><span class="o">::</span><span class="n">untracked_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="summary">Summary</h4>
<div class="paragraph">
<p>As you can see, the property system is not trivial, but quite powerful.
Implementing a custom executor is a problem category of its own, which is why this documentation doesn&#8217;t do that.
Rather, there is an example of how to wrap a python event loop in an executor.</p>
</div>
<div class="paragraph">
<p>Below are some reading recommendations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://cppalliance.org/richard/2020/10/31/RichardsOctoberUpdate.html">Richards October 2020 Update - container a qt-executor</a></p>
</li>
<li>
<p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r13.html">A Unified Executors Proposal for C++ | P0443R13</a></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/std_executors.html">Asio&#8217;s documentation on std executors</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stackless">Stackless</h3>
<div class="paragraph">
<p>C++20 coroutines are stackless, meaning they don&#8217;t have their own stack.</p>
</div>
<div class="paragraph">
<p>A stack in C++ describes the callstack, i.e. all the function frames stacked.
A function frame is the memory a function needs to operate, i.e. a slice of memory
to store its variables and information such as the return address.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The size of a function frame is known at compile time, but not outside the compile unit containing its definition.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">int</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span> <span class="c1">// the deepest point of the stack</span>
<span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">bar</span><span class="p">();}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The call stack in the above example is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">main</span><span class="p">()</span>
  <span class="n">foo</span><span class="p">()</span>
    <span class="n">bar</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: mmdc failed:
Error: Failed to launch the browser process!
/root/.cache/puppeteer/chrome/linux-1108766/chrome-linux/chrome: error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory


TROUBLESHOOTING: https://pptr.dev/troubleshooting

    at Interface.onClose (file:///root/.nvm/versions/node/v18.18.1/lib/node_modules/@mermaid-js/mermaid-cli/node_modules/@puppeteer/browsers/lib/esm/launch.js:253:24)
    at Interface.emit (node:events:529:35)
    at Interface.close (node:internal/readline/interface:534:10)
    at Socket.onend (node:internal/readline/interface:260:10)
    at Socket.emit (node:events:529:35)
    at endReadableNT (node:internal/streams/readable:1368:12)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)


sequenceDiagram
    main-&gt;&gt;+foo: call
    foo-&gt;&gt;+bar: call
    bar-&gt;&gt;-foo: return
    foo-&gt;&gt;-main: return</pre>
</div>
</div>
<div class="paragraph">
<p>Coroutines can be implemented a stackful, which means that it allocates a fixes chunk of memory and stacks function frames similar to a thread.
C++20 coroutines are stackless, i.e. they only allocate their own frame and use the callers stack on resumption. Using our previous example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">fictional_eager_coro_type</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">co_yield</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">co_yield</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">nested_resume</span><span class="p">(</span><span class="n">fictional_eager_coro_type</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">example</span><span class="p">();</span>
    <span class="n">nested_resume</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">reenter</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will yield a call stack similar to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">main</span><span class="p">()</span>
  <span class="n">f</span><span class="err">$</span><span class="n">example</span><span class="p">()</span>
  <span class="n">nested_resume</span><span class="p">()</span>
    <span class="n">f</span><span class="err">$</span><span class="n">example</span><span class="p">()</span>
  <span class="n">f</span><span class="err">$</span><span class="n">example</span><span class="p">()</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: mmdc failed:
Error: Failed to launch the browser process!
/root/.cache/puppeteer/chrome/linux-1108766/chrome-linux/chrome: error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory


TROUBLESHOOTING: https://pptr.dev/troubleshooting

    at Interface.onClose (file:///root/.nvm/versions/node/v18.18.1/lib/node_modules/@mermaid-js/mermaid-cli/node_modules/@puppeteer/browsers/lib/esm/launch.js:253:24)
    at Interface.emit (node:events:529:35)
    at Interface.close (node:internal/readline/interface:534:10)
    at Socket.onend (node:internal/readline/interface:260:10)
    at Socket.emit (node:events:529:35)
    at endReadableNT (node:internal/streams/readable:1368:12)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)


sequenceDiagram
    participant main
    participant nested_resume
    main-&gt;&gt;+example: create &amp; call
    example--&gt;&gt;main: co_yield
    main-&gt;&gt;+nested_resume: call
    nested_resume--&gt;&gt;example: resume
    example--&gt;&gt;nested_resume: co_yield
    nested_resume-&gt;&gt;-main: return
    main--&gt;&gt;example: resume
    example-&gt;&gt;-main: co_return</pre>
</div>
</div>
<div class="paragraph">
<p>The same applies if a coroutine gets moved accross threads.</p>
</div>
</div>
<div class="sect2">
<h3 id="lazy_eager">Lazy &amp; eager</h3>
<div class="paragraph">
<p>Coroutines are lazy if they only start execution of its code after it gets resumed, while an eager one will execute right-away until its first suspension point (i.e. a <code>co_await</code>, <code>co_yield</code> or <code>co_return</code> expression.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">lazy_coro</span> <span class="nf">co_example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Entered coro</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">co_yield</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Coro done</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"enter main</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lazy</span> <span class="o">=</span> <span class="n">co_example</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"constructed coro</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">lazy</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"resumed once</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">lazy</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"resumed twice</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will produce output like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">enter</span> <span class="n">main</span>
<span class="n">constructed</span> <span class="n">coro</span>
<span class="n">Entered</span> <span class="n">coro</span>
<span class="n">resumed</span> <span class="n">once</span>
<span class="n">Coro</span> <span class="n">Done</span>
<span class="n">resumed</span> <span class="n">twice</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: mmdc failed:
Error: Failed to launch the browser process!
/root/.cache/puppeteer/chrome/linux-1108766/chrome-linux/chrome: error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory


TROUBLESHOOTING: https://pptr.dev/troubleshooting

    at Interface.onClose (file:///root/.nvm/versions/node/v18.18.1/lib/node_modules/@mermaid-js/mermaid-cli/node_modules/@puppeteer/browsers/lib/esm/launch.js:253:24)
    at Interface.emit (node:events:529:35)
    at Interface.close (node:internal/readline/interface:534:10)
    at Socket.onend (node:internal/readline/interface:260:10)
    at Socket.emit (node:events:529:35)
    at endReadableNT (node:internal/streams/readable:1368:12)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)


sequenceDiagram
    participant main;
    Note left of main: "enter main"
    main--&gt;&gt;+lazy: co_example()
    Note left of main: "constructed coro"
    main-&gt;&gt;lazy: resume()
    Note right of lazy: "Entered coro
    lazy--&gt;&gt;main: co_yield 0
    Note left of main: "resumed once"
    main--&gt;&gt;+lazy: resume()
    Note right of lazy: "Coro done"
    lazy-&gt;&gt;main: co_return
    Note left of main: "resumed twice"</pre>
</div>
</div>
<div class="paragraph">
<p>Whereas an eager coro would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">eager_coro</span> <span class="nf">co_example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Entered coro</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">co_yield</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Coro done</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"enter main</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lazy</span> <span class="o">=</span> <span class="n">co_example</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"constructed coro</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">lazy</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"resumed once</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will produce output like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">enter</span> <span class="n">main</span>
<span class="n">Entered</span> <span class="n">coro</span>
<span class="n">constructed</span> <span class="n">coro</span>
<span class="n">resume</span> <span class="n">once</span>
<span class="n">Coro</span> <span class="n">Done</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Failed to generate image: mmdc failed:
Error: Failed to launch the browser process!
/root/.cache/puppeteer/chrome/linux-1108766/chrome-linux/chrome: error while loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory


TROUBLESHOOTING: https://pptr.dev/troubleshooting

    at Interface.onClose (file:///root/.nvm/versions/node/v18.18.1/lib/node_modules/@mermaid-js/mermaid-cli/node_modules/@puppeteer/browsers/lib/esm/launch.js:253:24)
    at Interface.emit (node:events:529:35)
    at Interface.close (node:internal/readline/interface:534:10)
    at Socket.onend (node:internal/readline/interface:260:10)
    at Socket.emit (node:events:529:35)
    at endReadableNT (node:internal/streams/readable:1368:12)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21)


sequenceDiagram
    participant main;
    Note left of main: "enter main"
    main-&gt;&gt;lazy: co_example()
    Note right of lazy: "Entered coro
    lazy--&gt;&gt;main: co_yield 0
    Note left of main: "constructed coro"
    main--&gt;&gt;+lazy: resume()
    Note right of lazy: "Coro done"
    lazy-&gt;&gt;main: co_return
    Note left of main: "resumed once"</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="benchmarks">Benchmarks</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Run on 11th Gen Intel&#174; Core&#8482; i7-1185G7 @ 3.00GHz</em></p>
</div>
<div class="sect2">
<h3 id="posting_to_an_executor">Posting to an executor</h3>
<div class="paragraph">
<p>The benchmark is running the following code, with cobalt&#8217;s task, <code>asio::awaitable</code> and `asio&#8217;s
stackful coroutine (boost.context) based.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">atest</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">co_await</span> <span class="n">asio</span><span class="o">::</span><span class="n">post</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. results for 50M times in ms</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">gcc 12</th>
<th class="tableblock halign-left valign-top">clang 16</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cobalt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2472</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2098</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">awaitable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2432</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2253</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stackful</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3655</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3725</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="running_noop_coroutine_in_parallel">Running noop coroutine in parallel</h3>
<div class="paragraph">
<p>This benchmark uses an <code>asio::experimental::channel</code> that has a size of zero,
to read &amp; write in parallel to it. It uses <a href="#gather">gather</a> with cobalt
and an <code>awaitable_operator</code> in the <code>asio::awaitable</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">atest</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">chan</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="mi">0u</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">gather</span><span class="p">(</span>
              <span class="n">chan</span><span class="p">.</span><span class="n">async_send</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">{},</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">use_task</span><span class="p">),</span>
              <span class="n">chan</span><span class="p">.</span><span class="n">async_receive</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_task</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">asio</span><span class="o">::</span><span class="n">awaitable</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">awtest</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">chan</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="mi">0u</span><span class="p">};</span>
  <span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">awaitable_operators</span><span class="o">::</span><span class="k">operator</span><span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">co_await</span> <span class="p">(</span>
        <span class="n">chan</span><span class="p">.</span><span class="n">async_send</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">{},</span> <span class="n">asio</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span>
        <span class="n">chan</span><span class="p">.</span><span class="n">async_receive</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">use_awaitable</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. results for 3M times in ms</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">gcc 12</th>
<th class="tableblock halign-left valign-top">clang 16</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cobalt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1563</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1468</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">awaitable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2800</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2805</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="immediate">Immediate</h3>
<div class="paragraph">
<p>This benchmark utilizes the immediate completion, by using a channel
with a size of 1, so that every operation is immediate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">cobalt</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">atest</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">chan</span><span class="p">{</span><span class="k">co_await</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="mi">1u</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">co_await</span> <span class="n">chan</span><span class="p">.</span><span class="n">async_send</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">{},</span> <span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
    <span class="k">co_await</span> <span class="n">chan</span><span class="p">.</span><span class="n">async_receive</span><span class="p">(</span><span class="n">cobalt</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. result for 10M times in ms</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">gcc 12</th>
<th class="tableblock halign-left valign-top">clang 16</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cobalt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1810</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1864</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">awaitable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3109</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4110</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stackful</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3922</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4705</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="channels">Channels</h3>
<div class="paragraph">
<p>In this benchmark asio::experimental::channel and cobalt::channel get compared.</p>
</div>
<div class="paragraph">
<p>This is similar to the parallel test, but uses the <code>cobalt::channel</code> instead.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. result of running the test 3M times in ms</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">gcc</th>
<th class="tableblock halign-left valign-top">clang</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cobalt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">350</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">awaitable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">790</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">770</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stackful</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">867</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">907</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="operation_allocations">Operation Allocations</h3>
<div class="paragraph">
<p>This benchmark compares the different possible solutions for the associated allocator of asynchronous operations</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. result of running the test 2M times in ms</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">gcc</th>
<th class="tableblock halign-left valign-top">clang</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">std::allocator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1136</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1139</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cobalt::monotonic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1149</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1270</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pmr::monotonic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1164</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1173</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cobalt::sbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1021</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1060</p>
<p class="tableblock">The latter method is used internally by cobalt.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="requirements">Requirements</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="libraries">Libraries</h3>
<div class="paragraph">
<p>Boost.cobalt requires a C++20 compilers and directly depends on the following boost libraries:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>boost.asio</p>
</li>
<li>
<p>boost.system</p>
</li>
<li>
<p>boost.circular_buffer</p>
</li>
<li>
<p>boost.intrusive</p>
</li>
<li>
<p>boost.smart_ptr</p>
</li>
<li>
<p>boost.container (for clang &lt; 16)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="compiler">Compiler</h3>
<div class="paragraph">
<p>This library is supported since Clang 14, Gcc 10 &amp; MSVC 19.30 (Visual Studio 2022).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Gcc versions 12.1 and 12.2 appear to have a bug for coroutines with out stack variables
as can be seen [here](<a href="https://godbolt.org/z/6adGcqP1z" class="bare">https://godbolt.org/z/6adGcqP1z</a>) and should be avoided for coroutines.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Clang only added <code>std::pmr</code> support in 16, so older clang versions use <code>boost::contianer::pmr</code> as a drop-in replacement.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Some if not all MSVC versions have a broken coroutine implementation,
that this library needs to workaround. This may cause non-deterministic behaviour and overhead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A coroutine continuation may be done in the awaitable returned from a <code>final_suspend</code>, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// in promise</span>
<span class="k">auto</span> <span class="n">final_suspend</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">final_awaitable</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">continuation</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">()};</span> <i class="conum" data-value="1"></i><b>(1)</b>
      <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="p">{</span>
        <span class="k">auto</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">continuation</span><span class="p">;</span>
        <span class="n">h</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">return</span> <span class="n">cc</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kt">void</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="n">final_awaitable</span><span class="p">{</span><span class="n">my_continuation</span><span class="p">};</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The continuation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Self-destroying the coroutine before continuation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The final_suspend does not properly suspend the coroutine on MSVC, so that the <code>h.destroy()</code> will cause
double destruction of elements on the coroutine frame.
Therefor, msvc will need to post the destruction, to do it out of line.
This will cause overhead and make the actual freeing of memory not deterministic.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="acknowledgements">Acknowledgements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This library would not have been possible without the CppAlliance and its founder Vinnie Falco.
Vinnie trusted me enough to let me work on this project, while himself having very different views on how such a library should be designed.</p>
</div>
<div class="paragraph">
<p>Thanks also go to Ruben Perez &amp; Richard Hodges for listening to my design problems and giving me advice &amp; use-cases. Furthermore, this library would not have been possible without the great boost.asio by Chris Kohlhoff.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.1<br>
Last updated 2023-12-06 21:03:01 UTC
</div>
</div>
</body>
</html>