<?xml version="1.0" standalone="yes"?>
<library-reference id="reference_section_of_pfr"><title>Reference Section of PFR</title><header name="boost/pfr.hpp">
<para>Includes all the Boost.PFR headers </para></header>
<header name="boost/pfr/config.hpp">
<para>Contains all the macros that describe Boost.PFR configuration, like BOOST_PFR_ENABLED</para><para><note><para>This header file doesn't require C++14 Standard and supports all C++ compilers, even pre C++14 compilers (C++11, C++03...). </para>
</note>
</para><macro name="BOOST_PFR_NOT_SUPPORTED"/>
<macro name="BOOST_PFR_USE_LOOPHOLE"/>
<macro name="BOOST_PFR_USE_CPP17"><purpose>in Visual Studio 2017 v15.9 PFR library with classic engine normally works </purpose></macro>
<macro name="BOOST_PFR_USE_STD_MAKE_INTEGRAL_SEQUENCE"/>
<macro name="BOOST_PFR_HAS_GUARANTEED_COPY_ELISION"/>
<macro name="BOOST_PFR_ENABLE_IMPLICIT_REFLECTION"/>
<macro name="BOOST_PFR_CORE_NAME_ENABLED"/>
<macro name="BOOST_PFR_CORE_NAME_PARSING"/>
<macro name="BOOST_PFR_MAYBE_UNUSED"/>
<macro name="BOOST_PFR_ENABLED"/>
</header>
<header name="boost/pfr/core.hpp">
<para>Contains all the basic tuple-like interfaces  <link linkend="boost.pfr.get"> boost::pfr::get </link>,  <link linkend="boost.pfr.tuple_size"> boost::pfr::tuple_size </link>,  <link linkend="boost.pfr.tuple_element_t"> boost::pfr::tuple_element_t </link>, and others.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<typedef name="tuple_element"><purpose><computeroutput>tuple_element</computeroutput> has a member typedef <computeroutput>type</computeroutput> that returns the type of a field with index I in  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> T. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::vector&lt; boost::pfr::tuple_element&lt;0, my_structure&gt;::type &gt; v;
</programlisting> </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="tuple_element_t"><purpose>Type of a field with index <computeroutput>I</computeroutput> in  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>T</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::vector&lt; boost::pfr::tuple_element_t&lt;0, my_structure&gt; &gt; v;
</programlisting> </para></description><type>typename tuple_element&lt; I, T &gt;::type</type></typedef>

























<function name="get"><type>constexpr decltype(auto)</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><purpose>Returns reference or const reference to a field with index <computeroutput>I</computeroutput> in  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>val</computeroutput>. Overload taking the type <computeroutput>U</computeroutput> returns reference or const reference to a field with provided type <computeroutput>U</computeroutput> in  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>val</computeroutput> if there's only one field of such type in <computeroutput>val</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };
my_struct s {10, 11};

assert(boost::pfr::get&lt;0&gt;(s) == 10);
boost::pfr::get&lt;1&gt;(s) = 0;

assert(boost::pfr::get&lt;int&gt;(s) == 10);
boost::pfr::get&lt;short&gt;(s) = 11;
</programlisting> </para></description></function>
<function name="get"><type>constexpr decltype(auto)</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="get"><type>constexpr auto</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="get"><type>constexpr auto</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="get"><type>constexpr const U &amp;</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>const T &amp;</paramtype></parameter></function>
<function name="get"><type>constexpr U &amp;</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="get"><type>constexpr U &amp;</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="get"><type>constexpr U &amp;&amp;</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="structure_to_tuple"><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><purpose>Creates a <computeroutput>std::tuple</computeroutput> from fields of an  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>val</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };
my_struct s {10, 11};
std::tuple&lt;int, short&gt; t = boost::pfr::structure_to_tuple(s);
assert(get&lt;0&gt;(t) == 10);
</programlisting> </para></description></function>
<function name="structure_tie"><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><purpose>std::tie` like function that ties fields of a structure. </purpose><description><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">void foo(const int&amp;, const short&amp;);
struct my_struct { int i, short s; };

const my_struct const_s{1, 2};
std::apply(foo, boost::pfr::structure_tie(const_s));

my_struct s;
boost::pfr::structure_tie(s) = std::tuple&lt;int, short&gt;{10, 11};
assert(s.s == 11);
</programlisting> </para></description><returns><para>a <computeroutput>std::tuple</computeroutput> with lvalue and const lvalue references to fields of an  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>val</computeroutput>.</para>
</returns></function>
<function name="structure_tie"><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="val"><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="structure_tie"><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt;!std::is_assignable&lt; T, T &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="structure_tie"><type>constexpr auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>std::enable_if_t&lt; std::is_rvalue_reference&lt; T &amp;&amp; &gt;::value &gt; *</paramtype><default>nullptr</default></parameter></function>
<function name="for_each_field"><type>constexpr void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="F"/>
        </template><parameter name="value"><paramtype>T &amp;&amp;</paramtype><description><para>To each field of this variable will be the <computeroutput>func</computeroutput> applied.</para></description></parameter><parameter name="func"><paramtype>F &amp;&amp;</paramtype><description><para>must have one of the following signatures:<itemizedlist>
<listitem><para>any_return_type func(U&amp;&amp; field) // field of value is perfect forwarded to function</para>
</listitem><listitem><para>any_return_type func(U&amp;&amp; field, std::size_t i)</para>
</listitem><listitem><para>any_return_type func(U&amp;&amp; value, I i) // Here I is an <computeroutput>std::integral_constant&lt;size_t, field_index&gt;</computeroutput></para>
</listitem></itemizedlist>
</para></description></parameter><description><para>Calls <computeroutput>func</computeroutput> for each field of a <computeroutput>value</computeroutput>.</para><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };
int sum = 0;
boost::pfr::for_each_field(my_struct{20, 22}, [&amp;sum](const auto&amp; field) { sum += field; });
assert(sum == 42);
</programlisting> </para></description></function>
<function name="tie_from_structure"><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Elements"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Elements &amp;...</paramtype></parameter><purpose>std::tie-like function that allows assigning to tied values from aggregates. </purpose><description><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">auto f() {
  struct { struct { int x, y } p; short s; } res { { 4, 5 }, 6 };
  return res;
}
auto [p, s] = f();
boost::pfr::tie_from_structure(p, s) = f();
</programlisting> </para></description><returns><para>an object with lvalue references to <computeroutput>args...</computeroutput>; on assignment of an  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> value to that object each field of an aggregate is assigned to the corresponding <computeroutput>args...</computeroutput> reference.</para>
</returns></function>
</namespace>
</namespace>
</header>
<header name="boost/pfr/core_name.hpp">
<para>Contains functions  <link linkend="boost.pfr.get_name"> boost::pfr::get_name </link> and  <link linkend="boost.pfr.names_as_array"> boost::pfr::names_as_array </link> to know which names each field of any  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> has.</para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.reflection_of_field_name"> 'Reflection of field names'  </link> for details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">























<function name="get_name"><type>constexpr std::string_view</type><template>
          <template-nontype-parameter name="I"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><purpose>Returns name of a field with index <computeroutput>I</computeroutput> in  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>T</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };

assert(boost::pfr::get_name&lt;0, my_struct&gt;() == "i");
assert(boost::pfr::get_name&lt;1, my_struct&gt;() == "s");
</programlisting> </para></description></function>
<function name="names_as_array"><type>constexpr std::array&lt; std::string_view, boost::pfr::tuple_size_v&lt; T &gt; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><purpose>Creates a <computeroutput>std::array</computeroutput> from names of fields of an  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>T</computeroutput>. </purpose><description><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i, short s; };
std::array&lt;std::string_view, 2&gt; a = boost::pfr::names_as_array&lt;my_struct&gt;();
assert(a[0] == "i");
</programlisting> </para></description></function>















</namespace>
</namespace>
</header>
<header name="boost/pfr/functions_for.hpp">
<para>Contains BOOST_PFR_FUNCTIONS_FOR macro that defined comparison and stream operators for T along with hash_value function. <emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/functions_for.hpp&gt;

namespace my_namespace {
    struct my_struct {      // No operators defined for that structure
        int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
    };
    BOOST_PFR_FUNCTIONS_FOR(my_struct)
}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators'  </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><macro name="BOOST_PFR_FUNCTIONS_FOR" kind="functionlike"><macro-parameter name="T"/><description><para>Defines comparison and stream operators for T along with hash_value function.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/functions_for.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
BOOST_PFR_FUNCTIONS_FOR(comparable_struct)
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
comparable_struct s2 {0, 1, "Hello", false, 6,7,8,9,10,11111};
assert(s1 &lt; s2);
std::cout &lt;&lt; s1 &lt;&lt; std::endl; // Outputs: {0, 1, H, e, l, l, o, , , 0, 6, 7, 8, 9, 10, 11}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators'  </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Defines</emphasis> <emphasis role="bold">following</emphasis> <emphasis role="bold">for</emphasis> <emphasis role="bold">T:</emphasis> <programlisting language="c++">bool operator==(const T&amp; lhs, const T&amp; rhs);
bool operator!=(const T&amp; lhs, const T&amp; rhs);
bool operator&lt; (const T&amp; lhs, const T&amp; rhs);
bool operator&gt; (const T&amp; lhs, const T&amp; rhs);
bool operator&lt;=(const T&amp; lhs, const T&amp; rhs);
bool operator&gt;=(const T&amp; lhs, const T&amp; rhs);

template &lt;class Char, class Traits&gt;
std::basic_ostream&lt;Char, Traits&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Char, Traits&gt;&amp; out, const T&amp; value);

template &lt;class Char, class Traits&gt;
std::basic_istream&lt;Char, Traits&gt;&amp; operator&gt;&gt;(std::basic_istream&lt;Char, Traits&gt;&amp; in, T&amp; value);

// helper function for Boost unordered containers and boost::hash&lt;&gt;.
std::size_t hash_value(const T&amp; value);
</programlisting> </para></description></macro>
</header>
<header name="boost/pfr/functors.hpp">
<para>Contains functors that are close to the Standard Library ones. Each functor calls corresponding Boost.PFR function from boost/pfr/ops.hpp</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/functors.hpp&gt;
struct my_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

std::unordered_set&lt;
    my_struct,
    <classname alt="boost::pfr::hash">boost::pfr::hash&lt;&gt;</classname>,
    <classname alt="boost::pfr::equal_to">boost::pfr::equal_to&lt;&gt;</classname>
&gt; my_set;
</programlisting></para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<struct name="equal_to"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::equal_to like comparator that returns  <link linkend="boost.pfr.eq"> boost::pfr::eq </link>(x, y) </purpose><typedef name="is_transparent"><purpose>This typedef exists only if T <emphasis role="bold">is</emphasis> void. </purpose><type>std::true_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if each field of <emphasis role="bold">x</emphasis> equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const V &amp;</paramtype></parameter><parameter name="y"><paramtype>const U &amp;</paramtype></parameter><description><para>This operator allows comparison of <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> that have different type. 
</para></description><requires><para>Exists only if T <emphasis role="bold">is</emphasis> void. </para>
</requires></method>
</method-group>
</struct><struct name="greater"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::greater like comparator that returns  <link linkend="boost.pfr.gt"> boost::pfr::gt </link>(x, y) </purpose><typedef name="is_transparent"><purpose>This typedef exists only if T <emphasis role="bold">is</emphasis> void. </purpose><type>std::true_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> greater than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const V &amp;</paramtype></parameter><parameter name="y"><paramtype>const U &amp;</paramtype></parameter><description><para>This operator allows comparison of <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> that have different type. 
</para></description><requires><para>Exists only if T <emphasis role="bold">is</emphasis> void. </para>
</requires></method>
</method-group>
</struct><struct name="greater_equal"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::greater_equal like comparator that returns  <link linkend="boost.pfr.ge"> boost::pfr::ge </link>(x, y) </purpose><typedef name="is_transparent"><purpose>This typedef exists only if T <emphasis role="bold">is</emphasis> void. </purpose><type>std::true_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> greater than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>; or if each field of <emphasis role="bold">x</emphasis> equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const V &amp;</paramtype></parameter><parameter name="y"><paramtype>const U &amp;</paramtype></parameter><description><para>This operator allows comparison of <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> that have different type. 
</para></description><requires><para>Exists only if T <emphasis role="bold">is</emphasis> void. </para>
</requires></method>
</method-group>
</struct><struct name="hash"><template>
      <template-type-parameter name="T"/>
    </template><purpose>std::hash like functor that returns  <link linkend="boost.pfr.hash_value"> boost::pfr::hash_value </link>(x) </purpose><method-group name="public member functions">
<method name="operator()" cv="const"><type>std::size_t</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para>hash value of <emphasis role="bold">x</emphasis>. </para>
</returns></method>
</method-group>
</struct><struct name="less"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::less like comparator that returns  <link linkend="boost.pfr.lt"> boost::pfr::lt </link>(x, y) </purpose><typedef name="is_transparent"><purpose>This typedef exists only if T <emphasis role="bold">is</emphasis> void. </purpose><type>std::true_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> less than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const V &amp;</paramtype></parameter><parameter name="y"><paramtype>const U &amp;</paramtype></parameter><description><para>This operator allows comparison of <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> that have different type. 
</para></description><requires><para>Exists only if T <emphasis role="bold">is</emphasis> void. </para>
</requires></method>
</method-group>
</struct><struct name="less_equal"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::less_equal like comparator that returns  <link linkend="boost.pfr.le"> boost::pfr::le </link>(x, y) </purpose><typedef name="is_transparent"><purpose>This typedef exists only if T <emphasis role="bold">is</emphasis> void. </purpose><type>std::true_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if field of <emphasis role="bold">x</emphasis> less than the field with same index of <emphasis role="bold">y</emphasis> and all previous fields of <emphasis role="bold">x</emphasis> equal to the same fields of <emphasis role="bold">y</emphasis>; or if each field of <emphasis role="bold">x</emphasis> equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const V &amp;</paramtype></parameter><parameter name="y"><paramtype>const U &amp;</paramtype></parameter><description><para>This operator allows comparison of <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> that have different type. 
</para></description><requires><para>Exists only if T <emphasis role="bold">is</emphasis> void. </para>
</requires></method>
</method-group>
</struct><struct name="not_equal"><template>
      <template-type-parameter name="T"><default>void</default></template-type-parameter>
    </template><purpose>std::not_equal like comparator that returns  <link linkend="boost.pfr.ne"> boost::pfr::ne </link>(x, y) </purpose><typedef name="is_transparent"><purpose>This typedef exists only if T <emphasis role="bold">is</emphasis> void. </purpose><type>std::true_type</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><parameter name="y"><paramtype>const T &amp;</paramtype></parameter><description><para>
</para></description><returns><para><emphasis role="bold">true</emphasis> if at least one field <emphasis role="bold">x</emphasis> not equals the field with same index of <emphasis role="bold">y</emphasis>. </para>
</returns></method>
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype>const V &amp;</paramtype></parameter><parameter name="y"><paramtype>const U &amp;</paramtype></parameter><description><para>This operator allows comparison of <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> that have different type. 
</para></description><requires><para>Exists only if T <emphasis role="bold">is</emphasis> void. </para>
</requires></method>
</method-group>
</struct>







































</namespace>
</namespace>
</header>
<header name="boost/pfr/io.hpp">
<para>Contains IO stream manipulator  <link linkend="boost.pfr.io"> boost::pfr::io </link> for types. If type is streamable using its own operator or its conversion operator, then the types operator is used.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/io.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
std::cout &lt;&lt; boost::pfr::io(s1);  // Outputs: {0, 1, H, e, l, l, o, , , 0, 6, 7, 8, 9, 10, 11}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators'  </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">






















<function name="io"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>IO manipulator to read/write  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>value</computeroutput> using its IO stream operators or using  <link linkend="boost.pfr.io_fields"> boost::pfr::io_fields </link> if operators are not available.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct { int i; short s; };
my_struct x;
std::stringstream ss;
ss &lt;&lt; "{ 12, 13 }";
ss &gt;&gt; boost::pfr::io(x);
assert(x.i == 12);
assert(x.s == 13);
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.custom_printing_of_aggregates"> 'Custom printing of aggregates'  </link> for info on how to implement your own manipulator with custom format. </para></description></function>

















</namespace>
</namespace>
</header>
<header name="boost/pfr/io_fields.hpp">
<para>Contains IO manipulator  <link linkend="boost.pfr.io_fields"> boost::pfr::io_fields </link> to read/write any  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> field-by-field.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct {
    int i;
    short s;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_struct&amp; x) {
    return os &lt;&lt; boost::pfr::io_fields(x);  // Equivalent to: os &lt;&lt; "{ " &lt;&lt; x.i &lt;&lt; " ," &lt;&lt;  x.s &lt;&lt; " }"
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, my_struct&amp; x) {
    return is &gt;&gt; boost::pfr::io_fields(x);  // Equivalent to: is &gt;&gt; "{ " &gt;&gt; x.i &gt;&gt; " ," &gt;&gt;  x.s &gt;&gt; " }"
}
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators'  </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">





















<function name="io_fields"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>IO manipulator to read/write  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link> <computeroutput>value</computeroutput> field-by-field.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct my_struct {
    int i;
    short s;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_struct&amp; x) {
    return os &lt;&lt; boost::pfr::io_fields(x);  // Equivalent to: os &lt;&lt; "{ " &lt;&lt; x.i &lt;&lt; " ," &lt;&lt;  x.s &lt;&lt; " }"
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, my_struct&amp; x) {
    return is &gt;&gt; boost::pfr::io_fields(x);  // Equivalent to: is &gt;&gt; "{ " &gt;&gt; x.i &gt;&gt; " ," &gt;&gt;  x.s &gt;&gt; " }"
}
</programlisting></para><para>Input and output streaming operators for <computeroutput>boost::pfr::io_fields</computeroutput> are symmetric, meaning that you get the original value by streaming it and reading back if each fields streaming operator is symmetric.</para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.custom_printing_of_aggregates"> 'Custom printing of aggregates'  </link> for info on how to implement your own manipulator with custom format. </para></description></function>


















</namespace>
</namespace>
</header>
<header name="boost/pfr/ops.hpp">
<para>Contains comparison and hashing functions. If type is comparable using its own operator or its conversion operator, then the types operator is used. Otherwise the operation is done via corresponding function from boost/pfr/ops.hpp header.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/ops.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s; char data[7]; bool bl; int a,b,c,d,e,f;
};
// ...

comparable_struct s1 {0, 1, "Hello", false, 6,7,8,9,10,11};
comparable_struct s2 {0, 1, "Hello", false, 6,7,8,9,10,11111};
assert(boost::pfr::lt(s1, s2));
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators'  </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">







<function name="eq"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><purpose>Compares lhs and rhs for equality using their own comparison and conversion operators; if no operators available returns  <link linkend="boost.pfr.eq_fields"> boost::pfr::eq_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is equal to rhs; false otherwise </para>
</returns></function>
<function name="eq"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="ne"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><purpose>Compares lhs and rhs for inequality using their own comparison and conversion operators; if no operators available returns  <link linkend="boost.pfr.ne_fields"> boost::pfr::ne_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is not equal to rhs; false otherwise </para>
</returns></function>
<function name="ne"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="lt"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><purpose>Compares lhs and rhs for less-than using their own comparison and conversion operators; if no operators available returns  <link linkend="boost.pfr.lt_fields"> boost::pfr::lt_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is less than rhs; false otherwise </para>
</returns></function>
<function name="lt"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="gt"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><purpose>Compares lhs and rhs for greater-than using their own comparison and conversion operators; if no operators available returns  <link linkend="boost.pfr.lt_fields"> boost::pfr::lt_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is greater than rhs; false otherwise </para>
</returns></function>
<function name="gt"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="le"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><purpose>Compares lhs and rhs for less-equal using their own comparison and conversion operators; if no operators available returns  <link linkend="boost.pfr.le_fields"> boost::pfr::le_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is less or equal to rhs; false otherwise </para>
</returns></function>
<function name="le"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="ge"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><purpose>Compares lhs and rhs for greater-equal using their own comparison and conversion operators; if no operators available returns  <link linkend="boost.pfr.ge_fields"> boost::pfr::ge_fields </link>(lhs, rhs). </purpose><description><para>
</para></description><returns><para>true if lhs is greater or equal to rhs; false otherwise </para>
</returns></function>
<function name="ge"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter></function>
<function name="hash_value"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><purpose>Hashes value using its own std::hash specialization; if no std::hash specialization available returns  <link linkend="boost.pfr.hash_fields"> boost::pfr::hash_fields </link>(value). </purpose><description><para>
</para></description><returns><para>std::size_t with hash of the value </para>
</returns></function>
<function name="hash_value"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>const T &amp;</paramtype></parameter></function>



















</namespace>
</namespace>
</header>
<header name="boost/pfr/ops_fields.hpp">
<para>Contains field-by-fields comparison and hash functions.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">#include &lt;boost/pfr/ops_fields.hpp&gt;
struct comparable_struct {      // No operators defined for that structure
    int i; short s;
};
// ...

comparable_struct s1 {0, 1};
comparable_struct s2 {0, 2};
assert(boost::pfr::lt_fields(s1, s2));
</programlisting></para><para><emphasis role="bold">See</emphasis> <emphasis role="bold">Also</emphasis> :  <link linkend="boost_pfr.tutorial.three_ways_of_getting_operators"> 'Three ways of getting operators'  </link> for other ways to define operators and more details.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<function name="eq_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field equality comparison.</para><para>
</para></description><returns><para><computeroutput>L == R &amp;&amp; tuple_size_v&lt;T&gt; == tuple_size_v&lt;U&gt;</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="ne_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field inequality comparison.</para><para>
</para></description><returns><para><computeroutput>L != R || tuple_size_v&lt;T&gt; != tuple_size_v&lt;U&gt;</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="gt_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field greter comparison.</para><para>
</para></description><returns><para><computeroutput>L &gt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &gt; tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="lt_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field less comparison.</para><para>
</para></description><returns><para><computeroutput>L &lt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &lt; tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="ge_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field greater equal comparison.</para><para>
</para></description><returns><para><computeroutput>L &gt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &gt;= tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="le_fields"><type>constexpr bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="lhs"><paramtype>const T &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const U &amp;</paramtype></parameter><description><para>Does a field-by-field less equal comparison.</para><para>
</para></description><returns><para><computeroutput>L &lt; R || (L == R &amp;&amp; tuple_size_v&lt;T&gt; &lt;= tuple_size_v&lt;U&gt;)</computeroutput>, where <computeroutput>L</computeroutput> and <computeroutput>R</computeroutput> are the results of calling <computeroutput>std::tie</computeroutput> on first <computeroutput>N</computeroutput> fields of <computeroutput>lhs</computeroutput> and </para>
</returns></function>
<function name="hash_fields"><type>std::size_t</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para>Does a field-by-field hashing.</para><para>
</para></description><returns><para>combined hash of all the fields </para>
</returns></function>

































</namespace>
</namespace>
</header>
<header name="boost/pfr/traits.hpp">
<para>Contains traits  <link linkend="boost.pfr.is_reflectable"> <classname alt="boost::pfr::is_reflectable">boost::pfr::is_reflectable</classname> </link> and  <link linkend="boost.pfr.is_implicitly_reflectable"> boost::pfr::is_implicitly_reflectable </link> for detecting an ability to reflect type.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<struct name="is_reflectable"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="WhatFor"/>
    </template><description><para>Has a static const member variable <computeroutput>value</computeroutput> when it is known that type T can or can't be reflected using Boost.PFR; otherwise, there is no member variable. Every user may (and in some difficult cases - should) specialize <classname alt="boost::pfr::is_reflectable">is_reflectable</classname> on his own.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">namespace boost { namespace pfr {
    template&lt;class All&gt; struct is_reflectable&lt;A, All&gt; : std::false_type {};       // 'A' won't be interpreted as reflectable everywhere
    template&lt;&gt; struct is_reflectable&lt;B, boost_fusion_tag&gt; : std::false_type {};   // 'B' won't be interpreted as reflectable in only Boost Fusion
}}
</programlisting> <note><para><classname alt="boost::pfr::is_reflectable">is_reflectable</classname> affects is_implicitly_reflectable, the decision made by <classname alt="boost::pfr::is_reflectable">is_reflectable</classname> is used by is_implicitly_reflectable. </para>
</note>
</para></description></struct><struct-specialization name="is_reflectable"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="WhatFor"/>
    </template><specialization><template-arg>const T</template-arg><template-arg>WhatFor</template-arg></specialization><inherit access="public">boost::pfr::is_reflectable&lt; T, WhatFor &gt;</inherit></struct-specialization><struct-specialization name="is_reflectable"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="WhatFor"/>
    </template><specialization><template-arg>const volatile T</template-arg><template-arg>WhatFor</template-arg></specialization><inherit access="public">boost::pfr::is_reflectable&lt; T, WhatFor &gt;</inherit></struct-specialization><struct-specialization name="is_reflectable"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="WhatFor"/>
    </template><specialization><template-arg>volatile T</template-arg><template-arg>WhatFor</template-arg></specialization><inherit access="public">boost::pfr::is_reflectable&lt; T, WhatFor &gt;</inherit></struct-specialization><typedef name="is_implicitly_reflectable"><description><para>Checks the input type for the potential to be reflected. Specialize <classname alt="boost::pfr::is_reflectable">is_reflectable</classname> if you disagree with is_implicitly_reflectable's default decision. </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="is_implicitly_reflectable_v"><type>constexpr bool</type><description><para>Checks the input type for the potential to be reflected. Specialize <classname alt="boost::pfr::is_reflectable">is_reflectable</classname> if you disagree with is_implicitly_reflectable_v's default decision. </para></description></data-member>








































</namespace>
</namespace>
</header>
<header name="boost/pfr/traits_fwd.hpp">
<namespace name="boost">
<namespace name="pfr">








































</namespace>
</namespace>
</header>
<header name="boost/pfr/tuple_size.hpp">
<para>Contains tuple-like interfaces to get fields count  <link linkend="boost.pfr.tuple_size"> boost::pfr::tuple_size </link>,  <link linkend="boost.pfr.tuple_size_v"> boost::pfr::tuple_size_v </link>.</para><para><emphasis role="bold">Synopsis:</emphasis> </para><namespace name="boost">
<namespace name="pfr">
<typedef name="tuple_size"><description><para>Has a static const member variable <computeroutput>value</computeroutput> that contains fields count in a T. Works for any T that satisfies  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link>.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::array&lt;int, boost::pfr::tuple_size&lt;my_structure&gt;::value &gt; a;
</programlisting> </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="tuple_size_v"><type>constexpr std::size_t</type><description><para><computeroutput>tuple_size_v</computeroutput> is a template variable that contains fields count in a T and works for any T that satisfies  <link linkend="boost_pfr.limitations_and_configuration"> simple aggregate  </link>.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">std::array&lt;int, boost::pfr::tuple_size_v&lt;my_structure&gt; &gt; a;
</programlisting> </para></description></data-member>








































</namespace>
</namespace>
</header>
</library-reference>