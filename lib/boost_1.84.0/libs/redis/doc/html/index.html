<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boost.Redis: Boost.Redis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Boost.Redis<span id="projectnumber">&#160;1.4.2</span>
   </div>
   <div id="projectbrief">A redis client library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Boost.Redis </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> Boost.Redis is a high-level <a href="https://redis.io/">Redis</a> client library built on top of <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio.html">Boost.Asio</a> that implements the Redis protocol <a href="https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md">RESP3</a>. The requirements for using Boost.Redis are:</p>
<ul>
<li>Boost. The library is included in Boost distributions starting with 1.84.</li>
<li>C++17 or higher.</li>
<li>Redis 6 or higher (must support RESP3).</li>
<li>Gcc (10, 11, 12), Clang (11, 13, 14) and Visual Studio (16 2019, 17 2022).</li>
<li>Have basic-level knowledge about <a href="https://redis.io/docs/">Redis</a> and <a href="https://www.boost.org/doc/libs/1_82_0/doc/html/boost_asio/overview.html">Boost.Asio</a>.</li>
</ul>
<p >The latest release can be downloaded on <a href="https://github.com/boostorg/redis/releases">https://github.com/boostorg/redis/releases</a>. The library headers can be found in the <code>include</code> subdirectory and a compilation of the source</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/redis/src.hpp&gt;</span></div>
</div><!-- fragment --><p >is required. The simplest way to do it is to included this header in no more than one source file in your applications. To build the examples and tests cmake is supported, for example</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Linux</span></div>
<div class="line">$ BOOST_ROOT=/opt/boost_1_81_0 cmake --preset g++-11</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Windows </span></div>
<div class="line">$ cmake -G <span class="stringliteral">&quot;Visual Studio 17 2022&quot;</span> -A x64 -B bin64 -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake</div>
</div><!-- fragment --><p ><a class="anchor" id="connection"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Connection</h1>
<p >Let us start with a simple application that uses a short-lived connection to send a <a href="https://redis.io/commands/ping/">ping</a> command to Redis</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> co_main(config <span class="keyword">const</span>&amp; cfg) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">auto</span> conn = std::make_shared&lt;connection&gt;(<span class="keyword">co_await</span> net::this_coro::executor);</div>
<div class="line">   conn-&gt;async_run(cfg, {}, net::consign(net::detached, conn));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// A request containing only a ping command.</span></div>
<div class="line">   request req;</div>
<div class="line">   req.push(<span class="stringliteral">&quot;PING&quot;</span>, <span class="stringliteral">&quot;Hello world&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Response where the PONG response will be stored.</span></div>
<div class="line">   response&lt;std::string&gt; resp;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Executes the request.</span></div>
<div class="line">   <span class="keyword">co_await</span> conn-&gt;async_exec(req, resp, net::deferred);</div>
<div class="line">   conn-&gt;cancel();</div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;PING: &quot;</span> &lt;&lt; std::get&lt;0&gt;(resp).value() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p >The roles played by the <code>async_run</code> and <code>async_exec</code> functions are</p>
<ul>
<li><code>async_exec</code>: Execute the commands contained in the request and store the individual responses in the <code>resp</code> object. Can be called from multiple places in your code concurrently.</li>
<li><code>async_run</code>: Resolve, connect, ssl-handshake, resp3-handshake, health-checks, reconnection and coordinate low-level read and write operations (among other things).</li>
</ul>
<h2><a class="anchor" id="autotoc_md2"></a>
Server pushes</h2>
<p >Redis servers can also send a variety of pushes to the client, some of them are</p>
<ul>
<li><a href="https://redis.io/docs/manual/pubsub/">Pubsub</a></li>
<li><a href="https://redis.io/docs/manual/keyspace-notifications/">Keyspace notification</a></li>
<li><a href="https://redis.io/docs/manual/client-side-caching/">Client-side caching</a></li>
</ul>
<p >The connection class supports server pushes by means of the <code><a class="el" href="classboost_1_1redis_1_1connection.html#a33a68feab0e9044f9055b93b4432f303" title="Calls boost::redis::basic_connection::async_receive.">boost::redis::connection::async_receive</a></code> function, which can be called in the same connection that is being used to execute commands. The coroutine below shows how to used it</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span></div>
<div class="line">receiver(std::shared_ptr&lt;connection&gt; conn) -&gt; net::awaitable&lt;void&gt;</div>
<div class="line">{</div>
<div class="line">   request req;</div>
<div class="line">   req.push(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, <span class="stringliteral">&quot;channel&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   generic_response resp;</div>
<div class="line">   conn-&gt;set_receive_response(resp);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Loop while reconnection is enabled</span></div>
<div class="line">   <span class="keywordflow">while</span> (conn-&gt;will_reconnect()) {</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Reconnect to channels.</span></div>
<div class="line">      <span class="keyword">co_await</span> conn-&gt;async_exec(req, ignore, net::deferred);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Loop reading Redis pushes.</span></div>
<div class="line">      <span class="keywordflow">for</span> (;;) {</div>
<div class="line">         error_code ec;</div>
<div class="line">         <span class="keyword">co_await</span> conn-&gt;async_receive(resp, net::redirect_error(net::use_awaitable, ec));</div>
<div class="line">         <span class="keywordflow">if</span> (ec)</div>
<div class="line">            <span class="keywordflow">break</span>; <span class="comment">// Connection lost, break so we can reconnect to channels.</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">// Use the response resp in some way and then clear it.</span></div>
<div class="line">         ...</div>
<div class="line"> </div>
<div class="line">         consume_one(resp);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p ><a class="anchor" id="requests"></a> </p>
<h1><a class="anchor" id="autotoc_md3"></a>
Requests</h1>
<p >Redis requests are composed of one or more commands (in the Redis documentation they are called <a href="https://redis.io/topics/pipelining">pipelines</a>). For example</p>
<div class="fragment"><div class="line"><span class="comment">// Some example containers.</span></div>
<div class="line">std::list&lt;std::string&gt; list {...};</div>
<div class="line">std::map&lt;std::string, mystruct&gt; map { ...};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The request can contain multiple commands.</span></div>
<div class="line">request req;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Command with variable length of arguments.</span></div>
<div class="line">req.push(<span class="stringliteral">&quot;SET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;some value&quot;</span>, <span class="stringliteral">&quot;EX&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a list.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, list);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but as an iterator range.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, std::cbegin(list), std::cend(list));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pushes a map.</span></div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, map);</div>
</div><!-- fragment --><p >Sending a request to Redis is performed with <code><a class="el" href="classboost_1_1redis_1_1connection.html#a210708e4827faeef49f27861ffb678a1" title="Calls boost::redis::basic_connection::async_exec.">boost::redis::connection::async_exec</a></code> as already stated.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Config flags</h2>
<p >The <code><a class="el" href="classboost_1_1redis_1_1request.html#structboost_1_1redis_1_1request_1_1config" title="Request configuration options.">boost::redis::request::config</a></code> object inside the request dictates how the <code><a class="el" href="classboost_1_1redis_1_1connection.html" title="A basic_connection that type erases the executor.">boost::redis::connection</a></code> should handle the request in some important situations. The reader is advised to read it carefully.</p>
<p ><a class="anchor" id="responses"></a> </p>
<h1><a class="anchor" id="autotoc_md5"></a>
Responses</h1>
<p >Boost.Redis uses the following strategy to support Redis responses</p>
<ul>
<li><code><a class="el" href="classboost_1_1redis_1_1request.html" title="Creates Redis requests.">boost::redis::request</a></code> is used for requests whose number of commands are not dynamic.</li>
<li><b>Dynamic</b>: Otherwise use <code><a class="el" href="group__high-level-api.html#gaa1dc751c19aca21d7bd661c8b9eea04f" title="A generic response to a request.">boost::redis::generic_response</a></code>.</li>
</ul>
<p >For example, the request below has three commands</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;INCR&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >and its response also has three comamnds and can be read in the following response object</p>
<div class="fragment"><div class="line">response&lt;std::string, int, std::string&gt;</div>
</div><!-- fragment --><p >The response behaves as a tuple and must have as many elements as the request has commands (exceptions below). It is also necessary that each tuple element is capable of storing the response to the command it refers to, otherwise an error will occur. To ignore responses to individual commands in the request use the tag <code><a class="el" href="group__high-level-api.html#ga71ed828bcaf291989dcf4050a18601ba" title="Type used to ignore responses.">boost::redis::ignore_t</a></code>, for example</p>
<div class="fragment"><div class="line"><span class="comment">// Ignore the second and last responses.</span></div>
<div class="line">response&lt;std::string, boost::redis::ignore_t, std::string, boost::redis::ignore_t&gt;</div>
</div><!-- fragment --><p >The following table provides the resp3-types returned by some Redis commands</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command   </th><th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Documentation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lpush   </td><td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lpush">https://redis.io/commands/lpush</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lrange   </td><td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/lrange">https://redis.io/commands/lrange</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set   </td><td class="markdownTableBodyNone">Simple-string, null or blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/set">https://redis.io/commands/set</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">get   </td><td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/get">https://redis.io/commands/get</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">smembers   </td><td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/smembers">https://redis.io/commands/smembers</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hgetall   </td><td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><a href="https://redis.io/commands/hgetall">https://redis.io/commands/hgetall</a>   </td></tr>
</table>
<p >To map these RESP3 types into a C++ data structure use the table below</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RESP3 type   </th><th class="markdownTableHeadNone">Possible C++ type   </th><th class="markdownTableHeadNone">Type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simple-string   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Simple-error   </td><td class="markdownTableBodyNone"><code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Blob-string   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Blob-error   </td><td class="markdownTableBodyNone"><code>std::string</code>, <code>std::vector</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number   </td><td class="markdownTableBodyNone"><code>long long</code>, <code>int</code>, <code>std::size_t</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Double   </td><td class="markdownTableBodyNone"><code>double</code>, <code>std::string</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Null   </td><td class="markdownTableBodyNone"><code>std::optional&lt;T&gt;</code>   </td><td class="markdownTableBodyNone">Simple    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Array   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::list</code>, <code>std::array</code>, <code>std::deque</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Map   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Set   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::set</code>, <code>std::unordered_set</code>   </td><td class="markdownTableBodyNone">Aggregate    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Push   </td><td class="markdownTableBodyNone"><code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code>   </td><td class="markdownTableBodyNone">Aggregate   </td></tr>
</table>
<p >For example, the response to the request</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;HELLO&quot;</span>, 3);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;RPUSH&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>, vec);</div>
<div class="line">req.push_range(<span class="stringliteral">&quot;HSET&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, map);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key4&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >can be read in the tuple below</p>
<div class="fragment"><div class="line">response&lt;</div>
<div class="line">   redis::ignore_t,  <span class="comment">// hello</span></div>
<div class="line">   int,              <span class="comment">// rpush</span></div>
<div class="line">   int,              <span class="comment">// hset</span></div>
<div class="line">   std::vector&lt;T&gt;,   <span class="comment">// lrange</span></div>
<div class="line">   std::map&lt;U, V&gt;,   <span class="comment">// hgetall</span></div>
<div class="line">   std::string       <span class="comment">// quit</span></div>
<div class="line">&gt; resp;</div>
</div><!-- fragment --><p >Where both are passed to <code>async_exec</code> as showed elsewhere</p>
<div class="fragment"><div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, resp, net::deferred);</div>
</div><!-- fragment --><p >If the intention is to ignore responses altogether use <code>ignore</code></p>
<div class="fragment"><div class="line"><span class="comment">// Ignores the response</span></div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, ignore, net::deferred);</div>
</div><!-- fragment --><p >Responses that contain nested aggregates or heterogeneous data types will be given special treatment later in <a class="el" href="index.html#the-general-case">The general case</a>. As of this writing, not all RESP3 types are used by the Redis server, which means in practice users will be concerned with a reduced subset of the RESP3 specification.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Pushes</h2>
<p >Commands that have no response like</p>
<ul>
<li><code>"SUBSCRIBE"</code></li>
<li><code>"PSUBSCRIBE"</code></li>
<li><code>"UNSUBSCRIBE"</code></li>
</ul>
<p >must <b>NOT</b> be included in the response tuple. For example, the request below</p>
<div class="fragment"><div class="line">request req;</div>
<div class="line">req.push(<span class="stringliteral">&quot;PING&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;SUBSCRIBE&quot;</span>, <span class="stringliteral">&quot;channel&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;QUIT&quot;</span>);</div>
</div><!-- fragment --><p >must be read in this tuple <code>response&lt;std::string, std::string&gt;</code>, that has static size two.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Null</h2>
<p >It is not uncommon for apps to access keys that do not exist or that have already expired in the Redis server, to deal with these cases Boost.Redis provides support for <code>std::optional</code>. To use it, wrap your type around <code>std::optional</code> like this</p>
<div class="fragment"><div class="line">response&lt;</div>
<div class="line">   std::optional&lt;A&gt;,</div>
<div class="line">   std::optional&lt;B&gt;,</div>
<div class="line">   ...</div>
<div class="line">   &gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, resp, net::deferred);</div>
</div><!-- fragment --><p >Everything else stays pretty much the same.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Transactions</h2>
<p >To read responses to transactions we must first observe that Redis will queue the transaction commands and send their individual responses as elements of an array, the array is itself the response to the <code>EXEC</code> command. For example, to read the response to this request</p>
<div class="fragment"><div class="line">req.push(<span class="stringliteral">&quot;MULTI&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;GET&quot;</span>, <span class="stringliteral">&quot;key1&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;LRANGE&quot;</span>, <span class="stringliteral">&quot;key2&quot;</span>, 0, -1);</div>
<div class="line">req.push(<span class="stringliteral">&quot;HGETALL&quot;</span>, <span class="stringliteral">&quot;key3&quot;</span>);</div>
<div class="line">req.push(<span class="stringliteral">&quot;EXEC&quot;</span>);</div>
</div><!-- fragment --><p >use the following response type</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_variable" href="group__high-level-api.html#ga67c4e424db0e0ee72bd5a62c2e649470">boost::redis::ignore</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>exec_resp_type = </div>
<div class="line">   response&lt;</div>
<div class="line">      std::optional&lt;std::string&gt;, <span class="comment">// get</span></div>
<div class="line">      std::optional&lt;std::vector&lt;std::string&gt;&gt;, <span class="comment">// lrange</span></div>
<div class="line">      std::optional&lt;std::map&lt;std::string, std::string&gt;&gt; <span class="comment">// hgetall</span></div>
<div class="line">   &gt;;</div>
<div class="line"> </div>
<div class="line">response&lt;</div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga71ed828bcaf291989dcf4050a18601ba">boost::redis::ignore_t</a>,  <span class="comment">// multi</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga71ed828bcaf291989dcf4050a18601ba">boost::redis::ignore_t</a>,  <span class="comment">// get</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga71ed828bcaf291989dcf4050a18601ba">boost::redis::ignore_t</a>,  <span class="comment">// lrange</span></div>
<div class="line">   <a class="code hl_typedef" href="group__high-level-api.html#ga71ed828bcaf291989dcf4050a18601ba">boost::redis::ignore_t</a>,  <span class="comment">// hgetall</span></div>
<div class="line">   exec_resp_type,        <span class="comment">// exec</span></div>
<div class="line">&gt; resp;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, resp, net::deferred);</div>
<div class="ttc" id="agroup__high-level-api_html_ga67c4e424db0e0ee72bd5a62c2e649470"><div class="ttname"><a href="group__high-level-api.html#ga67c4e424db0e0ee72bd5a62c2e649470">boost::redis::ignore</a></div><div class="ttdeci">ignore_t ignore</div><div class="ttdoc">Global ignore object.</div></div>
<div class="ttc" id="agroup__high-level-api_html_ga71ed828bcaf291989dcf4050a18601ba"><div class="ttname"><a href="group__high-level-api.html#ga71ed828bcaf291989dcf4050a18601ba">boost::redis::ignore_t</a></div><div class="ttdeci">std::decay_t&lt; decltype(std::ignore)&gt; ignore_t</div><div class="ttdoc">Type used to ignore responses.</div><div class="ttdef"><b>Definition:</b> <a href="ignore_8hpp_source.html#l00031">ignore.hpp:31</a></div></div>
</div><!-- fragment --><p >For a complete example see <a class="el" href="cpp20__containers_8cpp_source.html">cpp20_containers.cpp</a>.</p>
<p ><a class="anchor" id="the-general-case"></a></p>
<h2><a class="anchor" id="autotoc_md9"></a>
The general case</h2>
<p >There are cases where responses to Redis commands won't fit in the model presented above, some examples are</p>
<ul>
<li>Commands (like <code>set</code>) whose responses don't have a fixed RESP3 type. Expecting an <code>int</code> and receiving a blob-string will result in error.</li>
<li>RESP3 aggregates that contain nested aggregates can't be read in STL containers.</li>
<li>Transactions with a dynamic number of commands can't be read in a <code>response</code>.</li>
</ul>
<p >To deal with these cases Boost.Redis provides the <code><a class="el" href="group__high-level-api.html#ga4cce198a78c8f3ff23aaba06fbefdc50" title="A node in the response tree.">boost::redis::resp3::node</a></code> type abstraction, that is the most general form of an element in a response, be it a simple RESP3 type or the element of an aggregate. It is defined like this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;</div>
<div class="line"><span class="keyword">struct </span>basic_node {</div>
<div class="line">   <span class="comment">// The RESP3 type of the data in this node.</span></div>
<div class="line">   type data_type;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The number of elements of an aggregate (or 1 for simple data).</span></div>
<div class="line">   std::size_t aggregate_size;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The depth of this node in the response tree.</span></div>
<div class="line">   std::size_t depth;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// The actual data. For aggregate types this is always empty.</span></div>
<div class="line">   String value;</div>
<div class="line">};</div>
</div><!-- fragment --><p >Any response to a Redis command can be received in a <code><a class="el" href="group__high-level-api.html#gaa1dc751c19aca21d7bd661c8b9eea04f" title="A generic response to a request.">boost::redis::generic_response</a></code>. The vector can be seen as a pre-order view of the response tree. Using it is not different than using other types</p>
<div class="fragment"><div class="line"><span class="comment">// Receives any RESP3 simple or aggregate data type.</span></div>
<div class="line"><a class="code hl_typedef" href="group__high-level-api.html#gaa1dc751c19aca21d7bd661c8b9eea04f">boost::redis::generic_response</a> resp;</div>
<div class="line"><span class="keyword">co_await</span> conn-&gt;async_exec(req, resp, net::deferred);</div>
<div class="ttc" id="agroup__high-level-api_html_gaa1dc751c19aca21d7bd661c8b9eea04f"><div class="ttname"><a href="group__high-level-api.html#gaa1dc751c19aca21d7bd661c8b9eea04f">boost::redis::generic_response</a></div><div class="ttdeci">adapter::result&lt; std::vector&lt; resp3::node &gt; &gt; generic_response</div><div class="ttdoc">A generic response to a request.</div><div class="ttdef"><b>Definition:</b> <a href="response_8hpp_source.html#l00035">response.hpp:35</a></div></div>
</div><!-- fragment --><p >For example, suppose we want to retrieve a hash data structure from Redis with <code>HGETALL</code>, some of the options are</p>
<ul>
<li><code><a class="el" href="group__high-level-api.html#gaa1dc751c19aca21d7bd661c8b9eea04f" title="A generic response to a request.">boost::redis::generic_response</a></code>: Works always.</li>
<li><code>std::vector&lt;std::string&gt;</code>: Efficient and flat, all elements as string.</li>
<li><code>std::map&lt;std::string, std::string&gt;</code>: Efficient if you need the data as a <code>std::map</code>.</li>
<li><code>std::map&lt;U, V&gt;</code>: Efficient if you are storing serialized data. Avoids temporaries and requires <code>boost_redis_from_bulk</code> for <code>U</code> and <code>V</code>.</li>
</ul>
<p >In addition to the above users can also use unordered versions of the containers. The same reasoning applies to sets e.g. <code>SMEMBERS</code> and other data structures in general.</p>
<p ><a class="anchor" id="serialization"></a> </p>
<h1><a class="anchor" id="autotoc_md10"></a>
Serialization</h1>
<p >Boost.Redis supports serialization of user defined types by means of the following customization points</p>
<div class="fragment"><div class="line"><span class="comment">// Serialize.</span></div>
<div class="line"><span class="keywordtype">void</span> boost_redis_to_bulk(std::string&amp; to, mystruct <span class="keyword">const</span>&amp; obj);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deserialize</span></div>
<div class="line"><span class="keywordtype">void</span> boost_redis_from_bulk(mystruct&amp; obj, <span class="keywordtype">char</span> <span class="keyword">const</span>* p, std::size_t size, boost::system::error_code&amp; ec)</div>
</div><!-- fragment --><p >These functions are accessed over ADL and therefore they must be imported in the global namespace by the user. In the <a class="el" href="index.html#examples">Examples</a> section the reader can find examples showing how to serialize using json and <a href="https://protobuf.dev/">protobuf</a>.</p>
<p ><a class="anchor" id="examples"></a> </p>
<h1><a class="anchor" id="autotoc_md11"></a>
Examples</h1>
<p >The examples below show how to use the features discussed so far</p>
<ul>
<li><a class="el" href="cpp20__intro_8cpp_source.html">cpp20_intro.cpp</a>: Does not use awaitable operators.</li>
<li><a class="el" href="cpp20__intro__tls_8cpp_source.html">cpp20_intro_tls.cpp</a>: Communicates over TLS.</li>
<li><a class="el" href="cpp20__containers_8cpp_source.html">cpp20_containers.cpp</a>: Shows how to send and receive STL containers and how to use transactions.</li>
<li><a class="el" href="cpp20__json_8cpp_source.html">cpp20_json.cpp</a>: Shows how to serialize types using Boost.Json.</li>
<li><a class="el" href="cpp20__protobuf_8cpp_source.html">cpp20_protobuf.cpp</a>: Shows how to serialize types using protobuf.</li>
<li><a class="el" href="cpp20__resolve__with__sentinel_8cpp_source.html">cpp20_resolve_with_sentinel.cpp</a>: Shows how to resolve a master address using sentinels.</li>
<li><a class="el" href="cpp20__subscriber_8cpp_source.html">cpp20_subscriber.cpp</a>: Shows how to implement pubsub with reconnection re-subscription.</li>
<li><a class="el" href="cpp20__echo__server_8cpp_source.html">cpp20_echo_server.cpp</a>: A simple TCP echo server.</li>
<li><a class="el" href="cpp20__chat__room_8cpp_source.html">cpp20_chat_room.cpp</a>: A command line chat built on Redis pubsub.</li>
<li><a class="el" href="cpp17__intro_8cpp_source.html">cpp17_intro.cpp</a>: Uses callbacks and requires C++17.</li>
<li><a class="el" href="cpp17__intro__sync_8cpp_source.html">cpp17_intro_sync.cpp</a>: Runs <code>async_run</code> in a separate thread and performs synchronous calls to <code>async_exec</code>.</li>
</ul>
<p >The main function used in some async examples has been factored out in the <a class="el" href="main_8cpp_source.html">main.cpp</a> file.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Echo server benchmark</h1>
<p >This document benchmarks the performance of TCP echo servers I implemented in different languages using different Redis clients. The main motivations for choosing an echo server are</p>
<ul>
<li>Simple to implement and does not require expertise level in most languages.</li>
<li>I/O bound: Echo servers have very low CPU consumption in general and therefore are excelent to measure how a program handles concurrent requests.</li>
<li>It simulates very well a typical backend in regard to concurrency.</li>
</ul>
<p >I also imposed some constraints on the implementations</p>
<ul>
<li>It should be simple enough and not require writing too much code.</li>
<li>Favor the use standard idioms and avoid optimizations that require expert level.</li>
<li>Avoid the use of complex things like connection and thread pool.</li>
</ul>
<p >To reproduce these results run one of the echo-server programs in one terminal and the <a href="https://github.com/boostorg/redis/blob/42880e788bec6020dd018194075a211ad9f339e8/benchmarks/cpp/asio/echo_server_client.cpp">echo-server-client</a> in another.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Without Redis</h2>
<p >First I tested a pure TCP echo server, i.e. one that sends the messages directly to the client without interacting with Redis. The result can be seen below</p>
<p ><img src="https://boostorg.github.io/redis/tcp-echo-direct.png" alt="" class="inline"/></p>
<p >The tests were performed with a 1000 concurrent TCP connections on the localhost where latency is 0.07ms on average on my machine. On higher latency networks the difference among libraries is expected to decrease.</p>
<ul>
<li>I expected Libuv to have similar performance to Asio and Tokio.</li>
<li>I did expect nodejs to come a little behind given it is is javascript code. Otherwise I did expect it to have similar performance to libuv since it is the framework behind it.</li>
<li>Go did surprise me: faster than nodejs and libuv!</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/cpp/asio/echo_server_direct.cpp">Asio</a>: A variation of <a href="https://github.com/chriskohlhoff/asio/blob/4915cfd8a1653c157a1480162ae5601318553eb8/asio/src/examples/cpp20/coroutines/echo_server.cpp">this</a> Asio example.</li>
<li><a href="https://github.com/boostorg/redis/tree/835a1decf477b09317f391eddd0727213cdbe12b/benchmarks/c/libuv">Libuv</a>: Taken from <a href="https://github.com/libuv/libuv/blob/06948c6ee502862524f233af4e2c3e4ca876f5f6/docs/code/tcp-echo-server/main.c">here</a> Libuv example .</li>
<li><a href="https://github.com/boostorg/redis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/rust/echo_server_direct">Tokio</a>: Taken from <a href="https://docs.rs/tokio/latest/tokio/">here</a>.</li>
<li><a href="https://github.com/boostorg/redis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_direct">Nodejs</a></li>
<li><a href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_direct.go">Go</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
With Redis</h2>
<p >This is similar to the echo server described above but messages are echoed by Redis and not by the echo-server itself, which acts as a proxy between the client and the Redis server. The results can be seen below</p>
<p ><img src="https://boostorg.github.io/redis/tcp-echo-over-redis.png" alt="" class="inline"/></p>
<p >The tests were performed on a network where latency is 35ms on average, otherwise it uses the same number of TCP connections as the previous example.</p>
<p >As the reader can see, the Libuv and the Rust test are not depicted in the graph, the reasons are</p>
<ul>
<li><a href="https://github.com/redis-rs/redis-rs">redis-rs</a>: This client comes so far behind that it can't even be represented together with the other benchmarks without making them look insignificant. I don't know for sure why it is so slow, I suppose it has something to do with its lack of automatic <a href="https://redis.io/docs/manual/pipelining/">pipelining</a> support. In fact, the more TCP connections I lauch the worse its performance gets.</li>
<li>Libuv: I left it out because it would require me writing to much c code. More specifically, I would have to use hiredis and implement support for pipelines manually.</li>
</ul>
<p >The code used in the benchmarks can be found at</p>
<ul>
<li><a href="https://github.com/boostorg/redis">Boost.Redis</a>: <a href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/examples/echo_server.cpp">code</a></li>
<li><a href="https://github.com/redis/node-redis">node-redis</a>: <a href="https://github.com/boostorg/redis/tree/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/nodejs/echo_server_over_redis">code</a></li>
<li><a href="https://github.com/go-redis/redis">go-redis</a>: <a href="https://github.com/boostorg/redis/blob/3fb018ccc6138d310ac8b73540391cdd8f2fdad6/benchmarks/go/echo_server_over_redis.go">code</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Conclusion</h2>
<p >Redis clients have to support automatic pipelining to have competitive performance. For updates to this document follow <a href="https://github.com/boostorg/redis">https://github.com/boostorg/redis</a>.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Comparison</h1>
<p >The main reason for why I started writing Boost.Redis was to have a client compatible with the Asio asynchronous model. As I made progresses I could also address what I considered weaknesses in other libraries. Due to time constraints I won't be able to give a detailed comparison with each client listed in the <a href="https://redis.io/docs/clients/#cpp">official</a> list, instead I will focus on the most popular C++ client on github in number of stars, namely</p>
<ul>
<li><a href="https://github.com/sewenew/redis-plus-plus">https://github.com/sewenew/redis-plus-plus</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Boost.Redis vs Redis-plus-plus</h2>
<p >Before we start it is important to mention some of the things redis-plus-plus does not support</p>
<ul>
<li>The latest version of the communication protocol RESP3. Without that it is impossible to support some important Redis features like client side caching, among other things.</li>
<li>Coroutines.</li>
<li>Reading responses directly in user data structures to avoid creating temporaries.</li>
<li>Error handling with support for error-code.</li>
<li>Cancellation.</li>
</ul>
<p >The remaining points will be addressed individually. Let us first have a look at what sending a command a pipeline and a transaction look like</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> redis = Redis(<span class="stringliteral">&quot;tcp://127.0.0.1:6379&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send commands</span></div>
<div class="line">redis.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> val = redis.get(<span class="stringliteral">&quot;key&quot;</span>); <span class="comment">// val is of type OptionalString.</span></div>
<div class="line"><span class="keywordflow">if</span> (val)</div>
<div class="line">    std::cout &lt;&lt; *val &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending pipelines</span></div>
<div class="line"><span class="keyword">auto</span> pipe = redis.pipeline();</div>
<div class="line"><span class="keyword">auto</span> pipe_replies = pipe.set(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>)</div>
<div class="line">                        .get(<span class="stringliteral">&quot;key&quot;</span>)</div>
<div class="line">                        .rename(<span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;new-key&quot;</span>)</div>
<div class="line">                        .rpush(<span class="stringliteral">&quot;list&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>})</div>
<div class="line">                        .lrange(<span class="stringliteral">&quot;list&quot;</span>, 0, -1)</div>
<div class="line">                        .exec();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse reply with reply type and index.</span></div>
<div class="line"><span class="keyword">auto</span> set_cmd_result = pipe_replies.get&lt;<span class="keywordtype">bool</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sending a transaction</span></div>
<div class="line"><span class="keyword">auto</span> tx = redis.transaction();</div>
<div class="line"><span class="keyword">auto</span> tx_replies = tx.incr(<span class="stringliteral">&quot;num0&quot;</span>)</div>
<div class="line">                    .incr(<span class="stringliteral">&quot;num1&quot;</span>)</div>
<div class="line">                    .mget({<span class="stringliteral">&quot;num0&quot;</span>, <span class="stringliteral">&quot;num1&quot;</span>})</div>
<div class="line">                    .<a class="code hl_enumvalue" href="group__high-level-api.html#ggaaf95d0d45b3829342e8adff2d6c3fcbea52fb3679b07eb74d90784e612ca5cb30">exec</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> incr_result0 = tx_replies.get&lt;<span class="keywordtype">long</span> <span class="keywordtype">long</span>&gt;(0);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="agroup__high-level-api_html_ggaaf95d0d45b3829342e8adff2d6c3fcbea52fb3679b07eb74d90784e612ca5cb30"><div class="ttname"><a href="group__high-level-api.html#ggaaf95d0d45b3829342e8adff2d6c3fcbea52fb3679b07eb74d90784e612ca5cb30">boost::redis::operation::exec</a></div><div class="ttdeci">@ exec</div><div class="ttdoc">Refers to connection::async_exec operations.</div></div>
</div><!-- fragment --><p >Some of the problems with this API are</p>
<ul>
<li>Heterogeneous treatment of commands, pipelines and transaction. This makes auto-pipelining impossible.</li>
<li>Any Api that sends individual commands has a very restricted scope of usability and should be avoided for performance reasons.</li>
<li>The API imposes exceptions on users, no error-code overload is provided.</li>
<li>No way to reuse the buffer for new calls to e.g. redis.get in order to avoid further dynamic memory allocations.</li>
<li>Error handling of resolve and connection not clear.</li>
</ul>
<p >According to the documentation, pipelines in redis-plus-plus have the following characteristics</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: By default, creating a Pipeline object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>This is clearly a downside in the API as pipelines should be the default way of communicating and not an exception, paying such a high price for each pipeline imposes a severe cost in performance. Transactions also suffer from the very same problem.</p>
<blockquote class="doxtable">
<p >&zwj;NOTE: Creating a Transaction object is NOT cheap, since it creates a new connection. </p>
</blockquote>
<p>In Boost.Redis there is no difference between sending one command, a pipeline or a transaction because requests are decoupled from the IO objects.</p>
<blockquote class="doxtable">
<p >&zwj;redis-plus-plus also supports async interface, however, async support for Transaction and Subscriber is still on the way.</p>
<p >The async interface depends on third-party event library, and so far, only libuv is supported. </p>
</blockquote>
<p>Async code in redis-plus-plus looks like the following</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> async_redis = AsyncRedis(opts, pool_opts);</div>
<div class="line"> </div>
<div class="line">Future&lt;string&gt; ping_res = async_redis.ping();</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; ping_res.get() &lt;&lt; endl;</div>
</div><!-- fragment --><p> As the reader can see, the async interface is based on futures which is also known to have a bad performance. The biggest problem however with this async design is that it makes it impossible to write asynchronous programs correctly since it starts an async operation on every command sent instead of enqueueing a message and triggering a write when it can be sent. It is also not clear how are pipelines realised with this design (if at all).</p>
<p ><a class="anchor" id="api-reference"></a> </p>
<h1><a class="anchor" id="autotoc_md18"></a>
Reference</h1>
<p >The <a class="el" href="group__high-level-api.html">High-Level</a> page documents all public types.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Acknowledgement</h1>
<p >Acknowledgement to people that helped shape Boost.Redis</p>
<ul>
<li>Richard Hodges (<a href="https://github.com/madmongo1">madmongo1</a>): For very helpful support with Asio, the design of asynchronous programs, etc.</li>
<li>Vin√≠cius dos Santos Oliveira (<a href="https://github.com/vinipsmaker">vinipsmaker</a>): For useful discussion about how Boost.Redis consumes buffers in the read operation.</li>
<li>Petr Dannhofer (<a href="https://github.com/Eddie-cz">Eddie-cz</a>): For helping me understand how the <code>AUTH</code> and <code>HELLO</code> command can influence each other.</li>
<li>Mohammad Nejati (<a href="https://github.com/ashtum">ashtum</a>): For pointing out scenarios where calls to <code>async_exec</code> should fail when the connection is lost.</li>
<li>Klemens Morgenstern (<a href="https://github.com/klemens-morgenstern">klemens-morgenstern</a>): For useful discussion about timeouts, cancellation, synchronous interfaces and general help with Asio.</li>
<li>Vinnie Falco (<a href="https://github.com/vinniefalco">vinniefalco</a>): For general suggestions about how to improve the code and the documentation.</li>
<li>Bram Veldhoen (<a href="https://github.com/bveldhoen">bveldhoen</a>): For contributing a Redis-streams example.</li>
</ul>
<p >Also many thanks to all individuals that participated in the Boost review</p>
<ul>
<li>Zach Laine: <a href="https://lists.boost.org/Archives/boost/2023/01/253883.php">https://lists.boost.org/Archives/boost/2023/01/253883.php</a></li>
<li>Vinnie Falco: <a href="https://lists.boost.org/Archives/boost/2023/01/253886.php">https://lists.boost.org/Archives/boost/2023/01/253886.php</a></li>
<li>Christian Mazakas: <a href="https://lists.boost.org/Archives/boost/2023/01/253900.php">https://lists.boost.org/Archives/boost/2023/01/253900.php</a></li>
<li>Ruben Perez: <a href="https://lists.boost.org/Archives/boost/2023/01/253915.php">https://lists.boost.org/Archives/boost/2023/01/253915.php</a></li>
<li>Dmitry Arkhipov: <a href="https://lists.boost.org/Archives/boost/2023/01/253925.php">https://lists.boost.org/Archives/boost/2023/01/253925.php</a></li>
<li>Alan de Freitas: <a href="https://lists.boost.org/Archives/boost/2023/01/253927.php">https://lists.boost.org/Archives/boost/2023/01/253927.php</a></li>
<li>Mohammad Nejati: <a href="https://lists.boost.org/Archives/boost/2023/01/253929.php">https://lists.boost.org/Archives/boost/2023/01/253929.php</a></li>
<li>Sam Hartsfield: <a href="https://lists.boost.org/Archives/boost/2023/01/253931.php">https://lists.boost.org/Archives/boost/2023/01/253931.php</a></li>
<li>Miguel Portilla: <a href="https://lists.boost.org/Archives/boost/2023/01/253935.php">https://lists.boost.org/Archives/boost/2023/01/253935.php</a></li>
<li>Robert A.H. Leahy: <a href="https://lists.boost.org/Archives/boost/2023/01/253928.php">https://lists.boost.org/Archives/boost/2023/01/253928.php</a></li>
</ul>
<p >The Reviews can be found at: <a href="https://lists.boost.org/Archives/boost/2023/01/date.php">https://lists.boost.org/Archives/boost/2023/01/date.php</a>. The thread with the ACCEPT from the review manager can be found here: <a href="https://lists.boost.org/Archives/boost/2023/01/253944.php">https://lists.boost.org/Archives/boost/2023/01/253944.php</a>.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Changelog</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
develop</h2>
<ul>
<li>Deprecates the <code>async_receive</code> overload that takes a response. Users should now first call <code>set_receive_response</code> to avoid constantly and unnecessarily setting the same response.</li>
<li>Uses <code>std::function</code> to type erase the response adapter. This change should not influence users in any way but allowed important simplification in the connections internals. This resulted in massive performance improvement.</li>
<li>The connection has a new member <code>get_usage()</code> that returns the connection usage information, such as number of bytes written, received etc.</li>
<li>There are massive performance improvements in the consuming of server pushes which are now communicated with an <code>asio::channel</code> and therefore can be buffered which avoids blocking the socket read-loop. Batch reads are also supported by means of <code>channel.try_send</code> and buffered messages can be consumed synchronously with <code>connection::receive</code>. The function <code>boost::redis::cancel_one</code> has been added to simplify processing multiple server pushes contained in the same <code>generic_response</code>. <em>IMPORTANT</em>: These changes may result in more than one push in the response when <code>connection::async_receive</code> resumes. The user must therefore be careful when calling <code>resp.clear()</code>: either ensure that all message have been processed or just use <code>consume_one</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
v1.4.2 (incorporates changes to conform the boost review and more)</h2>
<ul>
<li>Adds <code><a class="el" href="group__high-level-api.html#a72f73dba57cbafb47d62f7f510b19984" title="Database that will be passed to the SELECT command.">boost::redis::config::database_index</a></code> to make it possible to choose a database before starting running commands e.g. after an automatic reconnection.</li>
<li>Massive performance improvement. One of my tests went from 140k req/s to 390k/s. This was possible after a parser simplification that reduced the number of reschedules and buffer rotations.</li>
<li>Adds Redis stream example.</li>
<li>Renames the project to Boost.Redis and moves the code into namespace <code>boost::redis</code>.</li>
<li>As pointed out in the reviews the <code>to_bulk</code> and <code>from_bulk</code> names were too generic for ADL customization points. They gained the prefix <code>boost_redis_</code>.</li>
<li>Moves <code>boost::redis::resp3::request</code> to <code><a class="el" href="classboost_1_1redis_1_1request.html" title="Creates Redis requests.">boost::redis::request</a></code>.</li>
<li>Adds new typedef <code><a class="el" href="group__high-level-api.html#ga98187b3330083b600ef412a763d6866a" title="Response with compile-time size.">boost::redis::response</a></code> that should be used instead of <code>std::tuple</code>.</li>
<li>Adds new typedef <code><a class="el" href="group__high-level-api.html#gaa1dc751c19aca21d7bd661c8b9eea04f" title="A generic response to a request.">boost::redis::generic_response</a></code> that should be used instead of <code>std::vector&lt;resp3::node&lt;std::string&gt;&gt;</code>.</li>
<li>Renames <code>redis::ignore</code> to <code>redis::ignore_t</code>.</li>
<li>Changes <code>async_exec</code> to receive a <code>redis::response</code> instead of an adapter, namely, instead of passing <code>adapt(resp)</code> users should pass <code>resp</code> directly.</li>
<li>Introduces <code><a class="el" href="group__high-level-api.html#ga4919a8e4a5eb26182516d8e1d3d53486" title="Stores response to individual Redis commands.">boost::redis::adapter::result</a></code> to store responses to commands including possible resp3 errors without losing the error diagnostic part. To access values now use <code>std::get&lt;N&gt;(resp).value()</code> instead of <code>std::get&lt;N&gt;(resp)</code>.</li>
<li>Implements full-duplex communication. Before these changes the connection would wait for a response to arrive before sending the next one. Now requests are continuously coalesced and written to the socket. <code>request::coalesce</code> became unnecessary and was removed. I could measure significative performance gains with theses changes.</li>
<li>Improves serialization examples using Boost.Describe to serialize to JSON and protobuf. See <a class="el" href="cpp20__json_8cpp_source.html">cpp20_json.cpp</a> and <a class="el" href="cpp20__protobuf_8cpp_source.html">cpp20_protobuf.cpp</a> for more details.</li>
<li>Upgrades to Boost 1.81.0.</li>
<li>Fixes build with libc++.</li>
<li>Adds high-level functionality to the connection classes. For example, <code><a class="el" href="classboost_1_1redis_1_1connection.html#a55cb11a29f2f9886dae0065f0f478c6a" title="Calls boost::redis::basic_connection::async_run.">boost::redis::connection::async_run</a></code> will automatically resolve, connect, reconnect and perform health checks.</li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
v1.4.0-1</h2>
<ul>
<li>Renames <code>retry_on_connection_lost</code> to <code>cancel_if_unresponded</code>. (v1.4.1)</li>
<li>Removes dependency on Boost.Hana, <code>boost::string_view</code>, Boost.Variant2 and Boost.Spirit.</li>
<li>Fixes build and setup CI on windows.</li>
</ul>
<h2><a class="anchor" id="autotoc_md24"></a>
v1.3.0-1</h2>
<ul>
<li>Upgrades to Boost 1.80.0</li>
<li>Removes automatic sending of the <code>HELLO</code> command. This can't be implemented properly without bloating the connection class. It is now a user responsibility to send HELLO. Requests that contain it have priority over other requests and will be moved to the front of the queue, see <code>aedis::request::config</code></li>
<li>Automatic name resolving and connecting have been removed from <code>aedis::connection::async_run</code>. Users have to do this step manually now. The reason for this change is that having them built-in doesn't offer enough flexibility that is need for boost users.</li>
<li>Removes healthy checks and idle timeout. This functionality must now be implemented by users, see the examples. This is part of making Aedis useful to a larger audience and suitable for the Boost review process.</li>
<li>The <code>aedis::connection</code> is now using a typeddef to a <code>net::ip::tcp::socket</code> and <code>aedis::ssl::connection</code> to <code>net::ssl::stream&lt;net::ip::tcp::socket&gt;</code>. Users that need to use other stream type must now specialize <code>aedis::basic_connection</code>.</li>
<li>Adds a low level example of async code.</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
v1.2.0</h2>
<ul>
<li><code>aedis::adapt</code> supports now tuples created with <code>std::tie</code>. <code>aedis::ignore</code> is now an alias to the type of <code>std::ignore</code>.</li>
<li>Provides allocator support for the internal queue used in the <code>aedis::connection</code> class.</li>
<li>Changes the behaviour of <code>async_run</code> to complete with success if asio::error::eof is received. This makes it easier to write composed operations with awaitable operators.</li>
<li>Adds allocator support in the <code>aedis::request</code> (a contribution from Klemens Morgenstern).</li>
<li>Renames <code>aedis::request::push_range2</code> to <code>push_range</code>. The suffix 2 was used for disambiguation. Klemens fixed it with SFINAE.</li>
<li>Renames <code>fail_on_connection_lost</code> to <code>aedis::request::config::cancel_on_connection_lost</code>. Now, it will only cause connections to be canceled when <code>async_run</code> completes.</li>
<li>Introduces <code>aedis::request::config::cancel_if_not_connected</code> which will cause a request to be canceled if <code>async_exec</code> is called before a connection has been established.</li>
<li>Introduces new request flag <code>aedis::request::config::retry</code> that if set to true will cause the request to not be canceled when it was sent to Redis but remained unresponded after <code>async_run</code> completed. It provides a way to avoid executing commands twice.</li>
<li>Removes the <code>aedis::connection::async_run</code> overload that takes request and adapter as parameters.</li>
<li>Changes the way <code>aedis::adapt()</code> behaves with <code>std::vector&lt;aedis::resp3::node&lt;T&gt;&gt;</code>. Receiving RESP3 simple errors, blob errors or null won't causes an error but will be treated as normal response. It is the user responsibility to check the content in the vector.</li>
<li>Fixes a bug in <code>connection::cancel(operation::exec)</code>. Now this call will only cancel non-written requests.</li>
<li>Implements per-operation implicit cancellation support for <code>aedis::connection::async_exec</code>. The following call will <code>co_await (conn.async_exec(...) || timer.async_wait(...))</code> will cancel the request as long as it has not been written.</li>
<li>Changes <code>aedis::connection::async_run</code> completion signature to <code>f(error_code)</code>. This is how is was in the past, the second parameter was not helpful.</li>
<li>Renames <code>operation::receive_push</code> to <code>aedis::operation::receive</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
v1.1.0-1</h2>
<ul>
<li>Removes <code>coalesce_requests</code> from the <code>aedis::connection::config</code>, it became a request property now, see <code>aedis::request::config::coalesce</code>.</li>
<li>Removes <code>max_read_size</code> from the <code>aedis::connection::config</code>. The maximum read size can be specified now as a parameter of the <code>aedis::adapt()</code> function.</li>
<li>Removes <code>aedis::sync</code> class, see intro_sync.cpp for how to perform synchronous and thread safe calls. This is possible in Boost. 1.80 only as it requires <code>boost::asio::deferred</code>.</li>
<li>Moves from <code>boost::optional</code> to <code>std::optional</code>. This is part of moving to C++17.</li>
<li>Changes the behaviour of the second <code>aedis::connection::async_run</code> overload so that it always returns an error when the connection is lost.</li>
<li>Adds TLS support, see intro_tls.cpp.</li>
<li>Adds an example that shows how to resolve addresses over sentinels, see subscriber_sentinel.cpp.</li>
<li>Adds a <code>aedis::connection::timeouts::resp3_handshake_timeout</code>. This is timeout used to send the <code>HELLO</code> command.</li>
<li>Adds <code>aedis::endpoint</code> where in addition to host and port, users can optionally provide username, password and the expected server role (see <code>aedis::error::unexpected_server_role</code>).</li>
<li><code>aedis::connection::async_run</code> checks whether the server role received in the hello command is equal to the expected server role specified in <code>aedis::endpoint</code>. To skip this check let the role variable empty.</li>
<li>Removes reconnect functionality from <code>aedis::connection</code>. It is possible in simple reconnection strategies but bloats the class in more complex scenarios, for example, with sentinel, authentication and TLS. This is trivial to implement in a separate coroutine. As a result the <code>enum event</code> and <code>async_receive_event</code> have been removed from the class too.</li>
<li>Fixes a bug in <code>connection::async_receive_push</code> that prevented passing any response adapter other that <code>adapt(std::vector&lt;node&gt;)</code>.</li>
<li>Changes the behaviour of <code>aedis::adapt()</code> that caused RESP3 errors to be ignored. One consequence of it is that <code>connection::async_run</code> would not exit with failure in servers that required authentication.</li>
<li>Changes the behaviour of <code>connection::async_run</code> that would cause it to complete with success when an error in the <code>connection::async_exec</code> occurred.</li>
<li>Ports the buildsystem from autotools to CMake.</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
v1.0.0</h2>
<ul>
<li>Adds experimental cmake support for windows users.</li>
<li>Adds new class <code>aedis::sync</code> that wraps an <code>aedis::connection</code> in a thread-safe and synchronous API. All free functions from the <code>sync.hpp</code> are now member functions of <code>aedis::sync</code>.</li>
<li>Split <code>aedis::connection::async_receive_event</code> in two functions, one to receive events and another for server side pushes, see <code>aedis::connection::async_receive_push</code>.</li>
<li>Removes collision between <code>aedis::adapter::adapt</code> and <code>aedis::adapt</code>.</li>
<li>Adds <code>connection::operation</code> enum to replace <code>cancel_*</code> member functions with a single cancel function that gets the operations that should be cancelled as argument.</li>
<li>Bugfix: a bug on reconnect from a state where the <code>connection</code> object had unsent commands. It could cause <code>async_exec</code> to never complete under certain conditions.</li>
<li>Bugfix: Documentation of <code>adapt()</code> functions were missing from Doxygen.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
v0.3.0</h2>
<ul>
<li>Adds <code>experimental::exec</code> and <code>receive_event</code> functions to offer a thread safe and synchronous way of executing requests across threads. See <code>intro_sync.cpp</code> and <code>subscriber_sync.cpp</code> for examples.</li>
<li><code>connection::async_read_push</code> was renamed to <code>async_receive_event</code>.</li>
<li><code>connection::async_receive_event</code> is now being used to communicate internal events to the user, such as resolve, connect, push etc. For examples see <a class="el" href="cpp20__subscriber_8cpp_source.html">cpp20_subscriber.cpp</a> and <code>connection::event</code>.</li>
<li>The <code>aedis</code> directory has been moved to <code>include</code> to look more similar to Boost libraries. Users should now replace <code>-I/aedis-path</code> with <code>-I/aedis-path/include</code> in the compiler flags.</li>
<li>The <code>AUTH</code> and <code>HELLO</code> commands are now sent automatically. This change was necessary to implement reconnection. The username and password used in <code>AUTH</code> should be provided by the user on <code>connection::config</code>.</li>
<li>Adds support for reconnection. See <code>connection::enable_reconnect</code>.</li>
<li>Fixes a bug in the <code>connection::async_run(host, port)</code> overload that was causing crashes on reconnection.</li>
<li>Fixes the executor usage in the connection class. Before theses changes it was imposing <code>any_io_executor</code> on users.</li>
<li><code>connection::async_receiver_event</code> is not cancelled anymore when <code>connection::async_run</code> exits. This change makes user code simpler.</li>
<li><code>connection::async_exec</code> with host and port overload has been removed. Use the other <code>connection::async_run</code> overload.</li>
<li>The host and port parameters from <code>connection::async_run</code> have been move to <code>connection::config</code> to better support authentication and failover.</li>
<li>Many simplifications in the <code>chat_room</code> example.</li>
<li>Fixes build in clang the compilers and makes some improvements in the documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
v0.2.0-1</h2>
<ul>
<li>Fixes a bug that happens on very high load. (v0.2.1)</li>
<li>Major rewrite of the high-level API. There is no more need to use the low-level API anymore.</li>
<li>No more callbacks: Sending requests follows the ASIO asynchronous model.</li>
<li>Support for reconnection: Pending requests are not canceled when a connection is lost and are re-sent when a new one is established.</li>
<li>The library is not sending HELLO-3 on user behalf anymore. This is important to support AUTH properly.</li>
</ul>
<h2><a class="anchor" id="autotoc_md30"></a>
v0.1.0-2</h2>
<ul>
<li>Adds reconnect coroutine in the <code>echo_server</code> example. (v0.1.2)</li>
<li>Corrects <code>client::async_wait_for_data</code> with <code>make_parallel_group</code> to launch operation. (v0.1.2)</li>
<li>Improvements in the documentation. (v0.1.2)</li>
<li>Avoids dynamic memory allocation in the client class after reconnection. (v0.1.2)</li>
<li>Improves the documentation and adds some features to the high-level client. (v.0.1.1)</li>
<li>Improvements in the design and documentation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
v0.0.1</h2>
<ul>
<li>First release to collect design feedback. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 6 2023 21:06:35 for Boost.Redis by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
