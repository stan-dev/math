<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Boost.Unordered</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Boost.Unordered</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#intro">Introduction</a></li>
<li><a href="#buckets">Basics of Hash Tables</a>
<ul class="sectlevel2">
<li><a href="#buckets_controlling_the_number_of_buckets">Controlling the Number of Buckets</a></li>
</ul>
</li>
<li><a href="#hash_equality">Equality Predicates and Hash Functions</a>
<ul class="sectlevel2">
<li><a href="#hash_equality_custom_types">Custom Types</a></li>
</ul>
</li>
<li><a href="#regular">Regular Containers</a>
<ul class="sectlevel2">
<li><a href="#regular_iterator_invalidation">Iterator Invalidation</a></li>
<li><a href="#comparison">Comparison with Associative Containers</a></li>
</ul>
</li>
<li><a href="#concurrent">Concurrent Containers</a>
<ul class="sectlevel2">
<li><a href="#concurrent_visitation_based_api">Visitation-based API</a></li>
<li><a href="#concurrent_whole_table_visitation">Whole-Table Visitation</a></li>
<li><a href="#concurrent_bulk_visitation">Bulk visitation</a></li>
<li><a href="#concurrent_blocking_operations">Blocking Operations</a></li>
<li><a href="#concurrent_interoperability_with_non_concurrent_containers">Interoperability with non-concurrent containers</a></li>
</ul>
</li>
<li><a href="#compliance">Standard Compliance</a>
<ul class="sectlevel2">
<li><a href="#compliance_closed_addressing_containers">Closed-addressing Containers</a>
<ul class="sectlevel3">
<li><a href="#compliance_deduction_guides">Deduction Guides</a></li>
<li><a href="#compliance_piecewise_pair_emplacement">Piecewise Pair Emplacement</a></li>
<li><a href="#compliance_swap">Swap</a></li>
</ul>
</li>
<li><a href="#compliance_open_addressing_containers">Open-addressing Containers</a></li>
<li><a href="#compliance_concurrent_containers">Concurrent Containers</a></li>
</ul>
</li>
<li><a href="#structures">Data Structures</a>
<ul class="sectlevel2">
<li><a href="#structures_closed_addressing_containers">Closed-addressing Containers</a></li>
<li><a href="#structures_open_addressing_containers">Open-addressing Containers</a></li>
<li><a href="#structures_concurrent_containers">Concurrent Containers</a></li>
</ul>
</li>
<li><a href="#benchmarks">Benchmarks</a>
<ul class="sectlevel2">
<li><a href="#benchmarks_boostunordered_multiset">boost::unordered_[multi]set</a>
<ul class="sectlevel3">
<li><a href="#benchmarks_gcc_12_libstdc_v3_x64">GCC 12 + libstdc++-v3, x64</a></li>
<li><a href="#benchmarks_clang_15_libc_x64">Clang 15 + libc++, x64</a></li>
<li><a href="#benchmarks_visual_studio_2022_dinkumware_x64">Visual Studio 2022 + Dinkumware, x64</a></li>
</ul>
</li>
<li><a href="#benchmarks_boostunordered_flatnode_map">boost::unordered_(flat|node)_map</a>
<ul class="sectlevel3">
<li><a href="#benchmarks_gcc_12_x64">GCC 12, x64</a></li>
<li><a href="#benchmarks_clang_15_x64">Clang 15, x64</a></li>
<li><a href="#benchmarks_visual_studio_2022_x64">Visual Studio 2022, x64</a></li>
<li><a href="#benchmarks_clang_12_arm64">Clang 12, ARM64</a></li>
<li><a href="#benchmarks_gcc_12_x86">GCC 12, x86</a></li>
<li><a href="#benchmarks_clang_15_x86">Clang 15, x86</a></li>
<li><a href="#benchmarks_visual_studio_2022_x86">Visual Studio 2022, x86</a></li>
</ul>
</li>
<li><a href="#benchmarks_boostconcurrent_flat_map">boost::concurrent_flat_map</a>
<ul class="sectlevel3">
<li><a href="#benchmarks_gcc_12_x64_2">GCC 12, x64</a></li>
<li><a href="#benchmarks_clang_15_x64_2">Clang 15, x64</a></li>
<li><a href="#benchmarks_visual_studio_2022_x64_2">Visual Studio 2022, x64</a></li>
<li><a href="#benchmarks_clang_12_arm64_2">Clang 12, ARM64</a></li>
<li><a href="#benchmarks_gcc_12_x86_2">GCC 12, x86</a></li>
<li><a href="#benchmarks_clang_15_x86_2">Clang 15, x86</a></li>
<li><a href="#benchmarks_visual_studio_2022_x86_2">Visual Studio 2022, x86</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rationale">Implementation Rationale</a>
<ul class="sectlevel2">
<li><a href="#rationale_closed_addressing_containers">Closed-addressing Containers</a>
<ul class="sectlevel3">
<li><a href="#rationale_data_structure">Data Structure</a></li>
<li><a href="#rationale_number_of_buckets">Number of Buckets</a></li>
</ul>
</li>
<li><a href="#rationale_open_addresing_containers">Open-addresing Containers</a>
<ul class="sectlevel3">
<li><a href="#rationale_hash_function">Hash Function</a></li>
<li><a href="#rationale_platform_interoperability">Platform Interoperability</a></li>
</ul>
</li>
<li><a href="#rationale_concurrent_containers">Concurrent Containers</a>
<ul class="sectlevel3">
<li><a href="#rationale_hash_function_and_platform_interoperability">Hash Function and Platform Interoperability</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#unordered_map">Class Template unordered_map</a>
<ul class="sectlevel3">
<li><a href="#unordered_map_synopsis">Synopsis</a></li>
<li><a href="#unordered_map_description">Description</a></li>
<li><a href="#unordered_map_configuration_macros">Configuration macros</a></li>
<li><a href="#unordered_map_typedefs">Typedefs</a></li>
<li><a href="#unordered_map_constructors">Constructors</a></li>
<li><a href="#unordered_map_destructor">Destructor</a></li>
<li><a href="#unordered_map_assignment">Assignment</a></li>
<li><a href="#unordered_map_iterators">Iterators</a></li>
<li><a href="#unordered_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_map_modifiers">Modifiers</a></li>
<li><a href="#unordered_map_observers">Observers</a></li>
<li><a href="#unordered_map_lookup">Lookup</a></li>
<li><a href="#unordered_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_map_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_map_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_map_swap_2">Swap</a></li>
<li><a href="#unordered_map_erase_if">erase_if</a></li>
<li><a href="#unordered_map_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#unordered_multimap">Class Template unordered_multimap</a>
<ul class="sectlevel3">
<li><a href="#unordered_multimap_synopsis">Synopsis</a></li>
<li><a href="#unordered_multimap_description">Description</a></li>
<li><a href="#unordered_multimap_configuration_macros">Configuration macros</a></li>
<li><a href="#unordered_multimap_typedefs">Typedefs</a></li>
<li><a href="#unordered_multimap_constructors">Constructors</a></li>
<li><a href="#unordered_multimap_destructor">Destructor</a></li>
<li><a href="#unordered_multimap_assignment">Assignment</a></li>
<li><a href="#unordered_multimap_iterators">Iterators</a></li>
<li><a href="#unordered_multimap_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_multimap_modifiers">Modifiers</a></li>
<li><a href="#unordered_multimap_observers">Observers</a></li>
<li><a href="#unordered_multimap_lookup">Lookup</a></li>
<li><a href="#unordered_multimap_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_multimap_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_multimap_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_multimap_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_multimap_swap_2">Swap</a></li>
<li><a href="#unordered_multimap_erase_if">erase_if</a></li>
<li><a href="#unordered_multimap_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#unordered_set">Class Template unordered_set</a>
<ul class="sectlevel3">
<li><a href="#unordered_set_synopsis">Synopsis</a></li>
<li><a href="#unordered_set_description">Description</a></li>
<li><a href="#unordered_set_configuration_macros">Configuration macros</a></li>
<li><a href="#unordered_set_typedefs">Typedefs</a></li>
<li><a href="#unordered_set_constructors">Constructors</a></li>
<li><a href="#unordered_set_destructor">Destructor</a></li>
<li><a href="#unordered_set_assignment">Assignment</a></li>
<li><a href="#unordered_set_iterators">Iterators</a></li>
<li><a href="#unordered_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_set_modifiers">Modifiers</a></li>
<li><a href="#unordered_set_observers">Observers</a></li>
<li><a href="#unordered_set_lookup">Lookup</a></li>
<li><a href="#unordered_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_set_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_set_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_set_swap_2">Swap</a></li>
<li><a href="#unordered_set_erase_if">erase_if</a></li>
<li><a href="#unordered_set_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#unordered_multiset">Class Template unordered_multiset</a>
<ul class="sectlevel3">
<li><a href="#unordered_multiset_synopsis">Synopsis</a></li>
<li><a href="#unordered_multiset_description">Description</a></li>
<li><a href="#unordered_multiset_configuration_macros">Configuration macros</a></li>
<li><a href="#unordered_multiset_typedefs">Typedefs</a></li>
<li><a href="#unordered_multiset_constructors">Constructors</a></li>
<li><a href="#unordered_multiset_destructor">Destructor</a></li>
<li><a href="#unordered_multiset_assignment">Assignment</a></li>
<li><a href="#unordered_multiset_iterators">Iterators</a></li>
<li><a href="#unordered_multiset_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_multiset_modifiers">Modifiers</a></li>
<li><a href="#unordered_multiset_observers">Observers</a></li>
<li><a href="#unordered_multiset_lookup">Lookup</a></li>
<li><a href="#unordered_multiset_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_multiset_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_multiset_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_multiset_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_multiset_swap_2">Swap</a></li>
<li><a href="#unordered_multiset_erase_if">erase_if</a></li>
<li><a href="#unordered_multiset_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#hash_traits">Hash traits</a>
<ul class="sectlevel3">
<li><a href="#hash_traits_synopsis">Synopsis</a></li>
<li><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a></li>
</ul>
</li>
<li><a href="#unordered_flat_map">Class Template unordered_flat_map</a>
<ul class="sectlevel3">
<li><a href="#unordered_flat_map_synopsis">Synopsis</a></li>
<li><a href="#unordered_flat_map_description">Description</a></li>
<li><a href="#unordered_flat_map_typedefs">Typedefs</a></li>
<li><a href="#unordered_flat_map_constructors">Constructors</a></li>
<li><a href="#unordered_flat_map_destructor">Destructor</a></li>
<li><a href="#unordered_flat_map_assignment">Assignment</a></li>
<li><a href="#unordered_flat_map_iterators">Iterators</a></li>
<li><a href="#unordered_flat_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_flat_map_modifiers">Modifiers</a></li>
<li><a href="#unordered_flat_map_observers">Observers</a></li>
<li><a href="#unordered_flat_map_lookup">Lookup</a></li>
<li><a href="#unordered_flat_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_flat_map_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_flat_map_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_flat_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_flat_map_swap_2">Swap</a></li>
<li><a href="#unordered_flat_map_erase_if">erase_if</a></li>
<li><a href="#unordered_flat_map_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#unordered_flat_set">Class Template unordered_flat_set</a>
<ul class="sectlevel3">
<li><a href="#unordered_flat_set_synopsis">Synopsis</a></li>
<li><a href="#unordered_flat_set_description">Description</a></li>
<li><a href="#unordered_flat_set_typedefs">Typedefs</a></li>
<li><a href="#unordered_flat_set_constructors">Constructors</a></li>
<li><a href="#unordered_flat_set_destructor">Destructor</a></li>
<li><a href="#unordered_flat_set_assignment">Assignment</a></li>
<li><a href="#unordered_flat_set_iterators">Iterators</a></li>
<li><a href="#unordered_flat_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_flat_set_modifiers">Modifiers</a></li>
<li><a href="#unordered_flat_set_observers">Observers</a></li>
<li><a href="#unordered_flat_set_lookup">Lookup</a></li>
<li><a href="#unordered_flat_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_flat_set_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_flat_set_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_flat_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_flat_set_swap_2">Swap</a></li>
<li><a href="#unordered_flat_set_erase_if">erase_if</a></li>
<li><a href="#unordered_flat_set_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#unordered_node_map">Class Template unordered_node_map</a>
<ul class="sectlevel3">
<li><a href="#unordered_node_map_synopsis">Synopsis</a></li>
<li><a href="#unordered_node_map_description">Description</a></li>
<li><a href="#unordered_node_map_typedefs">Typedefs</a></li>
<li><a href="#unordered_node_map_constructors">Constructors</a></li>
<li><a href="#unordered_node_map_destructor">Destructor</a></li>
<li><a href="#unordered_node_map_assignment">Assignment</a></li>
<li><a href="#unordered_node_map_iterators">Iterators</a></li>
<li><a href="#unordered_node_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_node_map_modifiers">Modifiers</a></li>
<li><a href="#unordered_node_map_observers">Observers</a></li>
<li><a href="#unordered_node_map_lookup">Lookup</a></li>
<li><a href="#unordered_node_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_node_map_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_node_map_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_node_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_node_map_swap_2">Swap</a></li>
<li><a href="#unordered_node_map_erase_if">erase_if</a></li>
<li><a href="#unordered_node_map_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#unordered_node_set">Class Template unordered_node_set</a>
<ul class="sectlevel3">
<li><a href="#unordered_node_set_synopsis">Synopsis</a></li>
<li><a href="#unordered_node_set_description">Description</a></li>
<li><a href="#unordered_node_set_typedefs">Typedefs</a></li>
<li><a href="#unordered_node_set_constructors">Constructors</a></li>
<li><a href="#unordered_node_set_destructor">Destructor</a></li>
<li><a href="#unordered_node_set_assignment">Assignment</a></li>
<li><a href="#unordered_node_set_iterators">Iterators</a></li>
<li><a href="#unordered_node_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_node_set_modifiers">Modifiers</a></li>
<li><a href="#unordered_node_set_observers">Observers</a></li>
<li><a href="#unordered_node_set_lookup">Lookup</a></li>
<li><a href="#unordered_node_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_node_set_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_node_set_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_node_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_node_set_swap_2">Swap</a></li>
<li><a href="#unordered_node_set_erase_if">erase_if</a></li>
<li><a href="#unordered_node_set_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#concurrent_flat_map">Class Template concurrent_flat_map</a>
<ul class="sectlevel3">
<li><a href="#concurrent_flat_map_synopsis">Synopsis</a></li>
<li><a href="#concurrent_flat_map_description">Description</a></li>
<li><a href="#concurrent_flat_map_concurrency_requirements_and_guarantees">Concurrency Requirements and Guarantees</a></li>
<li><a href="#concurrent_flat_map_configuration_macros">Configuration Macros</a></li>
<li><a href="#concurrent_flat_map_constants">Constants</a></li>
<li><a href="#concurrent_flat_map_constructors">Constructors</a></li>
<li><a href="#concurrent_flat_map_destructor">Destructor</a></li>
<li><a href="#concurrent_flat_map_assignment">Assignment</a></li>
<li><a href="#concurrent_flat_map_visitation">Visitation</a></li>
<li><a href="#concurrent_flat_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#concurrent_flat_map_modifiers">Modifiers</a></li>
<li><a href="#concurrent_flat_map_observers">Observers</a></li>
<li><a href="#concurrent_flat_map_map_operations">Map Operations</a></li>
<li><a href="#concurrent_flat_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#concurrent_flat_map_hash_policy">Hash Policy</a></li>
<li><a href="#concurrent_flat_map_deduction_guides">Deduction Guides</a></li>
<li><a href="#concurrent_flat_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#concurrent_flat_map_swap_2">Swap</a></li>
<li><a href="#concurrent_flat_map_erase_if_2">erase_if</a></li>
<li><a href="#concurrent_flat_map_serialization">Serialization</a></li>
</ul>
</li>
<li><a href="#concurrent_flat_set">Class Template concurrent_flat_set</a>
<ul class="sectlevel3">
<li><a href="#concurrent_flat_set_synopsis">Synopsis</a></li>
<li><a href="#concurrent_flat_set_description">Description</a></li>
<li><a href="#concurrent_flat_set_concurrency_requirements_and_guarantees">Concurrency Requirements and Guarantees</a></li>
<li><a href="#concurrent_flat_set_configuration_macros">Configuration Macros</a></li>
<li><a href="#concurrent_flat_set_constants">Constants</a></li>
<li><a href="#concurrent_flat_set_constructors">Constructors</a></li>
<li><a href="#concurrent_flat_set_destructor">Destructor</a></li>
<li><a href="#concurrent_flat_set_assignment">Assignment</a></li>
<li><a href="#concurrent_flat_set_visitation">Visitation</a></li>
<li><a href="#concurrent_flat_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#concurrent_flat_set_modifiers">Modifiers</a></li>
<li><a href="#concurrent_flat_set_observers">Observers</a></li>
<li><a href="#concurrent_flat_set_set_operations">Set Operations</a></li>
<li><a href="#concurrent_flat_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#concurrent_flat_set_hash_policy">Hash Policy</a></li>
<li><a href="#concurrent_flat_set_deduction_guides">Deduction Guides</a></li>
<li><a href="#concurrent_flat_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#concurrent_flat_set_swap_2">Swap</a></li>
<li><a href="#concurrent_flat_set_erase_if_2">erase_if</a></li>
<li><a href="#concurrent_flat_set_serialization">Serialization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#changes">Change Log</a>
<ul class="sectlevel2">
<li><a href="#changes_release_1_84_0_major_update">Release 1.84.0 - Major update</a></li>
<li><a href="#changes_release_1_83_0_major_update">Release 1.83.0 - Major update</a></li>
<li><a href="#changes_release_1_82_0_major_update">Release 1.82.0 - Major update</a></li>
<li><a href="#changes_release_1_81_0_major_update">Release 1.81.0 - Major update</a></li>
<li><a href="#changes_release_1_80_0_major_update">Release 1.80.0 - Major update</a></li>
<li><a href="#changes_release_1_79_0">Release 1.79.0</a></li>
<li><a href="#changes_release_1_67_0">Release 1.67.0</a></li>
<li><a href="#changes_release_1_66_0">Release 1.66.0</a></li>
<li><a href="#changes_release_1_65_0">Release 1.65.0</a></li>
<li><a href="#changes_release_1_64_0">Release 1.64.0</a></li>
<li><a href="#changes_release_1_63_0">Release 1.63.0</a></li>
<li><a href="#changes_release_1_62_0">Release 1.62.0</a></li>
<li><a href="#changes_release_1_58_0">Release 1.58.0</a></li>
<li><a href="#changes_release_1_57_0">Release 1.57.0</a></li>
<li><a href="#changes_release_1_56_0">Release 1.56.0</a></li>
<li><a href="#changes_release_1_55_0">Release 1.55.0</a></li>
<li><a href="#changes_release_1_54_0">Release 1.54.0</a></li>
<li><a href="#changes_release_1_53_0">Release 1.53.0</a></li>
<li><a href="#changes_release_1_52_0">Release 1.52.0</a></li>
<li><a href="#changes_release_1_51_0">Release 1.51.0</a></li>
<li><a href="#changes_release_1_50_0">Release 1.50.0</a></li>
<li><a href="#changes_release_1_49_0">Release 1.49.0</a></li>
<li><a href="#changes_release_1_48_0_major_update">Release 1.48.0 - Major update</a></li>
<li><a href="#changes_release_1_45_0">Release 1.45.0</a></li>
<li><a href="#changes_release_1_43_0">Release 1.43.0</a></li>
<li><a href="#changes_release_1_42_0">Release 1.42.0</a></li>
<li><a href="#changes_release_1_41_0_major_update">Release 1.41.0 - Major update</a></li>
<li><a href="#changes_release_1_40_0">Release 1.40.0</a></li>
<li><a href="#changes_release_1_39_0">Release 1.39.0</a></li>
<li><a href="#changes_release_1_38_0">Release 1.38.0</a></li>
<li><a href="#changes_release_1_37_0">Release 1.37.0</a></li>
<li><a href="#changes_release_1_36_0">Release 1.36.0</a></li>
<li><a href="#changes_boost_1_35_0_add_on_31st_march_2008">Boost 1.35.0 Add-on - 31st March 2008</a></li>
<li><a href="#changes_review_version">Review Version</a></li>
</ul>
</li>
<li><a href="#bibliography">Bibliography</a></li>
<li><a href="#copyright">Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="intro"><a class="link" href="#intro">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Hash tables</a> are extremely popular
computer data structures and can be found under one form or another in virtually any programming
language. Whereas other associative structures such as rb-trees (used in C++ by <code>std::set</code> and <code>std::map</code>)
have logarithmic-time complexity for insertion and lookup, hash tables, if configured properly,
perform these operations in constant time on average, and are generally much faster.</p>
</div>
<div class="paragraph">
<p>C++ introduced <em>unordered associative containers</em> <code>std::unordered_set</code>, <code>std::unordered_map</code>,
<code>std::unordered_multiset</code> and <code>std::unordered_multimap</code> in C++11, but research on hash tables
hasn&#8217;t stopped since: advances in CPU architectures such as
more powerful caches, <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> operations
and increasingly available <a href="https://en.wikipedia.org/wiki/Multi-core_processor">multicore processors</a>
open up possibilities for improved hash-based data structures and new use cases that
are simply beyond reach of unordered associative containers as specified in 2011.</p>
</div>
<div class="paragraph">
<p>Boost.Unordered offers a catalog of hash containers with different standards compliance levels,
performances and intented usage scenarios:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Boost.Unordered containers</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"><p class="tableblock"><strong>Node-based</strong></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Flat</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Closed addressing</strong></p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_set<br>
boost::unordered_map<br>
boost::unordered_multiset<br>
boost::unordered_multimap</code></p></td>
<td class="tableblock halign-center valign-middle"></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Open addressing</strong></p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_node_set<br>
boost::unordered_node_map</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>boost::unordered_flat_set<br>
boost::unordered_flat_map</code></p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Concurrent</strong></p></th>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>boost::concurrent_flat_set</code><br>
<code>boost::concurrent_flat_map</code></p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p><strong>Closed-addressing containers</strong> are fully compliant with the C++ specification
for unordered associative containers and feature one of the fastest implementations
in the market within the technical constraints imposed by the required standard interface.</p>
</li>
<li>
<p><strong>Open-addressing containers</strong> rely on much faster data structures and algorithms
(more than 2 times faster in typical scenarios) while slightly diverging from the standard
interface to accommodate the implementation.
There are two variants: <strong>flat</strong> (the fastest) and <strong>node-based</strong>, which
provide pointer stability under rehashing at the expense of being slower.</p>
</li>
<li>
<p>Finally, <strong>concurrent containers</strong> are designed and implemented to be used in high-performance
multithreaded scenarios. Their interface is radically different from that of regular C++ containers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All sets and maps in Boost.Unordered are instantiatied similarly as
<code>std::unordered_set</code> and <code>std::unordered_map</code>, respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_set</span><span class="p">;</span>
    <span class="c1">// same for unordered_multiset, unordered_flat_set, unordered_node_set</span>
    <span class="c1">// and concurrent_flat_set</span>

    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_map</span><span class="p">;</span>
    <span class="c1">// same for unordered_multimap, unordered_flat_map, unordered_node_map</span>
    <span class="c1">// and concurrent_flat_map</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Storing an object in an unordered associative container requires both a
key equality function and a hash function. The default function objects in
the standard containers support a few basic types including integer types,
floating point types, pointer types, and the standard strings. Since
Boost.Unordered uses <a href="../../../container_hash/index.html" target="_blank" rel="noopener">boost::hash</a> it also supports some other types,
including standard containers. To use any types not supported by these methods
you have to extend Boost.Hash to support the type or use
your own custom equality predicates and hash functions. See the
<a href="#hash_equality">Equality Predicates and Hash Functions</a> section
for more details.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buckets"><a class="link" href="#buckets">Basics of Hash Tables</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The containers are made up of a number of <em>buckets</em>, each of which can contain
any number of elements. For example, the following diagram shows a <a href="#unordered_set"><code>boost::unordered_set</code></a> with 7 buckets containing 5 elements, <code>A</code>,
<code>B</code>, <code>C</code>, <code>D</code> and <code>E</code> (this is just for illustration, containers will typically
have more buckets).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../diagrams/buckets.png" alt="buckets">
</div>
</div>
<div class="paragraph">
<p>In order to decide which bucket to place an element in, the container applies
the hash function, <code>Hash</code>, to the element&#8217;s key (for sets the key is the whole element, but is referred to as the key
so that the same terminology can be used for sets and maps). This returns a
value of type <code>std::size_t</code>. <code>std::size_t</code> has a much greater range of values
then the number of buckets, so the container applies another transformation to
that value to choose a bucket to place the element in.</p>
</div>
<div class="paragraph">
<p>Retrieving the elements for a given key is simple. The same process is applied
to the key to find the correct bucket. Then the key is compared with the
elements in the bucket to find any elements that match (using the equality
predicate <code>Pred</code>). If the hash function has worked well the elements will be
evenly distributed amongst the buckets so only a small number of elements will
need to be examined.</p>
</div>
<div class="paragraph">
<p>There is <a href="#hash_equality">more information on hash functions and
equality predicates in the next section</a>.</p>
</div>
<div class="paragraph">
<p>You can see in the diagram that <code>A</code> &amp; <code>D</code> have been placed in the same bucket.
When looking for elements in this bucket up to 2 comparisons are made, making
the search slower. This is known as a <strong>collision</strong>. To keep things fast we try to
keep collisions to a minimum.</p>
</div>
<div class="paragraph">
<p>If instead of <code>boost::unordered_set</code> we had used <a href="#unordered_flat_set"><code>boost::unordered_flat_set</code></a>, the
diagram would look as follows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../diagrams/buckets-oa.png" alt="buckets oa">
</div>
</div>
<div class="paragraph">
<p>In open-addressing containers, buckets can hold at most one element; if a collision happens
(like is the case of <code>D</code> in the example), the element uses some other available bucket in
the vicinity of the original position. Given this simpler scenario, Boost.Unordered
open-addressing containers offer a very limited API for accessing buckets.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 2. Methods for Accessing Buckets</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>All containers</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of buckets.</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>Closed-addressing containers only</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type max_bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">An upper bound on the number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_size(size_type n) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of elements in bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket(key_type const&amp; k) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the index of the bucket which would contain <code>k</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator begin(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle" rowspan="6"><p class="tableblock">Return begin and end iterators for bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator end(size_type n)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator begin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator end(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cbegin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cend(size_type n) const</code></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="buckets_controlling_the_number_of_buckets"><a class="link" href="#buckets_controlling_the_number_of_buckets">Controlling the Number of Buckets</a></h3>
<div class="paragraph">
<p>As more elements are added to an unordered associative container, the number
of collisions will increase causing performance to degrade.
To combat this the containers increase the bucket count as elements are inserted.
You can also tell the container to change the bucket count (if required) by
calling <code>rehash</code>.</p>
</div>
<div class="paragraph">
<p>The standard leaves a lot of freedom to the implementer to decide how the
number of buckets is chosen, but it does make some requirements based on the
container&#8217;s <em>load factor</em>, the number of elements divided by the number of buckets.
Containers also have a <em>maximum load factor</em> which they should try to keep the
load factor below.</p>
</div>
<div class="paragraph">
<p>You can&#8217;t control the bucket count directly but there are two ways to
influence it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify the minimum number of buckets when constructing a container or when calling <code>rehash</code>.</p>
</li>
<li>
<p>Suggest a maximum load factor by calling <code>max_load_factor</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>max_load_factor</code> doesn&#8217;t let you set the maximum load factor yourself, it just
lets you give a <em>hint</em>. And even then, the standard doesn&#8217;t actually
require the container to pay much attention to this value. The only time the
load factor is <em>required</em> to be less than the maximum is following a call to
<code>rehash</code>. But most implementations will try to keep the number of elements
below the max load factor, and set the maximum load factor to be the same as
or close to the hint - unless your hint is unreasonably small or large.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 3. Methods for Controlling Bucket Size</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>All containers</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(InputIterator i, InputIterator j, size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets and insert elements from the range <code>[i, j)</code> (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The average number of elements per bucket.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the current maximum load factor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor(float z)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.<br>
<strong>Open-addressing containers:</strong> this function does nothing: users are not allowed to change the maximum load factor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rehash(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>Open-addressing and concurrent containers only</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type max_load() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the maximum number of allowed elements in the container before rehash.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A note on <code>max_load</code> for open-addressing and concurrent containers: the maximum load will be
(<code>max_load_factor() * bucket_count()</code>) right after <code>rehash</code> or on container creation, but may
slightly decrease when erasing elements in high-load situations. For instance, if we
have a <a href="#unordered_flat_map"><code>boost::unordered_flat_map</code></a> with <code>size()</code> almost
at <code>max_load()</code> level and then erase 1,000 elements, <code>max_load()</code> may decrease by around a
few dozen elements. This is done internally by Boost.Unordered in order
to keep its performance stable, and must be taken into account when planning for rehash-free insertions.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hash_equality"><a class="link" href="#hash_equality">Equality Predicates and Hash Functions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>While the associative containers use an ordering relation to specify how the
elements are stored, the unordered associative containers use an equality
predicate and a hash function. For example, <a href="#unordered_map">boost::unordered_map</a>
is declared as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
    <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">unordered_map</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The hash function comes first as you might want to change the hash function
but not the equality predicate. For example, if you wanted to use the
<a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash" target="_blank" rel="noopener">FNV-1a hash</a> you could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hash</span><span class="o">::</span><span class="n">fnv_1a</span><span class="o">&gt;</span>
    <span class="n">dictionary</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is an <a href="../../examples/fnv1.hpp" target="_blank" rel="noopener">implementation of FNV-1a</a> in the examples directory.</p>
</div>
<div class="paragraph">
<p>If you wish to use a different equality function, you will also need to use a matching hash function. For example, to implement a case insensitive dictionary you need to define a case insensitive equality predicate and hash function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">iequal_to</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">algorithm</span><span class="o">::</span><span class="n">iequals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">ihash</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">locale</span> <span class="n">locale</span><span class="p">;</span>

        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="n">it</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">locale</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which you can then use in a case insensitive dictionary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ihash</span><span class="p">,</span> <span class="n">iequal_to</span><span class="o">&gt;</span>
    <span class="n">idictionary</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simplified version of the example at
<a href="../../examples/case_insensitive.hpp" target="_blank" rel="noopener">/libs/unordered/examples/case_insensitive.hpp</a> which supports other locales and string types.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Be careful when using the equality (<code>==</code>) operator with custom equality
predicates, especially if you&#8217;re using a function pointer. If you compare two
containers with different equality predicates then the result is undefined.
For most stateless function objects this is impossible - since you can only
compare objects with the same equality predicate you know the equality
predicates must be equal. But if you&#8217;re using function pointers or a stateful
equality predicate (e.g. <code>boost::function</code>) then you can get into trouble.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="hash_equality_custom_types"><a class="link" href="#hash_equality_custom_types">Custom Types</a></h3>
<div class="paragraph">
<p>Similarly, a custom hash function can be used for custom types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">point_hash</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">boost</span><span class="o">::</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">point</span><span class="p">,</span> <span class="n">point_hash</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the default hash function is <a href="../../../container_hash/index.html" target="_blank" rel="noopener">Boost.Hash</a>,
we can extend it to support the type so that the hash function doesn&#8217;t need to be explicitly given:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">hash_value</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Now the default function objects work.</span>
<span class="n">boost</span><span class="o">::</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="../../../container_hash/index.html" target="_blank" rel="noopener">Boost.Hash documentation</a> for more detail on how to
do this. Remember that it relies on extensions to the standard - so it
won&#8217;t work for other implementations of the unordered associative containers,
you&#8217;ll need to explicitly use Boost.Hash.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 4 Methods for accessing the hash and equality functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-middle">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasher hash_function() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the container&#8217;s hash function.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>key_equal key_eq() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the container&#8217;s key equality function..</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="regular"><a class="link" href="#regular">Regular Containers</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Boost.Unordered closed-addressing containers (<code>boost::unordered_set</code>, <code>boost::unordered_map</code>,
<code>boost::unordered_multiset</code> and <code>boost::unordered_multimap</code>) are fully conformant with the
C++ specification for unordered associative containers, so for those who know how to use
<code>std::unordered_set</code>, <code>std::unordered_map</code>, etc., their homonyms in Boost.Unordered are
drop-in replacements. The interface of open-addressing containers (<code>boost::unordered_node_set</code>,
<code>boost::unordered_node_map</code>, <code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>)
is very similar, but they present some minor differences listed in the dedicated
<a href="#compliance_open_addressing_containers">standard compliance section</a>.</p>
</div>
<div class="paragraph">
<p>For readers without previous experience with hash containers but familiar
with normal associative containers (<code>std::set</code>, <code>std::map</code>,
<code>std::multiset</code> and <code>std::multimap</code>), Boost.Unordered containers are used in a similar manner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
<span class="n">map</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"one"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"two"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"three"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"missing"</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But since the elements aren&#8217;t ordered, the output of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">map</span><span class="o">::</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">i</span><span class="o">:</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">","</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>can be in any order. For example, it might be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">two</span><span class="p">,</span><span class="mi">2</span>
<span class="n">one</span><span class="p">,</span><span class="mi">1</span>
<span class="n">three</span><span class="p">,</span><span class="mi">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other differences, which are listed in the
<a href="#comparison">Comparison with Associative Containers</a> section.</p>
</div>
<div class="sect2">
<h3 id="regular_iterator_invalidation"><a class="link" href="#regular_iterator_invalidation">Iterator Invalidation</a></h3>
<div class="paragraph">
<p>It is not specified how member functions other than <code>rehash</code> and <code>reserve</code> affect
the bucket count, although <code>insert</code> can only invalidate iterators
when the insertion causes the container&#8217;s load to be greater than the maximum allowed.
For most implementations this means that <code>insert</code> will only
change the number of buckets when this happens. Iterators can be
invalidated by calls to <code>insert</code>, <code>rehash</code> and <code>reserve</code>.</p>
</div>
<div class="paragraph">
<p>As for pointers and references,
they are never invalidated for node-based containers
(<code>boost::unordered_[multi]set</code>, <code>boost::unordered_[multi]map</code>, <code>boost::unordered_node_set</code>, <code>boost::unordered_node_map</code>),
but they will be when rehashing occurs for
<code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>: this is because
these containers store elements directly into their holding buckets, so
when allocating a new bucket array the elements must be transferred by means of move construction.</p>
</div>
<div class="paragraph">
<p>In a similar manner to using <code>reserve</code> for <code>vector</code>s, it can be a good idea
to call <code>reserve</code> before inserting a large number of elements. This will get
the expensive rehashing out of the way and let you store iterators, safe in
the knowledge that they won&#8217;t be invalidated. If you are inserting <code>n</code>
elements into container <code>x</code>, you could first call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">x</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Note</dt>
<dd>
<p><code>reserve(n)</code> reserves space for at least <code>n</code> elements, allocating enough buckets
so as to not exceed the maximum load factor.</p>
<div class="paragraph">
<p>Because the maximum load factor is defined as the number of elements divided by the total
number of available buckets, this function is logically equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">x</span><span class="p">.</span><span class="n">rehash</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">x</span><span class="p">.</span><span class="n">max_load_factor</span><span class="p">()))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#unordered_map_rehash">reference for more details</a> on the <code>rehash</code> function.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="comparison"><a class="link" href="#comparison">Comparison with Associative Containers</a></h3>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 5 Interface differences</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Associative Containers</th>
<th class="tableblock halign-left valign-top">Unordered Associative Containers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameterized by an ordering relation <code>Compare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameterized by a function object <code>Hash</code> and an equivalence relation <code>Pred</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys can be compared using <code>key_compare</code> which is accessed by member function <code>key_comp()</code>, values can be compared using <code>value_compare</code> which is accessed by member function <code>value_comp()</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys can be hashed using <code>hasher</code> which is accessed by member function <code>hash_function()</code>, and checked for equality using <code>key_equal</code> which is accessed by member function <code>key_eq()</code>. There is no function object for compared or hashing values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructors have optional extra parameters for the comparison object.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructors have optional extra parameters for the initial minimum number of buckets, a hash function and an equality object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys <code>k1</code>, <code>k2</code> are considered equivalent if <code>!Compare(k1, k2) &amp;&amp; !Compare(k2, k1)</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys <code>k1</code>, <code>k2</code> are considered equivalent if <code>Pred(k1, k2)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Member function <code>lower_bound(k)</code> and <code>upper_bound(k)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No equivalent. Since the elements aren&#8217;t ordered <code>lower_bound</code> and <code>upper_bound</code> would be meaningless.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code> returns an empty range at the position that <code>k</code> would be inserted if <code>k</code> isn&#8217;t present in the container.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code> returns a range at the end of the container if <code>k</code> isn&#8217;t present in the container. It can&#8217;t return a positioned range as <code>k</code> could be inserted into multiple place.<br>
<strong>Closed-addressing containers:</strong> To find out the bucket that <code>k</code> would be inserted into use <code>bucket(k)</code>. But remember that an insert can cause the container to rehash - meaning that the element can be inserted into a different bucket.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iterator</code>, <code>const_iterator</code> are of the bidirectional category.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iterator</code>, <code>const_iterator</code> are of at least the forward category.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators, pointers and references to the container&#8217;s elements are never invalidated.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#regular_iterator_invalidation">Iterators can be invalidated by calls to insert or rehash</a>.<br>
<strong>Node-based containers:</strong> Pointers and references to the container&#8217;s elements are never invalidated.<br>
<strong>Flat containers:</strong> Pointers and references to the container&#8217;s elements are invalidated when rehashing occurs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators iterate through the container in the order defined by the comparison object.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators iterate through the container in an arbitrary order, that can change as elements are inserted, although equivalent elements are always adjacent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">No equivalent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Closed-addressing containers:</strong> Local iterators can be used to iterate through individual buckets. (The order of local iterators and iterators aren&#8217;t required to have any correspondence.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can be compared using the <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> operators.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can be compared using the <code>==</code> and <code>!=</code> operators.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When inserting with a hint, implementations are permitted to ignore the hint.</p></td>
</tr>
</tbody>
</table>
<hr>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 6 Complexity Guarantees</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operation</th>
<th class="tableblock halign-left valign-top">Associative Containers</th>
<th class="tableblock halign-left valign-top">Unordered Associative Containers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Construction of empty container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<em>n</em>) where <em>n</em> is the minimum number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Construction of container from a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<em>N log N</em>), O(<em>N</em>) if the range is sorted with <code>value_comp()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case O(<em>N</em>), worst case O(<em>N<sup>2</sup></em>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Insert a single element</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case constant, worst case linear</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Insert a single element with a hint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amortized constant if <code>t</code> elements inserted right after hint, logarithmic otherwise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case constant, worst case linear (ie. the same as a normal insert).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inserting a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N</em> log(<code>size()</code> + <em>N</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case O(<em>N</em>), worst case O(<em>N</em> * <code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase by key, <code>k</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <code>count(k)</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<code>count(k)</code>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase a single element by iterator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amortized constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <em>N</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<em>N</em>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clearing the container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<code>size()</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Find</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <code>count(k)</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<code>count(k)</code>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lower_bound</code>,<code>upper_bound</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent"><a class="link" href="#concurrent">Concurrent Containers</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Boost.Unordered provides <code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code>,
hash tables that allow concurrent write/read access from
different threads without having to implement any synchronzation mechanism on the user&#8217;s side.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>                    <span class="n">input</span><span class="p">;</span>
<span class="n">boost</span><span class="o">::</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// process input in parallel</span>
<span class="k">const</span> <span class="kt">int</span>                 <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">jthread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>               <span class="n">chunk</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span> <span class="c1">// how many elements per thread</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// calculate the portion of input this thread takes care of</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">chunk</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span> <span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">m</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">calculation</span><span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">n</span><span class="p">]));</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, threads access <code>m</code> without synchronization, just as we&#8217;d do in a
single-threaded scenario. In an ideal setting, if a given workload is distributed among
<em>N</em> threads, execution is <em>N</em> times faster than with one thread this limit is
never attained in practice due to synchronization overheads and <em>contention</em> (one thread
waiting for another to leave a locked portion of the map), but Boost.Unordered concurrent containers
are designed to perform with very little overhead and typically achieve <em>linear scaling</em>
(that is, performance is proportional to the number of threads up to the number of
logical cores in the CPU).</p>
</div>
<div class="sect2">
<h3 id="concurrent_visitation_based_api"><a class="link" href="#concurrent_visitation_based_api">Visitation-based API</a></h3>
<div class="paragraph">
<p>The first thing a new user of <code>boost::concurrent_flat_set</code> or <code>boost::concurrent_flat_map</code>
will notice is that these classes <em>do not provide iterators</em> (which makes them technically
not <a href="https://en.cppreference.com/w/cpp/named_req/Container" target="_blank" rel="noopener">Containers</a>
in the C++ standard sense). The reason for this is that iterators are inherently
thread-unsafe. Consider this hypothetical code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>  <span class="c1">// A: get an iterator pointing to the element with key k</span>
<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">some_function</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span> <span class="c1">// B: use the value of the element</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In a multithreaded scenario, the iterator <code>it</code> may be invalid at point B if some other
thread issues an <code>m.erase(k)</code> operation between A and B. There are designs that
can remedy this by making iterators lock the element they point to, but this
approach lends itself to high contention and can easily produce deadlocks in a program.
<code>operator[]</code> has similar concurrency issues, and is not provided by
<code>boost::concurrent_flat_map</code> either. Instead, element access is done through
so-called <em>visitation functions</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// x is the element with key k (if it exists)</span>
  <span class="n">some_function</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>            <span class="c1">// use it</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The visitation function passed by the user (in this case, a lambda function)
is executed internally by Boost.Unordered in
a thread-safe manner, so it can access the element without worrying about other
threads interfering in the process.</p>
</div>
<div class="paragraph">
<p>On the other hand, a visitation function can <em>not</em> access the container itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">some_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// forbidden: m can't be accessed inside visitation</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Access to a different container is allowed, though:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">some_function</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">m2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// OK, m2 is a different boost::concurrent_flat_map</span>
  <span class="p">}</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But, in general, visitation functions should be as lightweight as possible to
reduce contention and increase parallelization. In some cases, moving heavy work
outside of visitation may be beneficial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">o</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">o</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">});</span>
<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">some_heavy_duty_function</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Visitation is prominent in the API provided by <code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code>, and
many classical operations have visitation-enabled variations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">insert_or_visit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// if insertion failed because of an equivalent element y,</span>
  <span class="c1">// do something with it, for instance:</span>
  <span class="o">++</span><span class="n">y</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="c1">// increment the mapped part of the element</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in this last example the visitation function could actually <em>modify</em>
the element: as a general rule, operations on a <code>boost::concurrent_flat_map</code> <code>m</code>
will grant visitation functions const/non-const access to  the element depending on whether
<code>m</code> is const/non-const. Const access can be always be explicitly requested
by using <code>cvisit</code> overloads (for instance, <code>insert_or_cvisit</code>) and may result
in higher parallelization. For <code>boost::concurrent_flat_set</code>, on the other hand,
visitation is always const access.
Consult the references of
<a href="#concurrent_flat_set"><code>boost::concurrent_flat_set</code></a> and
<a href="#concurrent_flat_map"><code>boost::concurrent_flat_map</code></a>
for the complete list of visitation-enabled operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="concurrent_whole_table_visitation"><a class="link" href="#concurrent_whole_table_visitation">Whole-Table Visitation</a></h3>
<div class="paragraph">
<p>In the absence of iterators, <code>visit_all</code> is provided
as an alternative way to process all the elements in the container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">visit_all</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// reset the mapped part of the element</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In C++17 compilers implementing standard parallel algorithms, whole-table
visitation can be parallelized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">visit_all</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// run in parallel</span>
  <span class="n">x</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// reset the mapped part of the element</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traversal can be interrupted midway:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// finds the key to a given (unique) value</span>

<span class="kt">int</span>  <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span>  <span class="n">value</span> <span class="o">=</span> <span class="p">...;</span>
<span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="o">!</span><span class="n">m</span><span class="p">.</span><span class="n">visit_while</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// finish</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// keep on visiting</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is one last whole-table visitation operation, <code>erase_if</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">erase_if</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// erase the elements whose mapped value is zero</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>visit_while</code> and <code>erase_if</code> can also be parallelized. Note that, in order to increase efficiency,
whole-table visitation operations do not block the table during execution: this implies that elements
may be inserted, modified or erased by other threads during visitation. It is
advisable not to assume too much about the exact global state of a concurrent container
at any point in your program.</p>
</div>
</div>
<div class="sect2">
<h3 id="concurrent_bulk_visitation"><a class="link" href="#concurrent_bulk_visitation">Bulk visitation</a></h3>
<div class="paragraph">
<p>Suppose you have an <code>std::array</code> of keys you want to look up for in a concurrent map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">:</span> <span class="n">keys</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Bulk visitation</em> allows us to pass all the keys in one operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">keys</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This functionality is not provided for mere syntactic convenience, though: by processing all the
keys at once, some internal optimizations can be applied that increase
performance over the regular, one-at-a-time case (consult the
<a href="#benchmarks_boostconcurrent_flat_map">benchmarks</a>). In fact, it may be beneficial
to buffer incoming keys so that they can be bulk visited in chunks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">bulk_visit_size</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">bulk_visit_size</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">bulk_visit_size</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>                      <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(...)</span> <span class="p">{</span> <span class="c1">// processing loop</span>
  <span class="p">...</span>
  <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">bulk_visit_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">map</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">buffer</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="c1">// flush remaining keys</span>
<span class="n">map</span><span class="p">.</span><span class="n">visit</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">buffer</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a latency/throughput tradeoff here: it will take longer for incoming keys to
be processed (since they are buffered), but the number of processed keys per second
is higher. <code>bulk_visit_size</code> is the recommended chunk size smaller buffers
may yield worse performance.</p>
</div>
</div>
<div class="sect2">
<h3 id="concurrent_blocking_operations"><a class="link" href="#concurrent_blocking_operations">Blocking Operations</a></h3>
<div class="paragraph">
<p><code>boost::concurrent_flat_set</code>s  and <code>boost::concurrent_flat_map</code>s can be copied, assigned, cleared and merged just like any
Boost.Unordered container. Unlike most other operations, these are <em>blocking</em>,
that is, all other threads are prevented from accesing the tables involved while a copy, assignment,
clear or merge operation is in progress. Blocking is taken care of automatically by the library
and the user need not take any special precaution, but overall performance may be affected.</p>
</div>
<div class="paragraph">
<p>Another blocking operation is <em>rehashing</em>, which happens explicitly via <code>rehash</code>/<code>reserve</code>
or during insertion when the table&#8217;s load hits <code>max_load()</code>. As with non-concurrent containers,
reserving space in advance of bulk insertions will generally speed up the process.</p>
</div>
</div>
<div class="sect2">
<h3 id="concurrent_interoperability_with_non_concurrent_containers"><a class="link" href="#concurrent_interoperability_with_non_concurrent_containers">Interoperability with non-concurrent containers</a></h3>
<div class="paragraph">
<p>As open-addressing and concurrent containers are based on the same internal data structure,
<code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code> can
be efficiently move-constructed from <code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code>,
respectively, and vice versa.
This interoperability comes handy in multistage scenarios where parts of the data processing happen
in parallel whereas other steps are non-concurrent (or non-modifying). In the following example,
we want to construct a histogram from a huge input vector of words:
the population phase can be done in parallel with <code>boost::concurrent_flat_map</code> and results
then transferred to the final container.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="p">...;</span>

<span class="c1">// Insert words in parallel</span>
<span class="n">boost</span><span class="o">::</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">m0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span>
  <span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
  <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m0</span><span class="p">.</span><span class="n">try_emplace_or_visit</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="o">++</span><span class="n">x</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">});</span>
  <span class="p">});</span>

<span class="c1">// Transfer to a regular unordered_flat_map</span>
<span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span> <span class="n">m</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m0</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="compliance"><a class="link" href="#compliance">Standard Compliance</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="compliance_closed_addressing_containers"><a class="link" href="#compliance_closed_addressing_containers">Closed-addressing Containers</a></h3>
<div class="paragraph">
<p><code>boost::unordered_[multi]set</code> and <code>boost::unordered_[multi]map</code> provide a conformant
implementation for C++11 (or later) compilers of the latest standard revision of
C++ unordered associative containers, with very minor deviations as noted.
The containers are fully <a href="https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer" target="_blank" rel="noopener">AllocatorAware</a>
and support <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers" target="_blank" rel="noopener">fancy pointers</a>.</p>
</div>
<div class="sect3">
<h4 id="compliance_deduction_guides"><a class="link" href="#compliance_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>Deduction guides for
<a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction" target="_blank" rel="noopener">class template argument deduction (CTAD)</a>
are only available on C++17 (or later) compilers.</p>
</div>
</div>
<div class="sect3">
<h4 id="compliance_piecewise_pair_emplacement"><a class="link" href="#compliance_piecewise_pair_emplacement">Piecewise Pair Emplacement</a></h4>
<div class="paragraph">
<p>In accordance with the standard specification,
<code>boost::unordered_[multi]map::emplace</code> supports piecewise pair construction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>

<span class="n">x</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="s">"key"</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, the same
functionality is provided via non-standard <code>boost::unordered::piecewise_construct</code>
and Boost.Tuple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">x</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">unordered</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="s">"key"</span><span class="p">),</span> <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This feature has been retained for backwards compatibility with
previous versions of Boost.Unordered: users are encouraged to
update their code to use <code>std::piecewise_construct</code> and
<code>std::tuple</code>s instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="compliance_swap"><a class="link" href="#compliance_swap">Swap</a></h4>
<div class="paragraph">
<p>When swapping, <code>Pred</code> and <code>Hash</code> are not currently swapped by calling
<code>swap</code>, their copy constructors are used. As a consequence, when swapping
an exception may be thrown from their copy constructor.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="compliance_open_addressing_containers"><a class="link" href="#compliance_open_addressing_containers">Open-addressing Containers</a></h3>
<div class="paragraph">
<p>The C++ standard does not currently provide any open-addressing container
specification to adhere to, so <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and
<code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> take inspiration from <code>std::unordered_set</code> and
<code>std::unordered_map</code>, respectively, and depart from their interface where
convenient or as dictated by their internal data structure, which is
radically different from that imposed by the standard (closed addressing).</p>
</div>
<div class="paragraph">
<p>Open-addressing containers provided by Boost.Unordered only work with reasonably
compliant C++11 (or later) compilers. Language-level features such as move semantics
and variadic template parameters are then not emulated.
The containers are fully <a href="https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer" target="_blank" rel="noopener">AllocatorAware</a>
and support <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers" target="_blank" rel="noopener">fancy pointers</a>.</p>
</div>
<div class="paragraph">
<p>The main differences with C++ unordered associative containers are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In general:</p>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> does not return an iterator to the following element, but
a proxy object that converts to that iterator if requested; this avoids
a potentially costly iterator increment operation when not needed.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user. The maximum load,
exposed through the public function <code>max_load</code>, may decrease on erasure under high-load conditions.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Flat containers (<code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>):</p>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p>There is no API for node extraction/insertion.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="compliance_concurrent_containers"><a class="link" href="#compliance_concurrent_containers">Concurrent Containers</a></h3>
<div class="paragraph">
<p>There is currently no specification in the C++ standard for this or any other type of concurrent
data structure. The APIs of <code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code>
are modelled after <code>std::unordered_flat_set</code> and <code>std::unordered_flat_map</code>, respectively,
with the crucial difference that iterators are not provided
due to their inherent problems in concurrent scenarios (high contention, prone to deadlocking):
so, Boost.Unordered concurrent containers are technically not models of
<a href="https://en.cppreference.com/w/cpp/named_req/Container" target="_blank" rel="noopener">Container</a>, although
they meet all the requirements of <a href="https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer" target="_blank" rel="noopener">AllocatorAware</a>
containers (including
<a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers" target="_blank" rel="noopener">fancy pointer</a> support)
except those implying iterators.</p>
</div>
<div class="paragraph">
<p>In a non-concurrent unordered container, iterators serve two main purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to an element previously located via lookup.</p>
</li>
<li>
<p>Container traversal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In place of iterators, <code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code> use <em>internal visitation</em>
facilities as a thread-safe substitute. Classical operations returning an iterator to an
element already existing in the container, like for instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>are transformed to accept a <em>visitation function</em> that is passed such element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="nf">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(In the second case <code>f</code> is only invoked if there&#8217;s an equivalent element
to <code>obj</code> in the table, not if insertion is successful). Container traversal
is served by:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="nf">visit_all</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>of which there are parallelized versions in C++17 compilers with parallel
algorithm support. In general, the interface of concurrent containers
is derived from that of their non-concurrent counterparts by a fairly straightforward
process of replacing iterators with visitation where applicable. If for
regular maps <code>iterator</code> and <code>const_iterator</code> provide mutable and const access to elements,
respectively, here visitation is granted mutable or const access depending on
the constness of the member function used (there are also <code>*cvisit</code> overloads for
explicit const visitation); In the case of <code>boost::concurrent_flat_set</code>, visitation is always const.</p>
</div>
<div class="paragraph">
<p>One notable operation not provided by <code>boost::concurrent_flat_map</code> is <code>operator[]</code>/<code>at</code>, which can be
replaced, if in a more convoluted manner, by
<a href="#concurrent_flat_map_try_emplace_or_cvisit"><code>try_emplace_or_visit</code></a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="structures"><a class="link" href="#structures">Data Structures</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="structures_closed_addressing_containers"><a class="link" href="#structures_closed_addressing_containers">Closed-addressing Containers</a></h3>
<style>
  .imageblock > .title {
    text-align: inherit;
  }
</style>
<div class="paragraph">
<p>Boost.Unordered sports one of the fastest implementations of closed addressing, also commonly known as <a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining">separate chaining</a>. An example figure representing the data structure is below:</p>
</div>
<div id="img-bucket-groups" class="imageblock text-center">
<div class="content">
<img src="../diagrams/bucket-groups.png" alt="bucket groups">
</div>
<div class="title">Figure 1. A simple bucket group approach</div>
</div>
<div class="paragraph">
<p>An array of "buckets" is allocated and each bucket in turn points to its own individual linked list. This makes meeting the standard requirements of bucket iteration straight-forward. Unfortunately, iteration of the entire container is often times slow using this layout as each bucket must be examined for occupancy, yielding a time complexity of <code>O(bucket_count() + size())</code> when the standard requires complexity to be <code>O(size())</code>.</p>
</div>
<div class="paragraph">
<p>Canonical standard implementations will wind up looking like the diagram below:</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<a class="image" href="../diagrams/singly-linked.png" target="_blank" rel="noopener"><img src="../diagrams/singly-linked.png" alt="singly linked"></a>
</div>
<div class="title">Figure 2. The canonical standard approach</div>
</div>
<div class="paragraph">
<p>It&#8217;s worth noting that this approach is only used by libc++ and libstdc++; the MSVC Dinkumware implementation uses a different one. A more detailed analysis of the standard containers can be found <a href="http://bannalia.blogspot.com/2013/10/implementation-of-c-unordered.html">here</a>.</p>
</div>
<div class="paragraph">
<p>This unusually laid out data structure is chosen to make iteration of the entire container efficient by inter-connecting all of the nodes into a singly-linked list. One might also notice that buckets point to the node <em>before</em> the start of the bucket&#8217;s elements. This is done so that removing elements from the list can be done efficiently without introducing the need for a doubly-linked list. Unfortunately, this data structure introduces a guaranteed extra indirection. For example, to access the first element of a bucket, something like this must be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="k">const</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_bucket_idx</span><span class="p">(</span><span class="n">hash_function</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="n">node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="c1">// first load</span>
<span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// second load</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">is_in_bucket</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="c1">// third load</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With a simple bucket group layout, this is all that must be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="k">const</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_bucket_idx</span><span class="p">(</span><span class="n">hash_function</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="c1">// first load</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="c1">// second load</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In practice, the extra indirection can have a dramatic performance impact to common operations such as <code>insert</code>, <code>find</code> and <code>erase</code>. But to keep iteration of the container fast, Boost.Unordered introduces a novel data structure, a "bucket group". A bucket group is a fixed-width view of a subsection of the buckets array. It contains a bitmask (a <code>std::size_t</code>) which it uses to track occupancy of buckets and contains two pointers so that it can form a doubly-linked list with non-empty groups. An example diagram is below:</p>
</div>
<div id="img-fca-layout" class="imageblock text-center">
<div class="content">
<img src="../diagrams/fca.png" alt="fca">
</div>
<div class="title">Figure 3. The new layout used by Boost</div>
</div>
<div class="paragraph">
<p>Thus container-wide iteration is turned into traversing the non-empty bucket groups (an operation with constant time complexity) which reduces the time complexity back to <code>O(size())</code>. In total, a bucket group is only 4 words in size and it views <code>sizeof(std::size_t) * CHAR_BIT</code> buckets meaning that for all common implementations, there&#8217;s only 4 bits of space overhead per bucket introduced by the bucket groups.</p>
</div>
<div class="paragraph">
<p>A more detailed description of Boost.Unordered&#8217;s closed-addressing implementation is
given in an
<a href="https://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html">external article</a>.
For more information on implementation rationale, read the
<a href="#rationale_closed_addressing_containers">corresponding section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="structures_open_addressing_containers"><a class="link" href="#structures_open_addressing_containers">Open-addressing Containers</a></h3>
<div class="paragraph">
<p>The diagram shows the basic internal layout of <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and
<code>boost:unordered_flat_map</code>/<code>unordered_node_map</code>.</p>
</div>
<div id="img-foa-layout" class="imageblock text-center">
<div class="content">
<img src="../diagrams/foa.png" alt="foa">
</div>
<div class="title">Figure 4. Open-addressing layout used by Boost.Unordered.</div>
</div>
<div class="paragraph">
<p>As with all open-addressing containers, elements (or pointers to the element nodes in the case of
<code>boost::unordered_node_set</code> and <code>boost::unordered_node_map</code>) are stored directly in the bucket array.
This array is logically divided into 2<sup><em>n</em></sup> <em>groups</em> of 15 elements each.
In addition to the bucket array, there is an associated <em>metadata array</em> with 2<sup><em>n</em></sup>
16-byte words.</p>
</div>
<div id="img-foa-metadata" class="imageblock text-center">
<div class="content">
<img src="../diagrams/foa-metadata.png" alt="foa metadata">
</div>
<div class="title">Figure 5. Breakdown of a metadata word.</div>
</div>
<div class="paragraph">
<p>A metadata word is divided into 15 <em>h</em><sub><em>i</em></sub> bytes (one for each associated
bucket), and an <em>overflow byte</em> (<em>ofw</em> in the diagram). The value of <em>h</em><sub><em>i</em></sub> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 if the corresponding bucket is empty.</p>
</li>
<li>
<p>1 to encode a special empty bucket called a <em>sentinel</em>, which is used internally to
stop iteration when the container has been fully traversed.</p>
</li>
<li>
<p>If the bucket is occupied, a <em>reduced hash value</em> obtained from the hash value of
the element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When looking for an element with hash value <em>h</em>, SIMD technologies such as
<a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> and
<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(Neon)">Neon</a> allow us
to very quickly inspect the full metadata word and look for the reduced value of <em>h</em> among all the
15 buckets with just a handful of CPU instructions: non-matching buckets can be
readily discarded, and those whose reduced hash value matches need be inspected via full
comparison with the corresponding element. If the looked-for element is not present,
the overflow byte is inspected:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the bit in the position <em>h</em> mod 8 is zero, lookup terminates (and the
element is not present).</p>
</li>
<li>
<p>If the bit is set to 1 (the group has been <em>overflowed</em>), further groups are
checked using <a href="https://en.wikipedia.org/wiki/Quadratic_probing"><em>quadratic probing</em></a>, and
the process is repeated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Insertion is algorithmically similar: empty buckets are located using SIMD,
and when going past a full group its corresponding overflow bit is set to 1.</p>
</div>
<div class="paragraph">
<p>In architectures without SIMD support, the logical layout stays the same, but the metadata
word is codified using a technique we call <em>bit interleaving</em>: this layout allows us
to emulate SIMD with reasonably good performance using only standard arithmetic and
logical operations.</p>
</div>
<div id="img-foa-metadata-interleaving" class="imageblock text-center">
<div class="content">
<img src="../diagrams/foa-metadata-interleaving.png" alt="foa metadata interleaving">
</div>
<div class="title">Figure 6. Bit-interleaved metadata word.</div>
</div>
<div class="paragraph">
<p>A more detailed description of Boost.Unordered&#8217;s open-addressing implementation is
given in an
<a href="https://bannalia.blogspot.com/2022/11/inside-boostunorderedflatmap.html">external article</a>.
For more information on implementation rationale, read the
<a href="#rationale_open_addresing_containers">corresponding section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="structures_concurrent_containers"><a class="link" href="#structures_concurrent_containers">Concurrent Containers</a></h3>
<div class="paragraph">
<p><code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code> use the basic
<a href="#structures_open_addressing_containers">open-addressing layout</a> described above
augmented with synchronization mechanisms.</p>
</div>
<div id="img-cfoa-layout" class="imageblock text-center">
<div class="content">
<img src="../diagrams/cfoa.png" alt="cfoa">
</div>
<div class="title">Figure 7. Concurrent open-addressing layout used by Boost.Unordered.</div>
</div>
<div class="paragraph">
<p>Two levels of synchronization are used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Container level: A read-write mutex is used to control access from any operation
to the container. Typically, such access is in read mode (that is, concurrent) even
for modifying operations, so for most practical purposes there is no thread
contention at this level. Access is only in write mode (blocking) when rehashing or
performing container-wide operations such as swapping or assignment.</p>
</li>
<li>
<p>Group level: Each 15-slot group is equipped with an 8-byte word containing:</p>
<div class="ulist">
<ul>
<li>
<p>A read-write spinlock for synchronized access to any element in the group.</p>
</li>
<li>
<p>An atomic <em>insertion counter</em> used for optimistic insertion as described
below.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>By using atomic operations to access the group metadata, lookup is (group-level)
lock-free up to the point where an actual comparison needs to be done with an element
that has been previously SIMD-matched: only then is the group&#8217;s spinlock used.</p>
</div>
<div class="paragraph">
<p>Insertion uses the following <em>optimistic algorithm</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The value of the insertion counter for the initial group in the probe
sequence is locally recorded (let&#8217;s call this value <code>c0</code>).</p>
</li>
<li>
<p>Lookup is as described above. If lookup finds no equivalent element,
search for an available slot for insertion successively locks/unlocks
each group in the probing sequence.</p>
</li>
<li>
<p>When an available slot is located, it is preemptively occupied (its
reduced hash value is set) and the insertion counter is atomically
incremented: if no other thread has incremented the counter during the
whole operation (which is checked by comparing with <code>c0</code>), then we&#8217;re
good to go and complete the insertion, otherwise we roll back and start
over.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This algorithm has very low contention both at the lookup and actual
insertion phases in exchange for the possibility that computations have
to be started over if some other thread interferes in the process by
performing a succesful insertion beginning at the same group. In
practice, the start-over frequency is extremely small, measured in the range
of parts per million for some of our benchmarks.</p>
</div>
<div class="paragraph">
<p>For more information on implementation rationale, read the
<a href="#rationale_concurrent_containers">corresponding section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="benchmarks"><a class="link" href="#benchmarks">Benchmarks</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="benchmarks_boostunordered_multiset"><a class="link" href="#benchmarks_boostunordered_multiset">boost::unordered_[multi]set</a></h3>
<div class="paragraph">
<p>All benchmarks were created using <code>unordered_set&lt;unsigned int&gt;</code> (non-duplicate) and <code>unordered_multiset&lt;unsigned int&gt;</code> (duplicate). The source code can be <a href="https://github.com/boostorg/boost_unordered_benchmarks/tree/boost_unordered_set" target="_blank" rel="noopener">found here</a>.</p>
</div>
<div class="paragraph">
<p>The insertion benchmarks insert <code>n</code> random values, where <code>n</code> is between 10,000 and 3 million. For the duplicated benchmarks, the same random values are repeated an average of 5 times.</p>
</div>
<div class="paragraph">
<p>The erasure benchmarks erase all <code>n</code> elements randomly until the container is empty. Erasure by key uses <code>erase(const key_type&amp;)</code> to remove entire groups of equivalent elements in each operation.</p>
</div>
<div class="paragraph">
<p>The successful lookup benchmarks are done by looking up all <code>n</code> values, in their original insertion order.</p>
</div>
<div class="paragraph">
<p>The unsuccessful lookup benchmarks use <code>n</code> randomly generated integers but using a different seed value.</p>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_12_libstdc_v3_x64"><a class="link" href="#benchmarks_gcc_12_libstdc_v3_x64">GCC 12 + libstdc++-v3, x64</a></h4>
<div class="sect4">
<h5 id="benchmarks_insertion"><a class="link" href="#benchmarks_insertion">Insertion</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running insertion.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice.png" alt="running insertion.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20non-unique.png" alt="running%20insertion.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20non-unique%205.png" alt="running%20insertion.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice norehash.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20norehash.png" alt="running%20insertion.xlsx.practice norehash" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice norehash non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20norehash%20non-unique.png" alt="running%20insertion.xlsx.practice norehash non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice norehash non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20norehash%20non-unique%205.png" alt="running%20insertion.xlsx.practice norehash non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5,<br>
prior <code>reserve</code></p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_erasure"><a class="link" href="#benchmarks_erasure">Erasure</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice.png" alt="scattered%20erasure.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice%20non-unique.png" alt="scattered%20erasure.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure%20by%20key.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure%20by%20key.xlsx.practice%20non-unique.png" alt="scattered%20erasure%20by%20key.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure%20by%20key.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure%20by%20key.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure%20by%20key.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"></div></td>
<th class="tableblock halign-center valign-middle"><p class="tableblock">by key, duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">by key, duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_successful_lookup"><a class="link" href="#benchmarks_successful_lookup">Successful Lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice.png" alt="scattered%20successful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20successful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20successful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_unsuccessful_lookup"><a class="link" href="#benchmarks_unsuccessful_lookup">Unsuccessful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_15_libc_x64"><a class="link" href="#benchmarks_clang_15_libc_x64">Clang 15 + libc++, x64</a></h4>
<div class="sect4">
<h5 id="benchmarks_insertion_2"><a class="link" href="#benchmarks_insertion_2">Insertion</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice.png" alt="running%20insertion.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20non-unique.png" alt="running%20insertion.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20non-unique%205.png" alt="running%20insertion.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice norehash.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20norehash.png" alt="running%20insertion.xlsx.practice norehash" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice norehash non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20norehash%20non-unique.png" alt="running%20insertion.xlsx.practice norehash non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice norehash non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20norehash%20non-unique%205.png" alt="running%20insertion.xlsx.practice norehash non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5,<br>
prior <code>reserve</code></p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_erasure_2"><a class="link" href="#benchmarks_erasure_2">Erasure</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice.png" alt="scattered%20erasure.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice%20non-unique.png" alt="scattered%20erasure.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure%20by%20key.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure%20by%20key.xlsx.practice%20non-unique.png" alt="scattered%20erasure%20by%20key.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure%20by%20key.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure%20by%20key.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure%20by%20key.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"></div></td>
<th class="tableblock halign-center valign-middle"><p class="tableblock">by key, duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">by key, duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_successful_lookup_2"><a class="link" href="#benchmarks_successful_lookup_2">Successful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice.png" alt="scattered%20successful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20successful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20successful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_unsuccessful_lookup_2"><a class="link" href="#benchmarks_unsuccessful_lookup_2">Unsuccessful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2022_dinkumware_x64"><a class="link" href="#benchmarks_visual_studio_2022_dinkumware_x64">Visual Studio 2022 + Dinkumware, x64</a></h4>
<div class="sect4">
<h5 id="benchmarks_insertion_3"><a class="link" href="#benchmarks_insertion_3">Insertion</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice.png" alt="running%20insertion.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20non-unique.png" alt="running%20insertion.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20non-unique%205.png" alt="running%20insertion.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice norehash.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20norehash.png" alt="running%20insertion.xlsx.practice norehash" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice norehash non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20norehash%20non-unique.png" alt="running%20insertion.xlsx.practice norehash non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice norehash non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20norehash%20non-unique%205.png" alt="running%20insertion.xlsx.practice norehash non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5,<br>
prior <code>reserve</code></p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_erasure_3"><a class="link" href="#benchmarks_erasure_3">Erasure</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice.png" alt="scattered%20erasure.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice%20non-unique.png" alt="scattered%20erasure.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure%20by%20key.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure%20by%20key.xlsx.practice%20non-unique.png" alt="scattered%20erasure%20by%20key.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure%20by%20key.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure%20by%20key.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure%20by%20key.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"></div></td>
<th class="tableblock halign-center valign-middle"><p class="tableblock">by key, duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">by key, duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_successful_lookup_3"><a class="link" href="#benchmarks_successful_lookup_3">Successful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice.png" alt="scattered%20successful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20successful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20successful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_unsuccessful_lookup_3"><a class="link" href="#benchmarks_unsuccessful_lookup_3">Unsuccessful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="benchmarks_boostunordered_flatnode_map"><a class="link" href="#benchmarks_boostunordered_flatnode_map">boost::unordered_(flat|node)_map</a></h3>
<div class="paragraph">
<p>All benchmarks were created using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://abseil.io/docs/cpp/guides/container" target="_blank" rel="noopener">absl::flat_hash_map</a>&lt;uint64_t, uint64_t&gt;</code></p>
</li>
<li>
<p><code>boost::unordered_map&lt;uint64_t, uint64_t&gt;</code></p>
</li>
<li>
<p><code>boost::unordered_flat_map&lt;uint64_t, uint64_t&gt;</code></p>
</li>
<li>
<p><code>boost::unordered_node_map&lt;uint64_t, uint64_t&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The source code can be <a href="https://github.com/boostorg/boost_unordered_benchmarks/tree/boost_unordered_flat_map" target="_blank" rel="noopener">found here</a>.</p>
</div>
<div class="paragraph">
<p>The insertion benchmarks insert <code>n</code> random values, where <code>n</code> is between 10,000 and 10 million.</p>
</div>
<div class="paragraph">
<p>The erasure benchmarks erase traverse the <code>n</code> elements and erase those with odd key (50% on average).</p>
</div>
<div class="paragraph">
<p>The successful lookup benchmarks are done by looking up all <code>n</code> values, in their original insertion order.</p>
</div>
<div class="paragraph">
<p>The unsuccessful lookup benchmarks use <code>n</code> randomly generated integers but using a different seed value.</p>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_12_x64"><a class="link" href="#benchmarks_gcc_12_x64">GCC 12, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_15_x64"><a class="link" href="#benchmarks_clang_15_x64">Clang 15, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2022_x64"><a class="link" href="#benchmarks_visual_studio_2022_x64">Visual Studio 2022, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_12_arm64"><a class="link" href="#benchmarks_clang_12_arm64">Clang 12, ARM64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_12_x86"><a class="link" href="#benchmarks_gcc_12_x86">GCC 12, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_15_x86"><a class="link" href="#benchmarks_clang_15_x86">Clang 15, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2022_x86"><a class="link" href="#benchmarks_visual_studio_2022_x86">Visual Studio 2022, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="benchmarks_boostconcurrent_flat_map"><a class="link" href="#benchmarks_boostconcurrent_flat_map">boost::concurrent_flat_map</a></h3>
<div class="paragraph">
<p>All benchmarks were created using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://spec.oneapi.io/versions/latest/elements/oneTBB/source/containers/concurrent_hash_map_cls.html" target="_blank" rel="noopener">oneapi::tbb::concurrent_hash_map</a>&lt;int, int&gt;</code></p>
</li>
<li>
<p><code><a href="https://github.com/greg7mdp/gtl/blob/main/docs/phmap.md" target="_blank" rel="noopener">gtl::parallel_flat_hash_map</a>&lt;int, int&gt;</code> with 64 submaps</p>
</li>
<li>
<p><code>boost::concurrent_flat_map&lt;int, int&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The source code can be <a href="https://github.com/boostorg/boost_unordered_benchmarks/tree/boost_concurrent_flat_map" target="_blank" rel="noopener">found here</a>.</p>
</div>
<div class="paragraph">
<p>The benchmarks exercise a number of threads <em>T</em> (between 1 and 16) concurrently performing operations
randomly chosen among <strong>update</strong>, <strong>successful lookup</strong> and <strong>unsuccessful lookup</strong>. The keys used in the
operations follow a <a href="https://en.wikipedia.org/wiki/Zipf%27s_law#Formal_definition" target="_blank" rel="noopener">Zipf distribution</a>
with different <em>skew</em> parameters: the higher the skew, the more concentrated are the keys in the lower values
of the covered range.</p>
</div>
<div class="paragraph">
<p><code>boost::concurrent_flat_map</code> is exercised using both regular and <a href="#concurrent_bulk_visitation">bulk visitation</a>:
in the latter case, lookup keys are buffered in a local array and then processed at
once each time the buffer reaches <a href="#concurrent_flat_map_constants"><code>bulk_visit_size</code></a>.</p>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_12_x64_2"><a class="link" href="#benchmarks_gcc_12_x64_2">GCC 12, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.500k%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.500k%2C%200.01.png" alt="Parallel%20workload.xlsx.500k%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.500k%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.500k%2C%200.5.png" alt="Parallel%20workload.xlsx.500k%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.500k%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.500k%2C%200.99.png" alt="Parallel%20workload.xlsx.500k%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.5M%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.5M%2C%200.01.png" alt="Parallel%20workload.xlsx.5M%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.5M%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.5M%2C%200.5.png" alt="Parallel%20workload.xlsx.5M%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.5M%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x64/Parallel%20workload.xlsx.5M%2C%200.99.png" alt="Parallel%20workload.xlsx.5M%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_15_x64_2"><a class="link" href="#benchmarks_clang_15_x64_2">Clang 15, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.500k%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.500k%2C%200.01.png" alt="Parallel%20workload.xlsx.500k%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.500k%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.500k%2C%200.5.png" alt="Parallel%20workload.xlsx.500k%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.500k%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.500k%2C%200.99.png" alt="Parallel%20workload.xlsx.500k%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.5M%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.5M%2C%200.01.png" alt="Parallel%20workload.xlsx.5M%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.5M%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.5M%2C%200.5.png" alt="Parallel%20workload.xlsx.5M%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.5M%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x64/Parallel%20workload.xlsx.5M%2C%200.99.png" alt="Parallel%20workload.xlsx.5M%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2022_x64_2"><a class="link" href="#benchmarks_visual_studio_2022_x64_2">Visual Studio 2022, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.500k%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.500k%2C%200.01.png" alt="Parallel%20workload.xlsx.500k%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.500k%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.500k%2C%200.5.png" alt="Parallel%20workload.xlsx.500k%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.500k%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.500k%2C%200.99.png" alt="Parallel%20workload.xlsx.500k%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.5M%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.5M%2C%200.01.png" alt="Parallel%20workload.xlsx.5M%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.5M%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.5M%2C%200.5.png" alt="Parallel%20workload.xlsx.5M%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.5M%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x64/Parallel%20workload.xlsx.5M%2C%200.99.png" alt="Parallel%20workload.xlsx.5M%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_12_arm64_2"><a class="link" href="#benchmarks_clang_12_arm64_2">Clang 12, ARM64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.500k%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.500k%2C%200.01.png" alt="Parallel%20workload.xlsx.500k%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.500k%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.500k%2C%200.5.png" alt="Parallel%20workload.xlsx.500k%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.500k%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.500k%2C%200.99.png" alt="Parallel%20workload.xlsx.500k%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.5M%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.5M%2C%200.01.png" alt="Parallel%20workload.xlsx.5M%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.5M%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.5M%2C%200.5.png" alt="Parallel%20workload.xlsx.5M%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.5M%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-arm64/Parallel%20workload.xlsx.5M%2C%200.99.png" alt="Parallel%20workload.xlsx.5M%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_12_x86_2"><a class="link" href="#benchmarks_gcc_12_x86_2">GCC 12, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.500k%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.500k%2C%200.01.png" alt="Parallel%20workload.xlsx.500k%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.500k%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.500k%2C%200.5.png" alt="Parallel%20workload.xlsx.500k%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.500k%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.500k%2C%200.99.png" alt="Parallel%20workload.xlsx.500k%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.5M%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.5M%2C%200.01.png" alt="Parallel%20workload.xlsx.5M%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.5M%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.5M%2C%200.5.png" alt="Parallel%20workload.xlsx.5M%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.5M%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/gcc-x86/Parallel%20workload.xlsx.5M%2C%200.99.png" alt="Parallel%20workload.xlsx.5M%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_15_x86_2"><a class="link" href="#benchmarks_clang_15_x86_2">Clang 15, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.500k%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.500k%2C%200.01.png" alt="Parallel%20workload.xlsx.500k%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.500k%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.500k%2C%200.5.png" alt="Parallel%20workload.xlsx.500k%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.500k%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.500k%2C%200.99.png" alt="Parallel%20workload.xlsx.500k%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.5M%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.5M%2C%200.01.png" alt="Parallel%20workload.xlsx.5M%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.5M%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.5M%2C%200.5.png" alt="Parallel%20workload.xlsx.5M%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.5M%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/clang-x86/Parallel%20workload.xlsx.5M%2C%200.99.png" alt="Parallel%20workload.xlsx.5M%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2022_x86_2"><a class="link" href="#benchmarks_visual_studio_2022_x86_2">Visual Studio 2022, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.500k%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.500k%2C%200.01.png" alt="Parallel%20workload.xlsx.500k%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.500k%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.500k%2C%200.5.png" alt="Parallel%20workload.xlsx.500k%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.500k%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.500k%2C%200.99.png" alt="Parallel%20workload.xlsx.500k%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">500k updates, 4.5M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.5M%2C%200.01.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.5M%2C%200.01.png" alt="Parallel%20workload.xlsx.5M%2C%200.01" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.5M%2C%200.5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.5M%2C%200.5.png" alt="Parallel%20workload.xlsx.5M%2C%200.5" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.5M%2C%200.99.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-concurrent_map/vs-x86/Parallel%20workload.xlsx.5M%2C%200.99.png" alt="Parallel%20workload.xlsx.5M%2C%200.99" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.01</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.5</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">5M updates, 45M lookups<br>
skew=0.99</p></th>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale"><a class="link" href="#rationale">Implementation Rationale</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="rationale_closed_addressing_containers"><a class="link" href="#rationale_closed_addressing_containers">Closed-addressing Containers</a></h3>
<div class="paragraph">
<p><code>boost::unordered_[multi]set</code> and <code>boost::unordered_[multi]map</code>
adhere to the standard requirements for unordered associative
containers, so the interface was fixed. But there are
still some implementation decisions to make. The priorities are
conformance to the standard and portability.</p>
</div>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Wikipedia article on hash tables</a>
has a good summary of the implementation issues for hash tables in general.</p>
</div>
<div class="sect3">
<h4 id="rationale_data_structure"><a class="link" href="#rationale_data_structure">Data Structure</a></h4>
<div class="paragraph">
<p>By specifying an interface for accessing the buckets of the container the
standard pretty much requires that the hash table uses closed addressing.</p>
</div>
<div class="paragraph">
<p>It would be conceivable to write a hash table that uses another method. For
example, it could use open addressing, and use the lookup chain to act as a
bucket but there are some serious problems with this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The standard requires that pointers to elements aren&#8217;t invalidated, so
the elements can&#8217;t be stored in one array, but will need a layer of
indirection instead - losing the efficiency and most of the memory gain,
the main advantages of open addressing.</p>
</li>
<li>
<p>Local iterators would be very inefficient and may not be able to
meet the complexity requirements.</p>
</li>
<li>
<p>There are also the restrictions on when iterators can be invalidated. Since
open addressing degrades badly when there are a high number of collisions the
restrictions could prevent a rehash when it&#8217;s really needed. The maximum load
factor could be set to a fairly low value to work around this - but the
standard requires that it is initially set to 1.0.</p>
</li>
<li>
<p>And since the standard is written with a eye towards closed
addressing, users will be surprised if the performance doesn&#8217;t reflect that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So closed addressing is used.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale_number_of_buckets"><a class="link" href="#rationale_number_of_buckets">Number of Buckets</a></h4>
<div class="paragraph">
<p>There are two popular methods for choosing the number of buckets in a hash
table. One is to have a prime number of buckets, another is to use a power
of 2.</p>
</div>
<div class="paragraph">
<p>Using a prime number of buckets, and choosing a bucket by using the modulus
of the hash function&#8217;s result will usually give a good result. The downside
is that the required modulus operation is fairly expensive. This is what the
containers used to do in most cases.</p>
</div>
<div class="paragraph">
<p>Using a power of 2 allows for much quicker selection of the bucket to use,
but at the expense of losing the upper bits of the hash value. For some
specially designed hash functions it is possible to do this and still get a
good result but as the containers can take arbitrary hash functions this can&#8217;t
be relied on.</p>
</div>
<div class="paragraph">
<p>To avoid this a transformation could be applied to the hash function, for an
example see
<a href="http://web.archive.org/web/20121102023700/http://www.concentric.net/~Ttwang/tech/inthash.htm" target="_blank" rel="noopener">Thomas Wang&#8217;s article on integer hash functions</a>.
Unfortunately, a transformation like Wang&#8217;s requires knowledge of the number
of bits in the hash value, so it was only used when <code>size_t</code> was 64 bit.</p>
</div>
<div class="paragraph">
<p>Since release 1.79.0, <a href="https://en.wikipedia.org/wiki/Hash_function#Fibonacci_hashing">Fibonacci hashing</a>
is used instead. With this implementation, the bucket number is determined
by using <code>(h * m) &gt;&gt; (w - k)</code>, where <code>h</code> is the hash value, <code>m</code> is <code>2^w</code> divided
by the golden ratio, <code>w</code> is the word size (32 or 64), and <code>2^k</code> is the
number of buckets. This provides a good compromise between speed and
distribution.</p>
</div>
<div class="paragraph">
<p>Since release 1.80.0, prime numbers are chosen for the number of buckets in
tandem with sophisticated modulo arithmetic. This removes the need for "mixing"
the result of the user&#8217;s hash function as was used for release 1.79.0.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rationale_open_addresing_containers"><a class="link" href="#rationale_open_addresing_containers">Open-addresing Containers</a></h3>
<div class="paragraph">
<p>The C++ standard specification of unordered associative containers impose
severe limitations on permissible implementations, the most important being
that closed addressing is implicitly assumed. Slightly relaxing this specification
opens up the possibility of providing container variations taking full
advantage of open-addressing techniques.</p>
</div>
<div class="paragraph">
<p>The design of <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> has been
guided by Peter Dimov&#8217;s <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a>.
We discuss here the most relevant principles.</p>
</div>
<div class="sect3">
<h4 id="rationale_hash_function"><a class="link" href="#rationale_hash_function">Hash Function</a></h4>
<div class="paragraph">
<p>Given its rich functionality and cross-platform interoperability,
<code>boost::hash</code> remains the default hash function of open-addressing containers.
As it happens, <code>boost::hash</code> for integral and other basic types does not possess
the statistical properties required by open addressing; to cope with this,
we implement a post-mixing stage:</p>
</div>
<div class="paragraph">
<p>&#160;&#160;&#160;&#160; <em>a</em> &#8592; <em>h</em> <strong>mulx</strong> <em>C</em>,<br>
&#160;&#160;&#160;&#160; <em>h</em> &#8592; <strong>high</strong>(<em>a</em>) <strong>xor</strong> <strong>low</strong>(<em>a</em>),</p>
</div>
<div class="paragraph">
<p>where <strong>mulx</strong> is an <em>extended multiplication</em> (128 bits in 64-bit architectures, 64 bits in 32-bit environments),
and <strong>high</strong> and <strong>low</strong> are the upper and lower halves of an extended word, respectively.
In 64-bit architectures, <em>C</em> is the integer part of 2<sup>64</sup>&#8725;<a href="https://en.wikipedia.org/wiki/Golden_ratio"><em>&phi;</em></a>,
whereas in 32 bits <em>C</em> = 0xE817FB2Du has been obtained from <a href="https://arxiv.org/abs/2001.05304" target="_blank" rel="noopener">Steele and Vigna (2021)</a>.</p>
</div>
<div class="paragraph">
<p>When using a hash function directly suitable for open addressing, post-mixing can be opted out by via a dedicated <a href="#hash_traits_hash_is_avalanching"><code>hash_is_avalanching</code></a>trait.
<code>boost::hash</code> specializations for string types are marked as avalanching.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale_platform_interoperability"><a class="link" href="#rationale_platform_interoperability">Platform Interoperability</a></h4>
<div class="paragraph">
<p>The observable behavior of <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> is deterministically
identical across different compilers as long as their <code>std::size_t</code>s are the same size and the user-provided
hash function and equality predicate are also interoperable
&#8212;this includes elements being ordered in exactly the same way for the same sequence of
operations.</p>
</div>
<div class="paragraph">
<p>Although the implementation internally uses SIMD technologies, such as <a href="https://en.wikipedia.org/wiki/SSE2" target="_blank" rel="noopener">SSE2</a>
and <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)" target="_blank" rel="noopener">Neon</a>, when available,
this does not affect interoperatility. For instance, the behavior is the same
for Visual Studio on an x64-mode Intel CPU with SSE2 and for GCC on an IBM s390x without any supported SIMD technology.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rationale_concurrent_containers"><a class="link" href="#rationale_concurrent_containers">Concurrent Containers</a></h3>
<div class="paragraph">
<p>The same data structure used by Boost.Unordered open-addressing containers has been chosen
also as the foundation of <code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Open-addressing is faster than closed-addressing alternatives, both in non-concurrent and
concurrent scenarios.</p>
</li>
<li>
<p>Open-addressing layouts are eminently suitable for concurrent access and modification
with minimal locking. In particular, the metadata array can be used for implementations of
lookup that are lock-free up to the last step of actual element comparison.</p>
</li>
<li>
<p>Layout compatibility with Boost.Unordered flat containers allows for
<a href="#concurrent_interoperability_with_non_concurrent_containers">fast transfer</a>
of all elements between <code>boost::concurrent_flat_map</code> and <code>boost::unordered_flat_map</code>,
and vice versa.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="rationale_hash_function_and_platform_interoperability"><a class="link" href="#rationale_hash_function_and_platform_interoperability">Hash Function and Platform Interoperability</a></h4>
<div class="paragraph">
<p>Concurrent containers make the same decisions and provide the same guarantees
as Boost.Unordered open-addressing containers with regards to
<a href="#rationale_hash_function">hash function defaults</a> and
<a href="#rationale_platform_interoperability">platform interoperability</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference"><a class="link" href="#reference">Reference</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="unordered_map"><a class="link" href="#unordered_map">Class Template unordered_map</a></h3>
<div class="paragraph">
<p><code>boost::unordered_map</code>  An unordered associative container that associates unique keys with another value.</p>
</div>
<div class="sect3">
<h4 id="unordered_map_synopsis"><a class="link" href="#unordered_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_map_default_constructor">unordered_map</a>();
    explicit <a href="#unordered_map_bucket_count_constructor">unordered_map</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor">unordered_map</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_copy_constructor">unordered_map</a>(const unordered_map&amp; other);
    <a href="#unordered_map_move_constructor">unordered_map</a>(unordered_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_allocator">unordered_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_map_allocator_constructor">unordered_map</a>(const Allocator&amp; a);
    <a href="#unordered_map_copy_constructor_with_allocator">unordered_map</a>(const unordered_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_move_constructor_with_allocator">unordered_map</a>(unordered_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_initializer_list_constructor">unordered_map</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_bucket_count_constructor_with_allocator">unordered_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator">unordered_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_map_destructor">~unordered_map</a>();
    unordered_map&amp; <a href="#unordered_map_copy_assignment">operator=</a>(const unordered_map&amp; other);
    unordered_map&amp; <a href="#unordered_map_move_assignment">operator=</a>(unordered_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_map&amp; <a href="#unordered_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator       <a href="#unordered_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_map_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    node_type <a href="#unordered_map_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_map_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_map_extract_by_key">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_map_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_map_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_map_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_map_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_map_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_map_swap">swap</a>(unordered_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_map_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_map_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_map_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_map_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_map_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_map_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_map_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_map_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash, Pred,
                       Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                  typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                  Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type,
                  Allocator)
      -&gt; unordered_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                  Allocator)
      -&gt; unordered_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_map_operator_2">operator==</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_map_operator_3">operator!=</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_map_swap_2">swap</a>(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_map_erase_if">erase_if</a>(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_description"><a class="link" href="#unordered_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_configuration_macros"><a class="link" href="#unordered_map_configuration_macros">Configuration macros</a></h4>
<div class="sect4">
<h5 id="unordered_map_boost_unordered_enable_serialization_compatibility_v0"><a class="link" href="#unordered_map_boost_unordered_enable_serialization_compatibility_v0"><code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code></a></h5>
<div class="paragraph">
<p>Globally define this macro to support loading of <code>unordered_map</code>s saved to
a Boost.Serialization archive with a version of Boost prior to Boost 1.84.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_typedefs"><a class="link" href="#unordered_map_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">NodeType</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc"><em>insert_return_type</em></span> <span class="c1">// name is exposition only</span>
<span class="p">{</span>
  <span class="n">Iterator</span> <span class="n">position</span><span class="p">;</span>
  <span class="kt">bool</span>     <span class="n">inserted</span><span class="p">;</span>
  <span class="n">NodeType</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_constructors"><a class="link" href="#unordered_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_map_default_constructor"><a class="link" href="#unordered_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor"><a class="link" href="#unordered_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor"><a class="link" href="#unordered_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_constructor"><a class="link" href="#unordered_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_constructor"><a class="link" href="#unordered_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_map_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_allocator_constructor"><a class="link" href="#unordered_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_constructor_with_allocator"><a class="link" href="#unordered_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_constructor_with_allocator"><a class="link" href="#unordered_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor"><a class="link" href="#unordered_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_destructor"><a class="link" href="#unordered_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_assignment"><a class="link" href="#unordered_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_map_copy_assignment"><a class="link" href="#unordered_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_assignment"><a class="link" href="#unordered_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_assignment"><a class="link" href="#unordered_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_iterators"><a class="link" href="#unordered_map_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_map_begin"><a class="link" href="#unordered_map_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_end"><a class="link" href="#unordered_map_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cbegin"><a class="link" href="#unordered_map_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cend"><a class="link" href="#unordered_map_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_size_and_capacity"><a class="link" href="#unordered_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_map_empty"><a class="link" href="#unordered_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_size"><a class="link" href="#unordered_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_size"><a class="link" href="#unordered_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_modifiers"><a class="link" href="#unordered_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_map_emplace"><a class="link" href="#unordered_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_hint"><a class="link" href="#unordered_map_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_insert"><a class="link" href="#unordered_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_insert"><a class="link" href="#unordered_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_insert"><a class="link" href="#unordered_map_emplace_insert">Emplace Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_insert_with_hint"><a class="link" href="#unordered_map_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_insert_with_hint"><a class="link" href="#unordered_map_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_insert_with_hint"><a class="link" href="#unordered_map_emplace_insert_with_hint">Emplace Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_iterator_range"><a class="link" href="#unordered_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_initializer_list"><a class="link" href="#unordered_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_try_emplace"><a class="link" href="#unordered_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace">emplace</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace">emplace</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_try_emplace_with_hint"><a class="link" href="#unordered_map_try_emplace_with_hint">try_emplace with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace_hint">emplace_hint</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace_hint">emplace_hint</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_or_assign"><a class="link" href="#unordered_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>std::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_or_assign_with_hint"><a class="link" href="#unordered_map_insert_or_assign_with_hint">insert_or_assign with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>std::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_extract_by_iterator"><a class="link" href="#unordered_map_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_extract_by_key"><a class="link" href="#unordered_map_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code>  overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_with_node_handle"><a class="link" href="#unordered_map_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_with_hint_and_node_handle"><a class="link" href="#unordered_map_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_by_position"><a class="link" href="#unordered_map_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_by_key"><a class="link" href="#unordered_map_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_range"><a class="link" href="#unordered_map_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_quick_erase"><a class="link" href="#unordered_map_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_return_void"><a class="link" href="#unordered_map_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_swap"><a class="link" href="#unordered_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_clear"><a class="link" href="#unordered_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_merge"><a class="link" href="#unordered_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_observers"><a class="link" href="#unordered_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_map_get_allocator"><a class="link" href="#unordered_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_hash_function"><a class="link" href="#unordered_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_key_eq"><a class="link" href="#unordered_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_lookup"><a class="link" href="#unordered_map_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_map_find"><a class="link" href="#unordered_map_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_count"><a class="link" href="#unordered_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_contains"><a class="link" href="#unordered_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_equal_range"><a class="link" href="#unordered_map_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_operator"><a class="link" href="#unordered_map_operator">operator[]</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an elements with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_at"><a class="link" href="#unordered_map_at">at</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket_interface"><a class="link" href="#unordered_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_map_bucket_count"><a class="link" href="#unordered_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_bucket_count"><a class="link" href="#unordered_map_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_size"><a class="link" href="#unordered_map_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket"><a class="link" href="#unordered_map_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_begin_2"><a class="link" href="#unordered_map_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_end_2"><a class="link" href="#unordered_map_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cbegin_2"><a class="link" href="#unordered_map_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cend_2"><a class="link" href="#unordered_map_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_hash_policy"><a class="link" href="#unordered_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_map_load_factor"><a class="link" href="#unordered_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_load_factor"><a class="link" href="#unordered_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_set_max_load_factor"><a class="link" href="#unordered_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_rehash"><a class="link" href="#unordered_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_reserve"><a class="link" href="#unordered_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_deduction_guides"><a class="link" href="#unordered_map_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_value_type"><a class="link" href="#unordered_map_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_key_type"><a class="link" href="#unordered_map_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_mapped_type"><a class="link" href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_to_alloc_type"><a class="link" href="#unordered_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_equality_comparisons"><a class="link" href="#unordered_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_map_operator_2"><a class="link" href="#unordered_map_operator_2">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_operator_3"><a class="link" href="#unordered_map_operator_3">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_swap_2"><a class="link" href="#unordered_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_erase_if"><a class="link" href="#unordered_map_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_serialization"><a class="link" href="#unordered_map_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_map</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_map_saving_an_unordered_map_to_an_archive"><a class="link" href="#unordered_map_saving_an_unordered_map_to_an_archive">Saving an unordered_map to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_map</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>std::remove_const&lt;key_type&gt;::type</code> and <code>std::remove_const&lt;mapped_type&gt;::type</code>
are serializable (XML serializable), and they do support Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_loading_an_unordered_map_from_an_archive"><a class="link" href="#unordered_map_loading_an_unordered_map_from_an_archive">Loading an unordered_map from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_map</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_map</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
from <code>(std::remove_const&lt;key_type&gt;::type&amp;&amp;, std::remove_const&lt;mapped_type&gt;::type&amp;&amp;)</code>.
<code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>If the archive was saved using a release of Boost prior to Boost 1.84,
the configuration macro <code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code>
has to be globally defined for this operation to succeed; otherwise, an exception is thrown.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_map_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_map</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_map_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_map</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap"><a class="link" href="#unordered_multimap">Class Template unordered_multimap</a></h3>
<div class="paragraph">
<p><code>boost::unordered_multimap</code>  An unordered associative container that associates keys with another value. The same key can be stored multiple times.</p>
</div>
<div class="sect3">
<h4 id="unordered_multimap_synopsis"><a class="link" href="#unordered_multimap_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_multimap {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multimap_default_constructor">unordered_multimap</a>();
    explicit <a href="#unordered_multimap_bucket_count_constructor">unordered_multimap</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor">unordered_multimap</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_copy_constructor">unordered_multimap</a>(const unordered_multimap&amp; other);
    <a href="#unordered_multimap_move_constructor">unordered_multimap</a>(unordered_multimap&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_allocator">unordered_multimap</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_multimap_allocator_constructor">unordered_multimap</a>(const Allocator&amp; a);
    <a href="#unordered_multimap_copy_constructor_with_allocator">unordered_multimap</a>(const unordered_multimap&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_move_constructor_with_allocator">unordered_multimap</a>(unordered_multimap&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_bucket_count_constructor_with_allocator">unordered_multimap</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator">unordered_multimap</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multimap_destructor">~unordered_multimap</a>();
    unordered_multimap&amp; <a href="#unordered_multimap_copy_assignment">operator=</a>(const unordered_multimap&amp; other);
    unordered_multimap&amp; <a href="#unordered_multimap_move_assignment">operator=</a>(unordered_multimap&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multimap&amp; <a href="#unordered_multimap_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multimap_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multimap_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multimap_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multimap_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multimap_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multimap_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multimap_size">size</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multimap_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator <a href="#unordered_multimap_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multimap_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multimap_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multimap_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multimap_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multimap_extract_by_key">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multimap_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multimap_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multimap_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multimap_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_multimap_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multimap_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multimap_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multimap_swap">swap</a>(unordered_multimap&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multimap_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multimap_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multimap_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_multimap_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multimap_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_multimap_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multimap_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multimap_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multimap_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multimap_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multimap_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_multimap_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multimap_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multimap_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multimap_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multimap_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multimap_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_multimap_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multimap&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_multimap&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_multimap&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_multimap&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multimap_operator">operator==</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multimap_operator_2">operator!=</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_multimap_swap_2">swap</a>(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_multimap&lt;K, T, H, P, A&gt;::size_type
      <a href="#unordered_multimap_erase_if">erase_if</a>(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_description"><a class="link" href="#unordered_multimap_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_configuration_macros"><a class="link" href="#unordered_multimap_configuration_macros">Configuration macros</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_boost_unordered_enable_serialization_compatibility_v0"><a class="link" href="#unordered_multimap_boost_unordered_enable_serialization_compatibility_v0"><code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code></a></h5>
<div class="paragraph">
<p>Globally define this macro to support loading of <code>unordered_multimap</code>s saved to
a Boost.Serialization archive with a version of Boost prior to Boost 1.84.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_typedefs"><a class="link" href="#unordered_multimap_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_map for details.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_constructors"><a class="link" href="#unordered_multimap_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_default_constructor"><a class="link" href="#unordered_multimap_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor"><a class="link" href="#unordered_multimap_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor"><a class="link" href="#unordered_multimap_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
<span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_constructor"><a class="link" href="#unordered_multimap_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_constructor"><a class="link" href="#unordered_multimap_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_allocator_constructor"><a class="link" href="#unordered_multimap_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_constructor_with_allocator"><a class="link" href="#unordered_multimap_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_constructor_with_allocator"><a class="link" href="#unordered_multimap_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor"><a class="link" href="#unordered_multimap_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_multimap_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_destructor"><a class="link" href="#unordered_multimap_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_multimap</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_assignment"><a class="link" href="#unordered_multimap_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_copy_assignment"><a class="link" href="#unordered_multimap_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_assignment"><a class="link" href="#unordered_multimap_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_assignment"><a class="link" href="#unordered_multimap_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iterators"><a class="link" href="#unordered_multimap_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_begin"><a class="link" href="#unordered_multimap_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_end"><a class="link" href="#unordered_multimap_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cbegin"><a class="link" href="#unordered_multimap_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cend"><a class="link" href="#unordered_multimap_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_size_and_capacity"><a class="link" href="#unordered_multimap_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_empty"><a class="link" href="#unordered_multimap_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_size"><a class="link" href="#unordered_multimap_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_size"><a class="link" href="#unordered_multimap_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_modifiers"><a class="link" href="#unordered_multimap_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_emplace"><a class="link" href="#unordered_multimap_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_hint"><a class="link" href="#unordered_multimap_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_insert"><a class="link" href="#unordered_multimap_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_insert"><a class="link" href="#unordered_multimap_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_insert"><a class="link" href="#unordered_multimap_emplace_insert">Emplace Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_insert_with_hint"><a class="link" href="#unordered_multimap_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_insert_with_hint"><a class="link" href="#unordered_multimap_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_insert_with_hint"><a class="link" href="#unordered_multimap_emplace_insert_with_hint">Emplace Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_iterator_range"><a class="link" href="#unordered_multimap_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_initializer_list"><a class="link" href="#unordered_multimap_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_extract_by_iterator"><a class="link" href="#unordered_multimap_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_extract_by_key"><a class="link" href="#unordered_multimap_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_with_node_handle"><a class="link" href="#unordered_multimap_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_with_hint_and_node_handle"><a class="link" href="#unordered_multimap_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_by_position"><a class="link" href="#unordered_multimap_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_by_key"><a class="link" href="#unordered_multimap_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_range"><a class="link" href="#unordered_multimap_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_quick_erase"><a class="link" href="#unordered_multimap_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_return_void"><a class="link" href="#unordered_multimap_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_swap"><a class="link" href="#unordered_multimap_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_clear"><a class="link" href="#unordered_multimap_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_merge"><a class="link" href="#unordered_multimap_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_observers"><a class="link" href="#unordered_multimap_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_get_allocator"><a class="link" href="#unordered_multimap_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_hash_function"><a class="link" href="#unordered_multimap_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_key_eq"><a class="link" href="#unordered_multimap_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_lookup"><a class="link" href="#unordered_multimap_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_find"><a class="link" href="#unordered_multimap_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_count"><a class="link" href="#unordered_multimap_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_contains"><a class="link" href="#unordered_multimap_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_equal_range"><a class="link" href="#unordered_multimap_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket_interface"><a class="link" href="#unordered_multimap_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count"><a class="link" href="#unordered_multimap_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_bucket_count"><a class="link" href="#unordered_multimap_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_size"><a class="link" href="#unordered_multimap_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket"><a class="link" href="#unordered_multimap_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_begin_2"><a class="link" href="#unordered_multimap_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_end_2"><a class="link" href="#unordered_multimap_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cbegin_2"><a class="link" href="#unordered_multimap_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cend_2"><a class="link" href="#unordered_multimap_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_hash_policy"><a class="link" href="#unordered_multimap_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_load_factor"><a class="link" href="#unordered_multimap_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_load_factor"><a class="link" href="#unordered_multimap_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_set_max_load_factor"><a class="link" href="#unordered_multimap_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_rehash"><a class="link" href="#unordered_multimap_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_reserve"><a class="link" href="#unordered_multimap_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_deduction_guides"><a class="link" href="#unordered_multimap_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_value_type"><a class="link" href="#unordered_multimap_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_key_type"><a class="link" href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_mapped_type"><a class="link" href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_to_alloc_type"><a class="link" href="#unordered_multimap_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_equality_comparisons"><a class="link" href="#unordered_multimap_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_operator"><a class="link" href="#unordered_multimap_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_operator_2"><a class="link" href="#unordered_multimap_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_swap_2"><a class="link" href="#unordered_multimap_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_erase_if"><a class="link" href="#unordered_multimap_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_serialization"><a class="link" href="#unordered_multimap_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_multimap</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_multimap_saving_an_unordered_multimap_to_an_archive"><a class="link" href="#unordered_multimap_saving_an_unordered_multimap_to_an_archive">Saving an unordered_multimap to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_multimap</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>std::remove_const&lt;key_type&gt;::type</code> and <code>std::remove_const&lt;mapped_type&gt;::type</code>
are serializable (XML serializable), and they do support Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_loading_an_unordered_multimap_from_an_archive"><a class="link" href="#unordered_multimap_loading_an_unordered_multimap_from_an_archive">Loading an unordered_multimap from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_multimap</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_multimap</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
from <code>(std::remove_const&lt;key_type&gt;::type&amp;&amp;, std::remove_const&lt;mapped_type&gt;::type&amp;&amp;)</code>.
<code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>If the archive was saved using a release of Boost prior to Boost 1.84,
the configuration macro <code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code>
has to be globally defined for this operation to succeed; otherwise, an exception is thrown.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_multimap_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_multimap</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_multimap_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_multimap</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set"><a class="link" href="#unordered_set">Class Template unordered_set</a></h3>
<div class="paragraph">
<p><code>boost::unordered_set</code>  An unordered associative container that stores unique values.</p>
</div>
<div class="sect3">
<h4 id="unordered_set_synopsis"><a class="link" href="#unordered_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_set_default_constructor">unordered_set</a>();
    explicit <a href="#unordered_set_bucket_count_constructor">unordered_set</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor">unordered_set</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_copy_constructor">unordered_set</a>(const unordered_set&amp; other);
    <a href="#unordered_set_move_constructor">unordered_set</a>(unordered_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_allocator">unordered_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_set_allocator_constructor">unordered_set</a>(const Allocator&amp; a);
    <a href="#unordered_set_copy_constructor_with_allocator">unordered_set</a>(const unordered_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_move_constructor_with_allocator">unordered_set</a>(unordered_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_initializer_list_constructor">unordered_set</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>,
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_bucket_count_constructor_with_allocator">unordered_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator">unordered_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_set_destructor">~unordered_set</a>();
    unordered_set&amp; <a href="#unordered_set_copy_assignment">operator=</a>(const unordered_set&amp; other);
    unordered_set&amp; <a href="#unordered_set_move_assignment">operator=</a>(unordered_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_set&amp; <a href="#unordered_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    node_type <a href="#unordered_set_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_set_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_set_extract_by_value">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_set_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_set_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_set_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_set_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_set_erase_by_value">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_set_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_set_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_set_swap">swap</a>(unordered_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_set_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_set_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_set_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_set_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_set_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_set_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_set_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_set_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_set_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_set_operator">operator==</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_set_operator_2">operator!=</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_set_swap_2">swap</a>(unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class H, class P, class A, class Predicate&gt;
    typename unordered_set&lt;K, H, P, A&gt;::size_type
      <a href="#unordered_set_erase_if">erase_if</a>(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_description"><a class="link" href="#unordered_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_configuration_macros"><a class="link" href="#unordered_set_configuration_macros">Configuration macros</a></h4>
<div class="sect4">
<h5 id="unordered_set_boost_unordered_enable_serialization_compatibility_v0"><a class="link" href="#unordered_set_boost_unordered_enable_serialization_compatibility_v0"><code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code></a></h5>
<div class="paragraph">
<p>Globally define this macro to support loading of <code>unordered_set</code>s saved to
a Boost.Serialization archive with a version of Boost prior to Boost 1.84.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_typedefs"><a class="link" href="#unordered_set_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">NodeType</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc"><em>insert_return_type</em></span> <span class="c1">// name is exposition only</span>
<span class="p">{</span>
  <span class="n">Iterator</span> <span class="n">position</span><span class="p">;</span>
  <span class="kt">bool</span>     <span class="n">inserted</span><span class="p">;</span>
  <span class="n">NodeType</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_constructors"><a class="link" href="#unordered_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_set_default_constructor"><a class="link" href="#unordered_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor"><a class="link" href="#unordered_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor"><a class="link" href="#unordered_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_constructor"><a class="link" href="#unordered_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_constructor"><a class="link" href="#unordered_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_set_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_allocator_constructor"><a class="link" href="#unordered_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_constructor_with_allocator"><a class="link" href="#unordered_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_constructor_with_allocator"><a class="link" href="#unordered_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor"><a class="link" href="#unordered_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_destructor"><a class="link" href="#unordered_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_assignment"><a class="link" href="#unordered_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_set_copy_assignment"><a class="link" href="#unordered_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_assignment"><a class="link" href="#unordered_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_assignment"><a class="link" href="#unordered_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_iterators"><a class="link" href="#unordered_set_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_set_begin"><a class="link" href="#unordered_set_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_end"><a class="link" href="#unordered_set_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cbegin"><a class="link" href="#unordered_set_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cend"><a class="link" href="#unordered_set_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_size_and_capacity"><a class="link" href="#unordered_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_set_empty"><a class="link" href="#unordered_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_size"><a class="link" href="#unordered_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_size"><a class="link" href="#unordered_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_modifiers"><a class="link" href="#unordered_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_set_emplace"><a class="link" href="#unordered_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_emplace_hint"><a class="link" href="#unordered_set_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_insert"><a class="link" href="#unordered_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_insert"><a class="link" href="#unordered_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_transparent_insert"><a class="link" href="#unordered_set_transparent_insert">Transparent Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_insert_with_hint"><a class="link" href="#unordered_set_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_insert_with_hint"><a class="link" href="#unordered_set_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_transparent_insert_with_hint"><a class="link" href="#unordered_set_transparent_insert_with_hint">Transparent Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_iterator_range"><a class="link" href="#unordered_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_initializer_list"><a class="link" href="#unordered_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_extract_by_iterator"><a class="link" href="#unordered_set_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_extract_by_value"><a class="link" href="#unordered_set_extract_by_value">Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_with_node_handle"><a class="link" href="#unordered_set_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>In C++17 this can be used to insert a node extracted from a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_with_hint_and_node_handle"><a class="link" href="#unordered_set_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multiset</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_by_position"><a class="link" href="#unordered_set_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_by_value"><a class="link" href="#unordered_set_erase_by_value">Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_range"><a class="link" href="#unordered_set_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_quick_erase"><a class="link" href="#unordered_set_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_return_void"><a class="link" href="#unordered_set_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_swap"><a class="link" href="#unordered_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_clear"><a class="link" href="#unordered_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_merge"><a class="link" href="#unordered_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_observers"><a class="link" href="#unordered_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_set_get_allocator"><a class="link" href="#unordered_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_hash_function"><a class="link" href="#unordered_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_key_eq"><a class="link" href="#unordered_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_lookup"><a class="link" href="#unordered_set_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_set_find"><a class="link" href="#unordered_set_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_count"><a class="link" href="#unordered_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_contains"><a class="link" href="#unordered_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_equal_range"><a class="link" href="#unordered_set_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket_interface"><a class="link" href="#unordered_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_set_bucket_count"><a class="link" href="#unordered_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_bucket_count"><a class="link" href="#unordered_set_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_size"><a class="link" href="#unordered_set_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket"><a class="link" href="#unordered_set_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_begin_2"><a class="link" href="#unordered_set_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_end_2"><a class="link" href="#unordered_set_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cbegin_2"><a class="link" href="#unordered_set_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cend_2"><a class="link" href="#unordered_set_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_hash_policy"><a class="link" href="#unordered_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_set_load_factor"><a class="link" href="#unordered_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_load_factor"><a class="link" href="#unordered_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_set_max_load_factor"><a class="link" href="#unordered_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_rehash"><a class="link" href="#unordered_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_reserve"><a class="link" href="#unordered_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_deduction_guides"><a class="link" href="#unordered_set_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_set_iter_value_type"><a class="link" href="#unordered_set_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_equality_comparisons"><a class="link" href="#unordered_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_set_operator"><a class="link" href="#unordered_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_operator_2"><a class="link" href="#unordered_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_swap_2"><a class="link" href="#unordered_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_erase_if"><a class="link" href="#unordered_set_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_serialization"><a class="link" href="#unordered_set_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_set</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_set_saving_an_unordered_set_to_an_archive"><a class="link" href="#unordered_set_saving_an_unordered_set_to_an_archive">Saving an unordered_set to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_set</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code>
is serializable (XML serializable), and it supports Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_loading_an_unordered_set_from_an_archive"><a class="link" href="#unordered_set_loading_an_unordered_set_from_an_archive">Loading an unordered_set from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_set</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_set</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.
<code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>If the archive was saved using a release of Boost prior to Boost 1.84,
the configuration macro <code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code>
has to be globally defined for this operation to succeed; otherwise, an exception is thrown.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_set_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_set</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_set_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_set</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset"><a class="link" href="#unordered_multiset">Class Template unordered_multiset</a></h3>
<div class="paragraph">
<p><code>boost::unordered_multiset</code>  An unordered associative container that stores values. The same key can be stored multiple times.</p>
</div>
<div class="sect3">
<h4 id="unordered_multiset_synopsis"><a class="link" href="#unordered_multiset_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_multiset {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multiset_default_constructor">unordered_multiset</a>();
    explicit <a href="#unordered_multiset_bucket_count_constructor">unordered_multiset</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor">unordered_multiset</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_copy_constructor">unordered_multiset</a>(const unordered_multiset&amp; other);
    <a href="#unordered_multiset_move_constructor">unordered_multiset</a>(unordered_multiset&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_allocator">unordered_multiset</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_multiset_allocator_constructor">unordered_multiset</a>(const Allocator&amp; a);
    <a href="#unordered_multiset_copy_constructor_with_allocator">unordered_multiset</a>(const unordered_multiset&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_move_constructor_with_allocator">unordered_multiset</a>(unordered_multiset&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_bucket_count_constructor_with_allocator">unordered_multiset</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator">unordered_multiset</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor_with_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a)
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multiset_destructor">~unordered_multiset()</a>;
    unordered_multiset&amp; <a href="#unordered_multiset_copy_assignment">operator=</a>(const unordered_multiset&amp; other);
    unordered_multiset&amp; <a href="#unordered_multiset_move_assignment">operator=</a>(unordered_multiset&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multiset&amp; <a href="#unordered_multiset_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multiset_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multiset_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multiset_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multiset_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multiset_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multiset_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multiset_size">size</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multiset_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert">insert</a>(value_type&amp;&amp; obj);
    iterator <a href="#unordered_multiset_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multiset_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multiset_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multiset_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multiset_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multiset_extract_by_value">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multiset_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multiset_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multiset_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multiset_erase_by_value">erase</a>(K&amp;&amp; x);
    iterator  <a href="#unordered_multiset_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multiset_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multiset_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multiset_swap">swap</a>(unordered_multiset&amp;)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multiset_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multiset_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multiset_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_multiset_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multiset_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multiset_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                          CompatiblePredicate const&amp;);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator  <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                           CompatiblePredicate const&amp;) const;
    size_type        <a href="#unordered_multiset_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multiset_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multiset_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multiset_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multiset_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multiset_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_multiset_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multiset_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multiset_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multiset_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multiset_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multiset_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multiset&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multiset&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_multiset&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_multiset&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multiset_operator">operator==</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multiset_operator_2">operator!=</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_multiset_swap_2">swap</a>(unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class H, class P, class A, class Predicate&gt;
    typename unordered_multiset&lt;K, H, P, A&gt;::size_type
      <a href="#unordered_multiset_erase_if">erase_if</a>(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_description"><a class="link" href="#unordered_multiset_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_configuration_macros"><a class="link" href="#unordered_multiset_configuration_macros">Configuration macros</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_boost_unordered_enable_serialization_compatibility_v0"><a class="link" href="#unordered_multiset_boost_unordered_enable_serialization_compatibility_v0"><code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code></a></h5>
<div class="paragraph">
<p>Globally define this macro to support loading of <code>unordered_multiset</code>s saved to
a Boost.Serialization archive with a version of Boost prior to Boost 1.84.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_typedefs"><a class="link" href="#unordered_multiset_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_set for details.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_constructors"><a class="link" href="#unordered_multiset_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_default_constructor"><a class="link" href="#unordered_multiset_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor"><a class="link" href="#unordered_multiset_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor"><a class="link" href="#unordered_multiset_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_constructor"><a class="link" href="#unordered_multiset_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_constructor"><a class="link" href="#unordered_multiset_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_allocator_constructor"><a class="link" href="#unordered_multiset_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_constructor_with_allocator"><a class="link" href="#unordered_multiset_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_constructor_with_allocator"><a class="link" href="#unordered_multiset_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor"><a class="link" href="#unordered_multiset_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_multiset_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_destructor"><a class="link" href="#unordered_multiset_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_multiset</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_assignment"><a class="link" href="#unordered_multiset_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_copy_assignment"><a class="link" href="#unordered_multiset_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_assignment"><a class="link" href="#unordered_multiset_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_assignment"><a class="link" href="#unordered_multiset_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iterators"><a class="link" href="#unordered_multiset_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_begin"><a class="link" href="#unordered_multiset_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_end"><a class="link" href="#unordered_multiset_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cbegin"><a class="link" href="#unordered_multiset_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cend"><a class="link" href="#unordered_multiset_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_size_and_capacity"><a class="link" href="#unordered_multiset_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_empty"><a class="link" href="#unordered_multiset_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_size"><a class="link" href="#unordered_multiset_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_size"><a class="link" href="#unordered_multiset_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_modifiers"><a class="link" href="#unordered_multiset_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_emplace"><a class="link" href="#unordered_multiset_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_emplace_hint"><a class="link" href="#unordered_multiset_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_insert"><a class="link" href="#unordered_multiset_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_insert"><a class="link" href="#unordered_multiset_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_insert_with_hint"><a class="link" href="#unordered_multiset_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_insert_with_hint"><a class="link" href="#unordered_multiset_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_iterator_range"><a class="link" href="#unordered_multiset_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_initializer_list"><a class="link" href="#unordered_multiset_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_extract_by_iterator"><a class="link" href="#unordered_multiset_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_extract_by_value"><a class="link" href="#unordered_multiset_extract_by_value">Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_with_node_handle"><a class="link" href="#unordered_multiset_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_with_hint_and_node_handle"><a class="link" href="#unordered_multiset_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_by_position"><a class="link" href="#unordered_multiset_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_by_value"><a class="link" href="#unordered_multiset_erase_by_value">Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_range"><a class="link" href="#unordered_multiset_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_quick_erase"><a class="link" href="#unordered_multiset_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_return_void"><a class="link" href="#unordered_multiset_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_swap"><a class="link" href="#unordered_multiset_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_clear"><a class="link" href="#unordered_multiset_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_merge"><a class="link" href="#unordered_multiset_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_observers"><a class="link" href="#unordered_multiset_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_get_allocator"><a class="link" href="#unordered_multiset_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_hash_function"><a class="link" href="#unordered_multiset_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_key_eq"><a class="link" href="#unordered_multiset_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_lookup"><a class="link" href="#unordered_multiset_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_find"><a class="link" href="#unordered_multiset_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span>  <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
                       <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_count"><a class="link" href="#unordered_multiset_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_contains"><a class="link" href="#unordered_multiset_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_equal_range"><a class="link" href="#unordered_multiset_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket_interface"><a class="link" href="#unordered_multiset_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count"><a class="link" href="#unordered_multiset_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_bucket_count"><a class="link" href="#unordered_multiset_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_size"><a class="link" href="#unordered_multiset_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket"><a class="link" href="#unordered_multiset_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_begin_2"><a class="link" href="#unordered_multiset_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_end_2"><a class="link" href="#unordered_multiset_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cbegin_2"><a class="link" href="#unordered_multiset_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cend_2"><a class="link" href="#unordered_multiset_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_hash_policy"><a class="link" href="#unordered_multiset_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_load_factor"><a class="link" href="#unordered_multiset_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_load_factor"><a class="link" href="#unordered_multiset_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_set_max_load_factor"><a class="link" href="#unordered_multiset_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_rehash"><a class="link" href="#unordered_multiset_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_reserve"><a class="link" href="#unordered_multiset_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_deduction_guides"><a class="link" href="#unordered_multiset_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iter_value_type"><a class="link" href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_equality_comparisons"><a class="link" href="#unordered_multiset_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_operator"><a class="link" href="#unordered_multiset_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_operator_2"><a class="link" href="#unordered_multiset_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_swap_2"><a class="link" href="#unordered_multiset_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_erase_if"><a class="link" href="#unordered_multiset_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_serialization"><a class="link" href="#unordered_multiset_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_multiset</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_multiset_saving_an_unordered_multiset_to_an_archive"><a class="link" href="#unordered_multiset_saving_an_unordered_multiset_to_an_archive">Saving an unordered_multiset to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_multiset</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code>
is serializable (XML serializable), and it supports Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_loading_an_unordered_multiset_from_an_archive"><a class="link" href="#unordered_multiset_loading_an_unordered_multiset_from_an_archive">Loading an unordered_multiset from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_multiset</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_multiset</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.
<code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>If the archive was saved using a release of Boost prior to Boost 1.84,
the configuration macro <code>BOOST_UNORDERED_ENABLE_SERIALIZATION_COMPATIBILITY_V0</code>
has to be globally defined for this operation to succeed; otherwise, an exception is thrown.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_multiset_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_multiset</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_multiset_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_multiset</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hash_traits"><a class="link" href="#hash_traits">Hash traits</a></h3>
<div class="sect3">
<h4 id="hash_traits_synopsis"><a class="link" href="#hash_traits_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/hash_traits.hpp&gt;

namespace boost {
namespace unordered {

template&lt;typename Hash&gt;
struct <a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>;

} // namespace unordered
} // namespace boost</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="hash_traits_hash_is_avalanching"><a class="link" href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Hash</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">hash_is_avalanching</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A hash function is said to have the <em>avalanching property</em> if small changes in the input translate to
large changes in the returned hash code &#8212;ideally, flipping one bit in the representation of
the input value results in each bit of the hash code flipping with probability 50%. Approaching
this property is critical for the proper behavior of open-addressing hash containers.</p>
</div>
<div class="paragraph">
<p><code>hash_is_avalanching&lt;Hash&gt;::value</code> is <code>true</code> if <code>Hash::is_avalanching</code> is a valid type,
and <code>false</code> otherwise.
Users can then declare a hash function <code>Hash</code> as avalanching either by embedding an <code>is_avalanching</code> typedef
into the definition of <code>Hash</code>, or directly by specializing <code>hash_is_avalanching&lt;Hash&gt;</code> to a class with
an embedded compile-time constant <code>value</code> set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Open-addressing and concurrent containers
use the provided hash function <code>Hash</code> as-is if <code>hash_is_avalanching&lt;Hash&gt;::value</code> is <code>true</code>; otherwise, they
implement a bit-mixing post-processing stage to increase the quality of hashing at the expense of
extra computational cost.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map"><a class="link" href="#unordered_flat_map">Class Template unordered_flat_map</a></h3>
<div class="paragraph">
<p><code>boost::unordered_flat_map</code>  An open-addressing unordered associative container that associates unique keys with another value.</p>
</div>
<div class="paragraph">
<p>The performance of <code>boost::unordered_flat_map</code> is much better than that of <code>boost::unordered_map</code>
or other implementations of <code>std::unordered_map</code>. Unlike standard unordered associative containers,
which are node-based, the elements of a <code>boost::unordered_flat_map</code> are held directly in the bucket
array, and insertions into an already occupied bucket are diverted to available buckets in the
vicinity of the original position. This type of data layout is known as <em>open addressing</em>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_flat_map</code> deviates in
a number of aspects from that of <code>boost::unordered_flat_map</code>/<code>std::unordered_flat_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>) or node extraction/insertion.</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_flat_map</code> is mostly a drop-in replacement of node-based standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_synopsis"><a class="link" href="#unordered_flat_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_flat_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_flat_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using init_type            = std::pair&lt;
                                   typename std::remove_const&lt;Key&gt;::type,
                                   typename std::remove_const&lt;T&gt;::type
                                 &gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_flat_map_default_constructor">unordered_flat_map</a>();
    explicit <a href="#unordered_flat_map_bucket_count_constructor">unordered_flat_map</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor">unordered_flat_map</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_map_copy_constructor">unordered_flat_map</a>(const unordered_flat_map&amp; other);
    <a href="#unordered_flat_map_move_constructor">unordered_flat_map</a>(unordered_flat_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_allocator">unordered_flat_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_flat_map_allocator_constructor">unordered_flat_map</a>(const Allocator&amp; a);
    <a href="#unordered_flat_map_copy_constructor_with_allocator">unordered_flat_map</a>(const unordered_flat_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_map_move_constructor_with_allocator">unordered_flat_map</a>(unordered_flat_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_map_move_constructor_from_concurrent_flat_map">unordered_flat_map</a>(concurrent_flat_map&lt;Key, T, Hash, Pred, Allocator&gt;&amp;&amp; other);
    <a href="#unordered_flat_map_initializer_list_constructor">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_map_bucket_count_constructor_with_allocator">unordered_flat_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator">unordered_flat_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_flat_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_flat_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_map_destructor">~unordered_flat_map</a>();
    unordered_flat_map&amp; <a href="#unordered_flat_map_copy_assignment">operator=</a>(const unordered_flat_map&amp; other);
    unordered_flat_map&amp; <a href="#unordered_flat_map_move_assignment">operator=</a>(unordered_flat_map&amp;&amp; other) noexcept(
      (boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
       boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) &amp;&amp;
       std::is_same&lt;pointer, value_type*&gt;::value);
    unordered_flat_map&amp; <a href="#unordered_flat_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_flat_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_flat_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_flat_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_flat_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_flat_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_flat_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_flat_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_flat_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_flat_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_flat_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_copy_insert">insert</a>(const init_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_move_insert">insert</a>(init_type&amp;&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, const init_type&amp; obj);
    iterator       <a href="#unordered_flat_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, init_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_flat_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_flat_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    <em>convertible-to-iterator</em>     <a href="#unordered_flat_map_erase_by_position">erase</a>(iterator position);
    <em>convertible-to-iterator</em>     <a href="#unordered_flat_map_erase_by_position">erase</a>(const_iterator position);
    size_type                   <a href="#unordered_flat_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_flat_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_flat_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_flat_map_swap">swap</a>(unordered_flat_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#unordered_flat_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_map_merge">merge</a>(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_map_merge">merge</a>(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_flat_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_flat_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_flat_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_flat_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_flat_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_flat_map_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_flat_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_flat_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_flat_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_flat_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_flat_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_flat_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_flat_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_flat_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_flat_map_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_flat_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_flat_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_flat_map_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_flat_map_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_flat_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_flat_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_flat_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_flat_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_map_operator_2">operator==</a>(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_map_operator_3">operator!=</a>(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_flat_map_swap_2">swap</a>(unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_flat_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_flat_map_erase_if">erase_if</a>(unordered_flat_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_description"><a class="link" href="#unordered_flat_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Key</code> and <code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible" target="_blank" rel="noopener">MoveConstructible</a>.
<code>std::pair&lt;const Key, T&gt;</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
into the container from any <code>std::pair</code> object convertible to it, and it also must be
<a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the container are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_typedefs"><a class="link" href="#unordered_flat_map_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_constructors"><a class="link" href="#unordered_flat_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_default_constructor"><a class="link" href="#unordered_flat_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count_constructor"><a class="link" href="#unordered_flat_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor"><a class="link" href="#unordered_flat_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_constructor"><a class="link" href="#unordered_flat_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_constructor"><a class="link" href="#unordered_flat_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_flat_map_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_allocator_constructor"><a class="link" href="#unordered_flat_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_constructor_with_allocator"><a class="link" href="#unordered_flat_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_constructor_with_allocator"><a class="link" href="#unordered_flat_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_constructor_from_concurrent_flat_map"><a class="link" href="#unordered_flat_map_move_constructor_from_concurrent_flat_map">Move Constructor from concurrent_flat_map</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move construction from a <a href="#concurrent_flat_map"><code>concurrent_flat_map</code></a>.
The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>Constant time.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor"><a class="link" href="#unordered_flat_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_flat_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_flat_map_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_destructor"><a class="link" href="#unordered_flat_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_flat_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_assignment"><a class="link" href="#unordered_flat_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_copy_assignment"><a class="link" href="#unordered_flat_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_assignment"><a class="link" href="#unordered_flat_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">((</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">value_type</span><span class="o">*&gt;::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_assignment"><a class="link" href="#unordered_flat_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iterators"><a class="link" href="#unordered_flat_map_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_begin"><a class="link" href="#unordered_flat_map_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_end"><a class="link" href="#unordered_flat_map_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_cbegin"><a class="link" href="#unordered_flat_map_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_cend"><a class="link" href="#unordered_flat_map_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_size_and_capacity"><a class="link" href="#unordered_flat_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_empty"><a class="link" href="#unordered_flat_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_size"><a class="link" href="#unordered_flat_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_max_size"><a class="link" href="#unordered_flat_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_modifiers"><a class="link" href="#unordered_flat_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_emplace"><a class="link" href="#unordered_flat_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_emplace_hint"><a class="link" href="#unordered_flat_map_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_insert"><a class="link" href="#unordered_flat_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_insert"><a class="link" href="#unordered_flat_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_insert_with_hint"><a class="link" href="#unordered_flat_map_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_insert_with_hint"><a class="link" href="#unordered_flat_map_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_iterator_range"><a class="link" href="#unordered_flat_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_initializer_list"><a class="link" href="#unordered_flat_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_try_emplace"><a class="link" href="#unordered_flat_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_flat_map_emplace">emplace</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_flat_map_emplace">emplace</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_try_emplace_with_hint"><a class="link" href="#unordered_flat_map_try_emplace_with_hint">try_emplace with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.  This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_or_assign"><a class="link" href="#unordered_flat_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>std::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load. <br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_or_assign_with_hint"><a class="link" href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>std::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_erase_by_position"><a class="link" href="#unordered_flat_map_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An opaque object implicitly convertible to the <code>iterator</code> or <code>const_iterator</code>
immediately following <code>position</code> prior to the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The opaque object returned must only be discarded or immediately converted to <code>iterator</code> or <code>const_iterator</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_erase_by_key"><a class="link" href="#unordered_flat_map_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_erase_range"><a class="link" href="#unordered_flat_map_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_swap"><a class="link" href="#unordered_flat_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_clear"><a class="link" href="#unordered_flat_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_merge"><a class="link" href="#unordered_flat_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_observers"><a class="link" href="#unordered_flat_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_get_allocator"><a class="link" href="#unordered_flat_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_hash_function"><a class="link" href="#unordered_flat_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_key_eq"><a class="link" href="#unordered_flat_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_lookup"><a class="link" href="#unordered_flat_map_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_find"><a class="link" href="#unordered_flat_map_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_count"><a class="link" href="#unordered_flat_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_contains"><a class="link" href="#unordered_flat_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_equal_range"><a class="link" href="#unordered_flat_map_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_operator"><a class="link" href="#unordered_flat_map_operator">operator[]</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an element with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_at"><a class="link" href="#unordered_flat_map_at">at</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_bucket_interface"><a class="link" href="#unordered_flat_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count"><a class="link" href="#unordered_flat_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_hash_policy"><a class="link" href="#unordered_flat_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_load_factor"><a class="link" href="#unordered_flat_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_max_load_factor"><a class="link" href="#unordered_flat_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_set_max_load_factor"><a class="link" href="#unordered_flat_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_max_load"><a class="link" href="#unordered_flat_map_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_rehash"><a class="link" href="#unordered_flat_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array. If the provided Allocator uses fancy pointers, a default allocation is subsequently performed.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_reserve"><a class="link" href="#unordered_flat_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_deduction_guides"><a class="link" href="#unordered_flat_map_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_value_type"><a class="link" href="#unordered_flat_map_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_key_type"><a class="link" href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_mapped_type"><a class="link" href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_to_alloc_type"><a class="link" href="#unordered_flat_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_equality_comparisons"><a class="link" href="#unordered_flat_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_operator_2"><a class="link" href="#unordered_flat_map_operator_2">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_operator_3"><a class="link" href="#unordered_flat_map_operator_3">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_swap_2"><a class="link" href="#unordered_flat_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_erase_if"><a class="link" href="#unordered_flat_map_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_serialization"><a class="link" href="#unordered_flat_map_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_flat_map</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_saving_an_unordered_flat_map_to_an_archive"><a class="link" href="#unordered_flat_map_saving_an_unordered_flat_map_to_an_archive">Saving an unordered_flat_map to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_flat_map</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>std::remove_const&lt;key_type&gt;::type</code> and <code>std::remove_const&lt;mapped_type&gt;::type</code>
are serializable (XML serializable), and they do support Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_loading_an_unordered_flat_map_from_an_archive"><a class="link" href="#unordered_flat_map_loading_an_unordered_flat_map_from_an_archive">Loading an unordered_flat_map from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_flat_map</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_flat_map</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_flat_map_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_flat_map</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_flat_map_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_flat_map</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set"><a class="link" href="#unordered_flat_set">Class Template unordered_flat_set</a></h3>
<div class="paragraph">
<p><code>boost::unordered_flat_set</code>  An open-addressing unordered associative container that stores unique values.</p>
</div>
<div class="paragraph">
<p>The performance of <code>boost::unordered_flat_set</code> is much better than that of <code>boost::unordered_set</code>
or other implementations of <code>std::unordered_set</code>. Unlike standard unordered associative containers,
which are node-based, the elements of a <code>boost::unordered_flat_set</code> are held directly in the bucket
array, and insertions into an already occupied bucket are diverted to available buckets in the
vicinity of the original position. This type of data layout is known as <em>open addressing</em>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_flat_set</code> deviates in
a number of aspects from that of <code>boost::unordered_flat_set</code>/<code>std::unordered_flat_set</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>) or node extraction/insertion.</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_flat_set</code> is mostly a drop-in replacement of node-based standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_synopsis"><a class="link" href="#unordered_flat_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_flat_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_flat_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using init_type            = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_flat_set_default_constructor">unordered_flat_set</a>();
    explicit <a href="#unordered_flat_set_bucket_count_constructor">unordered_flat_set</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor">unordered_flat_set</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_set_copy_constructor">unordered_flat_set</a>(const unordered_flat_set&amp; other);
    <a href="#unordered_flat_set_move_constructor">unordered_flat_set</a>(unordered_flat_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_allocator">unordered_flat_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_flat_set_allocator_constructor">unordered_flat_set</a>(const Allocator&amp; a);
    <a href="#unordered_flat_set_copy_constructor_with_allocator">unordered_flat_set</a>(const unordered_flat_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_set_move_constructor_from_concurrent_flat_set">unordered_flat_set</a>(concurrent_flat_set&lt;Key, Hash, Pred, Allocator&gt;&amp;&amp; other);
    <a href="#unordered_flat_set_initializer_list_constructor">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_set_bucket_count_constructor_with_allocator">unordered_flat_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator">unordered_flat_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_flat_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_flat_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_set_destructor">~unordered_flat_set</a>();
    unordered_flat_set&amp; <a href="#unordered_flat_set_copy_assignment">operator=</a>(const unordered_flat_set&amp; other);
    unordered_flat_set&amp; <a href="#unordered_flat_set_move_assignment">operator=</a>(unordered_flat_set&amp;&amp; other) noexcept(
      (boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
       boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) &amp;&amp;
       std::is_same&lt;pointer, value_type*&gt;::value);
    unordered_flat_set&amp; <a href="#unordered_flat_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_flat_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_flat_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_flat_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_flat_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_flat_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_flat_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_flat_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_flat_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_flat_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_flat_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_flat_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_flat_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_flat_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_flat_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_flat_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_flat_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    <em>convertible-to-iterator</em>     <a href="#unordered_flat_set_erase_by_position">erase</a>(iterator position);
    <em>convertible-to-iterator</em>     <a href="#unordered_flat_set_erase_by_position">erase</a>(const_iterator position);
    size_type                   <a href="#unordered_flat_set_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_flat_set_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_flat_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_flat_set_swap">swap</a>(unordered_flat_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#unordered_flat_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_set_merge">merge</a>(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_set_merge">merge</a>(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_flat_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_flat_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_flat_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_flat_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_flat_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_flat_set_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_flat_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_flat_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_flat_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_flat_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_flat_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_flat_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_flat_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_flat_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_flat_set_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_flat_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_flat_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_flat_set_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_flat_set_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_flat_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_flat_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_flat_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_set_operator_2">operator!=</a>(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_set_operator_3">operator!=</a>(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_flat_set_swap_2">swap</a>(unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_flat_set&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_flat_set_erase_if">erase_if</a>(unordered_flat_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_description"><a class="link" href="#unordered_flat_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a> into the container
and <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the container are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_typedefs"><a class="link" href="#unordered_flat_set_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_constructors"><a class="link" href="#unordered_flat_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_default_constructor"><a class="link" href="#unordered_flat_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count_constructor"><a class="link" href="#unordered_flat_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor"><a class="link" href="#unordered_flat_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_constructor"><a class="link" href="#unordered_flat_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_constructor"><a class="link" href="#unordered_flat_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_flat_set_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_allocator_constructor"><a class="link" href="#unordered_flat_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_set</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_constructor_with_allocator"><a class="link" href="#unordered_flat_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_constructor_with_allocator"><a class="link" href="#unordered_flat_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_constructor_from_concurrent_flat_set"><a class="link" href="#unordered_flat_set_move_constructor_from_concurrent_flat_set">Move Constructor from concurrent_flat_set</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move construction from a <a href="#concurrent_flat_set"><code>concurrent_flat_set</code></a>.
The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>Constant time.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor"><a class="link" href="#unordered_flat_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_flat_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_flat_set_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_destructor"><a class="link" href="#unordered_flat_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_flat_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_assignment"><a class="link" href="#unordered_flat_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_copy_assignment"><a class="link" href="#unordered_flat_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_assignment"><a class="link" href="#unordered_flat_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">((</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">value_type</span><span class="o">*&gt;::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_assignment"><a class="link" href="#unordered_flat_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_iterators"><a class="link" href="#unordered_flat_set_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_begin"><a class="link" href="#unordered_flat_set_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_end"><a class="link" href="#unordered_flat_set_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_cbegin"><a class="link" href="#unordered_flat_set_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_cend"><a class="link" href="#unordered_flat_set_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_size_and_capacity"><a class="link" href="#unordered_flat_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_empty"><a class="link" href="#unordered_flat_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_size"><a class="link" href="#unordered_flat_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_max_size"><a class="link" href="#unordered_flat_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_modifiers"><a class="link" href="#unordered_flat_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_emplace"><a class="link" href="#unordered_flat_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_emplace_hint"><a class="link" href="#unordered_flat_set_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_insert"><a class="link" href="#unordered_flat_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_insert"><a class="link" href="#unordered_flat_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_transparent_insert"><a class="link" href="#unordered_flat_set_transparent_insert">Transparent Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_insert_with_hint"><a class="link" href="#unordered_flat_set_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_insert_with_hint"><a class="link" href="#unordered_flat_set_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_transparent_insert_with_hint"><a class="link" href="#unordered_flat_set_transparent_insert_with_hint">Transparent Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_insert_iterator_range"><a class="link" href="#unordered_flat_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_insert_initializer_list"><a class="link" href="#unordered_flat_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_erase_by_position"><a class="link" href="#unordered_flat_set_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An opaque object implicitly convertible to the <code>iterator</code> or <code>const_iterator</code>
immediately following <code>position</code> prior to the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The opaque object returned must only be discarded or immediately converted to <code>iterator</code> or <code>const_iterator</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_erase_by_key"><a class="link" href="#unordered_flat_set_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_erase_range"><a class="link" href="#unordered_flat_set_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_swap"><a class="link" href="#unordered_flat_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_clear"><a class="link" href="#unordered_flat_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_merge"><a class="link" href="#unordered_flat_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_observers"><a class="link" href="#unordered_flat_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_get_allocator"><a class="link" href="#unordered_flat_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_hash_function"><a class="link" href="#unordered_flat_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_key_eq"><a class="link" href="#unordered_flat_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_lookup"><a class="link" href="#unordered_flat_set_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_find"><a class="link" href="#unordered_flat_set_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_count"><a class="link" href="#unordered_flat_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_contains"><a class="link" href="#unordered_flat_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_equal_range"><a class="link" href="#unordered_flat_set_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_bucket_interface"><a class="link" href="#unordered_flat_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count"><a class="link" href="#unordered_flat_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_hash_policy"><a class="link" href="#unordered_flat_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_load_factor"><a class="link" href="#unordered_flat_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_max_load_factor"><a class="link" href="#unordered_flat_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_set_max_load_factor"><a class="link" href="#unordered_flat_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_max_load"><a class="link" href="#unordered_flat_set_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_rehash"><a class="link" href="#unordered_flat_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array. If the provided Allocator uses fancy pointers, a default allocation is subsequently performed.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_reserve"><a class="link" href="#unordered_flat_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_deduction_guides"><a class="link" href="#unordered_flat_set_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iter_value_type"><a class="link" href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_equality_comparisons"><a class="link" href="#unordered_flat_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_operator"><a class="link" href="#unordered_flat_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_operator_2"><a class="link" href="#unordered_flat_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_swap_2"><a class="link" href="#unordered_flat_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_erase_if"><a class="link" href="#unordered_flat_set_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_serialization"><a class="link" href="#unordered_flat_set_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_flat_set</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_saving_an_unordered_flat_set_to_an_archive"><a class="link" href="#unordered_flat_set_saving_an_unordered_flat_set_to_an_archive">Saving an unordered_flat_set to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_flat_set</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code>
is serializable (XML serializable), and it supports Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_loading_an_unordered_flat_set_from_an_archive"><a class="link" href="#unordered_flat_set_loading_an_unordered_flat_set_from_an_archive">Loading an unordered_flat_set from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_flat_set</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_flat_set</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_flat_set_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_flat_set</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_flat_set_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_flat_set</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map"><a class="link" href="#unordered_node_map">Class Template unordered_node_map</a></h3>
<div class="paragraph">
<p><code>boost::unordered_node_map</code>  A node-based, open-addressing unordered associative container that associates unique keys with another value.</p>
</div>
<div class="paragraph">
<p><code>boost::unordered_node_map</code> uses an open-addressing layout like <code>boost::unordered_flat_map</code>, but,
being node-based, it provides pointer/iterator stability and node handling functionalities.
Its performance lies between those of <code>boost::unordered_map</code> and <code>boost::unordered_flat_map</code>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_node_map</code> deviates in
a number of aspects from that of <code>boost::unordered_map</code>/<code>std::unordered_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_node_map</code> is mostly a drop-in replacement of standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_node_map_synopsis"><a class="link" href="#unordered_node_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_node_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_node_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using init_type            = std::pair&lt;
                                   typename std::remove_const&lt;Key&gt;::type,
                                   typename std::remove_const&lt;T&gt;::type
                                 &gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_node_map_default_constructor">unordered_node_map</a>();
    explicit <a href="#unordered_node_map_bucket_count_constructor">unordered_node_map</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor">unordered_node_map</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_map_copy_constructor">unordered_node_map</a>(const unordered_node_map&amp; other);
    <a href="#unordered_node_map_move_constructor">unordered_node_map</a>(unordered_node_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_allocator">unordered_node_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_node_map_allocator_constructor">unordered_node_map</a>(const Allocator&amp; a);
    <a href="#unordered_node_map_copy_constructor_with_allocator">unordered_node_map</a>(const unordered_node_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_map_move_constructor_with_allocator">unordered_node_map</a>(unordered_node_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_map_bucket_count_constructor_with_allocator">unordered_node_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_node_map_bucket_count_constructor_with_hasher_and_allocator">unordered_node_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_node_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_node_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_node_map_destructor">~unordered_node_map</a>();
    unordered_node_map&amp; <a href="#unordered_node_map_copy_assignment">operator=</a>(const unordered_node_map&amp; other);
    unordered_node_map&amp; <a href="#unordered_node_map_move_assignment">operator=</a>(unordered_node_map&amp;&amp; other) noexcept(
      (boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
       boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) &amp;&amp;
       std::is_same&lt;pointer, value_type*&gt;::value);
    unordered_node_map&amp; <a href="#unordered_node_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_node_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_node_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_node_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_node_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_node_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_node_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_node_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_node_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_node_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_node_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_node_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_copy_insert">insert</a>(const init_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_move_insert">insert</a>(init_type&amp;&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, const init_type&amp; obj);
    iterator       <a href="#unordered_node_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, init_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_node_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_node_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);
    insert_return_type <a href="#unordered_node_map_insert_node">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_node_map_insert_node_with_hint">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    <em>convertible-to-iterator</em>     <a href="#unordered_node_map_erase_by_position">erase</a>(iterator position);
    <em>convertible-to-iterator</em>     <a href="#unordered_node_map_erase_by_position">erase</a>(const_iterator position);
    size_type                   <a href="#unordered_node_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_node_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_node_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_node_map_swap">swap</a>(unordered_node_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    node_type <a href="#unordered_node_map_extract_by_position">extract</a>(const_iterator position);
    node_type <a href="#unordered_node_map_extract_by_key">extract</a>(const key_type&amp; key);
    template&lt;class K&gt; node_type <a href="#unordered_node_map_extract_by_key">extract</a>(K&amp;&amp; key);
    void      <a href="#unordered_node_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_map_merge">merge</a>(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_map_merge">merge</a>(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_node_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_node_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_node_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_node_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_node_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_node_map_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_node_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_node_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_node_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_node_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_node_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_node_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_node_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_node_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_node_map_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_node_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_node_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_node_map_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_node_map_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_node_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_node_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_node_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_node_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_node_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_node_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_map_operator_2">operator==</a>(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_map_operator_3">operator!=</a>(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_node_map_swap_2">swap</a>(unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_node_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_node_map_erase_if">erase_if</a>(unordered_node_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_description"><a class="link" href="#unordered_node_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>std::pair&lt;const Key, T&gt;</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
into the container from any <code>std::pair</code> object convertible to it, and it also must be
<a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The element nodes of the container are held into an internal <em>bucket array</em>. A node is inserted into a bucket determined by the
hash code of its element, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_typedefs"><a class="link" href="#unordered_node_map_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">NodeType</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc"><em>insert_return_type</em></span> <span class="c1">// name is exposition only</span>
<span class="p">{</span>
  <span class="n">Iterator</span> <span class="n">position</span><span class="p">;</span>
  <span class="kt">bool</span>     <span class="n">inserted</span><span class="p">;</span>
  <span class="n">NodeType</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_constructors"><a class="link" href="#unordered_node_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_default_constructor"><a class="link" href="#unordered_node_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count_constructor"><a class="link" href="#unordered_node_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor"><a class="link" href="#unordered_node_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_constructor"><a class="link" href="#unordered_node_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_constructor"><a class="link" href="#unordered_node_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_node_map_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_allocator_constructor"><a class="link" href="#unordered_node_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_constructor_with_allocator"><a class="link" href="#unordered_node_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_constructor_with_allocator"><a class="link" href="#unordered_node_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the element nodes of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor"><a class="link" href="#unordered_node_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_node_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_node_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_node_map_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_destructor"><a class="link" href="#unordered_node_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_node_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_assignment"><a class="link" href="#unordered_node_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_copy_assignment"><a class="link" href="#unordered_node_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_assignment"><a class="link" href="#unordered_node_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">((</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">value_type</span><span class="o">*&gt;::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_assignment"><a class="link" href="#unordered_node_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iterators"><a class="link" href="#unordered_node_map_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_begin"><a class="link" href="#unordered_node_map_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_end"><a class="link" href="#unordered_node_map_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_cbegin"><a class="link" href="#unordered_node_map_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_cend"><a class="link" href="#unordered_node_map_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_size_and_capacity"><a class="link" href="#unordered_node_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_empty"><a class="link" href="#unordered_node_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_size"><a class="link" href="#unordered_node_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_max_size"><a class="link" href="#unordered_node_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_modifiers"><a class="link" href="#unordered_node_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_emplace"><a class="link" href="#unordered_node_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_emplace_hint"><a class="link" href="#unordered_node_map_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_insert"><a class="link" href="#unordered_node_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_insert"><a class="link" href="#unordered_node_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_insert_with_hint"><a class="link" href="#unordered_node_map_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_insert_with_hint"><a class="link" href="#unordered_node_map_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_iterator_range"><a class="link" href="#unordered_node_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_initializer_list"><a class="link" href="#unordered_node_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_node"><a class="link" href="#unordered_node_map_insert_node">Insert Node</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.key()</code>.
<code>nh</code> is empty when the function returns.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An <code>insert_return_type</code> object constructed from <code>position</code>, <code>inserted</code> and <code>node</code>:<br></p>
<div class="ulist">
<ul>
<li>
<p>If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty.</p>
</li>
<li>
<p>Otherwise if the insertion took place, <code>inserted</code> is true, <code>position</code> points to the inserted element, and <code>node</code> is empty.</p>
</li>
<li>
<p>If the insertion failed, <code>inserted</code> is false, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.key()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_node_with_hint"><a class="link" href="#unordered_node_map_insert_node_with_hint">Insert Node with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.key()</code>.
<code>nh</code> becomes empty if insertion took place, otherwise it is not changed.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator returned is <code>end()</code> if <code>nh</code> is empty.
If insertion took place, then the iterator points to the newly inserted element; otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_try_emplace"><a class="link" href="#unordered_node_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_node_map_emplace">emplace</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_node_map_emplace">emplace</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_try_emplace_with_hint"><a class="link" href="#unordered_node_map_try_emplace_with_hint">try_emplace with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.  This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_node_map_emplace_hint">emplace_hint</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_node_map_emplace_hint">emplace_hint</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_or_assign"><a class="link" href="#unordered_node_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>std::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. <br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_or_assign_with_hint"><a class="link" href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>std::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_erase_by_position"><a class="link" href="#unordered_node_map_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An opaque object implicitly convertible to the <code>iterator</code> or <code>const_iterator</code>
immediately following <code>position</code> prior to the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The opaque object returned must only be discarded or immediately converted to <code>iterator</code> or <code>const_iterator</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_erase_by_key"><a class="link" href="#unordered_node_map_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_erase_range"><a class="link" href="#unordered_node_map_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_swap"><a class="link" href="#unordered_node_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_extract_by_position"><a class="link" href="#unordered_node_map_extract_by_position">Extract by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_extract_by_key"><a class="link" href="#unordered_node_map_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element with key equivalent to <code>k</code>, if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element, or empty if no element was extracted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_clear"><a class="link" href="#unordered_node_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_merge"><a class="link" href="#unordered_node_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Transfers all the element nodes from <code>source</code> whose key is not already present in <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>this-&gt;get_allocator() == source.get_allocator()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates iterators to the elements transferred.
If the resulting size of <code>*this</code> is greater than its original maximum load,
invalidates all iterators associated to <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_observers"><a class="link" href="#unordered_node_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_get_allocator"><a class="link" href="#unordered_node_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_hash_function"><a class="link" href="#unordered_node_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_key_eq"><a class="link" href="#unordered_node_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_lookup"><a class="link" href="#unordered_node_map_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_find"><a class="link" href="#unordered_node_map_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_count"><a class="link" href="#unordered_node_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_contains"><a class="link" href="#unordered_node_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_equal_range"><a class="link" href="#unordered_node_map_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_operator"><a class="link" href="#unordered_node_map_operator">operator[]</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an element with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_at"><a class="link" href="#unordered_node_map_at">at</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_bucket_interface"><a class="link" href="#unordered_node_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count"><a class="link" href="#unordered_node_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_hash_policy"><a class="link" href="#unordered_node_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_load_factor"><a class="link" href="#unordered_node_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_max_load_factor"><a class="link" href="#unordered_node_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_set_max_load_factor"><a class="link" href="#unordered_node_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_max_load"><a class="link" href="#unordered_node_map_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_rehash"><a class="link" href="#unordered_node_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array. If the provided Allocator uses fancy pointers, a default allocation is subsequently performed.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_reserve"><a class="link" href="#unordered_node_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_deduction_guides"><a class="link" href="#unordered_node_map_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_value_type"><a class="link" href="#unordered_node_map_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_key_type"><a class="link" href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_mapped_type"><a class="link" href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_to_alloc_type"><a class="link" href="#unordered_node_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_equality_comparisons"><a class="link" href="#unordered_node_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_operator_2"><a class="link" href="#unordered_node_map_operator_2">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_operator_3"><a class="link" href="#unordered_node_map_operator_3">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_swap_2"><a class="link" href="#unordered_node_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_erase_if"><a class="link" href="#unordered_node_map_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_serialization"><a class="link" href="#unordered_node_map_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_node_map</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_node_map_saving_an_unordered_node_map_to_an_archive"><a class="link" href="#unordered_node_map_saving_an_unordered_node_map_to_an_archive">Saving an unordered_node_map to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_node_map</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>std::remove_const&lt;key_type&gt;::type</code> and <code>std::remove_const&lt;mapped_type&gt;::type</code>
are serializable (XML serializable), and they do support Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_loading_an_unordered_node_map_from_an_archive"><a class="link" href="#unordered_node_map_loading_an_unordered_node_map_from_an_archive">Loading an unordered_node_map from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_node_map</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_node_map</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_type</code> and <code>mapped_type</code> are constructible from
<code>std::remove_const&lt;key_type&gt;::type&amp;&amp;</code> and <code>std::remove_const&lt;mapped_type&gt;::type&amp;&amp;</code>,
respectively.
<code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_node_map_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_node_map</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_node_map_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_node_map</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set"><a class="link" href="#unordered_node_set">Class Template unordered_node_set</a></h3>
<div class="paragraph">
<p><code>boost::unordered_node_set</code>  A node-based, open-addressing unordered associative container that stores unique values.</p>
</div>
<div class="paragraph">
<p><code>boost::unordered_node_set</code> uses an open-addressing layout like <code>boost::unordered_flat_set</code>, but,
being node-based, it provides pointer/iterator stability and node handling functionalities.
Its performance lies between those of <code>boost::unordered_set</code> and <code>boost::unordered_flat_set</code>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_node_set</code> deviates in
a number of aspects from that of <code>boost::unordered_set</code>/<code>std::unordered_set</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_node_set</code> is mostly a drop-in replacement of standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_node_set_synopsis"><a class="link" href="#unordered_node_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_node_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_node_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using init_type            = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_node_set_default_constructor">unordered_node_set</a>();
    explicit <a href="#unordered_node_set_bucket_count_constructor">unordered_node_set</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor">unordered_node_set</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_set_copy_constructor">unordered_node_set</a>(const unordered_node_set&amp; other);
    <a href="#unordered_node_set_move_constructor">unordered_node_set</a>(unordered_node_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_allocator">unordered_node_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_node_set_allocator_constructor">unordered_node_set</a>(const Allocator&amp; a);
    <a href="#unordered_node_set_copy_constructor_with_allocator">unordered_node_set</a>(const unordered_node_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_set_move_constructor_with_allocator">unordered_node_set</a>(unordered_node_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_set_bucket_count_constructor_with_allocator">unordered_node_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_node_set_bucket_count_constructor_with_hasher_and_allocator">unordered_node_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_node_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_node_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_node_set_destructor">~unordered_node_set</a>();
    unordered_node_set&amp; <a href="#unordered_node_set_copy_assignment">operator=</a>(const unordered_node_set&amp; other);
    unordered_node_set&amp; <a href="#unordered_node_set_move_assignment">operator=</a>(unordered_node_set&amp;&amp; other) noexcept(
      (boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
       boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) &amp;&amp;
       std::is_same&lt;pointer, value_type*&gt;::value);
    unordered_node_set&amp; <a href="#unordered_node_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_node_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_node_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_node_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_node_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_node_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_node_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_node_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_node_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_node_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_node_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_node_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_node_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_node_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_node_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_node_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_node_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);
    insert_return_type <a href="#unordered_node_set_insert_node">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_node_set_insert_node_with_hint">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    <em>convertible-to-iterator</em>     <a href="#unordered_node_set_erase_by_position">erase</a>(iterator position);
    <em>convertible-to-iterator</em>     <a href="#unordered_node_set_erase_by_position">erase</a>(const_iterator position);
    size_type                   <a href="#unordered_node_set_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_node_set_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_node_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_node_set_swap">swap</a>(unordered_node_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    node_type <a href="#unordered_node_set_extract_by_position">extract</a>(const_iterator position);
    node_type <a href="#unordered_node_set_extract_by_key">extract</a>(const key_type&amp; key);
    template&lt;class K&gt; node_type <a href="#unordered_node_set_extract_by_key">extract</a>(K&amp;&amp; key);
    void      <a href="#unordered_node_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_set_merge">merge</a>(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_set_merge">merge</a>(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_node_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_node_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_node_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_node_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_node_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_node_set_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_node_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_node_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_node_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_node_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_node_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_node_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_node_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_node_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_node_set_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_node_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_node_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_node_set_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_node_set_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_node_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_node_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_node_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_node_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_set_operator_2">operator!=</a>(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_set_operator_3">operator!=</a>(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_node_set_swap_2">swap</a>(unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_node_set&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_node_set_erase_if">erase_if</a>(unordered_node_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_description"><a class="link" href="#unordered_node_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The element nodes of the container are held into an internal <em>bucket array</em>. A node is inserted into a bucket determined by
the hash code of its element, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_typedefs"><a class="link" href="#unordered_node_set_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">NodeType</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc"><em>insert_return_type</em></span> <span class="c1">// name is exposition only</span>
<span class="p">{</span>
  <span class="n">Iterator</span> <span class="n">position</span><span class="p">;</span>
  <span class="kt">bool</span>     <span class="n">inserted</span><span class="p">;</span>
  <span class="n">NodeType</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_constructors"><a class="link" href="#unordered_node_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_default_constructor"><a class="link" href="#unordered_node_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count_constructor"><a class="link" href="#unordered_node_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor"><a class="link" href="#unordered_node_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_constructor"><a class="link" href="#unordered_node_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_constructor"><a class="link" href="#unordered_node_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_node_set_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_allocator_constructor"><a class="link" href="#unordered_node_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_set</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_constructor_with_allocator"><a class="link" href="#unordered_node_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_constructor_with_allocator"><a class="link" href="#unordered_node_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the element nodes of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor"><a class="link" href="#unordered_node_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_node_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_node_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_node_set_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_destructor"><a class="link" href="#unordered_node_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_node_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_assignment"><a class="link" href="#unordered_node_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_copy_assignment"><a class="link" href="#unordered_node_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_assignment"><a class="link" href="#unordered_node_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">((</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">value_type</span><span class="o">*&gt;::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_assignment"><a class="link" href="#unordered_node_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_iterators"><a class="link" href="#unordered_node_set_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_begin"><a class="link" href="#unordered_node_set_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_end"><a class="link" href="#unordered_node_set_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_cbegin"><a class="link" href="#unordered_node_set_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_cend"><a class="link" href="#unordered_node_set_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_size_and_capacity"><a class="link" href="#unordered_node_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_empty"><a class="link" href="#unordered_node_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_size"><a class="link" href="#unordered_node_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_max_size"><a class="link" href="#unordered_node_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_modifiers"><a class="link" href="#unordered_node_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_emplace"><a class="link" href="#unordered_node_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_emplace_hint"><a class="link" href="#unordered_node_set_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_insert"><a class="link" href="#unordered_node_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_insert"><a class="link" href="#unordered_node_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_transparent_insert"><a class="link" href="#unordered_node_set_transparent_insert">Transparent Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_insert_with_hint"><a class="link" href="#unordered_node_set_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_insert_with_hint"><a class="link" href="#unordered_node_set_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_transparent_insert_with_hint"><a class="link" href="#unordered_node_set_transparent_insert_with_hint">Transparent Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_iterator_range"><a class="link" href="#unordered_node_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_initializer_list"><a class="link" href="#unordered_node_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_node"><a class="link" href="#unordered_node_set_insert_node">Insert Node</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.value()</code>.
<code>nh</code> is empty when the function returns.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An <code>insert_return_type</code> object constructed from <code>position</code>, <code>inserted</code> and <code>node</code>:<br></p>
<div class="ulist">
<ul>
<li>
<p>If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty.</p>
</li>
<li>
<p>Otherwise if the insertion took place, <code>inserted</code> is true, <code>position</code> points to the inserted element, and <code>node</code> is empty.</p>
</li>
<li>
<p>If the insertion failed, <code>inserted</code> is false, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.value()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_node_with_hint"><a class="link" href="#unordered_node_set_insert_node_with_hint">Insert Node with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.value()</code>.
<code>nh</code> becomes empty if insertion took place, otherwise it is not changed.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator returned is <code>end()</code> if <code>nh</code> is empty.
If insertion took place, then the iterator points to the newly inserted element; otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_erase_by_position"><a class="link" href="#unordered_node_set_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n"><em>convertible</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">iterator</em></span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An opaque object implicitly convertible to the <code>iterator</code> or <code>const_iterator</code>
immediately following <code>position</code> prior to the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The opaque object returned must only be discarded or immediately converted to <code>iterator</code> or <code>const_iterator</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_erase_by_key"><a class="link" href="#unordered_node_set_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_erase_range"><a class="link" href="#unordered_node_set_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_swap"><a class="link" href="#unordered_node_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_extract_by_position"><a class="link" href="#unordered_node_set_extract_by_position">Extract by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_extract_by_key"><a class="link" href="#unordered_node_set_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element with key equivalent to <code>k</code>, if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element, or empty if no element was extracted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_clear"><a class="link" href="#unordered_node_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_merge"><a class="link" href="#unordered_node_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Transfers all the element nodes from <code>source</code> whose key is not already present in <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>this-&gt;get_allocator() == source.get_allocator()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates iterators to the elements transferred.
If the resulting size of <code>*this</code> is greater than its original maximum load,
invalidates all iterators associated to <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_observers"><a class="link" href="#unordered_node_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_get_allocator"><a class="link" href="#unordered_node_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_hash_function"><a class="link" href="#unordered_node_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_key_eq"><a class="link" href="#unordered_node_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_lookup"><a class="link" href="#unordered_node_set_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_find"><a class="link" href="#unordered_node_set_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_count"><a class="link" href="#unordered_node_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_contains"><a class="link" href="#unordered_node_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_equal_range"><a class="link" href="#unordered_node_set_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_bucket_interface"><a class="link" href="#unordered_node_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count"><a class="link" href="#unordered_node_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_hash_policy"><a class="link" href="#unordered_node_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_load_factor"><a class="link" href="#unordered_node_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_max_load_factor"><a class="link" href="#unordered_node_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_set_max_load_factor"><a class="link" href="#unordered_node_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_max_load"><a class="link" href="#unordered_node_set_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_rehash"><a class="link" href="#unordered_node_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array. If the provided Allocator uses fancy pointers, a default allocation is subsequently performed.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_reserve"><a class="link" href="#unordered_node_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_deduction_guides"><a class="link" href="#unordered_node_set_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iter_value_type"><a class="link" href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_equality_comparisons"><a class="link" href="#unordered_node_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_operator"><a class="link" href="#unordered_node_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_operator_2"><a class="link" href="#unordered_node_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_swap_2"><a class="link" href="#unordered_node_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_erase_if"><a class="link" href="#unordered_node_set_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_serialization"><a class="link" href="#unordered_node_set_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>unordered_node_set</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="unordered_node_set_saving_an_unordered_node_set_to_an_archive"><a class="link" href="#unordered_node_set_saving_an_unordered_node_set_to_an_archive">Saving an unordered_node_set to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of an <code>unordered_node_set</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code>
is serializable (XML serializable), and it supports Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_loading_an_unordered_node_set_from_an_archive"><a class="link" href="#unordered_node_set_loading_an_unordered_node_set_from_an_archive">Loading an unordered_node_set from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of an <code>unordered_node_set</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>unordered_node_set</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.
<code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_saving_an_iteratorconst_iterator_to_an_archive"><a class="link" href="#unordered_node_set_saving_an_iteratorconst_iterator_to_an_archive">Saving an iterator/const_iterator to an archive</a></h5>
<div class="paragraph">
<p>Saves the positional information of an <code>iterator</code> (<code>const_iterator</code>) <code>it</code>
to an archive (XML archive) <code>ar</code>. <code>it</code> can be and <code>end()</code> iterator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>The <code>unordered_node_set</code> <code>x</code> pointed to by <code>it</code> has been previously saved to <code>ar</code>,
and no modifying operations have been issued on <code>x</code> between saving of <code>x</code> and
saving of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_loading_an_iteratorconst_iterator_from_an_archive"><a class="link" href="#unordered_node_set_loading_an_iteratorconst_iterator_from_an_archive">Loading an iterator/const_iterator from an archive</a></h5>
<div class="paragraph">
<p>Makes an <code>iterator</code> (<code>const_iterator</code>) <code>it</code> point to the restored position of
the original <code>iterator</code> (<code>const_iterator</code>) saved to the storage read by
an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If <code>x</code> is the <code>unordered_node_set</code> <code>it</code> points to, no modifying operations
have been issued on <code>x</code> between loading of <code>x</code> and loading of <code>it</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrent_flat_map"><a class="link" href="#concurrent_flat_map">Class Template concurrent_flat_map</a></h3>
<div class="paragraph">
<p><code>boost::concurrent_flat_map</code>  A hash table that associates unique keys with another value and
allows for concurrent element insertion, erasure, lookup and access
without external synchronization mechanisms.</p>
</div>
<div class="paragraph">
<p>Even though it acts as a container, <code>boost::concurrent_flat_map</code>
does not model the standard C++ <a href="https://en.cppreference.com/w/cpp/named_req/Container" target="_blank" rel="noopener">Container</a> concept.
In particular, iterators and associated operations (<code>begin</code>, <code>end</code>, etc.) are not provided.
Element access and modification are done through user-provided <em>visitation functions</em> that are passed
to <code>concurrent_flat_map</code> operations where they are executed internally in a controlled fashion.
Such visitation-based API allows for low-contention concurrent usage scenarios.</p>
</div>
<div class="paragraph">
<p>The internal data structure of <code>boost::concurrent_flat_map</code> is similar to that of
<code>boost::unordered_flat_map</code>. As a result of its using open-addressing techniques,
<code>value_type</code> must be move-constructible and pointer stability is not kept under rehashing.</p>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_synopsis"><a class="link" href="#concurrent_flat_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/concurrent_flat_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class concurrent_flat_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using init_type            = std::pair&lt;
                                   typename std::remove_const&lt;Key&gt;::type,
                                   typename std::remove_const&lt;T&gt;::type
                                 &gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    // constants
    static constexpr size_type <a href="#concurrent_flat_map_constants">bulk_visit_size</a> = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#concurrent_flat_map_default_constructor">concurrent_flat_map</a>();
    explicit <a href="#concurrent_flat_map_bucket_count_constructor">concurrent_flat_map</a>(size_type n,
                                 const hasher&amp; hf = hasher(),
                                 const key_equal&amp; eql = key_equal(),
                                 const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_map_iterator_range_constructor">concurrent_flat_map</a>(InputIterator f, InputIterator l,
                          size_type n = <em>implementation-defined</em>,
                          const hasher&amp; hf = hasher(),
                          const key_equal&amp; eql = key_equal(),
                          const allocator_type&amp; a = allocator_type());
    <a href="#concurrent_flat_map_copy_constructor">concurrent_flat_map</a>(const concurrent_flat_map&amp; other);
    <a href="#concurrent_flat_map_move_constructor">concurrent_flat_map</a>(concurrent_flat_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_map_iterator_range_constructor_with_allocator">concurrent_flat_map</a>(InputIterator f, InputIterator l,const allocator_type&amp; a);
    explicit <a href="#concurrent_flat_map_allocator_constructor">concurrent_flat_map</a>(const Allocator&amp; a);
    <a href="#concurrent_flat_map_copy_constructor_with_allocator">concurrent_flat_map</a>(const concurrent_flat_map&amp; other, const Allocator&amp; a);
    <a href="#concurrent_flat_map_move_constructor_with_allocator">concurrent_flat_map</a>(concurrent_flat_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#concurrent_flat_map_move_constructor_from_unordered_flat_map">concurrent_flat_map</a>(unordered_flat_map&lt;Key, T, Hash, Pred, Allocator&gt;&amp;&amp; other);
    <a href="#concurrent_flat_map_initializer_list_constructor">concurrent_flat_map</a>(std::initializer_list&lt;value_type&gt; il,
                        size_type n = <em>implementation-defined</em>
                        const hasher&amp; hf = hasher(),
                        const key_equal&amp; eql = key_equal(),
                        const allocator_type&amp; a = allocator_type());
    <a href="#concurrent_flat_map_bucket_count_constructor_with_allocator">concurrent_flat_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#concurrent_flat_map_bucket_count_constructor_with_hasher_and_allocator">concurrent_flat_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_map_iterator_range_constructor_with_bucket_count_and_allocator">concurrent_flat_map</a>(InputIterator f, InputIterator l, size_type n,
                          const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_map_iterator_range_constructor_with_bucket_count_and_hasher">concurrent_flat_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                          const allocator_type&amp; a);
    <a href="#concurrent_flat_map_initializer_list_constructor_with_allocator">concurrent_flat_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#concurrent_flat_map_initializer_list_constructor_with_bucket_count_and_allocator">concurrent_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                        const allocator_type&amp; a);
    <a href="#concurrent_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">concurrent_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                        const allocator_type&amp; a);
    <a href="#concurrent_flat_map_destructor">~concurrent_flat_map</a>();
    concurrent_flat_map&amp; <a href="#concurrent_flat_map_copy_assignment">operator=</a>(const concurrent_flat_map&amp; other);
    concurrent_flat_map&amp; <a href="#concurrent_flat_map_move_assignment">operator=</a>(concurrent_flat_map&amp;&amp; other) noexcept(
      (boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
       boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value) &amp;&amp;
       std::is_same&lt;pointer, value_type*&gt;::value);
    concurrent_flat_map&amp; <a href="#concurrent_flat_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#concurrent_flat_map_get_allocator">get_allocator</a>() const noexcept;


    // visitation
    template&lt;class F&gt; size_t <a href="#concurrent_flat_map_cvisit">visit</a>(const key_type&amp; k, F f);
    template&lt;class F&gt; size_t <a href="#concurrent_flat_map_cvisit">visit</a>(const key_type&amp; k, F f) const;
    template&lt;class F&gt; size_t <a href="#concurrent_flat_map_cvisit">cvisit</a>(const key_type&amp; k, F f) const;
    template&lt;class K, class F&gt; size_t <a href="#concurrent_flat_map_cvisit">visit</a>(const K&amp; k, F f);
    template&lt;class K, class F&gt; size_t <a href="#concurrent_flat_map_cvisit">visit</a>(const K&amp; k, F f) const;
    template&lt;class K, class F&gt; size_t <a href="#concurrent_flat_map_cvisit">cvisit</a>(const K&amp; k, F f) const;

    template&lt;class FwdIterator, class F&gt;
      size_t <a href="#concurrent_flat_map_bulk_visit">visit</a>(FwdIterator first, FwdIterator last, F f);
    template&lt;class FwdIterator, class F&gt;
      size_t <a href="#concurrent_flat_map_bulk_visit">visit</a>(FwdIterator first, FwdIterator last, F f) const;
    template&lt;class FwdIterator, class F&gt;
      size_t <a href="#concurrent_flat_map_bulk_visit">cvisit</a>(FwdIterator first, FwdIterator last, F f) const;

    template&lt;class F&gt; size_t <a href="#concurrent_flat_map_cvisit_all">visit_all</a>(F f);
    template&lt;class F&gt; size_t <a href="#concurrent_flat_map_cvisit_all">visit_all</a>(F f) const;
    template&lt;class F&gt; size_t <a href="#concurrent_flat_map_cvisit_all">cvisit_all</a>(F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      void <a href="#concurrent_flat_map_parallel_cvisit_all">visit_all</a>(ExecutionPolicy&amp;&amp; policy, F f);
    template&lt;class ExecutionPolicy, class F&gt;
      void <a href="#concurrent_flat_map_parallel_cvisit_all">visit_all</a>(ExecutionPolicy&amp;&amp; policy, F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      void <a href="#concurrent_flat_map_parallel_cvisit_all">cvisit_all</a>(ExecutionPolicy&amp;&amp; policy, F f) const;

    template&lt;class F&gt; bool <a href="#concurrent_flat_map_cvisit_while">visit_while</a>(F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_cvisit_while">visit_while</a>(F f) const;
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_cvisit_while">cvisit_while</a>(F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      bool <a href="#concurrent_flat_map_parallel_cvisit_while">visit_while</a>(ExecutionPolicy&amp;&amp; policy, F f);
    template&lt;class ExecutionPolicy, class F&gt;
      bool <a href="#concurrent_flat_map_parallel_cvisit_while">visit_while</a>(ExecutionPolicy&amp;&amp; policy, F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      bool <a href="#concurrent_flat_map_parallel_cvisit_while">cvisit_while</a>(ExecutionPolicy&amp;&amp; policy, F f) const;

    // capacity
    [[nodiscard]] bool <a href="#concurrent_flat_map_empty">empty</a>() const noexcept;
    size_type <a href="#concurrent_flat_map_size">size</a>() const noexcept;
    size_type <a href="#concurrent_flat_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; bool <a href="#concurrent_flat_map_emplace">emplace</a>(Args&amp;&amp;... args);
    bool <a href="#concurrent_flat_map_copy_insert">insert</a>(const value_type&amp; obj);
    bool <a href="#concurrent_flat_map_copy_insert">insert</a>(const init_type&amp; obj);
    bool <a href="#concurrent_flat_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    bool <a href="#concurrent_flat_map_move_insert">insert</a>(init_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; size_type <a href="#concurrent_flat_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    size_type <a href="#concurrent_flat_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    template&lt;class... Args, class F&gt; bool <a href="#concurrent_flat_map_emplace_or_cvisit">emplace_or_visit</a>(Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class... Args, class F&gt; bool <a href="#concurrent_flat_map_emplace_or_cvisit">emplace_or_cvisit</a>(Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_copy_insert_or_cvisit">insert_or_visit</a>(const value_type&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_copy_insert_or_cvisit">insert_or_cvisit</a>(const value_type&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_copy_insert_or_cvisit">insert_or_visit</a>(const init_type&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_copy_insert_or_cvisit">insert_or_cvisit</a>(const init_type&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_move_insert_or_cvisit">insert_or_visit</a>(value_type&amp;&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_move_insert_or_cvisit">insert_or_cvisit</a>(value_type&amp;&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_move_insert_or_cvisit">insert_or_visit</a>(init_type&amp;&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_map_move_insert_or_cvisit">insert_or_cvisit</a>(init_type&amp;&amp; obj, F f);
    template&lt;class InputIterator,class F&gt;
      size_type <a href="#concurrent_flat_map_insert_iterator_range_or_visit">insert_or_visit</a>(InputIterator first, InputIterator last, F f);
    template&lt;class InputIterator,class F&gt;
      size_type <a href="#concurrent_flat_map_insert_iterator_range_or_visit">insert_or_cvisit</a>(InputIterator first, InputIterator last, F f);
    template&lt;class F&gt; size_type <a href="#concurrent_flat_map_insert_initializer_list_or_visit">insert_or_visit</a>(std::initializer_list&lt;value_type&gt; il, F f);
    template&lt;class F&gt; size_type <a href="#concurrent_flat_map_insert_initializer_list_or_visit">insert_or_cvisit</a>(std::initializer_list&lt;value_type&gt; il, F f);

    template&lt;class... Args&gt; bool <a href="#concurrent_flat_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt; bool <a href="#concurrent_flat_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt; bool <a href="#concurrent_flat_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);

    template&lt;class... Args, class F&gt;
      bool <a href="#concurrent_flat_map_try_emplace_or_cvisit">try_emplace_or_visit</a>(const key_type&amp; k, Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class... Args, class F&gt;
      bool <a href="#concurrent_flat_map_try_emplace_or_cvisit">try_emplace_or_cvisit</a>(const key_type&amp; k, Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class... Args, class F&gt;
      bool <a href="#concurrent_flat_map_try_emplace_or_cvisit">try_emplace_or_visit</a>(key_type&amp;&amp; k, Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class... Args, class F&gt;
      bool <a href="#concurrent_flat_map_try_emplace_or_cvisit">try_emplace_or_cvisit</a>(key_type&amp;&amp; k, Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class K, class... Args, class F&gt;
      bool <a href="#concurrent_flat_map_try_emplace_or_cvisit">try_emplace_or_visit</a>(K&amp;&amp; k, Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class K, class... Args, class F&gt;
      bool <a href="#concurrent_flat_map_try_emplace_or_cvisit">try_emplace_or_cvisit</a>(K&amp;&amp; k, Args&amp;&amp;... args, F&amp;&amp; f);

    template&lt;class M&gt; bool <a href="#concurrent_flat_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt; bool <a href="#concurrent_flat_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt; bool <a href="#concurrent_flat_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);

    size_type <a href="#concurrent_flat_map_erase">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#concurrent_flat_map_erase">erase</a>(const K&amp; k);

    template&lt;class F&gt; size_type <a href="#concurrent_flat_map_erase_if_by_key">erase_if</a>(const key_type&amp; k, F f);
    template&lt;class K, class F&gt; size_type <a href="#concurrent_flat_map_erase_if_by_key">erase_if</a>(const K&amp; k, F f);
    template&lt;class F&gt; size_type <a href="#concurrent_flat_map_erase_if">erase_if</a>(F f);
    template&lt;class ExecutionPolicy, class  F&gt; void <a href="#concurrent_flat_map_parallel_erase_if">erase_if</a>(ExecutionPolicy&amp;&amp; policy, F f);

    void      <a href="#concurrent_flat_map_swap">swap</a>(concurrent_flat_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#concurrent_flat_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      size_type <a href="#concurrent_flat_map_merge">merge</a>(concurrent_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      size_type <a href="#concurrent_flat_map_merge">merge</a>(concurrent_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#concurrent_flat_map_hash_function">hash_function</a>() const;
    key_equal <a href="#concurrent_flat_map_key_eq">key_eq</a>() const;

    // map operations
    size_type        <a href="#concurrent_flat_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#concurrent_flat_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#concurrent_flat_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#concurrent_flat_map_contains">contains</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#concurrent_flat_map_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#concurrent_flat_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#concurrent_flat_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#concurrent_flat_map_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#concurrent_flat_map_max_load">max_load</a>() const noexcept;
    void <a href="#concurrent_flat_map_rehash">rehash</a>(size_type n);
    void <a href="#concurrent_flat_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#concurrent_flat_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    concurrent_flat_map(InputIterator, InputIterator, typename <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>,
                        Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; concurrent_flat_map&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#concurrent_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                             Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    concurrent_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                        typename <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                        Pred = Pred(), Allocator = Allocator())
      -&gt; concurrent_flat_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    concurrent_flat_map(InputIterator, InputIterator, typename <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; concurrent_flat_map&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#concurrent_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                             boost::hash&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                             std::equal_to&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    concurrent_flat_map(InputIterator, InputIterator, Allocator)
      -&gt; concurrent_flat_map&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#concurrent_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                             boost::hash&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                             std::equal_to&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    concurrent_flat_map(InputIterator, InputIterator, typename <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                        Allocator)
      -&gt; concurrent_flat_map&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#concurrent_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                             std::equal_to&lt;<a href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    concurrent_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                        Allocator)
      -&gt; concurrent_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    concurrent_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; concurrent_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    concurrent_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#concurrent_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                        Hash, Allocator)
      -&gt; concurrent_flat_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#concurrent_flat_map_operator">operator==</a>(const concurrent_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const concurrent_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#concurrent_flat_map_operator_2">operator!=</a>(const concurrent_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const concurrent_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#concurrent_flat_map_swap_2">swap</a>(concurrent_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              concurrent_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename concurrent_flat_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#concurrent_flat_map_erase_if_2">erase_if</a>(concurrent_flat_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_description"><a class="link" href="#concurrent_flat_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Key</code> and <code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible" target="_blank" rel="noopener">MoveConstructible</a>.
<code>std::pair&lt;const Key, T&gt;</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
into the table from any <code>std::pair</code> object convertible to it, and it also must be
<a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the table&#8217;s value type.
Allocators using <a href="https://en.cppreference.com/w/cpp/named_req/Allocator#Fancy_pointers">fancy pointers</a> are supported.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the table are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the table (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_concurrency_requirements_and_guarantees"><a class="link" href="#concurrent_flat_map_concurrency_requirements_and_guarantees">Concurrency Requirements and Guarantees</a></h4>
<div class="paragraph">
<p>Concurrent invocations of <code>operator()</code> on the same const instance of <code>Hash</code> or <code>Pred</code> are required
to not introduce data races. For <code>Alloc</code> being either <code>Allocator</code> or any allocator type rebound
from <code>Allocator</code>, concurrent invocations of the following operations on the same instance <code>al</code> of <code>Alloc</code>
are required to not introduce data races:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Copy construction from <code>al</code> of an allocator rebound from <code>Alloc</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::allocate</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::deallocate</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::construct</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::destroy</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In general, these requirements on <code>Hash</code>, <code>Pred</code> and <code>Allocator</code> are met if these types
are not stateful or if the operations only involve constant access to internal data members.</p>
</div>
<div class="paragraph">
<p>With the exception of destruction, concurrent invocations of any operation on the same instance of a
<code>concurrent_flat_map</code> do not introduce data races  that is, they are thread-safe.</p>
</div>
<div class="paragraph">
<p>If an operation <strong>op</strong> is explicitly designated as <em>blocking on</em> <code>x</code>, where <code>x</code> is an instance of a <code>boost::concurrent_flat_map</code>,
prior blocking operations on <code>x</code> synchronize with <strong>op</strong>. So, blocking operations on the same
<code>concurrent_flat_map</code> execute sequentially in a multithreaded scenario.</p>
</div>
<div class="paragraph">
<p>An operation is said to be <em>blocking on rehashing of</em> <code><em>x</em></code> if it blocks on <code>x</code>
only when an internal rehashing is issued.</p>
</div>
<div class="paragraph">
<p>Access or modification of an element of a <code>boost::concurrent_flat_map</code> passed by reference to a
user-provided visitation function do not introduce data races when the visitation function
is executed internally by the <code>boost::concurrent_flat_map</code>.</p>
</div>
<div class="paragraph">
<p>Any <code>boost::concurrent_flat_map operation</code> that inserts or modifies an element <code>e</code>
synchronizes with the internal invocation of a visitation function on <code>e</code>.</p>
</div>
<div class="paragraph">
<p>Visitation functions executed by a <code>boost::concurrent_flat_map</code> <code>x</code> are not allowed to invoke any operation
on <code>x</code>; invoking operations on a different <code>boost::concurrent_flat_map</code> instance <code>y</code> is allowed only
if concurrent outstanding operations on <code>y</code> do not access <code>x</code> directly or indirectly.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_configuration_macros"><a class="link" href="#concurrent_flat_map_configuration_macros">Configuration Macros</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_boost_unordered_disable_reentrancy_check"><a class="link" href="#concurrent_flat_map_boost_unordered_disable_reentrancy_check"><code>BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK</code></a></h5>
<div class="paragraph">
<p>In debug builds (more precisely, when
<a href="../../../assert/doc/html/assert.html#boost_assert_is_void" target="_blank" rel="noopener"><code>BOOST_ASSERT_IS_VOID</code></a>
is not defined), <em>container reentrancies</em> (illegaly invoking an operation on <code>m</code> from within
a function visiting elements of <code>m</code>) are detected and signalled through <code>BOOST_ASSERT_MSG</code>.
When run-time speed is a concern, the feature can be disabled by globally defining
this macro.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_constants"><a class="link" href="#concurrent_flat_map_constants">Constants</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">static</span> <span class="k">constexpr</span> <span class="n">size_type</span> <span class="n">bulk_visit_size</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Chunk size internally used in <a href="#concurrent_flat_map_bulk_visit">bulk visit</a> operations.</p>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_constructors"><a class="link" href="#concurrent_flat_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_default_constructor"><a class="link" href="#concurrent_flat_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_bucket_count_constructor"><a class="link" href="#concurrent_flat_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">concurrent_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                             <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                             <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iterator_range_constructor"><a class="link" href="#concurrent_flat_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                      <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                      <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                      <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_copy_constructor"><a class="link" href="#concurrent_flat_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">concurrent_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_move_constructor"><a class="link" href="#concurrent_flat_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new table.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iterator_range_constructor_with_allocator"><a class="link" href="#concurrent_flat_map_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_allocator_constructor"><a class="link" href="#concurrent_flat_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">concurrent_flat_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_copy_constructor_with_allocator"><a class="link" href="#concurrent_flat_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">concurrent_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a table, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_move_constructor_with_allocator"><a class="link" href="#concurrent_flat_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new table;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_move_constructor_from_unordered_flat_map"><a class="link" href="#concurrent_flat_map_move_constructor_from_unordered_flat_map">Move Constructor from unordered_flat_map</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move construction from a <a href="#unordered_flat_map"><code>unordered_flat_map</code></a>.
The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_initializer_list_constructor"><a class="link" href="#concurrent_flat_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                    <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
                    <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                    <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                    <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_bucket_count_constructor_with_allocator"><a class="link" href="#concurrent_flat_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#concurrent_flat_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#concurrent_flat_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#concurrent_flat_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_initializer_list_constructor_with_allocator"><a class="link" href="#concurrent_flat_map_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#concurrent_flat_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#concurrent_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_destructor"><a class="link" href="#concurrent_flat_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">concurrent_flat_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_assignment"><a class="link" href="#concurrent_flat_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_copy_assignment"><a class="link" href="#concurrent_flat_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">concurrent_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_move_assignment"><a class="link" href="#concurrent_flat_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">((</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">pointer</span><span class="p">,</span> <span class="n">value_type</span><span class="o">*&gt;::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to <code>*this</code>;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_initializer_list_assignment"><a class="link" href="#concurrent_flat_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_visitation"><a class="link" href="#concurrent_flat_map_visitation">Visitation</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_cvisit"><a class="link" href="#concurrent_flat_map_cvisit">[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="nf">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="nf">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If an element <code>x</code> exists with key equivalent to <code>k</code>, invokes <code>f</code> with a reference to <code>x</code>.
Such reference is const iff <code>*this</code> is const.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements visited (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K, class F&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_bulk_visit"><a class="link" href="#concurrent_flat_map_bulk_visit">Bulk visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">FwdIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">size_t</span> <span class="nf">visit</span><span class="p">(</span><span class="n">FwdIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">FwdIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">FwdIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">size_t</span> <span class="n">visit</span><span class="p">(</span><span class="n">FwdIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">FwdIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">FwdIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">size_t</span> <span class="n">cvisit</span><span class="p">(</span><span class="n">FwdIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">FwdIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For each element <code>k</code> in the range [<code>first</code>, <code>last</code>),
if there is an element <code>x</code> in the container with key equivalent to <code>k</code>,
invokes <code>f</code> with a reference to <code>x</code>.
Such reference is const iff <code>*this</code> is const.</p>
</div>
<div class="paragraph">
<p>Although functionally equivalent to individually invoking
<a href="#concurrent_flat_map_cvisit"><code>[c]visit</code></a> for each key, bulk visitation
performs generally faster due to internal streamlining optimizations.
It is advisable that <code>std::distance(first,last)</code> be at least
<a href="#concurrent_flat_map_constants"><code>bulk_visit_size</code></a> to enjoy
a performance gain: beyond this size, performance is not expected
to increase further.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>FwdIterator</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator" target="_blank" rel="noopener">LegacyForwardIterator</a>
(C++11 to C++17),
or satisfies <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator" target="_blank" rel="noopener">std::forward_iterator</a> (C++20 and later).
For <code>K</code> = <code>std::iterator_traits&lt;FwdIterator&gt;::value_type</code>, either <code>K</code> is <code>key_type</code> or
else <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs.
In the latter case, the library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent.
This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements visited.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_cvisit_all"><a class="link" href="#concurrent_flat_map_cvisit_all">[c]visit_all</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="nf">visit_all</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">visit_all</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">cvisit_all</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Successively invokes <code>f</code> with references to each of the elements in the table.
Such references are const iff <code>*this</code> is const.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements visited.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_parallel_cvisit_all"><a class="link" href="#concurrent_flat_map_parallel_cvisit_all">Parallel [c]visit_all</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">visit_all</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">visit_all</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">cvisit_all</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invokes <code>f</code> with references to each of the elements in the table. Such references are const iff <code>*this</code> is const.
Execution is parallelized according to the semantics of the execution policy specified.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Depending on the exception handling mechanism of the execution policy used, may call <code>std::terminate</code> if an exception is thrown within <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Only available in compilers supporting C++17 parallel algorithms.<br></p>
<div class="paragraph">
<p>These overloads only participate in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>true</code>.<br></p>
</div>
<div class="paragraph">
<p>Unsequenced execution policies are not allowed.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_cvisit_while"><a class="link" href="#concurrent_flat_map_cvisit_while">[c]visit_while</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">visit_while</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">visit_while</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">cvisit_while</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Successively invokes <code>f</code> with references to each of the elements in the table until <code>f</code> returns <code>false</code>
or all the elements are visited.
Such references to the elements are const iff <code>*this</code> is const.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>false</code> iff <code>f</code> ever returns <code>false</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_parallel_cvisit_while"><a class="link" href="#concurrent_flat_map_parallel_cvisit_while">Parallel [c]visit_while</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">visit_while</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">visit_while</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">cvisit_while</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invokes <code>f</code> with references to each of the elements in the table until <code>f</code> returns <code>false</code>
or all the elements are visited.
Such references to the elements are const iff <code>*this</code> is const.
Execution is parallelized according to the semantics of the execution policy specified.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>false</code> iff <code>f</code> ever returns <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Depending on the exception handling mechanism of the execution policy used, may call <code>std::terminate</code> if an exception is thrown within <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Only available in compilers supporting C++17 parallel algorithms.<br></p>
<div class="paragraph">
<p>These overloads only participate in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>true</code>.<br></p>
</div>
<div class="paragraph">
<p>Unsequenced execution policies are not allowed.<br></p>
</div>
<div class="paragraph">
<p>Parallelization implies that execution does not necessary finish as soon as <code>f</code> returns <code>false</code>, and as a result
<code>f</code> may be invoked with further elements for which the return value is also <code>false</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_size_and_capacity"><a class="link" href="#concurrent_flat_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_empty"><a class="link" href="#concurrent_flat_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_size"><a class="link" href="#concurrent_flat_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in the table.</p>
</td>
</tr>
</table>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true size of the table right after execution.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_max_size"><a class="link" href="#concurrent_flat_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible table.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_modifiers"><a class="link" href="#concurrent_flat_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_emplace"><a class="link" href="#concurrent_flat_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the table if and only if there is no element in the table with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_copy_insert"><a class="link" href="#concurrent_flat_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_move_insert"><a class="link" href="#concurrent_flat_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">insert</span><span class="p">(</span><span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_insert_iterator_range"><a class="link" href="#concurrent_flat_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  while(first != last) this-&gt;<a href="#concurrent_flat_map_emplace">emplace</a>(*first++);</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_insert_initializer_list"><a class="link" href="#concurrent_flat_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  this-&gt;<a href="#concurrent_flat_map_insert_iterator_range">insert</a>(il.begin(), il.end());</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_emplace_or_cvisit"><a class="link" href="#concurrent_flat_map_emplace_or_cvisit">emplace_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">emplace_or_visit</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">emplace_or_cvisit</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the table if there is no element in the table with an equivalent key.
Otherwise, invokes <code>f</code> with a reference to the equivalent element; such reference is const iff <code>emplace_or_cvisit</code> is used.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>The interface is exposition only, as C++ does not allow to declare a parameter <code>f</code> after a variadic parameter pack.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_copy_insert_or_cvisit"><a class="link" href="#concurrent_flat_map_copy_insert_or_cvisit">Copy insert_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.
Otherwise, invokes <code>f</code> with a reference to the equivalent element; such reference is const iff a <code>*_cvisit</code> overload is used.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>In a call of the form <code>insert_or_[c]visit(obj, f)</code>, the overloads accepting a <code>const value_type&amp;</code> argument participate in overload resolution
only if <code>std::remove_cv&lt;std::remove_reference&lt;decltype(obj)&gt;::type&gt;::type</code> is <code>value_type</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_move_insert_or_cvisit"><a class="link" href="#concurrent_flat_map_move_insert_or_cvisit">Move insert_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.
Otherwise, invokes <code>f</code> with a reference to the equivalent element; such reference is const iff a <code>*_cvisit</code> overload is used.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>In a call of the form <code>insert_or_[c]visit(obj, f)</code>, the overloads accepting a <code>value_type&amp;&amp;</code> argument participate in overload resolution
only if <code>std::remove_reference&lt;decltype(obj)&gt;::type</code> is <code>value_type</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_insert_iterator_range_or_visit"><a class="link" href="#concurrent_flat_map_insert_iterator_range_or_visit">Insert Iterator Range or Visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
    <span class="n">size_type</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
    <span class="n">size_type</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  while(first != last) this-&gt;<a href="#concurrent_flat_map_emplace_or_cvisit">emplace_or_[c]visit</a>(*first++, f);</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_insert_initializer_list_or_visit"><a class="link" href="#concurrent_flat_map_insert_initializer_list_or_visit">Insert Initializer List or Visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  this-&gt;<a href="#concurrent_flat_map_insert_iterator_range_or_visit">insert_or[c]visit</a>(il.begin(), il.end(), f);</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_try_emplace"><a class="link" href="#concurrent_flat_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>k</code> and <code>args</code> into the table if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#concurrent_flat_map_emplace">emplace</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#concurrent_flat_map_emplace">emplace</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_try_emplace_or_cvisit"><a class="link" href="#concurrent_flat_map_try_emplace_or_cvisit">try_emplace_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">try_emplace_or_visit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">try_emplace_or_cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">try_emplace_or_visit</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">try_emplace_or_cvisit</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">try_emplace_or_visit</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">try_emplace_or_cvisit</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>k</code> and <code>args</code> into the table if there is no existing element with key <code>k</code> contained within it.
Otherwise, invokes <code>f</code> with a reference to the equivalent element; such reference is const iff a <code>*_cvisit</code> overload is used.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>No <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first four overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// last two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</div>
<div class="paragraph">
<p>The interface is exposition only, as C++ does not allow to declare a parameter <code>f</code> after a variadic parameter pack.</p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class... Args, class F&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_insert_or_assign"><a class="link" href="#concurrent_flat_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the table or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>std::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the table as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_erase"><a class="link" href="#concurrent_flat_map_erase">erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the element with key equivalent to <code>k</code> if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_erase_if_by_key"><a class="link" href="#concurrent_flat_map_erase_if_by_key">erase_if by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase_if</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase_if</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the element <code>x</code> with key equivalent to <code>k</code> if it exists and <code>f(x)</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code>, <code>key_equal</code> or <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K, class F&gt;</code> overload only participates in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>false</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class F&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_erase_if"><a class="link" href="#concurrent_flat_map_erase_if">erase_if</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase_if</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Successively invokes <code>f</code> with references to each of the elements in the table, and erases those for which <code>f</code> returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>f</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_parallel_erase_if"><a class="link" href="#concurrent_flat_map_parallel_erase_if">Parallel erase_if</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span>  <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">erase_if</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invokes <code>f</code> with references to each of the elements in the table, and erases those for which <code>f</code> returns <code>true</code>.
Execution is parallelized according to the semantics of the execution policy specified.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Depending on the exception handling mechanism of the execution policy used, may call <code>std::terminate</code> if an exception is thrown within <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Only available in compilers supporting C++17 parallel algorithms.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>true</code>.<br></p>
</div>
<div class="paragraph">
<p>Unsequenced execution policies are not allowed.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_swap"><a class="link" href="#concurrent_flat_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the table with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the tables' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_clear"><a class="link" href="#concurrent_flat_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the table.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_merge"><a class="link" href="#concurrent_flat_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="n">size_type</span> <span class="nf">merge</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="n">size_type</span> <span class="nf">merge</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>source</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_observers"><a class="link" href="#concurrent_flat_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_get_allocator"><a class="link" href="#concurrent_flat_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The table&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_hash_function"><a class="link" href="#concurrent_flat_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The table&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_key_eq"><a class="link" href="#concurrent_flat_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The table&#8217;s key equality predicate.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_map_operations"><a class="link" href="#concurrent_flat_map_map_operations">Map Operations</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_count"><a class="link" href="#concurrent_flat_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code> (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.<br></p>
<div class="paragraph">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true state of the table right after execution.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_contains"><a class="link" href="#concurrent_flat_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>k</code> in the table.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type. <br></p>
<div class="paragraph">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true state of the table right after execution.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_bucket_interface"><a class="link" href="#concurrent_flat_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_bucket_count"><a class="link" href="#concurrent_flat_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_hash_policy"><a class="link" href="#concurrent_flat_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_load_factor"><a class="link" href="#concurrent_flat_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_max_load_factor"><a class="link" href="#concurrent_flat_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the table&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_set_max_load_factor"><a class="link" href="#concurrent_flat_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_max_load"><a class="link" href="#concurrent_flat_map_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the table can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the table&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.<br></p>
<div class="paragraph">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true state of the table right after execution.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_rehash"><a class="link" href="#concurrent_flat_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the table.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates pointers and references to elements, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the table&#8217;s hash function or comparison function.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
<hr>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_reserve"><a class="link" href="#concurrent_flat_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the table.</p>
</div>
<div class="paragraph">
<p>Invalidates pointers and references to elements, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the table&#8217;s hash function or comparison function.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_deduction_guides"><a class="link" href="#concurrent_flat_map_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
table type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iter_value_type"><a class="link" href="#concurrent_flat_map_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iter_key_type"><a class="link" href="#concurrent_flat_map_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#concurrent_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iter_mapped_type"><a class="link" href="#concurrent_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#concurrent_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_iter_to_alloc_type"><a class="link" href="#concurrent_flat_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#concurrent_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#concurrent_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_equality_comparisons"><a class="link" href="#concurrent_flat_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_map_operator"><a class="link" href="#concurrent_flat_map_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code> and <code>y</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two tables don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_operator_2"><a class="link" href="#concurrent_flat_map_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code> and <code>y</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two tables don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_swap_2"><a class="link" href="#concurrent_flat_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>x.<a href="#concurrent_flat_map_swap">swap</a>(y);</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_erase_if_2"><a class="link" href="#concurrent_flat_map_erase_if_2">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">concurrent_flat_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>c.<a href="#concurrent_flat_map_erase_if">erase_if</a>(pred);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_map_serialization"><a class="link" href="#concurrent_flat_map_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>concurrent_flat_map</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_saving_an_concurrent_flat_map_to_an_archive"><a class="link" href="#concurrent_flat_map_saving_an_concurrent_flat_map_to_an_archive">Saving an concurrent_flat_map to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of a <code>concurrent_flat_map</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>std::remove_const&lt;key_type&gt;::type</code> and <code>std::remove_const&lt;mapped_type&gt;::type</code>
are serializable (XML serializable), and they do support Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_map_loading_an_concurrent_flat_map_from_an_archive"><a class="link" href="#concurrent_flat_map_loading_an_concurrent_flat_map_from_an_archive">Loading an concurrent_flat_map from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of a <code>concurrent_flat_map</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>concurrent_flat_map</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrent_flat_set"><a class="link" href="#concurrent_flat_set">Class Template concurrent_flat_set</a></h3>
<div class="paragraph">
<p><code>boost::concurrent_flat_set</code>  A hash table that stores unique values and
allows for concurrent element insertion, erasure, lookup and access
without external synchronization mechanisms.</p>
</div>
<div class="paragraph">
<p>Even though it acts as a container, <code>boost::concurrent_flat_set</code>
does not model the standard C++ <a href="https://en.cppreference.com/w/cpp/named_req/Container" target="_blank" rel="noopener">Container</a> concept.
In particular, iterators and associated operations (<code>begin</code>, <code>end</code>, etc.) are not provided.
Element access is done through user-provided <em>visitation functions</em> that are passed
to <code>concurrent_flat_set</code> operations where they are executed internally in a controlled fashion.
Such visitation-based API allows for low-contention concurrent usage scenarios.</p>
</div>
<div class="paragraph">
<p>The internal data structure of <code>boost::concurrent_flat_set</code> is similar to that of
<code>boost::unordered_flat_set</code>. As a result of its using open-addressing techniques,
<code>value_type</code> must be move-constructible and pointer stability is not kept under rehashing.</p>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_synopsis"><a class="link" href="#concurrent_flat_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/concurrent_flat_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class concurrent_flat_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using init_type            = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    // constants
    static constexpr size_type <a href="#concurrent_flat_set_constants">bulk_visit_size</a> = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#concurrent_flat_set_default_constructor">concurrent_flat_set</a>();
    explicit <a href="#concurrent_flat_set_bucket_count_constructor">concurrent_flat_set</a>(size_type n,
                                 const hasher&amp; hf = hasher(),
                                 const key_equal&amp; eql = key_equal(),
                                 const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_set_iterator_range_constructor">concurrent_flat_set</a>(InputIterator f, InputIterator l,
                          size_type n = <em>implementation-defined</em>,
                          const hasher&amp; hf = hasher(),
                          const key_equal&amp; eql = key_equal(),
                          const allocator_type&amp; a = allocator_type());
    <a href="#concurrent_flat_set_copy_constructor">concurrent_flat_set</a>(const concurrent_flat_set&amp; other);
    <a href="#concurrent_flat_set_move_constructor">concurrent_flat_set</a>(concurrent_flat_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_set_iterator_range_constructor_with_allocator">concurrent_flat_set</a>(InputIterator f, InputIterator l,const allocator_type&amp; a);
    explicit <a href="#concurrent_flat_set_allocator_constructor">concurrent_flat_set</a>(const Allocator&amp; a);
    <a href="#concurrent_flat_set_copy_constructor_with_allocator">concurrent_flat_set</a>(const concurrent_flat_set&amp; other, const Allocator&amp; a);
    <a href="#concurrent_flat_set_move_constructor_with_allocator">concurrent_flat_set</a>(concurrent_flat_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#concurrent_flat_set_move_constructor_from_unordered_flat_set">concurrent_flat_set</a>(unordered_flat_set&lt;Key, Hash, Pred, Allocator&gt;&amp;&amp; other);
    <a href="#concurrent_flat_set_initializer_list_constructor">concurrent_flat_set</a>(std::initializer_list&lt;value_type&gt; il,
                        size_type n = <em>implementation-defined</em>
                        const hasher&amp; hf = hasher(),
                        const key_equal&amp; eql = key_equal(),
                        const allocator_type&amp; a = allocator_type());
    <a href="#concurrent_flat_set_bucket_count_constructor_with_allocator">concurrent_flat_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#concurrent_flat_set_bucket_count_constructor_with_hasher_and_allocator">concurrent_flat_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_set_iterator_range_constructor_with_bucket_count_and_allocator">concurrent_flat_set</a>(InputIterator f, InputIterator l, size_type n,
                          const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#concurrent_flat_set_iterator_range_constructor_with_bucket_count_and_hasher">concurrent_flat_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                          const allocator_type&amp; a);
    <a href="#concurrent_flat_set_initializer_list_constructor_with_allocator">concurrent_flat_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#concurrent_flat_set_initializer_list_constructor_with_bucket_count_and_allocator">concurrent_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                        const allocator_type&amp; a);
    <a href="#concurrent_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">concurrent_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                        const allocator_type&amp; a);
    <a href="#concurrent_flat_set_destructor">~concurrent_flat_set</a>();
    concurrent_flat_set&amp; <a href="#concurrent_flat_set_copy_assignment">operator=</a>(const concurrent_flat_set&amp; other);
    concurrent_flat_set&amp; <a href="#concurrent_flat_set_move_assignment">operator=</a>(concurrent_flat_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
              boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    concurrent_flat_set&amp; <a href="#concurrent_flat_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#concurrent_flat_set_get_allocator">get_allocator</a>() const noexcept;


    // visitation
    template&lt;class F&gt; size_t <a href="#concurrent_flat_set_cvisit">visit</a>(const key_type&amp; k, F f) const;
    template&lt;class F&gt; size_t <a href="#concurrent_flat_set_cvisit">cvisit</a>(const key_type&amp; k, F f) const;
    template&lt;class K, class F&gt; size_t <a href="#concurrent_flat_set_cvisit">visit</a>(const K&amp; k, F f) const;
    template&lt;class K, class F&gt; size_t <a href="#concurrent_flat_set_cvisit">cvisit</a>(const K&amp; k, F f) const;

    template&lt;class FwdIterator, class F&gt;
      size_t <a href="#concurrent_flat_set_bulk_visit">visit</a>(FwdIterator first, FwdIterator last, F f) const;
    template&lt;class FwdIterator, class F&gt;
      size_t <a href="#concurrent_flat_set_bulk_visit">cvisit</a>(FwdIterator first, FwdIterator last, F f) const;

    template&lt;class F&gt; size_t <a href="#concurrent_flat_set_cvisit_all">visit_all</a>(F f) const;
    template&lt;class F&gt; size_t <a href="#concurrent_flat_set_cvisit_all">cvisit_all</a>(F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      void <a href="#concurrent_flat_set_parallel_cvisit_all">visit_all</a>(ExecutionPolicy&amp;&amp; policy, F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      void <a href="#concurrent_flat_set_parallel_cvisit_all">cvisit_all</a>(ExecutionPolicy&amp;&amp; policy, F f) const;

    template&lt;class F&gt; bool <a href="#concurrent_flat_set_cvisit_while">visit_while</a>(F f) const;
    template&lt;class F&gt; bool <a href="#concurrent_flat_set_cvisit_while">cvisit_while</a>(F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      bool <a href="#concurrent_flat_set_parallel_cvisit_while">visit_while</a>(ExecutionPolicy&amp;&amp; policy, F f) const;
    template&lt;class ExecutionPolicy, class F&gt;
      bool <a href="#concurrent_flat_set_parallel_cvisit_while">cvisit_while</a>(ExecutionPolicy&amp;&amp; policy, F f) const;

    // capacity
    [[nodiscard]] bool <a href="#concurrent_flat_set_empty">empty</a>() const noexcept;
    size_type <a href="#concurrent_flat_set_size">size</a>() const noexcept;
    size_type <a href="#concurrent_flat_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; bool <a href="#concurrent_flat_set_emplace">emplace</a>(Args&amp;&amp;... args);
    bool <a href="#concurrent_flat_set_copy_insert">insert</a>(const value_type&amp; obj);
    bool <a href="#concurrent_flat_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; bool <a href="#concurrent_flat_set_transparent_insert">insert</a>(K&amp;&amp; k);
    template&lt;class InputIterator&gt; size_type <a href="#concurrent_flat_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    size_type <a href="#concurrent_flat_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    template&lt;class... Args, class F&gt; bool <a href="#concurrent_flat_set_emplace_or_cvisit">emplace_or_visit</a>(Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class... Args, class F&gt; bool <a href="#concurrent_flat_set_emplace_or_cvisit">emplace_or_cvisit</a>(Args&amp;&amp;... args, F&amp;&amp; f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_set_copy_insert_or_cvisit">insert_or_visit</a>(const value_type&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_set_copy_insert_or_cvisit">insert_or_cvisit</a>(const value_type&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_set_move_insert_or_cvisit">insert_or_visit</a>(value_type&amp;&amp; obj, F f);
    template&lt;class F&gt; bool <a href="#concurrent_flat_set_move_insert_or_cvisit">insert_or_cvisit</a>(value_type&amp;&amp; obj, F f);
    template&lt;class K, class F&gt; bool <a href="#concurrent_flat_set_transparent_insert_or_cvisit">insert_or_visit</a>(K&amp;&amp; k, F f);
    template&lt;class K, class F&gt; bool <a href="#concurrent_flat_set_transparent_insert_or_cvisit">insert_or_cvisit</a>(K&amp;&amp; k, F f);
    template&lt;class InputIterator,class F&gt;
      size_type <a href="#concurrent_flat_set_insert_iterator_range_or_visit">insert_or_visit</a>(InputIterator first, InputIterator last, F f);
    template&lt;class InputIterator,class F&gt;
      size_type <a href="#concurrent_flat_set_insert_iterator_range_or_visit">insert_or_cvisit</a>(InputIterator first, InputIterator last, F f);
    template&lt;class F&gt; size_type <a href="#concurrent_flat_set_insert_initializer_list_or_visit">insert_or_visit</a>(std::initializer_list&lt;value_type&gt; il, F f);
    template&lt;class F&gt; size_type <a href="#concurrent_flat_set_insert_initializer_list_or_visit">insert_or_cvisit</a>(std::initializer_list&lt;value_type&gt; il, F f);

    size_type <a href="#concurrent_flat_set_erase">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#concurrent_flat_set_erase">erase</a>(const K&amp; k);

    template&lt;class F&gt; size_type <a href="#concurrent_flat_set_erase_if_by_key">erase_if</a>(const key_type&amp; k, F f);
    template&lt;class K, class F&gt; size_type <a href="#concurrent_flat_set_erase_if_by_key">erase_if</a>(const K&amp; k, F f);
    template&lt;class F&gt; size_type <a href="#concurrent_flat_set_erase_if">erase_if</a>(F f);
    template&lt;class ExecutionPolicy, class  F&gt; void <a href="#concurrent_flat_set_parallel_erase_if">erase_if</a>(ExecutionPolicy&amp;&amp; policy, F f);

    void      <a href="#concurrent_flat_set_swap">swap</a>(concurrent_flat_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#concurrent_flat_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      size_type <a href="#concurrent_flat_set_merge">merge</a>(concurrent_flat_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      size_type <a href="#concurrent_flat_set_merge">merge</a>(concurrent_flat_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#concurrent_flat_set_hash_function">hash_function</a>() const;
    key_equal <a href="#concurrent_flat_set_key_eq">key_eq</a>() const;

    // set operations
    size_type        <a href="#concurrent_flat_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#concurrent_flat_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#concurrent_flat_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#concurrent_flat_set_contains">contains</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#concurrent_flat_set_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#concurrent_flat_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#concurrent_flat_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#concurrent_flat_set_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#concurrent_flat_set_max_load">max_load</a>() const noexcept;
    void <a href="#concurrent_flat_set_rehash">rehash</a>(size_type n);
    void <a href="#concurrent_flat_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    concurrent_flat_set(InputIterator, InputIterator, typename <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>,
                        Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; concurrent_flat_set&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    concurrent_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>,
                        Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; concurrent_flat_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    concurrent_flat_set(InputIterator, InputIterator, typename <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; concurrent_flat_set&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                             boost::hash&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                             std::equal_to&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    concurrent_flat_set(InputIterator, InputIterator, Allocator)
      -&gt; concurrent_flat_set&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                             boost::hash&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                             std::equal_to&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    concurrent_flat_set(InputIterator, InputIterator, typename <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash,
                        Allocator)
      -&gt; concurrent_flat_set&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                             std::equal_to&lt;<a href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    concurrent_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; concurrent_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    concurrent_flat_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; concurrent_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    concurrent_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#concurrent_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; concurrent_flat_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#concurrent_flat_set_operator">operator==</a>(const concurrent_flat_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const concurrent_flat_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#concurrent_flat_set_operator_2">operator!=</a>(const concurrent_flat_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const concurrent_flat_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    void <a href="#concurrent_flat_set_swap_2">swap</a>(concurrent_flat_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              concurrent_flat_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  // Erasure
  template&lt;class K, class H, class P, class A, class Predicate&gt;
    typename concurrent_flat_set&lt;K, H, P, A&gt;::size_type
       <a href="#concurrent_flat_set_erase_if_2">erase_if</a>(concurrent_flat_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_description"><a class="link" href="#concurrent_flat_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a> into the container
and <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the table&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the table are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the table (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_concurrency_requirements_and_guarantees"><a class="link" href="#concurrent_flat_set_concurrency_requirements_and_guarantees">Concurrency Requirements and Guarantees</a></h4>
<div class="paragraph">
<p>Concurrent invocations of <code>operator()</code> on the same const instance of <code>Hash</code> or <code>Pred</code> are required
to not introduce data races. For <code>Alloc</code> being either <code>Allocator</code> or any allocator type rebound
from <code>Allocator</code>, concurrent invocations of the following operations on the same instance <code>al</code> of <code>Alloc</code>
are required to not introduce data races:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Copy construction from <code>al</code> of an allocator rebound from <code>Alloc</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::allocate</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::deallocate</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::construct</code></p>
</li>
<li>
<p><code>std::allocator_traits&lt;Alloc&gt;::destroy</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In general, these requirements on <code>Hash</code>, <code>Pred</code> and <code>Allocator</code> are met if these types
are not stateful or if the operations only involve constant access to internal data members.</p>
</div>
<div class="paragraph">
<p>With the exception of destruction, concurrent invocations of any operation on the same instance of a
<code>concurrent_flat_set</code> do not introduce data races  that is, they are thread-safe.</p>
</div>
<div class="paragraph">
<p>If an operation <strong>op</strong> is explicitly designated as <em>blocking on</em> <code>x</code>, where <code>x</code> is an instance of a <code>boost::concurrent_flat_set</code>,
prior blocking operations on <code>x</code> synchronize with <strong>op</strong>. So, blocking operations on the same
<code>concurrent_flat_set</code> execute sequentially in a multithreaded scenario.</p>
</div>
<div class="paragraph">
<p>An operation is said to be <em>blocking on rehashing of</em> <code><em>x</em></code> if it blocks on <code>x</code>
only when an internal rehashing is issued.</p>
</div>
<div class="paragraph">
<p>Access or modification of an element of a <code>boost::concurrent_flat_set</code> passed by reference to a
user-provided visitation function do not introduce data races when the visitation function
is executed internally by the <code>boost::concurrent_flat_set</code>.</p>
</div>
<div class="paragraph">
<p>Any <code>boost::concurrent_flat_set operation</code> that inserts or modifies an element <code>e</code>
synchronizes with the internal invocation of a visitation function on <code>e</code>.</p>
</div>
<div class="paragraph">
<p>Visitation functions executed by a <code>boost::concurrent_flat_set</code> <code>x</code> are not allowed to invoke any operation
on <code>x</code>; invoking operations on a different <code>boost::concurrent_flat_set</code> instance <code>y</code> is allowed only
if concurrent outstanding operations on <code>y</code> do not access <code>x</code> directly or indirectly.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_configuration_macros"><a class="link" href="#concurrent_flat_set_configuration_macros">Configuration Macros</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_boost_unordered_disable_reentrancy_check"><a class="link" href="#concurrent_flat_set_boost_unordered_disable_reentrancy_check"><code>BOOST_UNORDERED_DISABLE_REENTRANCY_CHECK</code></a></h5>
<div class="paragraph">
<p>In debug builds (more precisely, when
<a href="../../../assert/doc/html/assert.html#boost_assert_is_void" target="_blank" rel="noopener"><code>BOOST_ASSERT_IS_VOID</code></a>
is not defined), <em>container reentrancies</em> (illegaly invoking an operation on <code>m</code> from within
a function visiting elements of <code>m</code>) are detected and signalled through <code>BOOST_ASSERT_MSG</code>.
When run-time speed is a concern, the feature can be disabled by globally defining
this macro.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_constants"><a class="link" href="#concurrent_flat_set_constants">Constants</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">static</span> <span class="k">constexpr</span> <span class="n">size_type</span> <span class="n">bulk_visit_size</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Chunk size internally used in <a href="#concurrent_flat_set_bulk_visit">bulk visit</a> operations.</p>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_constructors"><a class="link" href="#concurrent_flat_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_default_constructor"><a class="link" href="#concurrent_flat_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_bucket_count_constructor"><a class="link" href="#concurrent_flat_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">concurrent_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                             <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                             <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_iterator_range_constructor"><a class="link" href="#concurrent_flat_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                      <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                      <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                      <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_copy_constructor"><a class="link" href="#concurrent_flat_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">concurrent_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_move_constructor"><a class="link" href="#concurrent_flat_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new table.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_iterator_range_constructor_with_allocator"><a class="link" href="#concurrent_flat_set_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_allocator_constructor"><a class="link" href="#concurrent_flat_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">concurrent_flat_set</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_copy_constructor_with_allocator"><a class="link" href="#concurrent_flat_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">concurrent_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a table, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_move_constructor_with_allocator"><a class="link" href="#concurrent_flat_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new table;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_move_constructor_from_unordered_flat_set"><a class="link" href="#concurrent_flat_set_move_constructor_from_unordered_flat_set">Move Constructor from unordered_flat_set</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move construction from a <a href="#unordered_flat_set"><code>unordered_flat_set</code></a>.
The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_initializer_list_constructor"><a class="link" href="#concurrent_flat_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                    <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
                    <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                    <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                    <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_bucket_count_constructor_with_allocator"><a class="link" href="#concurrent_flat_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#concurrent_flat_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#concurrent_flat_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#concurrent_flat_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_initializer_list_constructor_with_allocator"><a class="link" href="#concurrent_flat_set_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#concurrent_flat_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#concurrent_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty table with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_destructor"><a class="link" href="#concurrent_flat_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">concurrent_flat_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_assignment"><a class="link" href="#concurrent_flat_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_copy_assignment"><a class="link" href="#concurrent_flat_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">concurrent_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_move_assignment"><a class="link" href="#concurrent_flat_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to <code>*this</code>;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_initializer_list_assignment"><a class="link" href="#concurrent_flat_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">concurrent_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_visitation"><a class="link" href="#concurrent_flat_set_visitation">Visitation</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_cvisit"><a class="link" href="#concurrent_flat_set_cvisit">[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">visit</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If an element <code>x</code> exists with key equivalent to <code>k</code>, invokes <code>f</code> with a const reference to <code>x</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements visited (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K, class F&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_bulk_visit"><a class="link" href="#concurrent_flat_set_bulk_visit">Bulk visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">FwdIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">size_t</span> <span class="n">visit</span><span class="p">(</span><span class="n">FwdIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">FwdIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">FwdIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="kt">size_t</span> <span class="n">cvisit</span><span class="p">(</span><span class="n">FwdIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">FwdIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For each element <code>k</code> in the range [<code>first</code>, <code>last</code>),
if there is an element <code>x</code> in the container with key equivalent to <code>k</code>,
invokes <code>f</code> with a const reference to <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Although functionally equivalent to individually invoking
<a href="#concurrent_flat_set_cvisit"><code>[c]visit</code></a> for each key, bulk visitation
performs generally faster due to internal streamlining optimizations.
It is advisable that <code>std::distance(first,last)</code> be at least
<a href="#concurrent_flat_set_constants"><code>bulk_visit_size</code></a> to enjoy
a performance gain: beyond this size, performance is not expected
to increase further.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>FwdIterator</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator" target="_blank" rel="noopener">LegacyForwardIterator</a>
(C++11 to C++17),
or satisfies <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator" target="_blank" rel="noopener">std::forward_iterator</a> (C++20 and later).
For <code>K</code> = <code>std::iterator_traits&lt;FwdIterator&gt;::value_type</code>, either <code>K</code> is <code>key_type</code> or
else <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs.
In the latter case, the library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent.
This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements visited.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_cvisit_all"><a class="link" href="#concurrent_flat_set_cvisit_all">[c]visit_all</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">visit_all</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">size_t</span> <span class="n">cvisit_all</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Successively invokes <code>f</code> with const references to each of the elements in the table.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements visited.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_parallel_cvisit_all"><a class="link" href="#concurrent_flat_set_parallel_cvisit_all">Parallel [c]visit_all</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">visit_all</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">cvisit_all</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invokes <code>f</code> with const references to each of the elements in the table.
Execution is parallelized according to the semantics of the execution policy specified.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Depending on the exception handling mechanism of the execution policy used, may call <code>std::terminate</code> if an exception is thrown within <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Only available in compilers supporting C++17 parallel algorithms.<br></p>
<div class="paragraph">
<p>These overloads only participate in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>true</code>.<br></p>
</div>
<div class="paragraph">
<p>Unsequenced execution policies are not allowed.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_cvisit_while"><a class="link" href="#concurrent_flat_set_cvisit_while">[c]visit_while</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">visit_while</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">cvisit_while</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Successively invokes <code>f</code> with const references to each of the elements in the table until <code>f</code> returns <code>false</code>
or all the elements are visited.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>false</code> iff <code>f</code> ever returns <code>false</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_parallel_cvisit_while"><a class="link" href="#concurrent_flat_set_parallel_cvisit_while">Parallel [c]visit_while</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">visit_while</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="n">cvisit_while</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invokes <code>f</code> with const references to each of the elements in the table until <code>f</code> returns <code>false</code>
or all the elements are visited.
Execution is parallelized according to the semantics of the execution policy specified.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>false</code> iff <code>f</code> ever returns <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Depending on the exception handling mechanism of the execution policy used, may call <code>std::terminate</code> if an exception is thrown within <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Only available in compilers supporting C++17 parallel algorithms.<br></p>
<div class="paragraph">
<p>These overloads only participate in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>true</code>.<br></p>
</div>
<div class="paragraph">
<p>Unsequenced execution policies are not allowed.<br></p>
</div>
<div class="paragraph">
<p>Parallelization implies that execution does not necessary finish as soon as <code>f</code> returns <code>false</code>, and as a result
<code>f</code> may be invoked with further elements for which the return value is also <code>false</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_size_and_capacity"><a class="link" href="#concurrent_flat_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_empty"><a class="link" href="#concurrent_flat_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_size"><a class="link" href="#concurrent_flat_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in the table.</p>
</td>
</tr>
</table>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true size of the table right after execution.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_max_size"><a class="link" href="#concurrent_flat_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible table.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_modifiers"><a class="link" href="#concurrent_flat_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_emplace"><a class="link" href="#concurrent_flat_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the table if and only if there is no element in the table with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_copy_insert"><a class="link" href="#concurrent_flat_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_move_insert"><a class="link" href="#concurrent_flat_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_transparent_insert"><a class="link" href="#concurrent_flat_set_transparent_insert">Transparent Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_insert_iterator_range"><a class="link" href="#concurrent_flat_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  while(first != last) this-&gt;<a href="#concurrent_flat_set_emplace">emplace</a>(*first++);</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_insert_initializer_list"><a class="link" href="#concurrent_flat_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  this-&gt;<a href="#concurrent_flat_set_insert_iterator_range">insert</a>(il.begin(), il.end());</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_emplace_or_cvisit"><a class="link" href="#concurrent_flat_set_emplace_or_cvisit">emplace_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">emplace_or_visit</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">emplace_or_cvisit</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the table if there is no element in the table with an equivalent key.
Otherwise, invokes <code>f</code> with a const reference to the equivalent element.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>The interface is exposition only, as C++ does not allow to declare a parameter <code>f</code> after a variadic parameter pack.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_copy_insert_or_cvisit"><a class="link" href="#concurrent_flat_set_copy_insert_or_cvisit">Copy insert_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.
Otherwise, invokes <code>f</code> with a const reference to the equivalent element.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_move_insert_or_cvisit"><a class="link" href="#concurrent_flat_set_move_insert_or_cvisit">Move insert_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the table if and only if there is no element in the table with an equivalent key.
Otherwise, invokes <code>f</code> with a const reference to the equivalent element.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.<br></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_transparent_insert_or_cvisit"><a class="link" href="#concurrent_flat_set_transparent_insert_or_cvisit">Transparent insert_or_[c]visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.
Otherwise, invokes <code>f</code> with a const reference to the equivalent element.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>true</code> if an insert took place.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on rehashing of <code>*this</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Invalidates pointers and references to elements if a rehashing is issued.<br></p>
<div class="paragraph">
<p>These overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_insert_iterator_range_or_visit"><a class="link" href="#concurrent_flat_set_insert_iterator_range_or_visit">Insert Iterator Range or Visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
    <span class="n">size_type</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
    <span class="n">size_type</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  while(first != last) this-&gt;<a href="#concurrent_flat_set_emplace_or_cvisit">emplace_or_[c]visit</a>(*first++, f);</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_insert_initializer_list_or_visit"><a class="link" href="#concurrent_flat_set_insert_initializer_list_or_visit">Insert Initializer List or Visit</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">insert_or_visit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">insert_or_cvisit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  this-&gt;<a href="#concurrent_flat_set_insert_iterator_range_or_visit">insert_or[c]visit</a>(il.begin(), il.end(), f);</pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_erase"><a class="link" href="#concurrent_flat_set_erase">erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the element with key equivalent to <code>k</code> if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_erase_if_by_key"><a class="link" href="#concurrent_flat_set_erase_if_by_key">erase_if by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase_if</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase_if</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the element <code>x</code> with key equivalent to <code>k</code> if it exists and <code>f(x)</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code>, <code>key_equal</code> or <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K, class F&gt;</code> overload only participates in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>false</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class F&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_erase_if"><a class="link" href="#concurrent_flat_set_erase_if">erase_if</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase_if</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Successively invokes <code>f</code> with references to each of the elements in the table, and erases those for which <code>f</code> returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>f</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_parallel_erase_if"><a class="link" href="#concurrent_flat_set_parallel_erase_if">Parallel erase_if</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ExecutionPolicy</span><span class="p">,</span> <span class="k">class</span>  <span class="nc">F</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">erase_if</span><span class="p">(</span><span class="n">ExecutionPolicy</span><span class="o">&amp;&amp;</span> <span class="n">policy</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invokes <code>f</code> with references to each of the elements in the table, and erases those for which <code>f</code> returns <code>true</code>.
Execution is parallelized according to the semantics of the execution policy specified.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Depending on the exception handling mechanism of the execution policy used, may call <code>std::terminate</code> if an exception is thrown within <code>f</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Only available in compilers supporting C++17 parallel algorithms.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> is <code>true</code>.<br></p>
</div>
<div class="paragraph">
<p>Unsequenced execution policies are not allowed.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_swap"><a class="link" href="#concurrent_flat_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the table with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the tables' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>other</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_clear"><a class="link" href="#concurrent_flat_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the table.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_merge"><a class="link" href="#concurrent_flat_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="n">size_type</span> <span class="nf">merge</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="n">size_type</span> <span class="nf">merge</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements inserted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code> and <code>source</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_observers"><a class="link" href="#concurrent_flat_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_get_allocator"><a class="link" href="#concurrent_flat_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The table&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_hash_function"><a class="link" href="#concurrent_flat_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The table&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_key_eq"><a class="link" href="#concurrent_flat_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The table&#8217;s key equality predicate.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_set_operations"><a class="link" href="#concurrent_flat_set_set_operations">Set Operations</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_count"><a class="link" href="#concurrent_flat_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code> (0 or 1).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.<br></p>
<div class="paragraph">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true state of the table right after execution.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_contains"><a class="link" href="#concurrent_flat_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>k</code> in the table.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type. <br></p>
<div class="paragraph">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true state of the table right after execution.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_bucket_interface"><a class="link" href="#concurrent_flat_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_bucket_count"><a class="link" href="#concurrent_flat_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_hash_policy"><a class="link" href="#concurrent_flat_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_load_factor"><a class="link" href="#concurrent_flat_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_max_load_factor"><a class="link" href="#concurrent_flat_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the table&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_set_max_load_factor"><a class="link" href="#concurrent_flat_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_max_load"><a class="link" href="#concurrent_flat_set_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the table can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the table&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.<br></p>
<div class="paragraph">
<p>In the presence of concurrent insertion operations, the value returned may not accurately reflect
the true state of the table right after execution.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_rehash"><a class="link" href="#concurrent_flat_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the table.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates pointers and references to elements, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the table&#8217;s hash function or comparison function.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
<hr>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_reserve"><a class="link" href="#concurrent_flat_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the table.</p>
</div>
<div class="paragraph">
<p>Invalidates pointers and references to elements, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the table&#8217;s hash function or comparison function.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>*this</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_deduction_guides"><a class="link" href="#concurrent_flat_set_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_type</code> parameter type in a deduction guide refers to the <code>size_type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_iter_value_type"><a class="link" href="#concurrent_flat_set_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_equality_comparisons"><a class="link" href="#concurrent_flat_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="concurrent_flat_set_operator"><a class="link" href="#concurrent_flat_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code> and <code>y</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two tables don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_operator_2"><a class="link" href="#concurrent_flat_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code> and <code>y</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two tables don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_swap_2"><a class="link" href="#concurrent_flat_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>x.<a href="#concurrent_flat_set_swap">swap</a>(y);</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_erase_if_2"><a class="link" href="#concurrent_flat_set_erase_if_2">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">concurrent_flat_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre>c.<a href="#concurrent_flat_set_erase_if">erase_if</a>(pred);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="concurrent_flat_set_serialization"><a class="link" href="#concurrent_flat_set_serialization">Serialization</a></h4>
<div class="paragraph">
<p><code>concurrent_flat_set</code>s can be archived/retrieved by means of
<a href="../../../serialization/index.html" target="_blank" rel="noopener">Boost.Serialization</a> using the API provided
by this library. Both regular and XML archives are supported.</p>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_saving_an_concurrent_flat_set_to_an_archive"><a class="link" href="#concurrent_flat_set_saving_an_concurrent_flat_set_to_an_archive">Saving an concurrent_flat_set to an archive</a></h5>
<div class="paragraph">
<p>Saves all the elements of a <code>concurrent_flat_set</code> <code>x</code> to an archive (XML archive) <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is serializable (XML serializable), and it supports Boost.Serialization
<code>save_construct_data</code>/<code>load_construct_data</code> protocol (automatically suported by
<a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>
types).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="concurrent_flat_set_loading_an_concurrent_flat_set_from_an_archive"><a class="link" href="#concurrent_flat_set_loading_an_concurrent_flat_set_from_an_archive">Loading an concurrent_flat_set from an archive</a></h5>
<div class="paragraph">
<p>Deletes all preexisting elements of a <code>concurrent_flat_set</code> <code>x</code> and inserts
from an archive (XML archive) <code>ar</code> restored copies of the elements of the
original <code>concurrent_flat_set</code> <code>other</code> saved to the storage read by <code>ar</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>x.key_equal()</code> is functionally equivalent to <code>other.key_equal()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Concurrency:
</td>
<td class="hdlist2">
<p>Blocking on <code>x</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="changes"><a class="link" href="#changes">Change Log</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="changes_release_1_84_0_major_update"><a class="link" href="#changes_release_1_84_0_major_update">Release 1.84.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>Added <code>boost::concurrent_flat_set</code>.</p>
</li>
<li>
<p>Added <code>[c]visit_while</code> operations to concurrent containers,
with serial and parallel variants.</p>
</li>
<li>
<p>Added efficient move construction of <code>boost::unordered_flat_(map|set)</code> from
<code>boost::concurrent_flat_(map|set)</code> and vice versa.</p>
</li>
<li>
<p>Added bulk visitation to concurrent containers for increased lookup performance.</p>
</li>
<li>
<p>Added debug-mode mechanisms for detecting illegal reentrancies into
a concurrent container from user code.</p>
</li>
<li>
<p>Added Boost.Serialization support to all containers and their (non-local) iterator types.</p>
</li>
<li>
<p>Added support for fancy pointers to open-addressing and concurrent containers.
This enables scenarios like the use of Boost.Interprocess allocators to construct containers in shared memory.</p>
</li>
<li>
<p>Fixed bug in member of pointer operator for local iterators of closed-addressing
containers (<a href="https://github.com/boostorg/unordered/pull/221" target="_blank" rel="noopener">PR#221</a>, credit goes to GitHub user vslashg for finding
and fixing this issue).</p>
</li>
<li>
<p>Starting with this release, <code>boost::unordered_[multi]set</code> and <code>boost::unordered_[multi]map</code>
only work with C++11 onwards.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_83_0_major_update"><a class="link" href="#changes_release_1_83_0_major_update">Release 1.83.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>Added <code>boost::concurrent_flat_map</code>, a fast, thread-safe hashmap based on open addressing.</p>
</li>
<li>
<p>Sped up iteration of open-addressing containers.</p>
</li>
<li>
<p>In open-addressing containers, <code>erase(iterator)</code>, which previously returned nothing, now
returns a proxy object convertible to an iterator to the next element.
This enables the typical <code>it = c.erase(it)</code> idiom without incurring any performance penalty
when the returned proxy is not used.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_82_0_major_update"><a class="link" href="#changes_release_1_82_0_major_update">Release 1.82.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>C++03 support is planned for deprecation. Boost 1.84.0 will no longer support
C++03 mode and C++11 will become the new minimum for using the library.</p>
</li>
<li>
<p>Added node-based, open-addressing containers
<code>boost::unordered_node_map</code> and <code>boost::unordered_node_set</code>.</p>
</li>
<li>
<p>Extended heterogeneous lookup to more member functions as specified in
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html">P2363</a>.</p>
</li>
<li>
<p>Replaced the previous post-mixing process for open-addressing containers with
a new algorithm based on extended multiplication by a constant.</p>
</li>
<li>
<p>Fixed bug in internal emplace() impl where stack-local types were not properly
constructed using the Allocator of the container which breaks uses-allocator
construction.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_81_0_major_update"><a class="link" href="#changes_release_1_81_0_major_update">Release 1.81.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>Added fast containers <code>boost::unordered_flat_map</code> and <code>boost::unordered_flat_set</code>
based on open addressing.</p>
</li>
<li>
<p>Added CTAD deduction guides for all containers.</p>
</li>
<li>
<p>Added missing constructors as specified in <a href="https://cplusplus.github.io/LWG/issue2713">LWG issue 2713</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_80_0_major_update"><a class="link" href="#changes_release_1_80_0_major_update">Release 1.80.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>Refactor internal implementation to be dramatically faster</p>
</li>
<li>
<p>Allow <code>final</code> Hasher and KeyEqual objects</p>
</li>
<li>
<p>Update documentation, adding benchmark graphs and notes on the new internal
data structures</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_79_0"><a class="link" href="#changes_release_1_79_0">Release 1.79.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Improved C++20 support:</p>
<div class="ulist">
<ul>
<li>
<p>All containers have been updated to support
heterogeneous <code>count</code>, <code>equal_range</code> and <code>find</code>.</p>
</li>
<li>
<p>All containers now implement the member function <code>contains</code>.</p>
</li>
<li>
<p><code>erase_if</code> has been implemented for all containers.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Improved C++23 support:</p>
<div class="ulist">
<ul>
<li>
<p>All containers have been updated to support
heterogeneous <code>erase</code> and <code>extract</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Changed behavior of <code>reserve</code> to eagerly
allocate (<a href="https://github.com/boostorg/unordered/pull/59" target="_blank" rel="noopener">PR#59</a>).</p>
</li>
<li>
<p>Various warning fixes in the test suite.</p>
</li>
<li>
<p>Update code to internally use <code>boost::allocator_traits</code>.</p>
</li>
<li>
<p>Switch to Fibonacci hashing.</p>
</li>
<li>
<p>Update documentation to be written in AsciiDoc instead of QuickBook.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_67_0"><a class="link" href="#changes_release_1_67_0">Release 1.67.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Improved C++17 support:</p>
<div class="ulist">
<ul>
<li>
<p>Add template deduction guides from the standard.</p>
</li>
<li>
<p>Use a simple implementation of <code>optional</code> in node handles, so
that they&#8217;re closer to the standard.</p>
</li>
<li>
<p>Add missing <code>noexcept</code> specifications to <code>swap</code>, <code>operator=</code>
and node handles, and change the implementation to match.
Using <code>std::allocator_traits::is_always_equal</code>, or our own
implementation when not available, and
<code>boost::is_nothrow_swappable</code> in the implementation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Improved C++20 support:</p>
<div class="ulist">
<ul>
<li>
<p>Use <code>boost::to_address</code>, which has the proposed C++20 semantics,
rather than the old custom implementation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Add <code>element_type</code> to iterators, so that <code>std::pointer_traits</code>
will work.</p>
</li>
<li>
<p>Use <code>std::piecewise_construct</code> on recent versions of Visual C++,
and other uses of the Dinkumware standard library,
now using Boost.Predef to check compiler and library versions.</p>
</li>
<li>
<p>Use <code>std::iterator_traits</code> rather than the boost iterator traits
in order to remove dependency on Boost.Iterator.</p>
</li>
<li>
<p>Remove iterators' inheritance from <code>std::iterator</code>, which is
deprecated in C++17, thanks to Daniela Engert
(<a href="https://github.com/boostorg/unordered/pull/7" target="_blank" rel="noopener">PR#7</a>).</p>
</li>
<li>
<p>Stop using <code>BOOST_DEDUCED_TYPENAME</code>.</p>
</li>
<li>
<p>Update some Boost include paths.</p>
</li>
<li>
<p>Rename some internal methods, and variables.</p>
</li>
<li>
<p>Various testing improvements.</p>
</li>
<li>
<p>Miscellaneous internal changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_66_0"><a class="link" href="#changes_release_1_66_0">Release 1.66.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Simpler move construction implementation.</p>
</li>
<li>
<p>Documentation fixes (<a href="https://github.com/boostorg/unordered/pull/6" target="_blank" rel="noopener">GitHub #6</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_65_0"><a class="link" href="#changes_release_1_65_0">Release 1.65.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Add deprecated attributes to <code>quick_erase</code> and <code>erase_return_void</code>.
I really will remove them in a future version this time.</p>
</li>
<li>
<p>Small standards compliance fixes:</p>
<div class="ulist">
<ul>
<li>
<p><code>noexpect</code> specs for <code>swap</code> free functions.</p>
</li>
<li>
<p>Add missing <code>insert(P&amp;&amp;)</code> methods.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_64_0"><a class="link" href="#changes_release_1_64_0">Release 1.64.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Initial support for new C++17 member functions:
<code>insert_or_assign</code> and <code>try_emplace</code> in <code>unordered_map</code>,</p>
</li>
<li>
<p>Initial support for <code>merge</code> and <code>extract</code>.
Does not include transferring nodes between
<code>unordered_map</code> and <code>unordered_multimap</code> or between <code>unordered_set</code> and
<code>unordered_multiset</code> yet. That will hopefully be in the next version of
Boost.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_63_0"><a class="link" href="#changes_release_1_63_0">Release 1.63.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Check hint iterator in <code>insert</code>/<code>emplace_hint</code>.</p>
</li>
<li>
<p>Fix some warnings, mostly in the tests.</p>
</li>
<li>
<p>Manually write out <code>emplace_args</code> for small numbers of arguments -
should make template error messages a little more bearable.</p>
</li>
<li>
<p>Remove superfluous use of <code>boost::forward</code> in emplace arguments,
which fixes emplacing string literals in old versions of Visual C++.</p>
</li>
<li>
<p>Fix an exception safety issue in assignment. If bucket allocation
throws an exception, it can overwrite the hash and equality functions while
leaving the existing elements in place. This would mean that the function
objects wouldn&#8217;t match the container elements, so elements might be in the
wrong bucket and equivalent elements would be incorrectly handled.</p>
</li>
<li>
<p>Various reference documentation improvements.</p>
</li>
<li>
<p>Better allocator support (<a href="https://svn.boost.org/trac/boost/ticket/12459" target="_blank" rel="noopener">#12459</a>).</p>
</li>
<li>
<p>Make the no argument constructors implicit.</p>
</li>
<li>
<p>Implement missing allocator aware constructors.</p>
</li>
<li>
<p>Fix assigning the hash/key equality functions for empty containers.</p>
</li>
<li>
<p>Remove unary/binary_function from the examples in the documentation.
They are removed in C++17.</p>
</li>
<li>
<p>Support 10 constructor arguments in emplace. It was meant to support up to 10
arguments, but an off by one error in the preprocessor code meant it only
supported up to 9.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_62_0"><a class="link" href="#changes_release_1_62_0">Release 1.62.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove use of deprecated <code>boost::iterator</code>.</p>
</li>
<li>
<p>Remove <code>BOOST_NO_STD_DISTANCE</code> workaround.</p>
</li>
<li>
<p>Remove <code>BOOST_UNORDERED_DEPRECATED_EQUALITY</code> warning.</p>
</li>
<li>
<p>Simpler implementation of assignment, fixes an exception safety issue
for <code>unordered_multiset</code> and <code>unordered_multimap</code>. Might be a little slower.</p>
</li>
<li>
<p>Stop using return value SFINAE which some older compilers have issues
with.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_58_0"><a class="link" href="#changes_release_1_58_0">Release 1.58.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove unnecessary template parameter from const iterators.</p>
</li>
<li>
<p>Rename private <code>iterator</code> typedef in some iterator classes, as it
confuses some traits classes.</p>
</li>
<li>
<p>Fix move assignment with stateful, propagate_on_container_move_assign
allocators (<a href="https://svn.boost.org/trac/boost/ticket/10777" target="_blank" rel="noopener">#10777</a>).</p>
</li>
<li>
<p>Fix rare exception safety issue in move assignment.</p>
</li>
<li>
<p>Fix potential overflow when calculating number of buckets to allocate
(<a href="https://github.com/boostorg/unordered/pull/4" target="_blank" rel="noopener">GitHub #4</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_57_0"><a class="link" href="#changes_release_1_57_0">Release 1.57.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix the <code>pointer</code> typedef in iterators (<a href="https://svn.boost.org/trac/boost/ticket/10672" target="_blank" rel="noopener">#10672</a>).</p>
</li>
<li>
<p>Fix Coverity warning
(<a href="https://github.com/boostorg/unordered/pull/2" target="_blank" rel="noopener">GitHub #2</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_56_0"><a class="link" href="#changes_release_1_56_0">Release 1.56.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix some shadowed variable warnings (<a href="https://svn.boost.org/trac/boost/ticket/9377" target="_blank" rel="noopener">#9377</a>).</p>
</li>
<li>
<p>Fix allocator use in documentation (<a href="https://svn.boost.org/trac/boost/ticket/9719" target="_blank" rel="noopener">#9719</a>).</p>
</li>
<li>
<p>Always use prime number of buckets for integers. Fixes performance
regression when inserting consecutive integers, although makes other
uses slower (<a href="https://svn.boost.org/trac/boost/ticket/9282" target="_blank" rel="noopener">#9282</a>).</p>
</li>
<li>
<p>Only construct elements using allocators, as specified in C++11 standard.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_55_0"><a class="link" href="#changes_release_1_55_0">Release 1.55.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Avoid some warnings (<a href="https://svn.boost.org/trac/boost/ticket/8851" target="_blank" rel="noopener">#8851</a>, <a href="https://svn.boost.org/trac/boost/ticket/8874" target="_blank" rel="noopener">#8874</a>).</p>
</li>
<li>
<p>Avoid exposing some detail functions via. ADL on the iterators.</p>
</li>
<li>
<p>Follow the standard by only using the allocators' construct and destroy
methods to construct and destroy stored elements. Don&#8217;t use them for internal
data like pointers.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_54_0"><a class="link" href="#changes_release_1_54_0">Release 1.54.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Mark methods specified in standard as <code>noexpect</code>. More to come in the next
release.</p>
</li>
<li>
<p>If the hash function and equality predicate are known to both have nothrow
move assignment or construction then use them.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_53_0"><a class="link" href="#changes_release_1_53_0">Release 1.53.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove support for the old pre-standard variadic pair constructors, and
equality implementation. Both have been deprecated since Boost 1.48.</p>
</li>
<li>
<p>Remove use of deprecated config macros.</p>
</li>
<li>
<p>More internal implementation changes, including a much simpler
implementation of <code>erase</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_52_0"><a class="link" href="#changes_release_1_52_0">Release 1.52.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Faster assign, which assigns to existing nodes where possible, rather than
creating entirely new nodes and copy constructing.</p>
</li>
<li>
<p>Fixed bug in <code>erase_range</code> (<a href="https://svn.boost.org/trac/boost/ticket/7471" target="_blank" rel="noopener">#7471</a>).</p>
</li>
<li>
<p>Reverted some of the internal changes to how nodes are created, especially
for C++11 compilers. 'construct' and 'destroy' should work a little better
for C++11 allocators.</p>
</li>
<li>
<p>Simplified the implementation a bit. Hopefully more robust.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_51_0"><a class="link" href="#changes_release_1_51_0">Release 1.51.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix construction/destruction issue when using a C++11 compiler with a
C++03 allocator (<a href="https://svn.boost.org/trac/boost/ticket/7100" target="_blank" rel="noopener">#7100</a>).</p>
</li>
<li>
<p>Remove a <code>try..catch</code> to support compiling without exceptions.</p>
</li>
<li>
<p>Adjust SFINAE use to try to support g++ 3.4 (<a href="https://svn.boost.org/trac/boost/ticket/7175" target="_blank" rel="noopener">#7175</a>).</p>
</li>
<li>
<p>Updated to use the new config macros.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_50_0"><a class="link" href="#changes_release_1_50_0">Release 1.50.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix equality for <code>unordered_multiset</code> and <code>unordered_multimap</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6857" target="_blank" rel="noopener">Ticket 6857</a>:
Implement <code>reserve</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6771" target="_blank" rel="noopener">Ticket 6771</a>:
Avoid gcc&#8217;s <code>-Wfloat-equal</code> warning.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6784" target="_blank" rel="noopener">Ticket 6784</a>:
Fix some Sun specific code.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6190" target="_blank" rel="noopener">Ticket 6190</a>:
Avoid gcc&#8217;s <code>-Wshadow</code> warning.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6905" target="_blank" rel="noopener">Ticket 6905</a>:
Make namespaces in macros compatible with <code>bcp</code> custom namespaces.
Fixed by Luke Elliott.</p>
</li>
<li>
<p>Remove some of the smaller prime number of buckets, as they may make
collisions quite probable (e.g. multiples of 5 are very common because
we used base 10).</p>
</li>
<li>
<p>On old versions of Visual C++, use the container library&#8217;s implementation
of <code>allocator_traits</code>, as it&#8217;s more likely to work.</p>
</li>
<li>
<p>On machines with 64 bit std::size_t, use power of 2 buckets, with Thomas
Wang&#8217;s hash function to pick which one to use. As modulus is very slow
for 64 bit values.</p>
</li>
<li>
<p>Some internal changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_49_0"><a class="link" href="#changes_release_1_49_0">Release 1.49.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix warning due to accidental odd assignment.</p>
</li>
<li>
<p>Slightly better error messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_48_0_major_update"><a class="link" href="#changes_release_1_48_0_major_update">Release 1.48.0 - Major update</a></h3>
<div class="paragraph">
<p>This is major change which has been converted to use Boost.Move&#8217;s move
emulation, and be more compliant with the C++11 standard. See the
<a href="#compliance">compliance section</a> for details.</p>
</div>
<div class="paragraph">
<p>The container now meets C++11&#8217;s complexity requirements, but to do so
uses a little more memory. This means that <code>quick_erase</code> and
<code>erase_return_void</code> are no longer required, they&#8217;ll be removed in a
future version.</p>
</div>
<div class="paragraph">
<p>C++11 support has resulted in some breaking changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Equality comparison has been changed to the C++11 specification.
In a container with equivalent keys, elements in a group with equal
keys used to have to be in the same order to be considered equal,
now they can be a permutation of each other. To use the old
behavior define the macro <code>BOOST_UNORDERED_DEPRECATED_EQUALITY</code>.</p>
</li>
<li>
<p>The behaviour of swap is different when the two containers to be
swapped has unequal allocators. It used to allocate new nodes using
the appropriate allocators, it now swaps the allocators if
the allocator has a member structure <code>propagate_on_container_swap</code>,
such that <code>propagate_on_container_swap::value</code> is true.</p>
</li>
<li>
<p>Allocator&#8217;s <code>construct</code> and <code>destroy</code> functions are called with raw
pointers, rather than the allocator&#8217;s <code>pointer</code> type.</p>
</li>
<li>
<p><code>emplace</code> used to emulate the variadic pair constructors that
appeared in early C++0x drafts. Since they were removed it no
longer does so. It does emulate the new <code>piecewise_construct</code>
pair constructors - only you need to use
<code>boost::piecewise_construct</code>. To use the old emulation of
the variadic constructors define
<code>BOOST_UNORDERED_DEPRECATED_PAIR_CONSTRUCT</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_45_0"><a class="link" href="#changes_release_1_45_0">Release 1.45.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix a bug when inserting into an <code>unordered_map</code> or <code>unordered_set</code> using
iterators which returns <code>value_type</code> by copy.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_43_0"><a class="link" href="#changes_release_1_43_0">Release 1.43.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3966" target="_blank" rel="noopener">Ticket 3966</a>:
<code>erase_return_void</code> is now <code>quick_erase</code>, which is the
<a href="http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#579" target="_blank" rel="noopener">
current forerunner for resolving the slow erase by iterator</a>, although
there&#8217;s a strong possibility that this may change in the future. The old
method name remains for backwards compatibility but is considered deprecated
and will be removed in a future release.</p>
</li>
<li>
<p>Use Boost.Exception.</p>
</li>
<li>
<p>Stop using deprecated <code>BOOST_HAS_*</code> macros.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_42_0"><a class="link" href="#changes_release_1_42_0">Release 1.42.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Support instantiating the containers with incomplete value types.</p>
</li>
<li>
<p>Reduced the number of warnings (mostly in tests).</p>
</li>
<li>
<p>Improved codegear compatibility.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3693" target="_blank" rel="noopener">Ticket 3693</a>:
Add <code>erase_return_void</code> as a temporary workaround for the current
<code>erase</code> which can be inefficient because it has to find the next
element to return an iterator.</p>
</li>
<li>
<p>Add templated find overload for compatible keys.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3773" target="_blank" rel="noopener">Ticket 3773</a>:
Add missing <code>std</code> qualifier to <code>ptrdiff_t</code>.</p>
</li>
<li>
<p>Some code formatting changes to fit almost all lines into 80 characters.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_41_0_major_update"><a class="link" href="#changes_release_1_41_0_major_update">Release 1.41.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>The original version made heavy use of macros to sidestep some of the older
compilers' poor template support. But since I no longer support those
compilers and the macro use was starting to become a maintenance burden it
has been rewritten to use templates instead of macros for the implementation
classes.</p>
</li>
<li>
<p>The container object is now smaller thanks to using <code>boost::compressed_pair</code>
for EBO and a slightly different function buffer - now using a bool instead
of a member pointer.</p>
</li>
<li>
<p>Buckets are allocated lazily which means that constructing an empty container
will not allocate any memory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_40_0"><a class="link" href="#changes_release_1_40_0">Release 1.40.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2975" target="_blank" rel="noopener">Ticket 2975</a>:
Store the prime list as a preprocessor sequence - so that it will always get
the length right if it changes again in the future.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/1978" target="_blank" rel="noopener">Ticket 1978</a>:
Implement <code>emplace</code> for all compilers.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2908" target="_blank" rel="noopener">Ticket 2908</a>,
<a href="https://svn.boost.org/trac/boost/ticket/3096" target="_blank" rel="noopener">Ticket 3096</a>:
Some workarounds for old versions of borland, including adding explicit
destructors to all containers.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3082" target="_blank" rel="noopener">Ticket 3082</a>:
Disable incorrect Visual C++ warnings.</p>
</li>
<li>
<p>Better configuration for C++0x features when the headers aren&#8217;t available.</p>
</li>
<li>
<p>Create less buckets by default.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_39_0"><a class="link" href="#changes_release_1_39_0">Release 1.39.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2756" target="_blank" rel="noopener">Ticket 2756</a>: Avoid a warning
on Visual C++ 2009.</p>
</li>
<li>
<p>Some other minor internal changes to the implementation, tests and
documentation.</p>
</li>
<li>
<p>Avoid an unnecessary copy in <code>operator[]</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2975" target="_blank" rel="noopener">Ticket 2975</a>: Fix length of
prime number list.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_38_0"><a class="link" href="#changes_release_1_38_0">Release 1.38.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Use <a href="../../../core/swap.html" target="_blank" rel="noopener"><code>boost::swap</code></a>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2237" target="_blank" rel="noopener">Ticket 2237</a>:
Document that the equality and inequality operators are undefined for two
objects if their equality predicates aren&#8217;t equivalent. Thanks to Daniel
Krgler.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/1710" target="_blank" rel="noopener">Ticket 1710</a>:
Use a larger prime number list. Thanks to Thorsten Ottosen and Herv
Brnnimann.</p>
</li>
<li>
<p>Use
<a href="../../../type_traits/index.html" target="_blank" rel="noopener">aligned storage</a> to store the types.
This changes the way the allocator is used to construct nodes. It used to
construct the node with two calls to the allocator&#8217;s <code>construct</code>
method - once for the pointers and once for the value. It now constructs
the node with a single call to construct and then constructs the value using
in place construction.</p>
</li>
<li>
<p>Add support for C++0x initializer lists where they&#8217;re available (currently
only g++ 4.4 in C++0x mode).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_37_0"><a class="link" href="#changes_release_1_37_0">Release 1.37.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Rename overload of <code>emplace</code> with hint, to <code>emplace_hint</code> as specified in
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2691.pdf" target="_blank" rel="noopener">n2691</a>.</p>
</li>
<li>
<p>Provide forwarding headers at <code>&lt;boost/unordered/unordered_map_fwd.hpp&gt;</code> and
<code>&lt;boost/unordered/unordered_set_fwd.hpp&gt;</code>.</p>
</li>
<li>
<p>Move all the implementation inside <code>boost/unordered</code>, to assist
modularization and hopefully make it easier to track Release subversion.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_36_0"><a class="link" href="#changes_release_1_36_0">Release 1.36.0</a></h3>
<div class="paragraph">
<p>First official release.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rearrange the internals.</p>
</li>
<li>
<p>Move semantics - full support when rvalue references are available, emulated
using a cut down version of the Adobe move library when they are not.</p>
</li>
<li>
<p>Emplace support when rvalue references and variadic template are available.</p>
</li>
<li>
<p>More efficient node allocation when rvalue references and variadic template
are available.</p>
</li>
<li>
<p>Added equality operators.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_boost_1_35_0_add_on_31st_march_2008"><a class="link" href="#changes_boost_1_35_0_add_on_31st_march_2008">Boost 1.35.0 Add-on - 31st March 2008</a></h3>
<div class="paragraph">
<p>Unofficial release uploaded to vault, to be used with Boost 1.35.0. Incorporated
many of the suggestions from the review.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Improved portability thanks to Boost regression testing.</p>
</li>
<li>
<p>Fix lots of typos, and clearer text in the documentation.</p>
</li>
<li>
<p>Fix floating point to <code>std::size_t</code> conversion when calculating sizes from
the max load factor, and use <code>double</code> in the calculation for greater accuracy.</p>
</li>
<li>
<p>Fix some errors in the examples.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_review_version"><a class="link" href="#changes_review_version">Review Version</a></h3>
<div class="paragraph">
<p>Initial review version, for the review conducted from 7th December 2007 to
16th December 2007.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bibliography"><a class="link" href="#bibliography">Bibliography</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><em>C/C++ Users Journal</em>. February, 2006. Pete Becker. <a href="http://www.ddj.com/cpp/184402066" target="_blank" rel="noopener">STL and TR1: Part III - Unordered containers</a>.<br>
An introduction to the standard unordered containers.</p>
</li>
<li>
<p><em>Wikipedia</em>. <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Hash table</a>.<br>
An introduction to hash table implementations. Discusses the differences between closed-addressing and open-addressing approaches.</p>
</li>
<li>
<p>Peter Dimov, 2022. <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright"><a class="link" href="#copyright">Copyright and License</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Daniel James</strong></p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2003, 2004 Jeremy B. Maitin-Shepard</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2005-2008 Daniel James</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2022-2023 Christian Mazakas</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2022-2023 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2022-2023 Peter Dimov</p>
</div>
<div class="paragraph">
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" class="bare">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div>
</div>
</div>
</div>
</body>
</html>