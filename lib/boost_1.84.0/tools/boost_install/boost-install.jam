# Copyright 2018-2020 Peter Dimov
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at http://boost.org/LICENSE_1_0.txt)

import modules ;
import boostcpp ;
import property-set ;
import "class" : new ;
import project ;
import common ;
import print ;
import os ;
import feature ;
import package ;
import sequence ;
import set ;
import type ;
import path ;
import regex ;
import ./boost-install-dirs ;

feature.feature library-type : : free ;
feature.feature boost-install.dependency : : free ;
feature.feature boost-install.cmakedir : : free ;
feature.feature boost-install.includedir : : free ;
feature.feature boost-install.libdir : : free ;
feature.feature boost-install.lib-target-type : : free ;
feature.feature boost-install.dll-target : : free ;

if "--verbose" in [ modules.peek : ARGV ]
{
    .info-enabled = 1 ;
}

if "--debug-boost-install" in [ modules.peek : ARGV ]
{
    .debug-enabled = 1 ;
}

local rule .info ( messages * )
{
    if $(.info-enabled)
    {
        ECHO "info:" $(messages) ;
    }
}

local rule .debug ( messages * )
{
    if $(.debug-enabled)
    {
        ECHO "boost-install:" $(messages) ;
    }
}

# generate-cmake-variant-

local rule remap-library ( lib )
{
    switch $(lib)
    {
    case "python.lib" :

        return ;

    case "zlib" :

        return "z" ;

    case "bzip2" :

        return "bz2" ;

    case "icuuc" :

        if [ modules.peek : ICU_ICUUC_NAME ]
        {
            return [ modules.peek : ICU_ICUUC_NAME ] ;
        }
        else
        {
            return "icuuc" ;
        }

    case "icudt" :

        if [ modules.peek : ICU_ICUDT_NAME ]
        {
            return [ modules.peek : ICU_ICUDT_NAME ] ;
        }
        else
        {
            return "icudata" ;
        }

    case "icuin" :

        if [ modules.peek : ICU_ICUIN_NAME ]
        {
            return [ modules.peek : ICU_ICUIN_NAME ] ;
        }
        else
        {
            return "icui18n" ;
        }

    case * :

        return $(lib) ;
    }
}

rule generate-cmake-variant- ( target : sources * : properties * )
{
    .info generate-cmake-variant- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    local name = [ $(ps).get <name> ] ;
    .info "  name=" $(name) ;

    local variant = [ $(ps).get <variant> ] ;
    .info "  variant=" $(variant) ;

    local link = [ $(ps).get <link> ] ;
    .info "  link= " $(link) ;

    local runtime-link = [ $(ps).get <runtime-link> ] ;
    .info "  runtime-link=" $(runtime-link) ;

    local runtime-debugging = [ $(ps).get <runtime-debugging> ] ;
    .info "  runtime-debugging=" $(runtime-debugging) ;

    local threading = [ $(ps).get <threading> ] ;
    .info "  threading=" $(threading) ;

    local address-model = [ $(ps).get <address-model> ] ;
    .info "  address-model=" $(address-model) ;

    local toolset = [ MATCH ^-(.*) : [ common.format-name <toolset> : "" : "" : $(ps) ] ] ;
    .info "  toolset=" $(toolset) ;

    local fname = $(sources[1]:BS) ;
    .info "  fname=" $(fname) ;

    local layout = [ modules.peek boostcpp : layout ] ;
    .info "  layout=" $(layout) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        : true ;

    print.text "# address-model=$(address-model)" "" : true ;

    if $(address-model) = 32
    {
        print.text

            "if(CMAKE_SIZEOF_VOID_P EQUAL 8)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"32 bit, need 64\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(CMAKE_SIZEOF_VOID_P EQUAL 4)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"64 bit, need 32\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    local python ;

    local relevant = [ $(ps).get <relevant> ] ;
    relevant = [ feature.expand-relevant $(relevant) ] ;

    if python in $(relevant)
    {
        python = [ $(ps).get <python> ] ;
    }

    if $(python)
    {
        .info "  python=" $(python) ;

        print.text "# python=$(python)" "" : true ;

        print.text

            "if(Boost_PYTHON_VERSION)"
            "  string(REGEX REPLACE \"([0-9]+[.][0-9]+)([.].*)?\" \"\\\\1\" __boost_pyver ${Boost_PYTHON_VERSION})"
            "  if(NOT __boost_pyver VERSION_EQUAL \"$(python)\")"
            "    _BOOST_SKIPPED(\"$(fname)\" \"$(python), Boost_PYTHON_VERSION=${Boost_PYTHON_VERSION}\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            "if(Boost_PYTHON_VERSION_MAJOR)"
            "  if(NOT \"$(python)\" MATCHES \"^${Boost_PYTHON_VERSION_MAJOR}[.]\")"
            "    _BOOST_SKIPPED(\"$(fname)\" \"$(python), Boost_PYTHON_VERSION_MAJOR=${Boost_PYTHON_VERSION_MAJOR}\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }

    print.text "# layout=$(layout)" "" : true ;

    print.text "# toolset=$(toolset)" "" : true ;

    if $(layout) = versioned
    {
        print.text

            "if(Boost_COMPILER)"
            "  if(NOT \"$(toolset)\" IN_LIST Boost_COMPILER AND NOT \"-$(toolset)\" IN_LIST Boost_COMPILER)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"$(toolset), Boost_COMPILER=${Boost_COMPILER}\")"
            "    return()"
            "  endif()"
            "else()"
            "  if(BOOST_DETECTED_TOOLSET AND NOT BOOST_DETECTED_TOOLSET STREQUAL \"$(toolset)\")"
            "    _BOOST_SKIPPED(\"$(fname)\" \"$(toolset), detected ${BOOST_DETECTED_TOOLSET}, set Boost_COMPILER to override\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }

    print.text "# link=$(link)" "" : true ;

    if $(link) = static
    {
        print.text

            "if(DEFINED Boost_USE_STATIC_LIBS)"
            "  if(NOT Boost_USE_STATIC_LIBS)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"static, Boost_USE_STATIC_LIBS=${Boost_USE_STATIC_LIBS}\")"
            "    return()"
            "  endif()"
            "else()"
            "  if(NOT WIN32 AND NOT _BOOST_SINGLE_VARIANT)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"static, default is shared, set Boost_USE_STATIC_LIBS=ON to override\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(DEFINED Boost_USE_STATIC_LIBS)"
            "  if(Boost_USE_STATIC_LIBS)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"shared, Boost_USE_STATIC_LIBS=${Boost_USE_STATIC_LIBS}\")"
            "    return()"
            "  endif()"
            "else()"
            "  if(WIN32 AND NOT _BOOST_SINGLE_VARIANT)"
            "    _BOOST_SKIPPED(\"$(fname)\" \"shared, default on Windows is static, set Boost_USE_STATIC_LIBS=OFF to override\")"
            "    return()"
            "  endif()"
            "endif()"
            ""
            : true ;
    }

    print.text "# runtime-link=$(runtime-link)" "" : true ;

    if $(runtime-link) = static
    {
        print.text

            "if(NOT Boost_USE_STATIC_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"static runtime, Boost_USE_STATIC_RUNTIME not ON\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(Boost_USE_STATIC_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"shared runtime, Boost_USE_STATIC_RUNTIME=${Boost_USE_STATIC_RUNTIME}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text "# runtime-debugging=$(runtime-debugging)" "" : true ;

    if $(runtime-debugging) = "on"
    {
        print.text

            "if(NOT \"${Boost_USE_DEBUG_RUNTIME}\" STREQUAL \"\" AND NOT Boost_USE_DEBUG_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"debug runtime, Boost_USE_DEBUG_RUNTIME=${Boost_USE_DEBUG_RUNTIME}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(Boost_USE_DEBUG_RUNTIME)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"release runtime, Boost_USE_DEBUG_RUNTIME=${Boost_USE_DEBUG_RUNTIME}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text "# threading=$(threading)" "" : true ;

    if $(layout) != system
    {
        if $(threading) = "multi"
        {
            print.text

                "if(DEFINED Boost_USE_MULTITHREADED AND NOT Boost_USE_MULTITHREADED)"
                "  _BOOST_SKIPPED(\"$(fname)\" \"multithreaded, Boost_USE_MULTITHREADED=${Boost_USE_MULTITHREADED}\")"
                "  return()"
                "endif()"
                ""
                : true ;
        }
        else
        {
            print.text

                "if(NOT DEFINED Boost_USE_MULTITHREADED)"
                "  _BOOST_SKIPPED(\"$(fname)\" \"single-threaded, Boost_USE_MULTITHREADED is not set and defaults to ON, set to OFF to override\")"
                "  return()"
                "endif()"
                ""
                "if(Boost_USE_MULTITHREADED)"
                "  _BOOST_SKIPPED(\"$(fname)\" \"single-threaded, Boost_USE_MULTITHREADED=${Boost_USE_MULTITHREADED}\")"
                "  return()"
                "endif()"
                ""
                : true ;
        }
    }

    print.text "# variant=$(variant)" "" : true ;

    if $(variant) = debug
    {
        print.text

            "if(NOT \"${Boost_USE_DEBUG_LIBS}\" STREQUAL \"\" AND NOT Boost_USE_DEBUG_LIBS)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"debug, Boost_USE_DEBUG_LIBS=${Boost_USE_DEBUG_LIBS}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }
    else
    {
        print.text

            "if(NOT \"${Boost_USE_RELEASE_LIBS}\" STREQUAL \"\" AND NOT Boost_USE_RELEASE_LIBS)"
            "  _BOOST_SKIPPED(\"$(fname)\" \"release, Boost_USE_RELEASE_LIBS=${Boost_USE_RELEASE_LIBS}\")"
            "  return()"
            "endif()"
            ""
            : true ;
    }

    print.text

        "if(Boost_VERBOSE OR Boost_DEBUG)"
        "  message(STATUS \"  [x] $(fname)\")"
        "endif()"
        ""
        : true ;

    if $(python)
    {
        print.text

            "if(NOT Boost_PYTHON_VERSION)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  Setting Boost_PYTHON_VERSION to $(python)\")"
            "  endif()"
            "  set(Boost_PYTHON_VERSION \"$(python)\")"
            "endif()"
            ""
            : true ;
    }

    local lname = [ MATCH boost_(.*) : $(name) ] ;
    .info "  lname=" $(lname) ;

    local target = "Boost::$(lname)" ;
    .info "  target=" $(target) ;

    print.text

        "# Create imported target $(target)"
        ""
        "if(NOT TARGET $(target))"
        "  add_library($(target) $(link:U) IMPORTED)"
        ""
        "  set_target_properties($(target) PROPERTIES"
        "    INTERFACE_INCLUDE_DIRECTORIES \"\${_BOOST_INCLUDEDIR}\""
        "    INTERFACE_COMPILE_DEFINITIONS \"BOOST_$(lname:U)_NO_LIB\""
        "  )"
        "endif()"
        ""
        : true ;

    print.text "# Target file name: $(fname)" "" : true ;

    local lib-target-type = [ $(ps).get <boost-install.lib-target-type> ] ;
    .info "  lib-target-type=" $(lib-target-type) ;

    local loc-prop = LOCATION ;

    if $(lib-target-type) = IMPORT_LIB
    {
        loc-prop = IMPLIB ;
    }

    .info "  loc-prop=" $(loc-prop) ;

    local dll-target = [ $(ps).get <boost-install.dll-target> ] ;

    local dll-name ;

    if $(dll-target)
    {
        dll-name = [ $(dll-target).name ] ;
    }

    .info "  dll-name=" $(dll-name) ;

    print.text

        "get_target_property(__boost_imploc $(target) IMPORTED_$(loc-prop)_$(variant:U))"
        "if(__boost_imploc)"
        "  message(SEND_ERROR \"Target $(target) already has an imported location '${__boost_imploc}', which is being overwritten with '${_BOOST_LIBDIR}/$(fname)'\")"
        "endif()"
        "unset(__boost_imploc)"
        ""
        "set_property(TARGET $(target) APPEND PROPERTY IMPORTED_CONFIGURATIONS $(variant:U))"
        ""
        "set_target_properties($(target) PROPERTIES"
        "  IMPORTED_LINK_INTERFACE_LANGUAGES_$(variant:U) CXX"
        "  IMPORTED_$(loc-prop)_$(variant:U) \"${_BOOST_LIBDIR}/$(fname)\""
        "  )"
        ""
        : true ;

    if $(lib-target-type) = IMPORT_LIB
    {
    print.text

        "set_target_properties($(target) PROPERTIES"
        "  IMPORTED_LOCATION_$(variant:U) \"${_BOOST_LIBDIR}/$(dll-name)\""
        "  )"
        ""
        : true ;
    }

    if $(variant) = release
    {
        print.text

        "set_target_properties($(target) PROPERTIES"
        "  MAP_IMPORTED_CONFIG_MINSIZEREL Release"
        "  MAP_IMPORTED_CONFIG_RELWITHDEBINFO Release"
        "  )"
        ""
        : true ;
    }

    if $(link) = shared
    {
        print.text

        "set_property(TARGET $(target) APPEND"
        "  PROPERTY INTERFACE_COMPILE_DEFINITIONS \"BOOST_$(lname:U)_DYN_LINK\""
        "  )"
        ""
        : true ;
    }

    local deps = [ MATCH "boost_(.*)" : [ $(ps).get <boost-install.dependency> ] ] headers ;
    .info "  deps=" $(deps) ;

    if $(deps)
    {
        print.text

            "list(APPEND _BOOST_$(lname:U)_DEPS $(deps:S=:J= ))"
            ""
            : true ;
    }

    local deps2 = [ set.difference [ $(ps).get <boost-install.dependency> ] : boost_$(deps) ] ;
    .info "  deps2=" $(deps2) ;

    local deps3 ;

    for local dep in $(deps2)
    {
        deps3 += [ remap-library $(dep) ] ;
    }

    .info "  deps3=" $(deps3) ;

    if $(deps3) && $(link) = static
    {
        print.text

            "if(CMAKE_CONFIGURATION_TYPES)"
            "  set_property(TARGET $(target) APPEND PROPERTY INTERFACE_LINK_LIBRARIES"
            "    \"$<$<CONFIG:$(variant)>:$(deps3:J=;)>\")"
            "else()"
            "  set_property(TARGET $(target) APPEND PROPERTY INTERFACE_LINK_LIBRARIES"
            "    $(deps3:J= ))"
            "endif()"
            ""
            : true ;
    }
}

actions generate-cmake-variant-
{
}

# tag

local rule tag ( name : type ? : property-set )
{
    .debug tag $(name) ;

    local link = [ $(property-set).get <link> ] ;
    .debug "  link=" $(link) ;

    local python = ;

    local relevant = [ $(property-set).get <relevant> ] ;
    relevant = [ feature.expand-relevant $(relevant) ] ;

    if python in $(relevant)
    {
        python = [ $(property-set).get <python> ] ;
        .debug "  python=" $(python) ;
    }

    local r = [ boostcpp.tag $(name) : STATIC_LIB : $(property-set) ] ;

    r = $(r:S=$(name:S)) ;
    r = $(r:B=$(r:B)-$(link)) ;

    if $(python)
    {
        r = $(r:B=$(r:B)-py$(python)) ;
    }

    .debug "  result=" $(r) ;

    return $(r) ;
}

# choose-lib-target: get the import library, if present, the
#   shared/static library otherwise, ignore .pdb et al

local rule choose-lib-target ( sources * )
{
    local result ;

    for local t in $(sources)
    {
        if [ type.is-derived [ $(t).type ] IMPORT_LIB ]
        {
            return $(t) ;
        }
        else if [ type.is-derived [ $(t).type ] LIB ]
        {
            result = $(t) ;
        }
    }

    return $(result) ;
}

local rule get-dll-target ( sources * )
{
    for local t in $(sources)
    {
        if [ type.is-derived [ $(t).type ] SHARED_LIB ]
        {
            return $(t) ;
        }
    }
}

# get-dependency-names: Returns the base names of all
# dependency libraries.
#
local rule get-dependency-names ( sources * )
{
    local all-targets = [ collect-targets $(sources) ] ;
    local lib-names ;
    for local t in [ set.difference $(all-targets) : $(sources) ]
    {
        if [ $(t).type ] && [ type.is-derived [ $(t).type ] LIB ]
        {
            # Get back the original unmangled name of the library
            local subvariant = [ $(t).creating-subvariant ] ;
            local main-target = [ $(subvariant).main-target ] ;
            lib-names += [ $(main-target).name ] ;
        }
    }
    return [ sequence.unique $(lib-names) ] ;
}

# generate-cmake-variant

rule generate-cmake-variant ( project name : property-set : sources * )
{
    .debug generate-cmake-variant $(name) ;

    for local s in $(sources)
    {
        .debug "  name=" [ $(s).name ] ;
    }

    local lib-target = [ choose-lib-target $(sources) ] ;

    local dll-target = [ get-dll-target $(sources) ] ;

    local other-names = [ get-dependency-names $(sources) ] ;
    property-set = [ $(property-set).add-raw <boost-install.dependency>$(other-names) ] ;

    local result ;

    if $(lib-target)
    {
        .debug "  lib-target=" [ $(lib-target).name ] ;

        local lib-target-type = [ $(lib-target).type ] ;

        .debug "  lib-target-type=" $(lib-target-type) ;

        if $(dll-target)
        {
            .debug "  dll-target=" [ $(dll-target).name ] ;
        }

        local tag = [ tag $(name) : : $(property-set) ] ;

        property-set = [ $(property-set).add-raw <boost-install.lib-target-type>$(lib-target-type) ] ;
        property-set = [ $(property-set).add-raw <boost-install.dll-target>$(dll-target) ] ;

        local a = [ new non-scanning-action $(lib-target) : boost-install.generate-cmake-variant- : $(property-set) ] ;

        result += [ new file-target $(tag) : : $(project) : $(a) ] ;
    }

    # The result is an optional property set, the usage requirements,
    # followed by a list of targets. When the list is empty, we need
    # to include the property set, to avoid a warning.

    return [ property-set.empty ] $(result) ;
}

# generate-cmake-config-

local rule path-native-fwd ( path )
{
    path = [ path.native $(path) ] ;

    if [ os.name ] = NT
    {
        path = $(path:T) ;
    }

    return $(path) ;
}

local rule get-dir ( name : dir )
{
    if [ path.is-rooted $(dir) ]
    {
        dir = [ path-native-fwd $(dir) ] ;

        print.text

            "set($(name) \"$(dir)\")"

        : true ;
    }
    else
    {
        print.text

            "get_filename_component($(name) \"${_BOOST_CMAKEDIR}/$(dir)/\" ABSOLUTE)"

        : true ;
    }
}

rule generate-cmake-config- ( target : sources * : properties * )
{
    .info generate-cmake-config- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    local name = [ $(ps).get <name> ] ;
    .info "  name=" $(name) ;

    local library-type = [ $(ps).get <library-type> ] ;
    .info "  library-type=" $(library-type) ;

    local cmakedir = [ $(ps).get <boost-install.cmakedir> ] ;
    .info "  cmakedir=" $(cmakedir) ;

    local includedir = [ $(ps).get <boost-install.includedir> ] ;
    .info "  includedir=" $(includedir) ;

    local libdir = [ $(ps).get <boost-install.libdir> ] ;
    .info "  libdir=" $(libdir) ;

    local lname = [ MATCH boost_(.*) : $(name) ] ;
    .info "  lname=" $(lname) ;

    local ltarget = "Boost::$(lname)" ;
    .info "  ltarget=" $(ltarget) ;

    print.output $(target) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        "if(TARGET $(ltarget))"
        "  return()"
        "endif()"
        ""
        "if(Boost_VERBOSE OR Boost_DEBUG)"
        "  message(STATUS \"Found $(name) ${$(name)_VERSION} at ${$(name)_DIR}\")"
        "endif()"
        ""
        "mark_as_advanced($(name)_DIR)"
        ""
        "# Compute the include and library directories relative to this file."
        ""
        "get_filename_component(_BOOST_CMAKEDIR \"${CMAKE_CURRENT_LIST_DIR}/../\" REALPATH)"
        : true ;

    if [ path.is-rooted $(cmakedir) ]
    {
        local cmakedir-native = [ path-native-fwd $(cmakedir) ] ;

        print.text

            ""
            "# If the computed and the original directories are symlink-equivalent, use original"
            "if(EXISTS \"$(cmakedir-native)\")"
            "  get_filename_component(_BOOST_CMAKEDIR_ORIGINAL \"$(cmakedir-native)\" REALPATH)"
            "  if(_BOOST_CMAKEDIR STREQUAL _BOOST_CMAKEDIR_ORIGINAL)"
            "    set(_BOOST_CMAKEDIR \"$(cmakedir-native)\")"
            "  endif()"
            "  unset(_BOOST_CMAKEDIR_ORIGINAL)"
            "endif()"
            ""
            : true ;
    }

    get-dir "_BOOST_INCLUDEDIR" : $(includedir) ;

    if $(library-type) = INTERFACE
    {
        print.text

            ""
            "add_library($(ltarget) INTERFACE IMPORTED)"
            ""
            "set_target_properties($(ltarget) PROPERTIES"
            "  INTERFACE_INCLUDE_DIRECTORIES \"\${_BOOST_INCLUDEDIR}\""
            ")"
            ""
            "unset(_BOOST_INCLUDEDIR)"
            "unset(_BOOST_CMAKEDIR)"
            ""
            : true ;
    }
    else
    {
        get-dir "_BOOST_LIBDIR" : $(libdir) ;

        print.text

            ""
            "include(${CMAKE_CURRENT_LIST_DIR}/../BoostDetectToolset-$(version).cmake)"
            ""
            "if(Boost_DEBUG)"
            "  message(STATUS \"Scanning ${CMAKE_CURRENT_LIST_DIR}/lib$(name)-variant*.cmake\")"
            "endif()"
            ""
            "file(GLOB __boost_variants \"${CMAKE_CURRENT_LIST_DIR}/lib$(name)-variant*.cmake\")"
            ""
            "macro(_BOOST_SKIPPED fname reason)"
            "  if(Boost_VERBOSE OR Boost_DEBUG)"
            "    message(STATUS \"  [ ] ${fname}\")"
            "  endif()"
            "  list(APPEND __boost_skipped \"${fname} (${reason})\")"
            "endmacro()"
            ""
            "list(LENGTH __boost_variants _BOOST_SINGLE_VARIANT)"
            "if(NOT _BOOST_SINGLE_VARIANT EQUAL 1)"
            "  set(_BOOST_SINGLE_VARIANT 0)"
            "endif()"
            ""
            "foreach(f IN LISTS __boost_variants)"
            "  if(Boost_DEBUG)"
            "    message(STATUS \"  Including ${f}\")"
            "  endif()"
            "  include(${f})"
            "endforeach()"
            ""
            "unset(_BOOST_SINGLE_VARIANT)"
            "unset(_BOOST_LIBDIR)"
            "unset(_BOOST_INCLUDEDIR)"
            "unset(_BOOST_CMAKEDIR)"
            ""
            "if(NOT __boost_variants AND (Boost_VERBOSE OR Boost_DEBUG))"
            "  message(STATUS \"  Library has no variants and is considered not found\")"
            "endif()"
            ""
            "if(NOT TARGET $(ltarget))"
            "  set(__boost_message \"No suitable build variant has been found.\")"
            "  if(__boost_skipped)"
            "    set(__boost_message \"${__boost_message}\\nThe following variants have been tried and rejected:\")"
            "    foreach(s IN LISTS __boost_skipped)"
            "      set(__boost_message \"${__boost_message}\\n* ${s}\")"
            "    endforeach()"
            "  endif()"
            "  set($(name)_FOUND 0)"
            "  set($(name)_NOT_FOUND_MESSAGE ${__boost_message})"
            "  unset(__boost_message)"
            "  unset(__boost_skipped)"
            "  unset(__boost_variants)"
            "  unset(_BOOST_$(lname:U)_DEPS)"
            "  return()"
            "endif()"
            ""
            "unset(__boost_skipped)"
            "unset(__boost_variants)"
            ""
            "if(_BOOST_$(lname:U)_DEPS)"
            "  list(REMOVE_DUPLICATES _BOOST_$(lname:U)_DEPS)"
            "  if(Boost_VERBOSE OR Boost_DEBUG)"
            "    message(STATUS \"Adding $(name) dependencies: ${_BOOST_$(lname:U)_DEPS}\")"
            "  endif()"
            "endif()"
            ""
            "foreach(dep_$(name) IN LISTS _BOOST_$(lname:U)_DEPS")
            "  set(_BOOST_QUIET)"
            "  if($(name)_FIND_QUIETLY)"
            "    set(_BOOST_QUIET QUIET)"
            "  endif()"
            "  set(_BOOST_REQUIRED)"
            "  if($(name)_FIND_REQUIRED)"
            "    set(_BOOST_REQUIRED REQUIRED)"
            "  endif()"
            "  get_filename_component(_BOOST_CMAKEDIR \"${CMAKE_CURRENT_LIST_DIR}/../\" ABSOLUTE)"
            "  find_package(boost_${dep_$(name)} $(version) EXACT CONFIG ${_BOOST_REQUIRED} ${_BOOST_QUIET} HINTS ${_BOOST_CMAKEDIR})"
            "  set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_LIBRARIES Boost::${dep_$(name)})"
            "  unset(_BOOST_QUIET)"
            "  unset(_BOOST_REQUIRED)"
            "  unset(_BOOST_CMAKEDIR)"
            "  if(NOT boost_${dep_$(name)}_FOUND)"
            "    set($(name)_FOUND 0)"
            "    set($(name)_NOT_FOUND_MESSAGE \"A required dependency, boost_${dep_$(name)}, has not been found.\")"
            "    unset(_BOOST_$(lname:U)_DEPS)"
            "    return()"
            "  endif()"
            "endforeach()"
            ""
            "unset(_BOOST_$(lname:U)_DEPS)"
            ""
            : true ;

        if $(name) = boost_thread
        {
            print.text

            "include(CMakeFindDependencyMacro)"
            "find_dependency(Threads)"
            "set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_LIBRARIES Threads::Threads)"
            ""
            : true ;
        }

        if $(name) = boost_mpi
        {
            print.text

            "include(CMakeFindDependencyMacro)"
            "find_dependency(MPI)"
            ""
            "if(MPI_CXX_FOUND AND NOT TARGET MPI::MPI_CXX)"
            "  if(MPI_CXX_COMPILE_FLAGS)"
            "    set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_COMPILE_OPTIONS \"${MPI_CXX_COMPILE_FLAGS}\")"
            "  endif()"
            "  if(MPI_CXX_INCLUDE_PATH)"
            "    set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_INCLUDE_DIRECTORIES \"${MPI_CXX_INCLUDE_PATH}\")"
            "  endif()"
            "  if(MPI_CXX_LINK_FLAGS)"
            "    set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_OPTIONS \"SHELL:${MPI_CXX_LINK_FLAGS}\")"
            "  endif()"
            "  if(MPI_CXX_LIBRARIES)"
            "    set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_LIBRARIES \"${MPI_CXX_LIBRARIES}\")"
            "  endif()"
            "else()"
            "  set_property(TARGET $(ltarget) APPEND PROPERTY INTERFACE_LINK_LIBRARIES MPI::MPI_CXX)"
            "endif()"
            ""
            : true ;
        }
    }
}

actions generate-cmake-config-
{
}

# generate-cmake-config

rule generate-cmake-config ( project name : property-set : sources * )
{
    .debug generate-cmake-config $(name) ;

    local pname = [ $(property-set).get <name> ] ;
    local version = [ $(property-set).get <version> ] ;
    local location = [ $(property-set).get <location> ] ;
    local library-type = [ $(property-set).get <library-type> ] ;
    local cmakedir = [ $(property-set).get <boost-install.cmakedir> ] ;
    local includedir = [ $(property-set).get <boost-install.includedir> ] ;
    local libdir = [ $(property-set).get <boost-install.libdir> ] ;

    local ps = [ property-set.create
        <name>$(pname) <version>$(version) <location>$(location)
        <library-type>$(library-type)
        <boost-install.cmakedir>$(cmakedir)
        <boost-install.includedir>$(includedir)
        <boost-install.libdir>$(libdir) ] ;

    local result ;

    local a = [ new non-scanning-action : boost-install.generate-cmake-config- : $(ps) ] ;

    result += [ new file-target $(name) : : $(project) : $(a) ] ;

    return $(result) ;
}

# generate-cmake-config-version-

rule generate-cmake-config-version- ( target : sources * : properties * )
{
    .info generate-cmake-config-version- $(target) ":" $(sources) ;

    local ps = [ property-set.create $(properties) ] ;

    print.output $(target) ;

    local version = [ $(ps).get <version> ] ;
    .info "  version=" $(version) ;

    print.output $(target) ;

    print.text

        "# Generated by Boost $(version)"
        ""
        "set(PACKAGE_VERSION $(version))"
        ""
        "if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)"
        "  set(PACKAGE_VERSION_COMPATIBLE FALSE)"
        "else()"
        "  set(PACKAGE_VERSION_COMPATIBLE TRUE)"
        "  if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)"
        "    set(PACKAGE_VERSION_EXACT TRUE)"
        "  endif()"
        "endif()"
        ""
        : true ;
}

actions generate-cmake-config-version-
{
}

# generate-cmake-config-version

rule generate-cmake-config-version ( project name : property-set : sources * )
{
    .debug generate-cmake-config-version $(name) ;

    local pname = [ $(property-set).get <name> ] ;
    local version = [ $(property-set).get <version> ] ;
    local location = [ $(property-set).get <location> ] ;

    local ps = [ property-set.create <name>$(pname) <version>$(version) <location>$(location) ] ;

    local result ;

    local a = [ new non-scanning-action : boost-install.generate-cmake-config-version- : $(ps) ] ;

    result += [ new file-target $(name) : : $(project) : $(a) ] ;

    return $(result) ;
}

# install-cmake-config-

local rule install-cmake-config- ( install-or-stage : location : includedir : libdir : version : name )
{
    #.debug install-cmake-config- $(name) ;

    local r ;

    if [ MATCH boost_(.*) : $(name) ]
    {
        local loc = $(location)/$(name)-$(version) ;

        local library-type = UNKNOWN ;

        if $(name) = boost_headers || $(name) = boost_math || $(name) = boost_exception
        {
            library-type = INTERFACE ;
        }

        local reqs = <name>$(name) <version>$(version) <library-type>$(library-type) <boost-install.cmakedir>$(location) <boost-install.includedir>$(includedir) <boost-install.libdir>$(libdir) ;

        r += [ generate $(install-or-stage)/$(name)-config.cmake : $(name) : <generating-rule>@boost-install%generate-cmake-config $(reqs) ] ;
        r += [ install $(install-or-stage)-$(name)-config.cmake : $(install-or-stage)/$(name)-config.cmake : <location>$(loc) ] ;

        r += [ generate $(install-or-stage)/$(name)-config-version.cmake : $(name) : <generating-rule>@boost-install%generate-cmake-config-version $(reqs) ] ;
        r += [ install $(install-or-stage)-$(name)-config-version.cmake : $(install-or-stage)/$(name)-config-version.cmake : <location>$(loc) ] ;

        if $(library-type) != INTERFACE
        {
            local v = [ generate $(install-or-stage)/$(name)-variant.cmake : $(name) : <generating-rule>@boost-install%generate-cmake-variant $(reqs) ] ;
            r += $(v) ;
            r += [ install $(install-or-stage)-$(name)-config-variant.cmake : $(v) : <location>$(loc) ] ;
        }
    }
    else
    {
        .info "target '$(name)' not prefixed by 'boost_', omitting CMake config" ;
    }

    return $(r) ;
}

# install-or-stage-cmake-config
#
# includedir, libdir, cmakedir should be in canonical path.make format

rule install-or-stage-cmake-config ( name * : install-or-stage : includedir : libdir : cmakedir )
{
    local p = [ project.current ] ;

    if "--no-cmake-config" in [ modules.peek : ARGV ]
    {
        alias $(install-or-stage)-cmake-config ;
        $(p).mark-target-as-explicit $(install-or-stage)-cmake-config ;
    }
    else
    {
        includedir = [ path.relative-to $(cmakedir) $(includedir) ] ;
        libdir = [ path.relative-to $(cmakedir) $(libdir) ] ;

        local BOOST_VERSION = [ modules.peek boostcpp : BOOST_VERSION ] ;

        local configs ;

        for local nm in $(name)
        {
            configs += [ install-cmake-config- $(install-or-stage) : $(cmakedir) : $(includedir) : $(libdir) : $(BOOST_VERSION) : $(nm) ] ;
        }

        # Target install/stage-detect-toolset

        local boost-install-dir = [ modules.binding $(__name__) ] ;
        boost-install-dir = $(boost-install-dir:D) ;

        install $(install-or-stage)-detect-toolset : $(boost-install-dir)/BoostDetectToolset.cmake : <location>$(cmakedir) <name>BoostDetectToolset-$(BOOST_VERSION).cmake ;
        $(p).mark-target-as-explicit $(install-or-stage)-detect-toolset ;

        # Target install/stage-boost-config

        install $(install-or-stage)-boost-config : $(boost-install-dir)/BoostConfig.cmake : <location>$(cmakedir)/Boost-$(BOOST_VERSION) ;
        $(p).mark-target-as-explicit $(install-or-stage)-boost-config ;

        # Target install/stage-boost-config-version

        project.load [ path.make $(boost-install-dir) ] ;

        install $(install-or-stage)-boost-config-version : /boost/tools/boost_install//BoostConfigVersion.cmake : <location>$(cmakedir)/Boost-$(BOOST_VERSION) ;
        $(p).mark-target-as-explicit $(install-or-stage)-boost-config-version ;

        # Target install/stage-cmake-config

        alias $(install-or-stage)-cmake-config : $(configs) $(install-or-stage)-detect-toolset $(install-or-stage)-boost-config $(install-or-stage)-boost-config-version ;
        $(p).mark-target-as-explicit $(install-or-stage)-cmake-config ;
    }
}

# install-cmake-config

rule install-cmake-config ( name * )
{
    #.debug install-cmake-config $(name) ;

    local includedir = [ boost-install-dirs.includedir ] ;
    local libdir = [ boost-install-dirs.libdir ] ;
    local cmakedir = [ boost-install-dirs.cmakedir ] ;
    local header-subdir = [ boost-install-dirs.header-subdir ] ;

    if $(header-subdir)
    {
        includedir = $(includedir)/$(header-subdir) ;
    }

    install-or-stage-cmake-config $(name) : install : $(includedir) : $(libdir) : $(cmakedir) ;
}

rule stage-cmake-config ( name * )
{
    local includedir = [ path.make [ modules.peek boostcpp : BOOST_ROOT ] ] ;
    local libdir = [ boost-install-dirs.stage-libdir ] ;
    local cmakedir = $(libdir)/cmake ;

    install-or-stage-cmake-config $(name) : stage : $(includedir) : $(libdir) : $(cmakedir) ;
}

# stage-cmake-config

# collect-targets: Returns the targets and all their dependencies.
# Copied from stage.jam
# TODO: Factor this out as a utility in virtal-target.jam

rule collect-targets ( targets * )
{
    # Find subvariants
    local s ;
    for local t in $(targets)
    {
        s += [ $(t).creating-subvariant ] ;
    }
    s = [ sequence.unique $(s) ] ;

    local result = [ new set ] ;
    $(result).add $(targets) ;

    for local i in $(s)
    {
        $(i).all-referenced-targets $(result) ;
    }
    local result2 ;
    for local r in [ $(result).list ]
    {
        if $(r:G) != <use>
        {
            result2 += $(r:G=) ;
        }
    }
    DELETE_MODULE $(result) ;
    return [ sequence.unique $(result2) ] ;
}

# get-dependency-projects: Returns all the projects of any dependency of the sources.

rule get-dependency-projects ( sources * )
{
    local result ;
    for local t in [ collect-targets $(sources) ]
    {
        result += [ $(t).project ] ;
    }
    return [ sequence.unique $(result) ] ;
}

# generate-dependencies: find and generate the stage and install targets
# corresponding to the source libraries.

rule generate-dependencies ( project name ? : property-set : sources * )
{
    local stage-targets ;
    local stage-or-install = [ $(property-set).get <name> ] ;
    local excluded-projects = $(project) [ $(project).find /boost ] ;
    for local p in [ get-dependency-projects $(sources) ] [ $(project).find /boost/headers ]
    {
        if ! ( $(p) in $(excluded-projects) )
        {
            stage-targets += [ $(p).find $(stage-or-install) : no-error ] ;
        }
    }
    local props = [ $(property-set).propagated ] ;
    local result ;
    local usage-requirements = [ property-set.empty ] ;
    for local t in $(stage-targets)
    {
        local g = [ $(t).generate $(props) ] ;
        usage-requirements = [ $(usage-requirements).add $(g[1]) ] ;
        result += $(g[2-]) ;
    }
    return $(usage-requirements) $(result) ;
}

# boost-install

local rule install-stage-subdir ( properties * )
{
    local ps = [ property-set.create $(properties) ] ;

    local r = [ boostcpp.tag boost : STATIC_LIB : $(ps) ] ;

    r = $(r:S=) ;

    local r2 = [ MATCH "lib(.*)" : $(r) ] ;
    if $(r2) { r = $(r2) ; }

    local python = [ $(ps).get <python> ] ;

    if $(python)
    {
        r = $(r:B=$(r:B)-python$(python)) ;
    }

    return $(r) ;
}

rule stage-subdir ( properties * )
{
    local r = [ install-stage-subdir $(properties) ] ;

    local libdir = [ boost-install-dirs.stage-libdir ] ;

    return <location>$(libdir)/$(r) ;
}

rule install-subdir ( properties * )
{
    local r = [ install-stage-subdir $(properties) ] ;

    local libdir = [ boost-install-dirs.libdir ] ;

    return <location>$(libdir)/$(r) ;
}

rule boost-install ( libraries * )
{
    .debug boost-install $(libraries) ;

    local l2 = ;
    local unprefixed = ;

    for local lib in $(libraries)
    {
        if [ MATCH boost_(.*) : $(lib) ]
        {
            l2 += $(lib) ;
        }
        else
        {
            unprefixed += $(lib) ;
        }
    }

    libraries = $(l2) ;

    # Target install

    local p = [ project.current ] ;

    local libdir = [ boost-install-dirs.libdir ] ;
    local bindir = [ boost-install-dirs.bindir ] ;

    install install-libraries-static : $(libraries) : <location>$(libdir) <install-dependencies>on <install-type>STATIC_LIB ;
    $(p).mark-target-as-explicit install-libraries-static ;

    alias install-libraries-shared : install-libraries-shared- ;
    alias install-libraries-shared : install-libraries-shared-cygwin : <target-os>cygwin ;
    $(p).mark-target-as-explicit install-libraries-shared ;

    install install-libraries-shared- : $(libraries) : <location>$(libdir) <install-type>SHARED_LIB <install-type>PDB <install-dependencies>on <install-no-version-symlinks>on ;
    $(p).mark-target-as-explicit install-libraries-shared- ;

    install install-libraries-shared-cygwin : $(libraries) : <location>$(bindir) <install-type>SHARED_LIB <install-type>PDB <install-dependencies>on <install-no-version-symlinks>on ;
    $(p).mark-target-as-explicit install-libraries-shared-cygwin ;

    install install-unprefixed-static : $(unprefixed) : <install-type>STATIC_LIB <conditional>@boost-install%install-subdir ;
    $(p).mark-target-as-explicit install-unprefixed-static ;

    install install-unprefixed-shared : $(unprefixed) : <install-type>SHARED_LIB <install-no-version-symlinks>on <conditional>@boost-install%install-subdir ;
    $(p).mark-target-as-explicit install-unprefixed-shared ;

    install-cmake-config $(libraries) ;

    generate install-dependencies : $(libraries) : <generating-rule>@boost-install%generate-dependencies <name>install ;
    $(p).mark-target-as-explicit install-dependencies ;

    alias install : install-libraries-static install-libraries-shared install-unprefixed-static install-unprefixed-shared install-cmake-config install-dependencies ;
    $(p).mark-target-as-explicit install ;

    # Target stage

    local stage-libdir = [ boost-install-dirs.stage-libdir ] ;

    stage-cmake-config $(libraries) ;

    install stage-libraries-static : $(libraries) : <location>$(stage-libdir) <install-dependencies>on <install-type>STATIC_LIB ;
    $(p).mark-target-as-explicit stage-libraries-static ;

    install stage-libraries-shared : $(libraries) : <location>$(stage-libdir) <install-dependencies>on <install-type>SHARED_LIB <install-type>PDB <install-no-version-symlinks>on ;
    $(p).mark-target-as-explicit stage-libraries-shared ;

    install stage-unprefixed-static : $(unprefixed) : <install-type>STATIC_LIB <conditional>@boost-install%stage-subdir ;
    $(p).mark-target-as-explicit stage-unprefixed-static ;

    install stage-unprefixed-shared : $(unprefixed) : <install-type>SHARED_LIB <install-type>PDB <install-no-version-symlinks>on <conditional>@boost-install%stage-subdir ;
    $(p).mark-target-as-explicit stage-unprefixed-shared ;

    generate stage-dependencies : $(libraries) : <generating-rule>@boost-install%generate-dependencies <name>stage ;
    $(p).mark-target-as-explicit stage-dependencies ;

    alias stage : stage-libraries-static stage-libraries-shared stage-unprefixed-static stage-unprefixed-shared stage-cmake-config stage-dependencies ;
    $(p).mark-target-as-explicit stage ;
}
