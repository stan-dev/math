<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Adding A New Distribution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doxygen_2contributor__help__pages_2adding__new__distributions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Adding A New Distribution</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Before reading this section it's a good idea to at least skim over the getting started guide. Stan's univariate distribution functions must work with mixes of scalars and vectors. This requirement can make the code for the distributions look a bit daunting, but in the below we'll cover each of the general steps needed to add a new distribution.</p>
<ol type="1">
<li>Get the distribution working in the Stan language.</li>
<li>Write out the partial derivatives for each input</li>
<li>Writing the function</li>
<li>Testing the function</li>
</ol>
<h2><a class="anchor" id="autotoc_md3"></a>
Get the Distribution Working In Stan</h2>
<p>We will use the normal distribution as an example and adding the lpdf function, though note for acceptance into Stan math a function must have its respective <code>lpdf</code>, <code>lcdf</code>, <code>cdf</code>, <code>lccdf</code> and <code>rng</code> implemented. Though we will only be doing the <code>lpdf</code> in the below all of the notes here will apply to the other functions.</p>
<p>So for the normal distribution probability density function</p>
<p class="formulaDsp">
\[
\text{Normal}(y|\mu,\sigma)=\frac{1}{\sigma \sqrt{2\pi}} e^{-\frac{1}{2}\left(\frac{y-\mu}{\sigma}\right)^2}
\]
</p>
<p>to get the log probability density function we log the above to get</p>
<p class="formulaDsp">
\[
\ln{\left(\text{Normal}(y|\mu,\sigma)\right)}=-\frac{1}{2} \left(\frac{y-\mu}{\sigma}\right)^2 - \ln{\left(\sigma\right)} - \frac{1}{2}\ln{\left(2\pi\right)}
\]
</p>
<p>Now we can directly plug this into Stan as a custom lpdf function</p>
<div class="fragment"><div class="line">real new_normal_lpdf (real y, real mu, real sigma){</div>
<div class="line">  return -0.5 * pow((y - mu) / sigma, 2) - log(sigma) - 0.5 * log(2*pi());</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is nice because now we can test this function against another implementations to verify its correctness. At this point it is a good idea to post something on <a href="https://discourse.mc-stan.org/">discourse</a> or file an <a href="https://github.com/stan-dev/math/issues">issue</a> to let folks know you would like to add this distribution.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Writing out the Partials</h2>
<p>For an efficient implimentation of the distribution we want to calculate each of its partials with respect to the distributions inputs. This is easy for normal but can be rough for other distributions. In that case then <a href="http://www.matrixcalculus.org/">matrixcalculus.org</a> or <a href="https://www.wolframalpha.com/">wolframalpha</a> is your friend. There we can plug in the lpdf and get back each of the partials.</p>
<p>Note that for univariate distributions wolfram handles things a bit simpler, though for multivariate distributions you'll have to use matrixcalculus. Though for both you'll have a much nicer time if you plug in the log'd version of the function. One other nice thing about the matrixcalculus site is that it can generate latex which is nice for documentation.</p>
<p class="formulaDsp">
\begin{aligned}
f = \text{ln}\left(\text{Normal}(y|\mu,\sigma)\right) &amp;= -\frac{1}{2} \left(\frac{y-\mu}{\sigma}\right)^2 - \ln\left(\sigma\right) - \frac{1}{2}\ln{\left(2\pi\right)} \cr
\frac{\partial f}{\partial y} &amp;= -\frac{y-\mu}{\sigma^{2}} \cr
\frac{\partial f}{\partial \mu} &amp;= \frac{y-\mu}{\sigma^{2}} \cr
\frac{\partial f}{\partial \sigma} &amp;= -\frac{1}{\sigma} + \frac{(y-\mu)^{2}}{\sigma^{3}}
\end{aligned}
</p>
<p>It's a little early, but once we get the <code>lpdf</code> function working with the above we will want to get out a pen and paper to simplify and find common subexpressions we only need to calculate once. For instance in the normal we can compute <code>y - mu</code> and <code>1/sigma</code></p>
<p class="formulaDsp">
\begin{aligned}
f(y|\mu,\sigma) = \text{ln}\left(\text{Normal}(y|\mu,\sigma)\right) &amp;= -\frac{1}{2} \left(\frac{y-\mu}{\sigma}\right)^2 - \ln{\left(\sigma\right)} - \frac{1}{2}\ln{\left(2\pi\right)} \cr
\frac{\partial f}{\partial y} &amp;= -t_3 \cr
\frac{\partial f}{\partial \mu} &amp;= t_3 \cr
\frac{\partial f}{\partial \sigma} &amp;= \frac{t_{2}^2}{t_1} \cdot t_0 - t_0 \cr
\text{Where} \cr
t_0 &amp;= \frac{1}{\sigma} \cr
t_1 &amp;= t_{0}^2 \cr
t_2 &amp;= y - \mu \cr
t_3 &amp;= \frac{t_2}{t_1}
\end{aligned}
</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Writing the function</h2>
<p>So now let's add the lpdf function in <code>stan/math/prim/dist/new_normal_lpdf.hpp</code>. First we'll go over what we have to do before we start doing any math. We'll be breaking down Stan's current <code>normal_lpdf</code> function which you can find <a href="https://github.com/stan-dev/math/blob/develop/stan/math/prim/prob/normal_lpdf.hpp">here</a>.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Distribution Signature</h3>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> propto, <span class="keyword">typename</span> T_y, <span class="keyword">typename</span> T_loc, <span class="keyword">typename</span> T_scale&gt;</div>
<div class="line"><span class="keyword">inline</span> return_type_t&lt;T_y, T_loc, T_scale&gt; normal_lpdf(<span class="keyword">const</span> T_y&amp; y,</div>
<div class="line">                                                      <span class="keyword">const</span> T_loc&amp; mu,</div>
<div class="line">                                                      <span class="keyword">const</span> T_scale&amp; sigma) {}</div>
</div><!-- fragment --><p>Each of the input arguments represent the inputs to the <code>Normal</code> function we wrote out above. The template parameters for univariate distributions are very general and they must work for all of Stan's scalar types <code>double</code>, <code>var</code>, and <code>fvar&lt;T&gt;</code> while accepting mixtures of scalars and vectors. The return of the function is the joint log probability accumulated over all of the inputs which is a scalar of the least upper bound of all the parameters scalar types. That's a lot of big words, but in essence means that if one of the inputs is a <code>var</code> and the others are double the return type needs to be a <code>var</code>. If the input signature contained <code>fvar&lt;var&gt;</code>, <code>var</code>, <code>double</code> then the return type would be <code>fvar&lt;var&gt;</code>. See the Common pitfalls for an explanation of <code>return_type_t</code>.</p>
<p>Notice the <code>bool propto</code> template parameter, this is used by the function to decide whether or not the function needs to propagate constants to the joint log probability we'll be calculating.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Preparing the Parameters</h3>
<p>At the start of the function we need to take each argument, deduce whether it is an unevaluated <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression, and extract the values from them and then convert them into <code>Eigen::Array</code> types. <code>ref_type_t</code> is the return type of <code>to_ref()</code> which is explained in the getting started guide. <code>ret_type_if_t&lt;&gt;</code> will conditionally evaluate <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions if both the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type passed is an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression <em>and</em> the compile time conditional passed to the function is also <code>true</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Making aliases for partials and unevaluated expressions</span></div>
<div class="line"><span class="keyword">using </span>T_partials_return = partials_return_t&lt;T_y, T_loc, T_scale&gt;;</div>
<div class="line"><span class="keyword">using </span>T_y_ref = ref_type_if_t&lt;!is_constant&lt;T_y&gt;::value, T_y&gt;;</div>
<div class="line"><span class="keyword">using </span>T_mu_ref = ref_type_if_t&lt;!is_constant&lt;T_loc&gt;::value, T_loc&gt;;</div>
<div class="line"><span class="keyword">using </span>T_sigma_ref = ref_type_if_t&lt;!is_constant&lt;T_scale&gt;::value, T_scale&gt;;</div>
<div class="line"><span class="comment">// Evaluating unevaluated eigen expressions</span></div>
<div class="line">T_y_ref y_ref = y;</div>
<div class="line">T_mu_ref mu_ref = mu;</div>
<div class="line">T_sigma_ref sigma_ref = sigma;</div>
<div class="line"><span class="comment">// Extracting values from arguments</span></div>
<div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) y_val = to_ref(as_value_column_array_or_scalar(y_ref));</div>
<div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) mu_val = to_ref(as_value_column_array_or_scalar(mu_ref));</div>
<div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) sigma_val = to_ref(as_value_column_array_or_scalar(sigma_ref));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Checking Correctness of the Inputs and Early Return</h3>
<p>Then we need to check that all the vector inputs sizes match, and then check that each of the inputs satisfies the conditions of the distribution. For the normal distribution we need to check that <code>y</code> does not contain nan values, <code>mu</code> is finite, and <code>sigma</code> is positive.</p>
<div class="fragment"><div class="line">check_consistent_sizes(function, <span class="stringliteral">&quot;Random variable&quot;</span>, y, <span class="stringliteral">&quot;Location parameter&quot;</span>,</div>
<div class="line">                       mu, <span class="stringliteral">&quot;Scale parameter&quot;</span>, sigma);</div>
<div class="line">check_not_nan(function, <span class="stringliteral">&quot;Random variable&quot;</span>, y_val);</div>
<div class="line">check_finite(function, <span class="stringliteral">&quot;Location parameter&quot;</span>, mu_val);</div>
<div class="line">check_positive(function, <span class="stringliteral">&quot;Scale parameter&quot;</span>, sigma_val);</div>
<div class="line"><span class="keywordflow">if</span> (size_zero(y, mu, sigma)) {</div>
<div class="line">  <span class="keywordflow">return</span> 0.0;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (!include_summand&lt;propto, T_y, T_loc, T_scale&gt;::value) {</div>
<div class="line">  <span class="keywordflow">return</span> 0.0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>if</code> statements here are checking if</p>
<ol type="1">
<li>Any of the inputs are length zero</li>
<li>Either the function drops constants <code>propto=true</code> and all of the inputs are constant (aka if they are all of type <code>double</code>).</li>
</ol>
<p>If either of the two conditions are met then there's no need to calculate the rest of the lpdf function and we can return back zero.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Actually Doing The Math</h3>
<p>Woof! That was a good bit of stuff just to get to the math, but here we are! Our goal is to calculate the partial adjoints using our stuff above, but we only want to bother ourselves to calculate adjoints of parameters which are not constant (<code>double</code>). There's some more technical bits to building the log joint probability, but those are all hidden away in the <code>operands_and_partials</code> class so we won't cover those here. For now you can take the evaluated inputs and pass them to the <code>operands_and_partials</code> class</p>
<div class="fragment"><div class="line">operands_and_partials&lt;T_y_ref, T_mu_ref, T_sigma_ref&gt; ops_partials(</div>
<div class="line">    y_ref, mu_ref, sigma_ref);</div>
</div><!-- fragment --><p>This sets up each of the input operand's partials so that we only store and calculate the ones we need.</p>
<hr  />
<p>On a side note it would be nice to have a helper function like <code>make_ops_partials</code> which would construct that class and then we could simply write</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ops_partials = make_ops_partials(y_ref, mu_ref, sigma_ref);</div>
</div><!-- fragment --><p>This would let us also cleanup the aliases for the unevaluated <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions so we could use <code>to_ref_if()</code> such as</p>
<div class="fragment"><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) y_ref = to_ref_if&lt;!is_constant&lt;T_y&gt;::value&gt;(y);</div>
<div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) mu_ref = to_ref_if&lt;!is_constant&lt;T_mu&gt;::value&gt;(mu);</div>
<div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) sigma_ref = to_ref_if&lt;!is_constant&lt;T_sigma&gt;::value&gt;(sigma);</div>
</div><!-- fragment --><hr  />
<p>There's two ways of doing the math, one using a simple loop and another utilizing <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions. Below I will cover both starting with the loop version.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Doing The Math With A Loop</h3>
<p>The loop version requires one other piece of overhead to make sure that vectors and scalars can both be iterated over in the loop.</p>
<div class="fragment"><div class="line"><span class="comment">// Make scalars and vectors iterable</span></div>
<div class="line">scalar_seq_view&lt;<span class="keyword">decltype</span>(y_val)&gt; y_vec(y_val);</div>
<div class="line">scalar_seq_view&lt;<span class="keyword">decltype</span>(mu_val)&gt; mu_vec(mu_val);</div>
<div class="line">scalar_seq_view&lt;<span class="keyword">decltype</span>(sigma_val)&gt; sigma_vec(sigma_val);</div>
</div><!-- fragment --><p>For vectors, <code>scalar_seq_view</code> simply holds a reference to the vector it's passed and calling <code>scalar_seq_view</code>'s method <code>.val(i)</code> will return element i in the vector after calling <code>value_of()</code> on the element. The actual element can be accessed with <code>operator[]</code>. For scalars, <code>scalar_seq_view</code>'s <code>.val(i)</code> and <code>operator[]</code> will just return the scalar no matter what index is passed.</p>
<p>But with that now we can get the maximum size of the input arguments and run a loop calculating the partials for each input argument's values.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> N = max_size(y, mu, sigma);</div>
<div class="line"><span class="comment">// Stores the accumulated value from the lpdf from operands</span></div>
<div class="line">T_partials_return logp(0.0);</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">double</span> NEGATIVE_HALF = -0.5;</div>
<div class="line"><span class="comment">// Include constant if user asked for them.</span></div>
<div class="line"><span class="keywordflow">if</span> (include_summand&lt;propto&gt;::value) {</div>
<div class="line">  logp += NEG_LOG_SQRT_TWO_PI * N;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> n = 0; n &lt; N; n++) {</div>
<div class="line">  <span class="comment">// Do the intermediate calculations from above</span></div>
<div class="line">  <span class="keyword">const</span> T_partials_return y_dbl = y_vec.val(n);</div>
<div class="line">  <span class="keyword">const</span> T_partials_return mu_dbl = mu_vec.val(n));</div>
<div class="line">  <span class="keyword">const</span> T_partials_return inv_sigma = 1.0 / sigma_vec.val(n);</div>
<div class="line">  <span class="keyword">const</span> T_partials_return log_sigma = log(sigma_vec.val(n));</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> T_partials_return y_minus_mu_over_sigma</div>
<div class="line">      = (y_dbl - mu_dbl) * inv_sigma;</div>
<div class="line">  <span class="keyword">const</span> T_partials_return y_minus_mu_over_sigma_squared</div>
<div class="line">      = y_minus_mu_over_sigma * y_minus_mu_over_sigma;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Include constants if user asked for them.</span></div>
<div class="line">  <span class="keywordflow">if</span> (include_summand&lt;propto, T_scale&gt;::value) {</div>
<div class="line">    logp -= log_sigma;</div>
<div class="line">  }</div>
<div class="line">  logp += NEGATIVE_HALF * y_minus_mu_over_sigma_squared;</div>
<div class="line">  <span class="comment">// Add partial calculations to each edge</span></div>
<div class="line">  T_partials_return scaled_diff = inv_sigma * y_minus_mu_over_sigma;</div>
<div class="line">  <span class="keywordflow">if</span> (!is_constant&lt;T_y&gt;::value) {</div>
<div class="line">    ops_partials.edge1_.partials_[n] -= scaled_diff;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!is_constant&lt;T_loc&gt;::value) {</div>
<div class="line">    ops_partials.edge2_.partials_[n] += scaled_diff;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!is_constant&lt;T_scale&gt;::value) {</div>
<div class="line">    ops_partials.edge3_.partials_[n]</div>
<div class="line">        += -inv_sigma + inv_sigma * y_minus_mu_over_sigma_squared;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// return `logp` and handle rules for propagating partials for each autodiff type.</span></div>
<div class="line"><span class="keywordflow">return</span> ops_partials.build(logp);</div>
</div><!-- fragment --><p>The <code>logp</code> is used to accumulate the log probability density function's value, where <code>propto</code> is used to decide whether or not that value should have constants added or dropped.</p>
<p>The odd bits here are mostly the <code>if</code>s that include <code>include_summand&lt;propto&gt;</code> and <code>!is_constant_all&lt;T_loc&gt;</code>. We want to only compute the partials and accumulate the constants if those values are not constant (<code>double</code>), so we have an if statement here, which since the conditional is a type trait whose value is known at compile time we won't pay for any of these if they are constant. And the compiler will remove the ifs that are false during the dead code elimination phase of optimization.</p>
<p>We collect the partials for each of our inputs via their respective <code>edge*_</code> in the <code>operands_and_partials</code> class. The first argument will have <code>edge1_</code>, the second <code>edge2_</code> and so on. One important question to ask here is, what if the edge is a scalar? It seems odd that we are able to call <code>partials_[n]</code> when the operand can be either a vector or scalar. Under the hood, <code>operands_and_partials</code> wraps the partials for <code>Scalar</code> types in what's called a <a href="https://github.com/stan-dev/math/blob/develop/stan/math/prim/functor/broadcast_array.hpp"><code>broadcast_array</code></a> which has an overloaded <code>operator[]</code> for scalars such that it just simply returns back the partials scalar. Similarly, <code>broadcast_array</code> has an overloaded <code>operator=</code> which when assigning a vector to the partial the overloaded <code>operator=</code> will sum the vector before assigning it to the partial.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!is_constant&lt;T_loc&gt;::value) {</div>
<div class="line">  <span class="comment">// pretend partials_ is a scalar and scaled_diff is a vector</span></div>
<div class="line">  ops_partials.edge2_.partials_ = scaled_diff;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally once the loop is finished we call <code>ops_partials.build()</code> passing it the joint log probability value. For reverse mode this will place a callback on the callback stack that takes the edge for each <code>partial_</code> and accumulates them into operands adjoint.</p>
<p>The for loop version is nice and simple, but there's a few things for performance that we can do better. For instance, in the for loop version we are constantly reading and writing to memory from a bunch of different places. We can fix that by rewriting the above to use multiple loops, but unless we have separate loops that turn on and off for when combinations of partials need to be calculated then we lose places where we can share calculations between partials.</p>
<p>For a more efficient version we can do the math for the partials with no loop and <em>possibly</em> sharing computation.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Doing The Math With Eigen</h3>
<p>The below code replaces the loop above with <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a>. It uses most of the same tricks we've used previously.</p>
<div class="fragment"><div class="line">  <span class="comment">// Only evaluate inv_sigma here if it&#39;s going to be used more than once</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; inv_sigma</div>
<div class="line">      = to_ref_if&lt;!is_constant_all&lt;T_y, T_scale, T_loc&gt;::value&gt;(inv(sigma_val));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; y_scaled = to_ref((y_val - mu_val) * inv_sigma);</div>
<div class="line">  <span class="comment">// Only evaluate y_scaled_sq here if T_scale is not constant</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; y_scaled_sq</div>
<div class="line">      = to_ref_if&lt;!is_constant&lt;T_scale&gt;::value&gt;(y_scaled * y_scaled);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">size_t</span> N = max_size(y, mu, sigma);</div>
<div class="line">  T_partials_return logp = -0.5 * sum(y_scaled_sq);</div>
<div class="line">  <span class="keywordflow">if</span> (include_summand&lt;propto&gt;::value) {</div>
<div class="line">    logp += NEG_LOG_SQRT_TWO_PI * N;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// division by size of sigma is a trick to work with vectors and scalars</span></div>
<div class="line">  <span class="keywordflow">if</span> (include_summand&lt;propto, T_scale&gt;::value) {</div>
<div class="line">    logp -= sum(log(sigma_val)) * N / size(sigma);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!is_constant_all&lt;T_y, T_scale, T_loc&gt;::value) {</div>
<div class="line">    <span class="comment">// Evaluate this if it&#39;s only used once</span></div>
<div class="line">    <span class="keyword">auto</span> scaled_diff = to_ref_if&lt;!is_constant&lt;T_y&gt;::value</div>
<div class="line">                                     + !is_constant&lt;T_scale&gt;::value</div>
<div class="line">                                     + !is_constant&lt;T_loc&gt;::value</div>
<div class="line">                                 &gt;= 2&gt;(inv_sigma * y_scaled);</div>
<div class="line">    <span class="keywordflow">if</span> (!is_constant&lt;T_y&gt;::value) {</div>
<div class="line">      ops_partials.edge1_.partials_ = -scaled_diff;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!is_constant&lt;T_scale&gt;::value) {</div>
<div class="line">      ops_partials.edge3_.partials_ = inv_sigma * y_scaled_sq - inv_sigma;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!is_constant&lt;T_loc&gt;::value) {</div>
<div class="line">      ops_partials.edge2_.partials_ = std::move(scaled_diff);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> ops_partials.build(logp);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Some of the same tricks from the above sections are used here in clever ways. For instance, when calculating <code>inv_sigma</code>, if that expression is used for calculating multiple partials then we want to evaluate it once on that line and reuse the precomputed operation multiple times in the preceding code. However if it's not used multiple times then we just want an expression that will then later be evaluated at its final destination. The same happens for <code>y_scaled_sq</code> and <code>scaled_diff</code>.</p>
<p>One odd piece of code here is</p>
<div class="fragment"><div class="line"><span class="comment">// division by size of sigma is a trick to work with vectors and scalars</span></div>
<div class="line"><span class="keywordflow">if</span> (include_summand&lt;propto, T_scale&gt;::value) {</div>
<div class="line">  logp -= sum(log(sigma_val)) * N / size(sigma);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If <code>sigma_val</code> is a scalar then we want to decrement the joint log probability by <code>log(sigma_val) * N</code>, but if it's a vector we want to decrement it by <code>sum(log(sigma_val))</code>. In Stan, passing a scalar to <code>sum()</code> is a no-op that just returns back the scalar, so we can use that to have the left hand side of the multiply work with both vectors and scalars. We always multiply the returned scalar from <code>sum()</code> by <code>N</code>, which we don't want if <code>sigma_val</code> is a vector. So then we just divide by the <code>size()</code> of <code>sigma</code>, which for a scalar will be 1 and for a vector will be <code>N</code>.</p>
<p>It might be easier to see how this would look if Stan used C++17</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (include_summand&lt;propto, T_scale&gt;::value) {</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (is_vector&lt;T_scale&gt;::value) {</div>
<div class="line">    logp -= sum(log(sigma_val));</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    logp -= log(sigma_val) * N;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<p>Side Note: We should make <code>size()</code> constexpr for scalars so then tricks like this let the compiler see we are doing division by 1 and will remove the operation.</p>
<hr  />
<p>But that's it, you can see the full <code>normal_lpdf</code> function <a href="https://github.com/stan-dev/math/blob/develop/stan/math/prim/prob/normal_lpdf.hpp">here</a> in Stan that uses the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> version.</p>
<p>One other little piece you'll want to do is add a <code>normal_lpdf</code> function with the exact same signature but without the <code>propto</code> parameter. Unless told otherwise we don't assume users want the proportional constants added so we have a default signature that does not require setting the <code>propto</code> parameter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_y, <span class="keyword">typename</span> T_loc, <span class="keyword">typename</span> T_scale&gt;</div>
<div class="line"><span class="keyword">inline</span> return_type_t&lt;T_y, T_loc, T_scale&gt; normal_lpdf(<span class="keyword">const</span> T_y&amp; y,</div>
<div class="line">                                                      <span class="keyword">const</span> T_loc&amp; mu,</div>
<div class="line">                                                      <span class="keyword">const</span> T_scale&amp; sigma) {</div>
<div class="line">  <span class="keywordflow">return</span> normal_lpdf&lt;false&gt;(y, mu, sigma);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Testing The Distribution</h2>
<p>For testing the new distribution you'll be adding to the <a href="https://github.com/stan-dev/math/tree/develop/test/prob">Distribution Testing Framework</a>. In <code>test/prob</code> you will add a new folder with the name of your distribution with the <code>.hpp</code> files for generating the tests inside of it. Looking at the <a href="https://github.com/stan-dev/math/tree/develop/test/prob/normal">normal distribution</a> testing files you'll see you need</p>
<ul>
<li><code>mydist_test.hpp</code> containing a class inheriting from <code>AgradDistributionTest</code> containing methods<ul>
<li><code>valid_values()</code> which fills the <code>[in/out]</code> params argument with valued testing values for your distribution and the <code>[in/out] log_prob</code> argument with the log probability given those parameters.</li>
<li><code>invalid_values()</code> which fills the <code>[in/out]</code> value argument with testing values that should fail.</li>
<li>Two <code>log_prob()</code> methods which calls your distribution, one with <code>propto</code> and the other without.</li>
<li><code>log_prob_function()</code> which is the log probability density function's simple implementation much like the one you wrote in Stan.</li>
</ul>
</li>
</ul>
<p>The other test files are quite similar, though note the <code>normal</code> cdf test uses some extra numeric tricks where for example the tests for <a href="https://github.com/stan-dev/math/blob/develop/test/prob/gumbel/gumbel_cdf_test.hpp">gumbel_lcdf</a> are very similar to the <code>normal_lpdf</code> test.</p>
<p>Once you've added those files you can run your tests for your distribution with <code>./runTests.py</code> pointing it to the folder containing your tests. This will generate all of the tests for each of Stan's scalar types and mixes of scalars and vectors.</p>
<div class="fragment"><div class="line">./runTests.py ./test/prob/mydist/</div>
</div><!-- fragment --><p>For more details see the distribution testing docs.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
That's it!</h2>
<p>The above should cover all of the <code>lpdf</code>, <code>lcdf</code>, <code>cdf</code>, <code>lccdf</code> and <code>rng</code> functions needed to add a new distribution to Stan. If you have further questions please reach out on our <a href="https://discourse.mc-stan.org/">discourse</a> or file an <a href="https://github.com/stan-dev/math/issues">issue</a>! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
