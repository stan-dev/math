<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Automatic Differentiation Testing Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doxygen_2contributor__help__pages_2autodiff__test__guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Automatic Differentiation Testing Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The automatic differentiation testing framework tests the value and derivatives (up to third order) of a function against results derived from the primitive implementation with finite differences. Multivariate functions are tested as unary functions by projecting to each output dimension. All that needs to be provided is a working primitive implementation and the inputs to test.</p>
<p>Derivatives are tested</p>
<ul>
<li>with user supplied arguments plus all combinations of automatic differentiation variables up to third order:<ul>
<li>first order: <code>var</code> (gradient), <code>fvar&lt;double&gt;</code> tested using <code>gradient()</code> functionals</li>
<li>second order: <code>fvar&lt;var&gt;</code>, <code>fvar&lt;fvar&lt;double&gt;&gt;</code> tested using <code>hessian()</code> functionals</li>
<li>third order: <code>fvar&lt;fvar&lt;var&gt;&gt;</code> tested using <code>grad_hessian()</code> functional</li>
</ul>
</li>
<li>for all possible output values for functions with multivariate outputs,</li>
<li>for all possible combinations of argument instantiations with primitive (<code>int</code> or <code>double</code>) and automatic differentiation variables, and</li>
<li>up to three levels of container nesting for elementwise vectorized functions.</li>
</ul>
<p>Exceptions are tested insofar as if one version of the primitive or autodiff versions of the function throws an exception they must all throw an exception That is, each autodiff call must throw exceptions for exactly the same argument values as the primitive implementation.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Scope of tests</h2>
<p>The framework can test unary and binary functions with any of the following input and output types. <br  />
</p>
<p>The basic types that can be handled by the testing framework are</p>
<ul>
<li><code>int</code>: integer</li>
<li><code>double</code>: double-precision floating point</li>
<li><code>Eigen::Matrix&lt;double, -1, 1&gt;</code>: column vector</li>
<li><code>Eigen::Matrix&lt;double, 1, -1&gt;</code>: row vector</li>
<li><code>Eigen::Matrix&lt;double, -1, -1&gt;</code>: matrix</li>
</ul>
<p>For any type <code>T</code> that can be handled, the framework can also handle the corresponding standard vector type (used for arrays in Stan)</p>
<ul>
<li><code>std::vector&lt;T&gt;</code>: array of elements of type <code>T</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
Relative error comparisons</h2>
<p>The tests are instrumented to test relative error between the values and derivatives produced by the function being tested and those produced by finite differences. For non-zero inputs, the relative error is defined to be the error divided by the average absolute values of the arguments:</p>
<div class="fragment"><div class="line">error(u, v) = u - v</div>
<div class="line">relative_error(u, v) = error(u, v) / (0.5 * (abs(u) + abs(v)))</div>
</div><!-- fragment --><p>If one of the inputs is zero, error is used rather than relative error (because relative error devolves if one or both inputs are zero)</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Tests and tolerances</h2>
<p>The following table lists the complete set of tests, with their default tolerances, the type of automatic differentiation variable used, the name of the functional used to perform the test, and the order of the test. The first column lists the names of the member variables in the simple struct <code>stan::test::ad_tolerances</code>. Every test accepts an <code>ad_tolerances</code> object as a first argument, so the defaults may be overridden for particular tests. The default tolerances are set relatively high because of the inaccuracy of simple finite difference calculations as used by these tests. <br  />
</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">function   </th><th class="markdownTableHeadCenter">tolerance   </th><th class="markdownTableHeadCenter">autodiff type   </th><th class="markdownTableHeadCenter">functional   </th><th class="markdownTableHeadLeft">(order) test    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><code>gradient_val_</code>   </td><td class="markdownTableBodyCenter">1e-8   </td><td class="markdownTableBodyCenter"><code>var</code>   </td><td class="markdownTableBodyCenter"><code>gradient</code>   </td><td class="markdownTableBodyLeft">(0) value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><code>gradient_grad_</code>   </td><td class="markdownTableBodyCenter">1e-4   </td><td class="markdownTableBodyCenter"><code>var</code>   </td><td class="markdownTableBodyCenter"><code>gradient</code>   </td><td class="markdownTableBodyLeft">(1) gradient    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><code>gradient_fvar_val_</code>   </td><td class="markdownTableBodyCenter">1e-8   </td><td class="markdownTableBodyCenter"><code>fvar&lt;double&gt;</code>   </td><td class="markdownTableBodyCenter"><code>gradient</code>   </td><td class="markdownTableBodyLeft">(0) value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><code>gradient_fvar_grad_</code>   </td><td class="markdownTableBodyCenter">1e-4   </td><td class="markdownTableBodyCenter"><code>fvar&lt;double&gt;</code>   </td><td class="markdownTableBodyCenter"><code>gradient</code>   </td><td class="markdownTableBodyLeft">(1) gradient    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><code>hessian_val_</code>   </td><td class="markdownTableBodyCenter">1e-8   </td><td class="markdownTableBodyCenter"><code>fvar&lt;var&gt;</code>   </td><td class="markdownTableBodyCenter"><code>hessian</code>   </td><td class="markdownTableBodyLeft">(0) value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><code>hessian_grad_</code>   </td><td class="markdownTableBodyCenter">1e-4   </td><td class="markdownTableBodyCenter"><code>fvar&lt;var&gt;</code>   </td><td class="markdownTableBodyCenter"><code>hessian</code>   </td><td class="markdownTableBodyLeft">(1) gradient    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><code>hessian_hessian_</code>   </td><td class="markdownTableBodyCenter">1e-3   </td><td class="markdownTableBodyCenter"><code>fvar&lt;var&gt;</code>   </td><td class="markdownTableBodyCenter"><code>hessian</code>   </td><td class="markdownTableBodyLeft">(2) Hessian    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><code>hessian_fvar_val_</code>   </td><td class="markdownTableBodyCenter">1e-8   </td><td class="markdownTableBodyCenter"><code>fvar&lt;fvar&lt;double&gt;&gt;</code>   </td><td class="markdownTableBodyCenter"><code>hessian</code>   </td><td class="markdownTableBodyLeft">(0) value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><code>hessian_fvar_grad_</code>   </td><td class="markdownTableBodyCenter">1e-4   </td><td class="markdownTableBodyCenter"><code>fvar&lt;fvar&lt;double&gt;&gt;</code>   </td><td class="markdownTableBodyCenter"><code>hessian</code>   </td><td class="markdownTableBodyLeft">(1) gradient    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><code>hessian_fvar_hessian_</code>   </td><td class="markdownTableBodyCenter">1e-3   </td><td class="markdownTableBodyCenter"><code>fvar&lt;fvar&lt;double&gt;&gt;</code>   </td><td class="markdownTableBodyCenter"><code>hessian</code>   </td><td class="markdownTableBodyLeft">(2) Hessian    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><code>grad_hessian_val_</code>   </td><td class="markdownTableBodyCenter">1e-8   </td><td class="markdownTableBodyCenter"><code>fvar&lt;fvar&lt;var&gt;&gt;</code>   </td><td class="markdownTableBodyCenter"><code>grad_hessian</code>   </td><td class="markdownTableBodyLeft">(0) value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><code>grad_hessian_hessian_</code>   </td><td class="markdownTableBodyCenter">1e-3   </td><td class="markdownTableBodyCenter"><code>fvar&lt;fvar&lt;var&gt;&gt;</code>   </td><td class="markdownTableBodyCenter"><code>grad_hessian</code>   </td><td class="markdownTableBodyLeft">(2) Hessian    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><code>grad_hessian_grad_hessian_</code>   </td><td class="markdownTableBodyCenter">1e-2   </td><td class="markdownTableBodyCenter"><code>fvar&lt;fvar&lt;var&gt;&gt;</code>   </td><td class="markdownTableBodyCenter"><code>grad_hessian</code>   </td><td class="markdownTableBodyLeft">(3) gradient of Hessian   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md21"></a>
Examples</h2>
<p>These examples are all included in the unit tests for the test framework in file <code>test/unit/math/test_ad_test.cpp</code></p>
<h3><a class="anchor" id="autotoc_md22"></a>
Example: matrix inverse (unary function)</h3>
<p>Let's start by seeing how to test matrix inverse. In Stan, that's a unary function <code>inverse</code> that takes a matrix input and returns a matrix output.</p>
<div class="fragment"><div class="line">Matrix&lt;T, -1, -1&gt; inverse(<span class="keyword">const</span> Matrix&lt;T, -1, 1&gt;&amp; a);</div>
</div><!-- fragment --><p>We'll need to include the test framework (which includes both the Google test framework and all of the Stan math library (by including `&lt;<a class="el" href="math_8hpp.html">stan/math.hpp</a>&gt;). The entire library is included to ensure that all functions work under the standard include system when all higher-order autodiff is included.</p>
<p>Each test is scoped within a Google test framework <code>TEST</code> macro. Thus all of our test files will look like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;test/unit/math/test_ad.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">TEST(test_name, subtest1_name) {</div>
<div class="line">  ... first test goes here...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST(test_name, subtest2_name) {</div>
<div class="line">  ... second test goes here...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">... more tests may follow ...</div>
</div><!-- fragment --><p>If there is more than one test, there will be more than one <code>TEST</code> macro invocation, each with a unique combination of test name and subtest name.</p>
<p>The body of a test will define a polymorphic functor to test, then a sequence of arguments to test with thest framework. Although a functor is necessary in order for there to be a single type encapsulating all possible overloads, it can be a simple closure.</p>
<p>Here's what the first test looks like for <code>inverse</code>, repeating the macro wrapper and include</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;test/unit/math/test_ad.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">TEST(inverse, two_by_two) {</div>
<div class="line">  <span class="keyword">auto</span> inverse_functor = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacestan_1_1math_a9758a1234f70a8b8954caff1a3ffbf03.html#a9758a1234f70a8b8954caff1a3ffbf03">stan::math::inverse</a>(u);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  Eigen::MatrixXd x(2, 2);</div>
<div class="line">  x &lt;&lt; 1.9, 0.3,</div>
<div class="line">       0.3, 1.7;</div>
<div class="line"> </div>
<div class="line">  stan::test::expect_ad(inverse_functor, x);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacestan_1_1math_a9758a1234f70a8b8954caff1a3ffbf03_html_a9758a1234f70a8b8954caff1a3ffbf03"><div class="ttname"><a href="namespacestan_1_1math_a9758a1234f70a8b8954caff1a3ffbf03.html#a9758a1234f70a8b8954caff1a3ffbf03">stan::math::inverse</a></div><div class="ttdeci">Eigen::Matrix&lt; value_type_t&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt; inverse(const EigMat &amp;m)</div><div class="ttdoc">Forward mode specialization of calculating the inverse of the matrix.</div><div class="ttdef"><b>Definition</b> <a href="fwd_2fun_2inverse_8hpp_source.html#l00028">inverse.hpp:28</a></div></div>
</div><!-- fragment --><p>That's it. The <code>inverse_functor</code> is defined using a lambda (with no closure &mdash; the <code>[ ]</code> bit) taking a <code>const auto&amp;</code> argument and returning the result of applying <code><a class="el" href="namespacestan_1_1math_a9758a1234f70a8b8954caff1a3ffbf03.html#a9758a1234f70a8b8954caff1a3ffbf03" title="Forward mode specialization of calculating the inverse of the matrix.">stan::math::inverse</a></code>. Generic lambdas are a C++14 feature (in <code>-std=c++1y</code> for the compiler). They're convenient here because they define a polymorphic functor defined for any argument for which the body is defined, which here means any argument <code>u</code> for which <code>stan::math::inverse(u)</code> is defined. Bare functions aren't enough for the testing framework functions like <code>expect_ad</code> to perform type inference as they do not have a single type. The functor defined by the lambda closure has a single type.</p>
<p>The second bit of the code defines the Matrix to test, here an invertible positive-definite matrix with first row <code>[1.9 0.3]</code> and second row <code>[0.3 1.9]</code>. <br  />
</p>
<p>The final bit of the code simply invokes the test framework for the functor and argument(s) being tested. The <code>expect_ad</code> function is both variadic and overloaded to deal with arbitrary Stan-relevant input and output types. <br  />
</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Example 1a: Adding tolerances</h3>
<p>If we wanted to lower the tolerance for the gradient test using reverse-mode autodiff, we could use</p>
<div class="fragment"><div class="line">ad_tolerances tols;  <span class="comment">// constructed with default tolerances</span></div>
<div class="line">tols.gradient_grad_ = 1e-3;</div>
<div class="line">expect_ad(tols, inverse_functor, x);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Example 2: Binary Function (multiply matrix/scalar)</h3>
<p>Binary functions are handled the same way as unary functions. The framework tests all combinations of input autodiff types, e.g., <code>f(double, var)</code>, <code>f(var, double)</code>, and <code>f(var, var)</code> for testing reverse-mode instantiations. When there is more than one autodiff variable argument, all autodiff arguments must be of the same type. <br  />
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;test/unit/math/test_ad.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">TEST(multiply_matrix_scalar, test1) {</div>
<div class="line">  <span class="keyword">auto</span> g = [ ] (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; v) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacestan_1_1math_a68817034db6ea04cda51c87bc86329a6.html#a68817034db6ea04cda51c87bc86329a6">stan::math::multiply</a>(u, v);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  Eigen::MatrixXd x(2, 3);</div>
<div class="line">  x &lt;&lt; 1, 2, 3, 4, 5, 6;</div>
<div class="line">  <span class="keywordtype">double</span> y = -3;</div>
<div class="line">  stan::test::expect_ad(g, x, y);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> y2 = std::numeric_limits&lt;double&gt;::quiet_NaN();</div>
<div class="line">  stan::test::expect_ad(g, x, y2);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacestan_1_1math_a68817034db6ea04cda51c87bc86329a6_html_a68817034db6ea04cda51c87bc86329a6"><div class="ttname"><a href="namespacestan_1_1math_a68817034db6ea04cda51c87bc86329a6.html#a68817034db6ea04cda51c87bc86329a6">stan::math::multiply</a></div><div class="ttdeci">auto multiply(const Mat1 &amp;m1, const Mat2 &amp;m2)</div><div class="ttdoc">Return the product of the specified matrices.</div><div class="ttdef"><b>Definition</b> <a href="fwd_2fun_2multiply_8hpp_source.html#l00019">multiply.hpp:19</a></div></div>
</div><!-- fragment --><p>The lambda here abstracts two arguments to which it applies the <code>multiply</code> function. There are two tests. Here The first takes <code>y = -3</code> and the second <code>y = NaN</code>. <br  />
</p>
<h3><a class="anchor" id="autotoc_md25"></a>
Example 3: vectorized unary scalar function</h3>
<p>Most of the unary scalar functions in Stan are vectorized in that they can be applied elementwise to any container type.</p>
<p>The only difference in calls is that the <code>expect_ad_vectorized</code> function is used in place of <code>expect_ad</code>. The <code>log10</code> function is vectorized to operate elementwise, and the following code will test it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;test/unit/math/test_ad.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">TEST(test_unit_math_test_ad, expect_ad_vectorized) {</div>
<div class="line">  <span class="keyword">auto</span> g = [ ] (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486">stan::math::log10</a>(u);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  stan::test::expect_ad_vectorized(g, 3.2);  <span class="comment">// finite return</span></div>
<div class="line">  stan::test::expect_ad_vectorized(g, 0);  <span class="comment">// infinite return</span></div>
<div class="line">  stan::test::expect_ad_vectorized(g, -1.7);  <span class="comment">// NaN return</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486_html_aaadc90acda3e608b200fc3eb6188c486"><div class="ttname"><a href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486">stan::math::log10</a></div><div class="ttdeci">static constexpr double log10()</div><div class="ttdoc">Returns the natural logarithm of ten.</div><div class="ttdef"><b>Definition</b> <a href="constants_8hpp_source.html#l00228">constants.hpp:228</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Example 4: Mismatched autodiff and double functions</h3>
<p>The following function has an autodiff implementation that differs by a negation from the primitive version, throwing off value and derivative tests.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;test/unit/math/test_ad.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">TEST(test_ad, mismatch) {</div>
<div class="line">  <span class="keywordtype">double</span> x = 3.2;</div>
<div class="line">  <span class="keyword">auto</span> g = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u) { <span class="keywordflow">return</span> f_mismatch(u); };</div>
<div class="line">  <span class="comment">// include following line to show exception error behavior</span></div>
<div class="line">  stan::test::expect_ad(g, x);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">~/cmdstan/<a class="code hl_namespace" href="namespacestan.html">stan</a>/lib/stan_math$ ./runTests.py -j4 test/unit/math/test_ad_test.cpp</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">[ RUN      ] test_ad.mismatch</div>
<div class="line">./test/unit/math/mix/mat/util/autodiff_tester.hpp:75: Failure</div>
<div class="line">The difference between x1 and x2 is 12.800000000000001, which exceeds tol, where</div>
<div class="line">x1 evaluates to -6.4000000000000004,</div>
<div class="line">x2 evaluates to 6.4000000000000004, and</div>
<div class="line">tol evaluates to 1.0000000000000001e-09.</div>
<div class="line">expect_near(-6.4000000000000004, 6.4000000000000004)</div>
<div class="line">test_gradient fx = fx_ad</div>
<div class="line"> </div>
<div class="line">./test/unit/math/mix/mat/util/autodiff_tester.hpp:75: Failure</div>
<div class="line">The difference between x1 and x2 is 4.0000000000000764, which exceeds tol, where</div>
<div class="line">x1 evaluates to -2.0000000000000759,</div>
<div class="line">x2 evaluates to 2, and</div>
<div class="line">tol evaluates to 9.9999999999999995e-08.</div>
<div class="line">expect_near(-2.0000000000000759, 2)</div>
<div class="line">expect_near elt x1(i) = x2(i)</div>
<div class="line">test gradient grad_fd == grad_ad</div>
<div class="line"> </div>
<div class="line">[  FAILED  ] test_ad.mismatch (1 ms)</div>
<div class="ttc" id="anamespacestan_html"><div class="ttname"><a href="namespacestan.html">stan</a></div><div class="ttdoc">The lgamma implementation in stan-math is based on either the reentrant safe lgamma_r implementation ...</div><div class="ttdef"><b>Definition</b> <a href="fwd_2constraint_2unit__vector__constrain_8hpp_source.html#l00015">unit_vector_constrain.hpp:15</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
Example 5: Mismatched Exceptions</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;test/unit/math/test_ad.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T f_misthrow(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  <span class="keywordflow">return</span> -2 * x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> f_misthrow(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; x) {</div>
<div class="line">  <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;f_misthrow(double) called&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> -2 * x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST(test_ad, misthrow) {</div>
<div class="line">  <span class="keywordtype">double</span> x = 1.73;</div>
<div class="line">  <span class="keyword">auto</span> h = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u) { <span class="keywordflow">return</span> f_misthrow(u); };</div>
<div class="line">  stan::test::expect_ad(h, x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Uncommenting the test above in the test file and running produces the exception diagnostic:</p>
<div class="fragment"><div class="line">~/cmdstan/<a class="code hl_namespace" href="namespacestan.html">stan</a>/lib/stan_math$ ./runTests.py -j4 test/unit/math/test_ad_test.cpp</div>
<div class="line"> </div>
<div class="line">[ RUN      ] test_ad.misthrow</div>
<div class="line">./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div>
<div class="line">Failed</div>
<div class="line"><span class="keywordtype">double</span> <span class="keywordflow">throws</span>, expect autodiff version to <span class="keywordflow">throw</span></div>
<div class="line">./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div>
<div class="line">Failed</div>
<div class="line"><span class="keywordtype">double</span> <span class="keywordflow">throws</span>, expect autodiff version to <span class="keywordflow">throw</span></div>
<div class="line">./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div>
<div class="line">Failed</div>
<div class="line"><span class="keywordtype">double</span> <span class="keywordflow">throws</span>, expect autodiff version to <span class="keywordflow">throw</span></div>
<div class="line">./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div>
<div class="line">Failed</div>
<div class="line"><span class="keywordtype">double</span> <span class="keywordflow">throws</span>, expect autodiff version to <span class="keywordflow">throw</span></div>
<div class="line">./test/unit/math/mix/mat/util/autodiff_tester.hpp:234: Failure</div>
<div class="line">Failed</div>
<div class="line"><span class="keywordtype">double</span> <span class="keywordflow">throws</span>, expect autodiff version to <span class="keywordflow">throw</span></div>
<div class="line">[  FAILED  ] test_ad.misthrow (0 ms)</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
