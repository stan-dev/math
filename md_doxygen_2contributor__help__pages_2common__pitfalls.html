<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Common pitfalls</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doxygen_2contributor__help__pages_2common__pitfalls.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Common pitfalls</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md28"></a>
Eigen expressions (and handling argument types with SFINAE)</h2>
<p>The additional complexity of the Math library is that <code>vector</code>, <code>row_vector</code>, and <code>matrix</code> do not map to just templated <code>Eigen::Matrix</code> types, they can also map to a variety of <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions.</p>
<p>For instance, in the following code, the result <code>c</code> is not a vector but a vector-like type representing the not-yet-calculated sum of <code>a</code> and <code>b</code>:</p>
<div class="fragment"><div class="line">Eigen::VectorXd a(5);</div>
<div class="line">Eigen::VectorXd b(5);</div>
<div class="line"><span class="comment">// auto is actually a</span></div>
<div class="line"><span class="comment">// Eigen::CwiseBinaryOp&lt;Eigen::internal::scalar_sum_op&lt;double, double&gt;, const Eigen::Matrix&lt;double, -1, 1&gt;, const Eigen::Matrix&lt;double, -1, 1&gt;&gt;</span></div>
<div class="line"><span class="keyword">auto</span> c = a + b;</div>
</div><!-- fragment --><p>Similarly, there are other representations of vectors and matrices yet discussed, in particular matrices stored in Math's special arena memory or matrices stored on a GPU. In either case, it is expedient to not write explicit overloads for all the different types that a function might accept but limit them with template metaprograms.</p>
<p>For instance, if only base <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> types are allowed, then a function that takes column vector types could be defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T norm(<span class="keyword">const</span> Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;&amp;);</div>
</div><!-- fragment --><p>A typical problem with a function like this is that <code>norm</code> can similarly be defined for a row vector (and the implementation is the same). In this case there are two signatures:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T norm(<span class="keyword">const</span> Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;&amp;);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T norm(<span class="keyword">const</span> Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt;&amp;);</div>
</div><!-- fragment --><p>The simple solution to this problem is to move to a fully templated signature:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">return_type_t&lt;T&gt; norm(<span class="keyword">const</span> T&amp;);</div>
</div><!-- fragment --><p>But what if we want different overloads to handle different types? The most common situation is when there is one template overload that works with any autodiff type, and then a second faster overload that only works with a specific autodiff type.</p>
<p>There can easily be ambiguities between the two function signatures. The previous examples took advantage of simple overloads. The more general solution is template metaprograms that additionally make use of C++ substitution failure is not an error (SFINAE) semantics. For the norm function above, SFINAE could be used to limit one signature to work with reverse mode autodiff types and one to work with anything else:</p>
<div class="fragment"><div class="line"><span class="comment">// For Eigen vector types with var Scalar types</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</div>
<div class="line">          require_eigen_vector_vt&lt;is_var, T&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">return_type_t&lt;T&gt; norm(<span class="keyword">const</span> T&amp;);</div>
<div class="line"><span class="comment">// For Eigen vector types with a non var scalar type.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</div>
<div class="line">          require_eigen_vector_t&lt;T&gt;* = <span class="keyword">nullptr</span>,</div>
<div class="line">          require_not_vt_var&lt;T&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">return_type_t&lt;T&gt; norm(<span class="keyword">const</span> T&amp;);</div>
</div><!-- fragment --><p>SFINAE should be thought of as a filter on what functions are visible to the compiler when it does a name lookup for a specific function. The type trait <code>require_st_var</code> should be read "require the @ref stan::scalar_type of the argument to be a @ref stan::math::var". The metaprogram <code>require_st_var&lt;T&gt;</code> will evaluate to a valid type if the scalar type of <code>T</code> is a <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>. If the scalar type of <code>T</code> is not a <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>, then <code>require_st_var&lt;T&gt;</code> does not evaluate to a valid type and the compiler treats it as if the signature does not exist. This is how SFINAE (substitution failure is not an error) works. Because the substitution does not work, the signature is ignored. This is all built based on C++'s <a href="https://en.cppreference.com/w/cpp/types/enable_if">std::enable_if</a> template metaprogram.</p>
<p>Again, there are many ways to solve a problem in C++. In particular there are cases where simple overloads or template specializations can achieve the same thing as the SFINAE template metaprograms. Unless there is a specific reason though, new functions in Math should use the SFINAE metaprograms to handle different implementations. These are tested to work with the broad set of C++ types that the relatively compact set of Stan types map to.</p>
<p>All of the SFINAE template metaprograms in Math are special to Stan or Math. Documentation can be found in the <a class="el" href="group__require__meta.html">Available requires&lt;&gt; for overloading.</a> docs.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Reference types</h2>
<p>Any time a function takes a vector or matrix type, it needs to be able to also handle an expression that evaluates to that type. Some expressions can be expensive to evaluate, so each expression should be evaluated only once. If the results of an expression is needed in multiple places, they should be saved. <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions can result from many places, including arithmetic operations, a matrix multiply, a sum, or a variety of other things. Some expressions are cheap to evaluate, any of the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> views qualify here (transpose, block access, segment, etc). In this case, evaluating the expression is not necessary &ndash; it would only lead to another allocation and copy.</p>
<p>The Math function <a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">stan::math::to_ref</a> is a solution for this. For a vector or matrix variable <code>x</code>, <code>to_ref(x)</code> returns an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> reference to the input variable <code>x</code>. If <code>x</code> was an expensive expression, it will be evaluated. If it was a cheap expression, the reference type won't evaluate. If it isn't an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type, the <code>to_ref</code> just forwards.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</div>
<div class="line">          require_eigen_t&lt;T&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> myfunc(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x_ref = to_ref(x);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Avoiding hanging pointers in return expressions with &lt;tt&gt;make_holder&lt;/tt&gt;</h2>
<p>If a function returns an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression, it may be necessary to use the <a class="el" href="namespacestan_1_1math_a2bf8e9e8eb72e2d7b85a91f6bd2ddd77.html#a2bf8e9e8eb72e2d7b85a91f6bd2ddd77">stan::math::make_holder</a> utility.</p>
<p>Returning expressions is tricky because the expression may have a longer lifetime than the objects it operates on. For instance, returning an expression on a local variable leads to this situation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> add_zero(<span class="keyword">const</span> T&amp; a) {</div>
<div class="line">  Eigen::VectorXd b = Eigen::VectorXd(a.size());</div>
<div class="line">  <span class="keywordflow">return</span> a + b;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Because the return type of this function is <code>auto</code>, it is will return an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression. The following code will segfault on the construction of <code>c</code> because by this time the temporary <code>b</code> will have been destructed.</p>
<div class="fragment"><div class="line">Eigen::VectorXd a(5);</div>
<div class="line">Eigen::VectorXd c = add_zero(a);</div>
<div class="line">std::cout &lt;&lt; c(0);</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/6Te856Mv7">godbolt example</a></p>
<p>When we return back an <b><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression</b> containing objects created in the local scope we need a way to store those locally created objects till the expression is evaluated. Stan's <a class="el" href="namespacestan_1_1math_a2bf8e9e8eb72e2d7b85a91f6bd2ddd77.html#a2bf8e9e8eb72e2d7b85a91f6bd2ddd77">stan::math::make_holder</a> can be used to extend the lifetime of objects created in a local scope so that it matches the expression it is used in.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> add_zero(T&amp;&amp; a) {</div>
<div class="line">  Eigen::VectorXd b = Eigen::VectorXd(a.size());</div>
<div class="line">  <span class="keywordflow">return</span> make_holder([](<span class="keyword">auto</span>&amp;&amp; l, <span class="keyword">auto</span>&amp;&amp; r) { <span class="keywordflow">return</span> l + r; }, a, std::move(b));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Returning expressions is an advanced feature, and it is easy to make mistakes. In this regard, it is simplest to start development not returning expressions (in this case holders are unnecessary) and only add expression return types later.</p>
<p>It is always possible to return a non-expression type by evaluating the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression. For convenience, there is an <code>eval</code> function in Math that will evaluate <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions and forward anything else. This is convenient because it works on non-Eigen types as well (as compared to the built-in <code>.eval()</code> member function on <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> types).</p>
<p>The implementation of <a class="el" href="namespacestan_1_1math_a2bf8e9e8eb72e2d7b85a91f6bd2ddd77.html#a2bf8e9e8eb72e2d7b85a91f6bd2ddd77">stan::math::make_holder</a> is <a href="https://github.com/stan-dev/math/blob/develop/stan/math/prim/meta/holder.hpp">here</a>.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Move Semantics</h2>
<p>Move semantics generally work as</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_big_type {</div>
<div class="line">  <span class="keywordtype">double</span>* m_data;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">explicit</span> my_big_type(<span class="keywordtype">size_t</span> N) m_data(<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(malloc(N))) {}</div>
<div class="line">  <span class="comment">// Standard copy constructor</span></div>
<div class="line">  my_big_type(<span class="keyword">const</span> my_big_type&amp; other) : m_data(static_cast&lt;double*&gt;(malloc(N))) {</div>
<div class="line">    std::copy(other.m_data, this-&gt;m_data);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Standard move constructor</span></div>
<div class="line">  my_big_type(my_big_type&amp;&amp; other) : m_data(other.m_data) {</div>
<div class="line">    other.m_data = <span class="keyword">nullptr</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>We can see in the above that the standard style of a move (the constructor taking an rvalue reference) is to copy the pointer and then null out the original pointer. But in Stan, particularly for reverse mode, we need to keep memory around even if it's only temporary for when we call the gradient calculations in the reverse pass. And since memory for reverse mode is stored in our arena allocator no copying happens in the first place.</p>
<p>Functions for Stan Math's reverse mode autodiff should use <a href="https://drewcampbell92.medium.com/understanding-move-semantics-and-perfect-forwarding-part-3-65575d523ff8"><em>perfect forwarding</em></a> arguments. Perfect forwarding arguments use a template parameter wit no attributes such as <code>const</code> and <code>volatile</code> and have a double ampersand <code>&amp;&amp;</code> next to them.</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"> <span class="keyword">auto</span> my_function(T&amp;&amp; x) {</div>
<div class="line">   <span class="keywordflow">return</span> my_other_function(std::forward&lt;T&gt;(x));</div>
<div class="line"> }</div>
</div><!-- fragment --><p>The <code>std::forward&lt;T&gt;</code> in the in the code above tells the compiler that if <code>T</code> is deduced to be an rvalue reference (such as <code>Eigen::MatrixXd&amp;&amp;</code>), then it should be moved to <code>my_other_function</code>, where there it can possibly use another objects move constructor to reuse memory. A perfect forwarding argument of a function accepts any reference type as its input argument. The above signature is equivalent to writing out several functions with different reference types</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> <span class="comment">// Accepts a plain lvalue reference</span></div>
<div class="line"> <span class="keyword">auto</span> my_function(Eigen::MatrixXd&amp; x) {</div>
<div class="line">   <span class="keywordflow">return</span> my_other_function(x);</div>
<div class="line"> }</div>
<div class="line"> <span class="comment">// Accepts a const lvalue reference</span></div>
<div class="line"> <span class="keyword">auto</span> my_function(<span class="keyword">const</span> Eigen::MatrixXd&amp; x) {</div>
<div class="line">   <span class="keywordflow">return</span> my_other_function(x);</div>
<div class="line"> }</div>
<div class="line"> <span class="comment">// Accepts an rvalue reference</span></div>
<div class="line"> <span class="keyword">auto</span> my_function(Eigen::MatrixXd&amp;&amp; x) {</div>
<div class="line">   <span class="keywordflow">return</span> my_other_function(std::move(x));</div>
<div class="line"> }</div>
<div class="line"> <span class="comment">// Accepts a const rvalue reference</span></div>
<div class="line"> <span class="keyword">auto</span> my_function(<span class="keyword">const</span> Eigen::MatrixXd&amp;&amp; x) {</div>
<div class="line">   <span class="keywordflow">return</span> my_other_function(std::move(x));</div>
<div class="line"> }</div>
</div><!-- fragment --><p>In Stan, perfect forwarding is used in reverse mode functions which can accept an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix type.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, require_eigen_vt&lt;is_var, T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> sin(T&amp;&amp; x) {</div>
<div class="line">  <span class="comment">// Store `x` on the arena</span></div>
<div class="line">  arena_t&lt;T&gt; x_arena(std::forward&lt;T&gt;(x));</div>
<div class="line">  arena_t&lt;T&gt; ret(x_arena.val().array().sin().matrix());</div>
<div class="line">  reverse_pass_callback([x_arena, ret] <span class="keyword">mutable</span> {</div>
<div class="line">    x_arena.adj() += ret.adj().cwiseProduct(x_arena.val().array().cos().matrix());</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's go through the above line by line.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, require_eigen_vt&lt;is_var, T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> sin(T&amp;&amp; x) {</div>
</div><!-- fragment --><p>The signature for this function has a template <code>T</code> that is required to be an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type with a <code>value_type</code> that is a <code>var</code> type. The template parameter <code>T</code> is then used in the signature as an perfect forwarding argument.</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> <span class="comment">// Store `x` on the arena</span></div>
<div class="line"> arena_t&lt;T&gt; x_arena(std::forward&lt;T&gt;(x));</div>
</div><!-- fragment --><p>The input is stored in the arena, which is where the perfect forwarding magic actually occurs. If <code>T</code> is an lvalue type such as <code>Eigen::MatrixXd&amp;</code> then <code>arena_matrix</code> will use it's copy constructor, creating new memory in Stan's arena allocator and then copying the values of <code>x</code> into that memory. But if <code>T</code> was a temporary rvalue type such as <code>Eigen::MatrixXd&amp;&amp;</code>, then the <code>arena_matrix</code> class will use it's move constructor to place the temporary matrix in Stan's <code>var_alloc_stack_</code>. The <code>var_alloc_stick_</code> is used to hold objects that were created outside of the arena allocator but need to be deleted when the arena allocator is cleared. This allows the <code>arena_matrix</code> to reuse the memory from the temporary matrix. Then the matrix will be deleted once arena allocator requests memory to be cleared.</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> arena_t&lt;T&gt; ret(x_arena.val().array().sin().matrix());</div>
</div><!-- fragment --><p>This construction of an <code>arena_matrix</code> will <em>not</em> use the move constructor for <code>arena_matrix</code>. Here, <code>x_arena</code> is an <code>arena_matrix&lt;T&gt;</code>, which is then wrapped in an expression to compute the elementwise <code>sin</code>. That expression will be evaluated into new memory allocated in the arena allocator and then a pointer to it will be stored in the <code>arena_matrix.</code></p>
<div class="fragment"><div class="line">++</div>
<div class="line"> reverse_pass_callback([x_arena, ret] <span class="keyword">mutable</span> {</div>
<div class="line">   x_arena.adj() += ret.adj().cwiseProduct(x_arena.val().array().cos().matrix());</div>
<div class="line"> });</div>
<div class="line"> <span class="keywordflow">return</span> ret;</div>
</div><!-- fragment --><p>The rest of this code follows the standard format for the rest of Stan Math's reverse mode that accepts <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> types as input. The <code>reverse_pass_callback</code> function accepts a lambda as input and places the lambda in Stan's callback stack to be called later when <code>grad()</code> is called by the user. Since <code>arena_matrix</code> types only store a pointer to memory allocated elsewhere they are copied into the lambda. The body of the lambda holds the gradient calculation needed for the reverse mode pass.</p>
<p>Then finally <code>ret</code>, the <code>arena_matrix</code> type is returned by the function.</p>
<p>When working with arithmetic types, keep in mind that moving Scalars is often less optimal than simply taking their copy. For instance, Stan's <code>var</code> type uses the pointer to implementation (PIMPL) pattern, so it simply holds a pointer of size 8 bytes. A <code>double</code> is also 8 bytes which just so happens to fit exactly in a <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">word</a> of most modern CPUs with at least 64-byte cache lines. While a reference to a double is also 8 bytes, unless the function is inlined by the compiler, the computer will have to place the reference into a cache, then go fetch the value that is being referenced which now takes up two words instead of one!</p>
<p>The general rules to follow for passing values to a function are:</p>
<ol type="1">
<li>If a type is smaller than two words (16 bytes), pass it by value</li>
<li>If you are writing a function for reverse mode, pass values by <code>const&amp;</code></li>
<li>In prim, if you are confident and working with larger types, use perfect forwarding to pass values that can be moved from. Otherwise simply pass values by <code>const&amp;</code>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md32"></a>
Using auto is Dangerous With Eigen Matrix Functions in Reverse Mode</h2>
<p>The use of auto with the Stan Math library should be used with care, like in <a href="https://eigen.tuxfamily.org/dox/TopicPitfalls.html">Eigen</a>. Along with the cautions mentioned in the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> docs, there are also memory considerations when using reverse mode automatic differentiation. When returning from a function in the Stan Math library with an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix output with a scalar <code>var</code> type, the actual returned type will often be an <code>arena_matrix&lt;Eigen::Matrix&lt;...&gt;&gt;</code>. The <code>arena_matrix</code> class is an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix where the underlying array of memory is located in Stan's memory arena. The <code>arena_matrix</code> that is returned by Math functions is normally the same one resting in the callback used to calculate gradients in the reverse pass. Directly changing the elements of this matrix would also change the memory the reverse pass callback sees which would result in incorrect calculations.</p>
<p>The simple solution to this is that when you use a math library function that returns a matrix and then want to assign to any of the individual elements of the matrix, assign to an actual <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix type instead of using auto. In the below example, we see the first case which uses auto and will change the memory of the <code>arena_matrix</code> returned in the callback for multiply's reverse mode. Directly below it is the safe version, which just directly assigns to an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix type and is safe to do element insertion into.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::Matrix&lt;var, -1, 1&gt; y;</div>
<div class="line">Eigen::Matrix&lt;var, -1, -1&gt; X;</div>
<div class="line"><span class="comment">// Bad!! Will change memory used by reverse pass callback within multiply!</span></div>
<div class="line"><span class="keyword">auto</span> mu = multiply(X, y);</div>
<div class="line">mu(4) = 1.0;</div>
<div class="line"><span class="comment">// Good! Will not change memory used by reverse pass callback within multiply</span></div>
<div class="line">Eigen::Matrix&lt;var, -1, 1&gt; mu_good = multiply(X, y);</div>
<div class="line">mu_good(4) = 1.0;</div>
</div><!-- fragment --><p>The reason we do this is for cases where function returns are passed to other functions. An <code>arena_matrix</code> will always make a shallow copy when being constructed from another <code>arena_matrix</code>, which lets the functions avoid unnecessary copies.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::Matrix&lt;var, -1, 1&gt; y1;</div>
<div class="line">Eigen::Matrix&lt;var, -1, -1&gt; X1;</div>
<div class="line">Eigen::Matrix&lt;var, -1, 1&gt; y2;</div>
<div class="line">Eigen::Matrix&lt;var, -1, -1&gt; X2;</div>
<div class="line"><span class="keyword">auto</span> mu1 = multiply(X1, y1);</div>
<div class="line"><span class="keyword">auto</span> mu2 = multiply(X2, y2);</div>
<div class="line"><span class="comment">// Inputs not copied in this case!</span></div>
<div class="line"><span class="keyword">auto</span> z = add(mu1, mu2);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
Passing variables that need destructors called after the reverse pass (&lt;tt&gt;make_chainable_ptr&lt;/tt&gt;)</h2>
<p>When possible, non-arena variables should be copied to the arena to be used in the reverse pass. The two tools for that are <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">stan::arena_t</a> and <a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">stan::math::to_arena</a> .</p>
<p>When these tools do not work, there is <a class="el" href="namespacestan_1_1math_a746b7da3f8dc730469bcde9c6dd47459.html#a746b7da3f8dc730469bcde9c6dd47459">stan::math::make_chainable_ptr</a> . <a class="el" href="namespacestan_1_1math_a746b7da3f8dc730469bcde9c6dd47459.html#a746b7da3f8dc730469bcde9c6dd47459">stan::math::make_chainable_ptr</a> constructs a copy of its argument onto stan's arena allocator and returns a pointer to that copy. The copy of the argument will only be destructed when <a class="el" href="namespacestan_1_1math_afe2cbb83ac9ef52296755690e61f4298.html#afe2cbb83ac9ef52296755690e61f4298">stan::math::recover_memory</a> is called.</p>
<p>The pointer is cheap to copy around and is safe to copy into lambdas for <a class="el" href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">stan::math::reverse_pass_callback</a> and <a class="el" href="namespacestan_1_1math_a4b42e5c1619046f156f42a8ce9308599.html#a4b42e5c1619046f156f42a8ce9308599">stan::math::make_callback_var</a> .</p>
<p>As an example, see the implementation of <a class="el" href="namespacestan_1_1math_ac0cfaaa35ed78c2a12842125064b3751.html#ac0cfaaa35ed78c2a12842125064b3751">stan::math::mdivide_left</a> <a href="https://github.com/stan-dev/math/blob/develop/stan/math/rev/fun/mdivide_left.hpp">here</a> where <a class="el" href="namespacestan_1_1math_a746b7da3f8dc730469bcde9c6dd47459.html#a746b7da3f8dc730469bcde9c6dd47459">stan::math::make_chainable_ptr</a> is used to save the result of an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Householder QR decomposition for use in the reverse pass.</p>
<p>The implementation is in <a href="https://github.com/stan-dev/math/blob/develop/stan/math/rev/core/chainable_object.hpp">stan/math/rev/core/chainable_object.hpp</a></p>
<h2><a class="anchor" id="autotoc_md34"></a>
Returning arena types</h2>
<p>Suppose we have a function such as</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vt&lt;is_var, EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> var cool_fun(<span class="keyword">const</span> EigVec&amp; v) {</div>
<div class="line">  arena_t&lt;EigVec&gt; arena_v(v);</div>
<div class="line">  arena_t&lt;EigVec&gt; res = arena_v.val().array() * arena_v.val().array();</div>
<div class="line">  reverse_pass_callback([res, arena_v]() <span class="keyword">mutable</span> {</div>
<div class="line">    arena_v.adj().array() += (2.0 * res.adj().array()) * arena_v.val().array();</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>There's a deceptive problem in this return! We are returning back a <a class="el" href="classstan_1_1math_1_1arena__matrix.html">stan::math::arena_matrix</a>, which is an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix whose dynamic memory sits in our arena allocator. The problem here is that we've also passed <code>res</code> to our callback, and now suppose a user does something like the following.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;var, -1, 1&gt; x = Eigen::Matrix&lt;double, -1, 1&gt;::Random(5);</div>
<div class="line"><span class="keyword">auto</span> innocent_return = cool_fun(x);</div>
<div class="line">innocent_return.coeffRef(3) = var(3.0);</div>
<div class="line"><span class="keyword">auto</span> other_return = cool_fun2(innocent_return);</div>
<div class="line">grad();</div>
</div><!-- fragment --><p>Now <code>res</code> is <code>innocent_return</code> and we've changed one of the elements of <code>innocent_return</code>, but that is also going to change the element of <code>res</code> which is being used in our reverse pass callback!</p>
<p>Care must be taken by end users of Stan Math by using <code>auto</code> with caution. When a user wishes to manipulate the coefficients of a matrix that is a return from a function in Stan Math, they should assign the matrix to a plain <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::Matrix&lt;var, -1, 1&gt; x = Eigen::Matrix&lt;double, -1, 1&gt;::Random(5);</div>
<div class="line">Eigen::MatrixXd actually_innocent_return = cool_fun(x);</div>
<div class="line">actually_innocent_return.coeffRef(3) = var(3.0);</div>
<div class="line"><span class="keyword">auto</span> still_unsafe_return = cool_fun2(actually_innocent_return);</div>
<div class="line">grad();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
Const correctness, reverse mode autodiff, and arena types</h2>
<p>In general, it's good to have arithmetic and integral types as <code>const</code>, for instance pulling out the size of a vector to reuse later such as <code>const size_t x_size = x.size();</code>. However, vars and anything that can contain a var should not be <code>const</code>. This is because in the reverse mode we want to update the value of the <code>adj_</code> inside of the var, which requires that it is non-const.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Handy tricks</h1>
<h2><a class="anchor" id="autotoc_md37"></a>
@ref stan::math::forward_as</h2>
<p>In functions such as <a href="https://github.com/stan-dev/math/blob/1bf96579de5ca3d06eafbc2eccffb228565b4607/stan/math/prim/prob/exponential_cdf.hpp#L64">Stan's distributions</a> you will see code which uses a little function called <a class="el" href="group__type__trait_gabc28f5f2b014cdb24e4e2ad58a6294c4.html#gabc28f5f2b014cdb24e4e2ad58a6294c4">stan::math::forward_as</a> inside of if statements whose values are known at compile time. In the following code, <code>one_m_exp</code> can be either an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector type or a scalar.</p>
<div class="fragment"><div class="line">T_partials_return cdf(1.0);</div>
<div class="line"><span class="keywordflow">if</span> (is_vector&lt;T_y&gt;::value || is_vector&lt;T_inv_scale&gt;::value) {</div>
<div class="line">  cdf = forward_as&lt;T_partials_array&gt;(one_m_exp).prod();</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  cdf = forward_as&lt;T_partials_return&gt;(one_m_exp);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since the if statements values are known at compile time, the compiler will always remove the unused side of the <code>if</code> during the dead code elimination pass. But the dead code elimination pass does not happen until all the code is instantiated and verified as compilable. So <a class="el" href="group__type__trait_gabc28f5f2b014cdb24e4e2ad58a6294c4.html#gabc28f5f2b014cdb24e4e2ad58a6294c4">stan::math::forward_as</a> exists to trick the compiler into believing both sides of the <code>if</code> will compile. If we used C++17, the above would become</p>
<div class="fragment"><div class="line">T_partials_return cdf(1.0);</div>
<div class="line"><span class="keywordflow">if</span> <span class="keyword">constexpr</span> (is_vector&lt;T_y&gt;::value || is_vector&lt;T_inv_scale&gt;::value) {</div>
<div class="line">  cdf = one_m_exp.prod();</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  cdf = one_m_exp;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Where <a href="https://en.cppreference.com/w/cpp/language/if"><code>if constexpr</code></a> is run before any tests are done to verify the code can be compiled.</p>
<p>Using <code>forward_as&lt;TheTypeIWant&gt;(the_obj)</code> will, when <code>the_obj</code> matches the type the user passes, simply pass back a reference to <code>the_obj</code>. But when <code>TheTypeIWant</code> and <code>the_obj</code> have different types it will throw a runtime error. This function should only be used inside of <code>if</code> statements like the above where the conditionals of the <code>if</code> are known at compile time. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
