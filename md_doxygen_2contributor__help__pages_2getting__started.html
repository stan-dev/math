<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Adding new functions guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doxygen_2contributor__help__pages_2getting__started.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Adding new functions guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is meant as a basic guide for writing and maintaining functions in the <a href="https://github.com/stan-dev/math">stan-dev/math</a> repository. Stan Math is the automatic differentiation (autodiff) library behind the Stan language, and the math functions exposed at the Stan language level are implemented here in C++.</p>
<p>In the course of the Math library's existence, C++ has changed substantially. Math was originally written before C++11. It currently targets C++14. In the near future it will transition to C++17. With this in mind, there are many different ways to write Math functions. This guide tries to document best practices, conventions which not all functions in Math follow, but should be followed for new code to keep the code from getting unwieldy (the old patterns will be updated eventually).</p>
<p>The title contains "Current State" to emphasize that if any information here is out of date or any advice does not work, it should be reported as a bug (<a href="https://github.com/stan-dev/math/issues/new">issue tracker link</a>).</p>
<p>This document builds on the information in the <a href="https://arxiv.org/abs/1509.07164">Stan Math Library</a>. While some parts of the paper are out of date now it is very useful for understanding the patterns used in the math library.</p>
<h1><a class="anchor" id="prelim_resources"></a>
Preliminary resources</h1>
<p>Before contributing to Stan Math it's recommended you become familiar with C++. While this guide attempts to cover the edges and odd things we do in the math library, we recommend the resources below for getting started on autodiff in C++.</p>
<p>Books and Papers:</p><ul>
<li><a href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996"><em>Effective Modern C++</em></a></li>
<li><a href="https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121"><em>C++ Templates: The Complete Guide</em></a></li>
<li><a href="https://github.com/bob-carpenter/ad-handbook/blob/master/ad-handbook-draft.pdf"><em>AD Handbook</em></a></li>
</ul>
<p>Talks:</p><ul>
<li><a href="https://www.youtube.com/watch?v=PorfLSr3DDI">Give me 15 minutes &amp; I'll change your view of GDB</a></li>
<li><a href="https://www.youtube.com/watch?v=bSkpMdDe4g4">What Has My Compiler Done for Me Lately?</a></li>
<li><a href="https://www.youtube.com/watch?v=2EWejmkKlxs">Going Nowwhere Faster</a></li>
</ul>
<p>Blog Posts and Articles:</p><ul>
<li><a href="https://blog.mc-stan.org/2020/11/23/thinking-about-automatic-differentiation-in-fun-new-ways/">Thinking About Automatic Differentiation in Fun New Ways</a></li>
<li><a href="https://people.maths.ox.ac.uk/gilesm/files/AD2008.pdf">Collected matrix derivative results for forward and reverse mode AD</a></li>
<li><a href="https://discourse.mc-stan.org/t/a-new-continuation-based-autodiff-by-refactoring/5037">Continuation Based Autodiff</a></li>
</ul>
<p>A generally good resource for making minimal examples for bugs is <a href="https://godbolt.org/">godbolt.org</a>. The godbolt link <a href="https://godbolt.org/z/GEhdcz8eo">here</a> (<a href="https://gist.github.com/SteveBronder/803227cccc66035f7b1988d0156e562a">backup gist</a>) contains a function for printing C++ types and has <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> and boost headers included.</p>
<p>The example function section is an amalgamation of the common_pitfalls section. It's recommended you skim over the common pitfalls before going over the examples below.</p>
<h1><a class="anchor" id="autotoc_md76"></a>
Code structure</h1>
<p>The Stan Math library is spit into 4 main source folders that hold functions, type traits, and classes.</p>
<ul>
<li>prim: General <code>Scalar</code>, <code>Matrix</code>, and <code>std::vector&lt;T&gt;</code> types</li>
<li>rev: Specializations for reverse mode automatic differentiation</li>
<li>fwd: Specializations for forward mode automatic differentiation.</li>
<li>mix: Sources to allow mixes of forward and reverse mode.</li>
<li>opencl: Sources for doing reverse mode automatic differentiation on GPUs.</li>
</ul>
<p>Within each of those folders you will find any one of the following folders</p>
<ul>
<li>core: Base implementations of custom scalars or backend setup.<ul>
<li>Ex: in <code>prim</code> this is operators for complex numbers and the setup for threading, <code>rev</code>'s core is the scalar and its base operators for reverse mode and the stack allocator, and <code>fwd</code> has the scalar for forward mode autodiff and its operators.</li>
</ul>
</li>
<li>err: Functions that perform a check and if true throw an error.</li>
<li>fun: The math functions exposed to the Stan language.</li>
<li>functor: Functions that take in other functions and data as input such as <code>reduce_sum()</code></li>
<li>meta: Type traits and helper functions used internally.</li>
</ul>
<p>Any function callable from the math library, excluding those in the <code>internal</code> namespace, should be compatible with Stan's reverse and forward mode autodiff types. Any new function introduced to the Math library is expected to support higher-order automatic differentiation. Though exceptions to supporting higher-order autodiff have been made in the past such as the differential equations solvers only supporting reverse mode autodiff.</p>
<p>You can contribute a new function by writing the function in the <code>prim/fun</code> folder. The function will need to accept arithmetic, reverse mode (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> ), and forward mode (<a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>) scalar types and should be tested using the <code>expect_ad()</code> testing framework. The <code>rev</code>, <code>fwd</code>, <code>mix</code>, and <code>opencl</code> folders are used for adding specialization for:</p>
<ol type="1">
<li>rev: reverse-mode autodiff specializations</li>
<li>fwd: forward-mode autodiff specializations</li>
<li>mix: mixed-mode autodiff specializations</li>
<li>opencl: GPU (reverse-mode?) autodiff specializations</li>
</ol>
<h1><a class="anchor" id="autotoc_md77"></a>
Adding a simple example function</h1>
<p>A generic function that takes in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector and performs a dot product on itself could be written in <code>prim/fun</code> as a for loop accumulating squared values of the original vector. In the example directly below, the lines with comments (1), (2), (3), and (4) are explained in more detail as they are Stan Math specific components of the function required to allow the function to work inside of the math library. <br  />
</p>
<div class="fragment"><div class="line"><span class="comment">// stan/math/prim/fun/dot_self.hpp</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vector_t&lt;EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt; <span class="comment">// (1)</span></div>
<div class="line"><span class="keyword">inline</span> value_type_t&lt;EigVec&gt; dot_self(<span class="keyword">const</span> EigVec&amp; x) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; x_ref = to_ref(x); <span class="comment">// (2)</span></div>
<div class="line">  value_type_t&lt;EigVec&gt; sum_x = 0.0; <span class="comment">// (3)</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; x.size(); ++i) {</div>
<div class="line">    sum_x += x_ref.coeff(i) * x_ref.coeff(i); <span class="comment">// (4)</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> sum_x;</div>
<div class="line">}</div>
</div><!-- fragment --><p>For a real implementation of this function, we would want to use the member method of the input <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix <code>x.squaredNorm()</code>, but unrolling <code>dot_self()</code> gives a nice example with a few subtleties we need to take into account.</p>
<h3><a class="anchor" id="autotoc_md78"></a>
(1) Using Stan's require type traits to specialize overloads</h3>
<p>The Stan math library requires that all functions are able to accept <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression templates, hence the general <code>EigVec</code> template above. Though the math library wants general template parameters for the functions in <code>prim</code>, functions should be restricted to a subset of types. For example, without the <code>require</code> in the above function, it would be perfectly valid to pass in an <code>Eigen::MatrixXd</code>, but that would not be good! In order to restrict the types that can go into a function, the math library uses the <code>require</code> type traits to detect which function a particular type should use. This is very similar conceptually to <a href="https://en.cppreference.com/w/cpp/language/constraints#Constraints">C++20 requires</a>.</p>
<p>To avoid document duplication please see the require_meta_doc for a lengthier discussion on the requires template types. The guide there explains the different styles and patterns of <code>require</code>s that we use throughout the math library as well as in this example. require_meta_doc has subsections which will show you the <code>requires</code> we have already set up for types we commonly see.</p>
<p>We want to restrict <code>dot_self()</code> to only accept <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> types which have one row or one column at compile time, which for us is <code>require_eigen_vector_t</code>. The C++ convention for require types looks odd at first, as it sets the <code>require</code> template parameter to be a pointer with a default value of <code>nullptr</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vector_t&lt;EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
</div><!-- fragment --><p>One C++ trick is that any non-type template parameter of type <code>void*</code> with a default of <code>nullptr</code> will be ignored by the compiler. Under the hood, if any of the <code>require</code>s are successful they will return back a type <code>void</code>. So in the case we are passing a type that our <code>require</code>s accepts we get back a <code>void* = nullptr</code> which is safely ignored by the compiler. In the case that the type does not satisfy the <code>require</code> then the function is removed from the set of possible functions the caller could use via SFINAE. This scheme leads to a very nice pattern for writing generic templates for functions while also being able to restrict the set of types that a function can be used for.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
(2) Ensure Eigen matrices are only evaluated once</h3>
<p>Before accessing individual coefficients of an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type, use <a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">stan::math::to_ref</a> to make sure accessing the coefficients will not cause a compiler error or force the coefficient to be computed multiple times. The function <a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">stan::math::to_ref</a> is a smart helper function that will evaluate expressions that perform computations, but will not evaluate expressions that are only a view or slice of a matrix or vector.</p>
<p>In the Stan Math library, we allow functions to accept <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions. This allows expressions to be accumulated across multiple function calls and can often give much more optimized code. For instance, in the example below the additions that go into <code>subtract()</code> will be combined together to form one large computation instead of many smaller ones.</p>
<div class="fragment"><div class="line">Eigen::MatrixXd x = subtract(add(A, multiply(B, C)), add(D, E));</div>
</div><!-- fragment --><p>The type created on the right hand side of the equals is an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression that looks like the following pseudotype of the real generated expression.</p>
<div class="fragment"><div class="line">Eigen::Subtract&lt;Eigen::Add&lt;MatrixXd, Eigen::Product&lt;MatrixXd, MatrixXd&gt;&gt;, Eigen::Add&lt;MatrixXd, MatrixXd&gt;&gt;</div>
</div><!-- fragment --><p>When the expression is assigned to an actual matrix it will execute code that performs the matrix multiply of <code>B</code> and <code>C</code> and then runs only one loop for the elementwise addition and subtraction.</p>
<div class="fragment"><div class="line">Eigen::MatrixXd tmp = B * C;</div>
<div class="line">Eigen::MatrixXd x(tmp.rows(), tmp.cols());</div>
<div class="line"><span class="keywordflow">for</span> (Eigen::Index i = 0; i &lt; x.size(); ++i) {</div>
<div class="line">  x(i) = A(i) + tmp(i) - D(i) + E(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using lazily evaluated expressions allows <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> to avoid redundant copies, reads and writes to our data. However, this comes at the cost of more complicated template traits and patterns as well as being careful around handling inputs to functions.</p>
<p>In (3), when we access the coefficients of <code>x</code> in the loop, if its type is similar to the expression above we can get incorrect results as <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> does not guarantee any safety of results when performing coefficient level access on an expression type that transforms its inputs. So <a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">stan::math::to_ref</a> looks at its input type, and if the input type is an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression that performs a calculation then it returns as if we called <code>.eval()</code> on our input, otherwise, it returns the same type as <code>x</code>.</p>
<p>Another example where <a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">stan::math::to_ref</a> is required is the example below, which you can copy and paste into godbolt.org to try yourself.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string_view&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">double</span> dot_self(<span class="keyword">const</span> T&amp; A) {</div>
<div class="line">  <span class="keywordtype">double</span> sum_a = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; A.size(); ++i) {</div>
<div class="line">    sum_a += A.coeff(i) * A.coeff(i);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> sum_a;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  Eigen::MatrixXd A_mat = Eigen::MatrixXd::Random(5, 5);</div>
<div class="line">  Eigen::VectorXd A_vec = Eigen::VectorXd::Random(5);</div>
<div class="line">  <span class="comment">// This works fine</span></div>
<div class="line">  <span class="comment">//double b2 = dot_self((A_mat * A_vec).eval());</span></div>
<div class="line">  <span class="comment">// This fails</span></div>
<div class="line">  <span class="keywordtype">double</span> b2 = <a class="code hl_function" href="namespacestan_1_1math_ac37be6da87f3444ae2f7a00f6fee2983.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a>(A_mat * A_vec);</div>
<div class="line">  std::cout &lt;&lt; b2;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacestan_1_1math_ac37be6da87f3444ae2f7a00f6fee2983_html_ac37be6da87f3444ae2f7a00f6fee2983"><div class="ttname"><a href="namespacestan_1_1math_ac37be6da87f3444ae2f7a00f6fee2983.html#ac37be6da87f3444ae2f7a00f6fee2983">stan::math::dot_self</a></div><div class="ttdeci">auto dot_self(const T &amp;a)</div><div class="ttdoc">Returns squared norm of a vector or matrix.</div><div class="ttdef"><b>Definition</b> <a href="opencl_2prim_2dot__self_8hpp_source.html#l00021">dot_self.hpp:21</a></div></div>
</div><!-- fragment --><p>Pasting the above into <a href="https://godbolt.org/">Godbolt</a> will show a compilation error! That's because <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> does not allow coefficient levels access to product functions. Instead, that expression needs to be evaluated before it is accessed elementwise. Alternatively, consider the following example, where we pass in an expression for elementwise multiplication.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  Eigen::VectorXd A_vec1 = Eigen::VectorXd::Random(5);</div>
<div class="line">  Eigen::VectorXd A_vec2 = Eigen::VectorXd::Random(5);</div>
<div class="line">  <span class="keywordtype">double</span> b2 = dot_self(A_vec1.array() * A_vec2.array());</div>
<div class="line">  std::cout &lt;&lt; b2;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The code above will compile and execute, but in the body of the <code>dot_self</code> function, when we call <code>A.coeff(i)</code> twice in the for loop we will end up evaluating the expression twice.</p>
<p>Suppose the input to <code>dot_self</code> is instead a segment of an existing vector such as the below example.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;var, Dynamic, 1&gt; A = Eigen::VectorXd::Random(20);</div>
<div class="line">var b = dot_self(A.segment(1, 5));</div>
</div><!-- fragment --><p>When calling <code>A.segment(1, 5)</code> <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> will create an instance of an expression class called <code>Eigen::Block&lt;Eigen::VectorXd&gt;</code> that holds a view into the original vector. An expression that is only a view into an object is safe to read coefficient-wise. In this case, <a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">stan::math::to_ref</a> knows this and as long as you use <code>const auto&amp;</code> as the object type returned from <code>to_ref(x)</code>, then <code>to_ref(x)</code> will deduce the correct type <code>Block</code> instead of casting to an evaluated vector. We use <code>const auto&amp;</code> here even when the output will store an object as <a href="https://en.cppreference.com/w/cpp/language/lifetime">C++'s lifetime rules</a> allow for this.</p>
<blockquote class="doxtable">
<p>&zwj;The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference (since C++11), see reference initialization for details. </p>
</blockquote>
<p>If we used <code>auto</code> here and if the return type of <a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">stan::math::to_ref</a> is an <code>Eigen::MatrixXd</code> then it would make a copy. But with <code>const auto&amp;</code> we do not make a copy as the lifetime of the object referenced by the <code>const auto&amp;</code> will be the same as if we had done <code>auto</code>.</p>
<h3><a class="anchor" id="autotoc_md80"></a>
(3) Using value_type_t and other type querying type traits</h3>
<p>The type trait <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> is one of several type traits we use in the library to query information about types. <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> will return the inner type of a container, so <code>value_type_t&lt;Eigen::Matrix&lt;double, -1, -1&gt;&gt;</code> will return <code>double</code>, <code>value_type_t&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;</code> will return a <code>std::vector&lt;double&gt;</code> and <code>value_type_t&lt;double&gt;</code> will simply return a double.</p>
<p>See the docs for <a class="el" href="structstan_1_1value__type.html">stan::value_type</a>, <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a> and <a class="el" href="structstan_1_1base__type.html">stan::base_type</a> for more information on these.</p>
<h3><a class="anchor" id="autotoc_md81"></a>
(4) Accessing Eigen matrices though &lt;tt&gt;.coeff()&lt;/tt&gt; and &lt;tt&gt;.coeffRef()&lt;/tt&gt;</h3>
<p><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> performs bounds checks by default when using <code>[]</code> or <code>()</code> to access elements. However <code>.coeff()</code> and <code>.coeffRef()</code> do not. Because Stan programs perform bounds checking at a higher level it's safe to remove the bounds checks here. Note that <code>.coeff()</code> should be used when accessing values of an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> types and <code>.coeffRef()</code> should be used when assigning values of an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type.</p>
<h3><a class="anchor" id="autotoc_md82"></a>
Testing</h3>
<p>From there you can use the unit test suite for automatic differentiation to verify your code produces the correct gradients and higher order derivatives and your done!</p>
<div class="fragment"><div class="line"><span class="comment">// Example tests in test/unit/math/mix/fun/dot_self_test.cpp</span></div>
<div class="line">TEST(MathMixMatFun, dotSelf) {</div>
<div class="line">  <span class="keyword">auto</span> f = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; y) { <span class="keywordflow">return</span> <a class="code hl_function" href="namespacestan_1_1math_ac37be6da87f3444ae2f7a00f6fee2983.html#ac37be6da87f3444ae2f7a00f6fee2983">stan::math::dot_self</a>(y); };</div>
<div class="line"> </div>
<div class="line">  Eigen::VectorXd x0(0);</div>
<div class="line">  Eigen::VectorXd x1(1);</div>
<div class="line">  x1 &lt;&lt; 2;</div>
<div class="line">  Eigen::VectorXd x2(2);</div>
<div class="line">  x2 &lt;&lt; 2, 3;</div>
<div class="line">  Eigen::VectorXd x3(3);</div>
<div class="line">  x3 &lt;&lt; 2, 3, 4;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : <a class="code hl_namespace" href="namespacestd.html">std</a>::vector&lt;<a class="code hl_namespace" href="namespace_eigen.html">Eigen</a>::VectorXd&gt;{x0, x1, x2, x3}) {</div>
<div class="line">    stan::test::expect_ad(f, a);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_eigen_html"><div class="ttname"><a href="namespace_eigen.html">Eigen</a></div><div class="ttdoc">(Expert) Numerical traits for algorithmic differentiation variables.</div><div class="ttdef"><b>Definition</b> <a href="fwd_2fun_2_eigen___num_traits_8hpp_source.html#l00011">Eigen_NumTraits.hpp:11</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
</div><!-- fragment --><p>That's it, your done! Make a PR, add some docs, have a cup of tea all is well.</p>
<p>But, while your function will work for all of our types, it probably won't be as fast as it could be. Indeed, since the above is using Stan's basic scalar reverse mode, for a vector of size N there will be N individual callback functions on the reverse pass callback stack. This is not the worst, Stan's base scalar operations are as efficient as they can be, but by writing a specialization for reverse mode we can have one callback with much more efficient memory access. The next section may seem a bit advanced, but for those who enjoy adventure, let's talk about how to make this function go faster.</p>
<h1><a class="anchor" id="autotoc_md83"></a>
Specializing for reverse mode</h1>
<p>The following material depends on understanding Stan Math's automatic differentiation, which is described in the <a class="el" href="md_doxygen_2contributor__help__pages_2getting__started.html#prelim_resources">Preliminary resources</a></p>
<h3><a class="anchor" id="autotoc_md84"></a>
Using type traits to expose Our new function</h3>
<p>First we need to stop our current function from compiling for reverse mode autodiff. This can be done using the <a class="el" href="group__require__meta.html">requires type traits</a> in Stan Math. The only thing that has changed in the function above and below is the additional template parameter for the requirement on the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vector_t&lt;EigVec&gt;* = <span class="keywordtype">nullptr</span>,</div>
<div class="line"> require_not_st_var&lt;EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> dot_self(<span class="keyword">const</span> EigVec&amp; x) {</div>
<div class="line">  <span class="keyword">auto</span> x_ref = to_ref(x);</div>
<div class="line">  var sum = 0.0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; x.size(); ++i) {</div>
<div class="line">    sum += x_ref.coeff(i) * x_ref.coeff(i);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> sum;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>require</code> type trait in the above stops the function from working specifically with <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vectors whose inner <code>Scalar</code> type is a <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> type. Now we can write the signature of our function that will go into the <code>stan/math/rev/fun/</code> folder</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vector_vt&lt;is_var, EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> dot_self(<span class="keyword">const</span> EigVec&amp; x) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The above signature is defined to only accept <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vectors whose <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> is <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> .</p>
<h2><a class="anchor" id="autotoc_md85"></a>
Working in reverse mode</h2>
<p>So now let's write our reverse mode specialization in <code>rev/fun</code>. In the below I've placed numbered comments to indicate places in the function which use patterns specific to reverse mode autodiff in Stan Math that will be discussed further.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vt&lt;is_var, EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> var dot_self(<span class="keyword">const</span> EigVec&amp; v) {</div>
<div class="line">  <span class="comment">// (1) put v into our arena</span></div>
<div class="line">  arena_t&lt;EigVec&gt; arena_v(v);</div>
<div class="line">  <span class="comment">// (2) calculate forward pass using</span></div>
<div class="line">  <span class="comment">// (3) the .val() method for matrices of var types  </span></div>
<div class="line">  var res = dot_self(arena_v.val());</div>
<div class="line">  <span class="comment">// (4) Place a callback for the reverse pass on the callback stack.</span></div>
<div class="line">  reverse_pass_callback([res, arena_v]() <span class="keyword">mutable</span> {</div>
<div class="line">    arena_v.adj().array() += (2.0 * res.adj().array()) * arena_v.val().array();</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
</div><!-- fragment --><p>There's a lot going on here particular to Stan math and so we will talk about each special bit.</p>
<h2><a class="anchor" id="autotoc_md86"></a>
(1) Arena memory</h2>
<p>The type <code>arena_t&lt;T&gt;</code> and the function <a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">stan::math::to_arena</a> takes an object and places it on Stan's arena allocator.</p>
<p>As discussed in <a href="https://blog.mc-stan.org/2020/11/23/thinking-about-automatic-differentiation-in-fun-new-ways/">Thinking About Automatic Differentiation in Fun New Ways</a> reverse mode automatic differentiation comes down to.</p>
<ol type="1">
<li>Calculating a function <code>z = f(x, y)</code>‘s output (forward pass)</li>
<li>Storing the input and output into a memory arena</li>
<li>Adding a callback to a callback stack that calculates the adjoint of the function</li>
</ol>
<p>This process allows us to call <a class="el" href="namespacestan_1_1math_a22dec695eb198173799ce3dd1c7c6302.html#a22dec695eb198173799ce3dd1c7c6302">stan::math::grad</a> , call each of the callbacks in the callback stack, and accumulate the gradients starting from the final outputs back to the inputs. (reverse pass)</p>
<p>Reverse mode autodiff in Stan Math requires a huge number of temporaries and intermediates to be computed and saved for the reverse pass. There are so many allocations that the overhead of <code>malloc()</code> becomes noticeable. To avoid this, Math provides its own memory arena. The assumptions of the Math arena are:</p>
<ol type="1">
<li>Objects allocated in the arena are <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">TriviallyCopyable</a> and <a href="https://en.cppreference.com/w/cpp/language/destructor#Trivial_destructor">TriviallyDestructable</a>. These objects do not need their destructors called. Although there are ways to destruct something allocated in the arena, it is not automatic.</li>
<li>All objects allocated on the arena have the same lifetime.</li>
<li>Memory allocated from the arena is available and valid until <a class="el" href="namespacestan_1_1math_afe2cbb83ac9ef52296755690e61f4298.html#afe2cbb83ac9ef52296755690e61f4298">stan::math::recover_memory</a> is called.</li>
</ol>
<p>The arena memory pattern fits nicely into automatic differentiation for MCMC as we will most commonly be calling gradients with data of the same size over and over again.</p>
<p>Functions that use reverse mode autodiff are allowed to save what they need to the arena, and then the objects saved here will be available during the reverse pass.</p>
<p>There is a utility for saving objects into the arena that do need their destructors called. This is discussed under <a class="el" href="namespacestan_1_1math_a746b7da3f8dc730469bcde9c6dd47459.html#a746b7da3f8dc730469bcde9c6dd47459">stan::math::make_chainable_ptr</a> . Arena types are helper functions and types for easily saving variables to the arena.</p>
<p><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">stan::arena_t</a> defines, for a given type <code>T</code>, the type of a lightweight object pointing to memory in the arena that can store a <code>T</code>. Memory for <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">stan::arena_t</a> objects is only recovered when <a class="el" href="namespacestan_1_1math_afe2cbb83ac9ef52296755690e61f4298.html#afe2cbb83ac9ef52296755690e61f4298">stan::math::recover_memory</a> is called. No destructors are called for objects stored with <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">stan::arena_t</a>.</p>
<p>Copying a variable <code>x</code> to the arena can be done with either <a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">stan::math::to_arena</a> while declaring the type of the object with <code>auto</code> or creating the type directly with the <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">stan::arena_t</a> type trait. Using <code>auto</code> and <a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">stan::math::to_arena</a> is the preferred form. Usually when you see code that directly uses <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">stan::arena_t</a> it is because the code was written before <a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">stan::math::to_arena</a> existed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> myfunc(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  <span class="keyword">auto</span> arena_x = to_arena(x);</div>
<div class="line">  <span class="comment">//...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> myfunc(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  arena_t&lt;T&gt; arena_x = x;</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md87"></a>
(2) Calculating the forward pass</h2>
<p>Because of our previous <code>require</code>s template we can now call <code>dot_self()</code> with the values of the matrix. The compiler will then know to call the previous definition of <code>dot_self</code> written to work with <code>double</code> scalar types.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
(3) Accessing the values and adjoints of matrices.</h2>
<p>The calculations for the forward and reverse passes of reverse mode autodiff often use custom <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> methods for matrices, vectors, and arrays. In the above, <code>.val()</code> will return a view of all of the values of the <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> scalars in the matrix while <code>.adj()</code> will return a view for all of the adjoints of the matrices <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> scalars. You can think of <code>.val()</code> and <code>.adj()</code> as returning an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix of doubles such as <code>Eigen::Matrix&lt;double, Rows, Cols&gt;</code> where both functions scalars are references to the values or adjoints of the original matrix with <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> scalars.</p>
<h2><a class="anchor" id="autotoc_md89"></a>
(4) Setting up the reverse pass</h2>
<p>Once the forward pass is complete, and the data for the reverse pass is in the arena the adjoint calculation for the portion of the reverse pass for this function needs to be written. The reverse pass consists of an adjoint calculation which is placed onto the callback stack. When a user calls <a class="el" href="namespacestan_1_1math_a22dec695eb198173799ce3dd1c7c6302.html#a22dec695eb198173799ce3dd1c7c6302">stan::math::grad</a> this adjoint calculation will be called so that adjoints are accumulated from the final output to the starting inputs.</p>
<p>The adjoint method for a self dot product is</p>
<div class="fragment"><div class="line">x.adj() += sum_x.adj() * 2.0 * x.val()</div>
</div><!-- fragment --><p>Once we know the adjoint calculation we can use <a class="el" href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">stan::math::reverse_pass_callback</a> to place the adjoint calculation onto the callback stack for the reverse pass. Calling <a class="el" href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">stan::math::reverse_pass_callback</a> with a lambda will place the lambda on Stan's callback stack so that it can be executed in the reverse pass.</p>
<div class="fragment"><div class="line">reverse_pass_callback([res, arena_v]() <span class="keyword">mutable</span> { <span class="comment">// (2)</span></div>
<div class="line">  v.adj() += (2 * res.adj()) * v.val();</div>
<div class="line">});</div>
</div><!-- fragment --><p>Notice that for the lambda we create <em>copies</em> of the objects <code>res</code> and <code>arena_v</code>. The trick here is that anything allocated with Stan's arena using <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">stan::arena_t</a> or <a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">stan::math::to_arena</a> is <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">TriviallyCopyable</a>. Note that arithmetic types and Stan Math's <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> type are trivially copyable by definition and so can be passed without having to make an explicit call to <a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">stan::math::to_arena</a> . Since the memory is safe and sound within our arena these objects are safe and fast to copy.</p>
<p>An alternative approach to the above function could also have been</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vt&lt;is_var, EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> var dot_self(<span class="keyword">const</span> EigVec&amp; v) {</div>
<div class="line">  arena_t&lt;EigVec&gt; arena_v(v); <span class="comment">// (1) put v into our arena</span></div>
<div class="line">  <span class="keywordflow">return</span> make_callback_var(arena_v.val().dot(arena_v.val()), [arena_v](<span class="keyword">auto</span>&amp; vi) {</div>
<div class="line">    arena_v.adj() += (2.0 * vi.adj()) * arena_v.val();</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>make_callback_var(x, f)</code> is similar to <a class="el" href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">stan::math::reverse_pass_callback</a> , but it constructs an autodiff type from the argument <code>x</code>. The function <code>f</code> is called on the reverse pass similarly to <a class="el" href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">stan::math::reverse_pass_callback</a> . <a class="el" href="namespacestan_1_1math_a4b42e5c1619046f156f42a8ce9308599.html#a4b42e5c1619046f156f42a8ce9308599">stan::math::make_callback_var</a> should only be used when returning a <code>var_value&lt;double&gt;</code> or <code>var_value&lt;Matrix&gt;</code>.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
Argument types</h1>
<p>The functions in Stan Math are used in the C++ code generated by the Stan compiler. This means that all types in the Stan language map to <code>C++</code> types. The map between Stan types and types in <code>C++</code> is a one-to-many relationship because of the different blocks in a Stan program. Objects created in <code>data</code>, <code>transformed data</code>, and <code>generated quantities</code> will hold arithmetic types while objects created in <code>parameters</code>, <code>transformed parameters</code>, and the <code>model</code> block will hold autodiff types. The basic Stan types are listed in the table below as well as arrays of any of these types.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Stan Type   </th><th class="markdownTableHeadNone">Data   </th><th class="markdownTableHeadNone">Model    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>int</code>   </td><td class="markdownTableBodyNone"><code>int</code>   </td><td class="markdownTableBodyNone"><code>int</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int[N]</code>   </td><td class="markdownTableBodyNone"><code>std::vector&lt;int&gt;</code>   </td><td class="markdownTableBodyNone"><code>std::vector&lt;int&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>real</code>   </td><td class="markdownTableBodyNone"><code>double</code>   </td><td class="markdownTableBodyNone"><code>var/fvar&lt;T&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>real[N]</code>   </td><td class="markdownTableBodyNone"><code>std::vector&lt;double&gt;</code>   </td><td class="markdownTableBodyNone"><code>std::vector&lt;var/fvar&lt;T&gt;&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vector[N]</code>   </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;double, Dynamic, 1&gt;(N)</code>   </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;var/fvar&lt;T&gt; Dynamic, 1&gt;(N)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>row_vector[N]</code>   </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;double, 1, Dynamic&gt;(N)</code>   </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;var/fvar&lt;T&gt; 1, Dynamic&gt;(N)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>matrix[N,M]</code>   </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;double, Dynamic, Dynamic&gt;(N, M)</code>   </td><td class="markdownTableBodyNone"><code>Eigen::Matrix&lt;var/fvar&lt;T&gt; Dynamic, Dynamic&gt;(N, M)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>matrix[N, M] x[K]</code>   </td><td class="markdownTableBodyNone"><code>std::vector&lt;Eigen::Matrix&lt;double, Dynamic, Dynamic&gt;&gt;(K, {M, N})</code>   </td><td class="markdownTableBodyNone"><code>std::vector&lt;Eigen::Matrix&lt;var/fvar&lt;T&gt; Dynamic, Dynamic&gt;&gt;(K, {M, N})</code>   </td></tr>
</table>
<p>Any array type (<code>int[]</code>, <code>real[]</code>, or <code>T[]</code> for <code>T</code> any of the above types) map to <code>std::vector&lt;C&gt;</code> types where <code>C</code> is the C++ equivalent of <code>T</code>.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
Unary functions working over arrays</h2>
<p>The Stan function <code>sin()</code> expects the math library has the following signatures available.</p>
<div class="fragment"><div class="line">real sin(real);</div>
<div class="line">vector sin(vector);</div>
<div class="line">array vector sin(array vector)</div>
</div><!-- fragment --><p>where <code>array</code> can be multiple arrays within one another. The above translates to the following C++ signatures</p>
<div class="fragment"><div class="line"><span class="comment">// reals</span></div>
<div class="line"><span class="keywordtype">double</span> sin(<span class="keywordtype">double</span>);</div>
<div class="line">var sin(var);</div>
<div class="line"><span class="comment">// vector</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Eigen::Vector&lt;T, Dynamic, 1&gt; sin(Eigen::Vector&lt;T, Dynamic, 1&gt;);</div>
<div class="line"><span class="comment">// array vector</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt; sin(std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt;);</div>
<div class="line"><span class="comment">// array array vector</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::vector&lt;std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt;&gt; sin(std::vector&lt;std::vector&lt;Eigen::Vector&lt;T, Dynamic, 1&gt;&gt;&gt;);</div>
</div><!-- fragment --><p>A function that accepts an autodiff type should return an autodiff type. Notice that because we have to support arithmetic and autodiff types the signatures expand out for both arithmetic and autodiff types. It would be tedious to write out this method for all of the array types, so Stan math provides helper classes <a class="el" href="structstan_1_1math_1_1apply__scalar__unary.html">stan::math::apply_scalar_unary</a> and <a class="el" href="structstan_1_1math_1_1apply__vector__unary.html">stan::math::apply_vector_unary</a> to apply a function over arrays.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">struct </span>sin_fun {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> T fun(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">    <span class="keyword">using </span>std::sin;</div>
<div class="line">    <span class="keywordflow">return</span> sin(x);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, require_not_container_st&lt;std::is_arithmetic, T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code hl_function" href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">sin</a>(<span class="keyword">const</span> T&amp; x) {</div>
<div class="line">  <span class="keywordflow">return</span> apply_scalar_unary&lt;sin_fun, T&gt;::apply(x);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, require_container_st&lt;std::is_arithmetic, Container&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code hl_function" href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">sin</a>(<span class="keyword">const</span> Container&amp; x) {</div>
<div class="line">  <span class="keywordflow">return</span> apply_vector_unary&lt;Container&gt;::apply(</div>
<div class="line">      x, [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v) { <span class="keywordflow">return</span> v.array().<a class="code hl_function" href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">sin</a>(); });</div>
<div class="line">}</div>
<div class="ttc" id="anamespacestan_1_1math_a03498ae670c61712c7fb60381e97368e_html_a03498ae670c61712c7fb60381e97368e"><div class="ttname"><a href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">stan::math::sin</a></div><div class="ttdeci">fvar&lt; T &gt; sin(const fvar&lt; T &gt; &amp;x)</div><div class="ttdef"><b>Definition</b> <a href="fwd_2fun_2sin_8hpp_source.html#l00016">sin.hpp:16</a></div></div>
</div><!-- fragment --><p>In Stan math, a <code>container</code> type is a <code>std::vector</code> that holds either other <code>std::vector</code>s or <code>Eigen::Matrix</code> types. In the first function we use <a class="el" href="structstan_1_1math_1_1apply__scalar__unary.html">stan::math::apply_scalar_unary</a> to apply <code>sin()</code> to either <code>Scalar</code>s, <code>std::vector</code>s holding scalars, or <code>Eigen::Matrix</code> types. The second function in the above uses <a class="el" href="structstan_1_1math_1_1apply__vector__unary.html">stan::math::apply_vector_unary</a> to apply its lambda to a container whose elements are also containers or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices.</p>
<h2><a class="anchor" id="autotoc_md92"></a>
Binary functions (and least-upper-bound return type semantics)</h2>
<p>Multiple argument functions are more involved. Consider <code>real atan2(real, real)</code> which requires four C++ overloads:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> atan2(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>);</div>
<div class="line">var atan2(<span class="keywordtype">double</span>, var);</div>
<div class="line">var atan2(var, <span class="keywordtype">double</span>);</div>
<div class="line">var atan2(var, var);</div>
</div><!-- fragment --><p>In this case, the return type is a function of both input types. <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> is written to take any number of input types and compute from them a single scalar return type. The return type is the least upper bound of the input types that can be constructed from all of the input types. For reverse mode autodiff, this means that if the scalar type of any input argument is a <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> , then the return type is a var.</p>
<p>A generic signature for <code>real atan2(real, real)</code> is:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;</div>
<div class="line">return_type_t&lt;T, S&gt; atan2(T, S);</div>
</div><!-- fragment --><p><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> can be used to construct non-scalar return types as well. For the function <code>vector add(vector, vector)</code>, the following generic C++ signature could be used:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;</div>
<div class="line">Eigen::Matrix&lt;return_type_t&lt;T, S&gt;, Eigen::Dynamic, 1&gt; atan2(T, S);</div>
</div><!-- fragment --><p>Alternativly, with C++14 one can also delay deducing the return type with <code>auto</code> and the compiler can deduce the return type from the code (which would then internally use <code>return_type_t&lt;T, S&gt;</code>)</p>
<h2><a class="anchor" id="autotoc_md93"></a>
Higher order autodiff</h2>
<p>Adding the forward mode autodiff type simply adds more overloads. The forward mode autodiff type itself takes a template argument to represent the types of the value and gradient and allows recursive templating. This technically defines an infinite number of new types, but the ones of interest in Math (and the ones that should be tested are) <code>fvar&lt;double&gt;</code>, <code>fvar&lt;fvar&lt;double&gt;&gt;</code>, <code>fvar&lt;var&gt;</code> and <code>fvar&lt;fvar&lt;var&gt;&gt;</code>. These are useful for computing various high-order derivatives. Going back to the <code>real sin(real)</code> function, Stan Math is now expected to implement the following rather expanded list of functions:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sin(<span class="keywordtype">double</span>);</div>
<div class="line">var sin(var);</div>
<div class="line">fvar&lt;double&gt; sin(fvar&lt;double&gt;);</div>
<div class="line">fvar&lt;fvar&lt;double&gt;&gt; sin(fvar&lt;fvar&lt;double&gt;&gt;);</div>
<div class="line">fvar&lt;var&gt; sin(fvar&lt;var&gt;);</div>
<div class="line">fvar&lt;fvar&lt;var&gt;&gt; sin(fvar&lt;fvar&lt;var&gt;&gt;);</div>
</div><!-- fragment --><p>For the sake of performance, it may be desirable to also define <code>var sin(var)</code>, or similarly <code>fvar&lt;double&gt; sin(fvar&lt;double&gt;)</code> etc.</p>
<p>The type trait <code>return_type_t</code> is defined similarly as for <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> . Autodiff types such as <code>fvar&lt;double&gt;</code> and <code>var</code> should not be mixed, and so the <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> does not need to account for various combinations of <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> , <code>fvar&lt;double&gt;</code>, etc.</p>
<h2><a class="anchor" id="autotoc_md94"></a>
Exceptions</h2>
<p>Math functions are expected to validate inputs and throw exceptions. It should be impossible to cause a segfault by calling a user-facing Math function or trigger an exception that is not handled by Stan itself. This means that argument sizes should be checked to be compatible. For instance, a matrix multiply function would need to check that the first matrix can in fact be multiplied by the second, if this is not so it should throw.</p>
<p>If a scalar argument should be positive, an exception should be thrown if it is not. If a matrix argument should be positive definite, the function should check this before operating on the matrix. This can lead to significant overhead in the checks, but the current library policy is to get informative errors back to the user, which means doing these checks.</p>
<p>Error checks should be done with the functions in <a href="https://github.com/stan-dev/math/tree/develop/stan/math/prim/err">stan/math/prim/err</a> which throw consistently formatted errors.</p>
<h2><a class="anchor" id="autotoc_md95"></a>
Tests</h2>
<p>Tests in Math are written with the Google test framework. At this point, there are enough functions in Math that the way to get started is by copying the tests of a similar Function and editing them to suit the new function. There are two basic sets of functions that every Stan function should have. First, for a function named <code>foo</code>, there should be a file in <code>test/unit/math/prim/fun</code> named <code>foo_test.cpp</code>.</p>
<p>This should include tests that:</p>
<ol type="1">
<li>Check that every exception is throwing in the right way at least once and that all edge cases are handled correctly.<ul>
<li>For instance, if there is a <a class="el" href="namespacestan_1_1math_adf85220664649c7ba7c9c893e013c20a.html#adf85220664649c7ba7c9c893e013c20a">stan::math::check_size_match</a> function, then there should be a test that makes sure that if the sizes don't match, and exception is thrown. It is not necessary to check the error message in the tests, just check that an exception is thrown and the exception type is correct.</li>
</ul>
</li>
<li>Check that the function returns the expect values for a couple suitable inputs.<ul>
<li>For some functions, these checks should be more extensive than others, but there should at least be two or three even in simple cases.</li>
</ul>
</li>
</ol>
<p>The <code>prim</code> tests should only have arithmetic types. No autodiff is tested here. The <code>prim</code> tests check that the function handles edge cases correctly and produces the correct output for different function values. The second set of tests should be in <code>stan/math/mix/fun</code> with the same name <code>foo_test.cpp</code>. These tests will be used to test all forms of the autodiff.</p>
<p>The tests in <code>mix/fun</code> should use the <code>expect_ad()</code> function to test all forms of autodiff. <code>expect_ad()</code> takes as its first argument a function to test and then up to three other arguments, all with arithmetic scalar types. For a given function <code>f</code>, and two arguments <code>a</code> and <code>b</code>, <code>expect_ad()</code> tests that:</p>
<ol type="1">
<li>For every combination of <code>a</code> and <code>b</code>, the returned value of <code>f</code> matches the returned value with non-autodiff types.</li>
<li>The finite difference gradients of <code>f</code> match those computed with autodiff.</li>
<li>Any time a <code>f</code> throws with arithmetic arguments, it also throws with autodiff arguments.</li>
</ol>
<h1><a class="anchor" id="autotoc_md96"></a>
Reverse mode</h1>
<h2><a class="anchor" id="autotoc_md97"></a>
Values</h2>
<p><a class="el" href="namespacestan_1_1math_a541f8f9d951f4d48c457dcecad5e326b.html#a541f8f9d951f4d48c457dcecad5e326b">stan::math::value_of</a> returns the values of the variable <code>x</code>. If <code>x</code> is not an autodiff type, the values are simply the input and the input is forwarded along. For reverse mode autodiff, values are <code>double</code> variables. For higher order autodiff (<code>fvar&lt;var&gt;</code>, etc.) this is not always the case. For instance, <code>value_of(fvar&lt;var&gt;)</code> is a <code>var</code>. <code>value_of_rec()</code> is a function which recursively calls <code>value_of()</code> until a <code>double</code> value is found. So calling <code>value_of_rec(fvar&lt;var&gt;)</code> will return a <code>double</code>. The values of <code>x</code> have the same shape as <code>x</code>.</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Values and adjoint extensions to Eigen</h2>
<p>The matrix and vector autodiff types come with an extra <code>.val()</code> and <code>.adj()</code>, member functions called <code>.val_op()</code> and <code>.adj_op()</code>. These <code>*_op()</code> member functions are used as a workaround for a bug in <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> where transpose expressions will be inaccessible because of an incorrect const reference. See <a href="https://github.com/stan-dev/math/issues/2653">here</a> for the details and other information for when this workaround is needed.</p>
<p>The member functions <code>.val()</code> and <code>.val_op()</code> return expressions that evaluate to the values of the autodiff matrix.</p>
<p>The member functions <code>.adj()</code> and <code>.adj_op()</code> return expressions that evaluate to the adjoints of the autodiff matrix.</p>
<p>The non-<code>_op</code> versions of the functions should be preferred. If the code does not compile (usually an error about const-ness) try the <code>_op</code> versions. This can happen when multiplying the values/adjoints of an autodiff type against other matrices.</p>
<p>It is not safe to use <code>.noalias()</code> with the <code>var&lt;Matrix&gt;</code> value/adjoint expressions. In <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a>, <code>.noalias()</code> is similar to the keyword <a href="https://en.cppreference.com/w/c/language/restrict"><code>restrict</code></a> which assumes that a pointer is unique within a given function. But when performing operations on <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices of <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> while using <code>.val()</code> and <code>.adj()</code> on the left and right-hand side of an operation, the pointer holding the underlying <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> types will be used on both sides. Since the pointer is used on both sides it will not be unique in the operation and so using <code>.noalias()</code> will lead to undefined behaviour. See the <a href="https://eigen.tuxfamily.org/dox/group__TopicAliasing.html">Aliasing</a> and <a href="https://eigen.tuxfamily.org/dox/TopicWritingEfficientProductExpression.html">Writing Efficient Matrix Product Expressions</a> <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> docs for more info. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
