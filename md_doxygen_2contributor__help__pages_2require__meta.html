<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Using requires&lt;&gt; template metaprograms for partial template specialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doxygen_2contributor__help__pages_2require__meta.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Using requires&lt;&gt; template metaprograms for partial template specialization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Most of the functions in the Stan Math library are implemented as <a href="https://en.cppreference.com/w/cpp/language/function_template">templated functions</a> which allow for arguments that can be C++ primitive types (e.g. <code>double</code>, <code>int</code>), Stan's reverse-mode or forward-mode automatic differentiation (autodiff) types, or containers and expressions of either primitive or autodiff types. We use templated functions rather than overloaded functions for a number of reasons including the sheer number of implementations we would need to write to handle the combinations of arguments that are allowed in the Stan language.</p>
<p>Many functions in the Stan Math library have a single function template defined in the <code>stan/math/prim</code> folder that is flexible enough to accept both primitive and autodiff types. Some of these functions also have template specializations (usually [partial template specializations](<a href="https://en.cppreference.com/w/cpp/language/partial_specialization">https://en.cppreference.com/w/cpp/language/partial_specialization</a>)) that define an implementation where at least one template parameters is restricted to a specific type. The source code for the function template specializations are found in either <code>stan/math/rev/</code> for reverse-mode implementations, <code>stan/math/fwd/</code> for forward-mode implementations, or <code>stan/math/mix/</code> for implementations that are for nested autodiff. This pattern of a primary template function definition with specialization is commonly used in templated C++.</p>
<p>In the Stan Math library, we have also adopted another technique which allows multiple template function definitions, while restricting the definition to apply only to when certain criteria are met. Since this technique is used repeatedly through the Math library and this is not a common use of template metaprogramming, we'll describe it in the next subsection.</p>
<h2><a class="anchor" id="autotoc_md107"></a>
Using SFINAE to allow multiple template function definitions</h2>
<p>In the Stan Math library, each function exposed through to the Stan language must have definitions that allow for both primitive and autodiff types. As the language has grown, we have also added broadcasting, which allows users to mix scalars arguments with vector or array arguments.</p>
<p>The typical C++ method of defining a primary function template and a set of function template specialization is untenable for many functions in the Math library. For example, a single argument of the function may take 7 distinct C++ types: <code>double</code>, <code><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a></code>, <code>std::vector&lt;double&gt;</code>, <code>std::vector&lt;<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>&gt;</code>, <code>Eigen::Matrix&lt;double, -1, 1&gt;</code>, <code>Eigen::Matrix&lt;<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>, -1, 1&gt;</code>, or <code><a class="el" href="classstan_1_1math_1_1var__value.html">stan::math::var_value</a>&lt;Eigen::Matrix&lt;double, -1, -1&gt;&gt;</code>. For a 3-argument function, we would need to define 343 (7^3) different function template specializations to handle all the autodiff types.</p>
<p>In the Math library, we use a technique similar to C++20's <code>require</code> keyword that allows the definition of multiple template functions where each handles a subset of allowable types.</p>
<p>When the compiler attempts to resolve which function should be called from a set of templated function signatures there must be only one possibly valid function signature available. This is called the [One Definition Rule](<a href="https://en.cppreference.com/w/cpp/language/definition">https://en.cppreference.com/w/cpp/language/definition</a>). For example, the following code would fail to compile because the compiler is unable to differentiate between the two function signatures.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T foo(T x) {</div>
<div class="line">  <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</div>
<div class="line">K foo(K x) {</div>
<div class="line">  <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The compiler needs a way to differentiate between the two signatures to select one and satisfy the One Definition Rule. One trick to have a single valid definition is to utilize <a href="https://en.cppreference.com/w/cpp/language/sfinae">Substitution Failure Is Not An Error (SFNIAE)</a> to purposefully create conditions where only one signature is valid because all of the other conditions fail to compile. The simplest way to do this is to start with a type trait like the below <code>enable_if</code>. The <code>enable_if</code> is only defined for the case where <code>B</code> is <code>true</code> and so if <code>B</code> is ever false the compiler would throw an error saying that <code>enable_if</code> is not well defined.</p>
<div class="fragment"><div class="line">// Define enable_if. Note: `type` is not a member typedef.</div>
<div class="line">template&lt;bool B, class T = void&gt;</div>
<div class="line">struct enable_if {};</div>
<div class="line"> </div>
<div class="line">// Only define member typedef `type` when B is true</div>
<div class="line">template&lt;class T&gt;</div>
<div class="line">struct enable_if&lt;true, T&gt; { typedef T type; };</div>
<div class="line"> </div>
<div class="line">template &lt;bool B, typename T&gt;</div>
<div class="line">using enable_if_t = typename enable_if&lt;B, T&gt;::type;</div>
</div><!-- fragment --><p>Attempting to construct this <code>enable_if</code> with <code>B</code> being <code>false</code> anywhere else in the program would cause the compiler to crash. Using it in the template of a function signature allows SFINAE to deduce which signature we would like to use.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// foo only works with floating point types </span></div>
<div class="line">template &lt;typename T,  enable_if_t&lt;std::is_floating_point&lt;T&gt;::value&gt;&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">T foo(T x) {</div>
<div class="line">  <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// foo only works with integer types</span></div>
<div class="line">template &lt;typename K,  enable_if_t&lt;std::is_intergral&lt;K&gt;::value&gt;&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line">K foo(K x) {</div>
<div class="line">  <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calls the first signature</span></div>
<div class="line"><span class="keywordtype">double</span> x_dbl = 1.0;</div>
<div class="line"><span class="keywordtype">double</span> y_dbl = foo(x_dbl); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calls the second signature</span></div>
<div class="line"><span class="keywordtype">int</span> x = 1;</div>
<div class="line"><span class="keywordtype">int</span> y = foo(x);</div>
</div><!-- fragment --><p>The second template argument is referred to as a <a href="https://en.cppreference.com/w/cpp/language
template_parameters#Non-type_template_parameter">non-type template parameter</a> and has a default value of <code>void</code>. When the templated signature has the correct type the <code>enable_if_t</code> produces a <code>void</code> type which is then made into a pointer and assigned a default value of <code>nullptr</code>. When the templated signature does not have the correct type, the compiler utilizes <a href="https://en.cppreference.com/w/cpp/language/sfinae">Substitution Failure Is Not An Error (SFNIAE)</a>, to remove the offending signature from the list of possible matches while continuing to search for the correct signature.</p>
<p>For convenience in using this technique, the Math library has implemented a set of <a class="el" href="group__require__meta.html">`requires` type traits</a>. When we pass a type that satisfies the <code>requires</code> type trait, the trait evaluates to <code>void</code>. When a type that does not satisfy the <code>requires</code> template parameter is passed, there is a substitution failure. These traits are used in the template functions by adding a call to a <code>requires</code> type trait to the parameter list.</p>
<p>Below is an example to illustrate how this technique is used. After the example, the rest of this page describes what the requires type traits are, how to use them, and how to add new ones if necessary.</p>
<h3><a class="anchor" id="autotoc_md108"></a>
Example</h3>
<p>Here's a function that would have two different template functions for <code><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a></code> and <code>double</code>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, requires_not_var_t&lt;T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line">T foo(<span class="keyword">const</span> T&amp; t) {</div>
<div class="line">  <span class="comment">// handles primitives</span></div>
<div class="line">  <span class="keywordflow">return</span> t;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, requires_var_t&lt;T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line">T foo(<span class="keyword">const</span> T&amp; t) {</div>
<div class="line">  <span class="comment">// handles stan::math::var</span></div>
<div class="line">  <span class="keywordflow">return</span> t;</div>
<div class="line">}</div>
</div><!-- fragment --><p>When <code>foo()</code> is called with a <code><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a></code>, the first template function matches but not the second. This works because <code>requires_var_t&lt;<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>&gt;</code> evaluates to <code>void</code> whereas <code>requires_not_var_t&lt;<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>&gt;</code> is a subsitution error causing the compiler to omit the second definition for <code><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a></code>.</p>
<p>When <code>foo()</code> is called with <code>double</code> or <code>int</code>, the second template function matches, but not the first.</p>
<h2><a class="anchor" id="autotoc_md109"></a>
Requires&lt;&gt; type traits</h2>
<p>The Stan Math library defines boolean type traits&ndash;template metaprograms that operate on types at compile time&ndash;in the <code>stan/math{prim, rev, fwd}/meta</code> folders. Each of these type traits are named <code>is_{condition}</code> and the struct contains a <code>value</code> that is <code>true</code> or <code>false</code> at compile time. For example, <code>is_var&lt;T&gt;::value</code> is <code>true</code> if and only if the type <code>T</code> is <code><a class="el" href="classstan_1_1math_1_1var__value.html">stan::math::var_value</a></code>.</p>
<p>We provide <a class="el" href="group__require__meta.html">`requires&lt;&gt;` type traits</a> based on the boolean <code>is_{condition}</code> type traits. When types satisfy the condition, the <code>requires&lt;&gt;</code> will evaluate to <code>void</code>. When the types do not satisfy the condition, <code>requires&lt;&gt;</code> is an invalid subsitution and is not used. (See <a class="el" href="md_doxygen_2contributor__help__pages_2require__meta.html#requires_impl">Implementation details of requires&lt;&gt; type traits</a> for more details.)</p>
<p>Note: every possible requires&lt;&gt; type trait is not implemented in the Stan Math library. If one of the missing requires&lt;&gt; type trait is missing, we can implement it and include it. Please see <a class="el" href="md_doxygen_2contributor__help__pages_2require__meta.html#requires_dev_guide">Developing new requires type traits</a> for more information.</p>
<h3><a class="anchor" id="autotoc_md110"></a>
All requires&lt;&gt; type traits</h3>
<p>For any boolean type trait, below is the list of possible requires&lt;&gt; type traits. Any <code>*</code> should be thought of as a wildcard where a type traits name is put in its place. For example, for <code>is_var</code>, we can substitute <code>var</code> for <code>*</code>.</p>
<ol type="1">
<li><code>require_*_t</code>: A template parameter <code>T</code> must satisfy the <code>is_*</code> type trait. This means <code>require_var_t&lt;<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>&gt;</code> is <code>void</code>, but <code>require_var_t&lt;double&gt;</code> is an invalid subsitution.</li>
<li><p class="startli"><code>require_not_*_t</code>: A template parameter <code>T</code> must not satisfy the <code>is_*</code> type trait.</p>
<p class="startli"><em>NOTE:</em> The <code>not</code> version of the <code>requires</code> template parameters should be used sparingly. Often a <code>requires</code> template parameter is used to specify what types a function should accept. Defining a function by the types it cannot accept can make understanding what goes into a function more difficult and error prone.</p>
</li>
<li><code>require_all_*_t</code>: All types in the parameter pack of types must satisfy the <code>is_*</code> type trait.</li>
<li><code>require_any_*_t</code>: Any type in the parameter pack of types must satisfy the <code>is_*</code> type trait.</li>
<li><code>require_any_not_*_t</code>: Any type in the parameter pack must not satisfy the <code>is_*</code> type trait.</li>
<li><p class="startli"><code>require_all_not_*_t</code>: All types in the parameter pack must not satisfy the <code>is_*</code> type trait.</p>
<p class="startli"><code>std::vector</code> and <code><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a></code> types have additional <code>requires</code> template parameters to detect if the <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> (the type of the elements of either <code>std::vector</code> or the <code><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a></code> type) or the <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a> (the underlying scalar type after recursively walking through the container types) satisfy a condition to enable a class or function.</p>
<p class="startli">The container <code>requires</code> template parameters have an ending at their signature of <code>_vt</code> and <code>_st</code> to symbolize whether you want to inspect the <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> or <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a>.</p>
<p class="startli">In the next requires traits, <code>is_type</code> is used to represent any boolean type trait.</p>
</li>
<li><code>require_*_vt&lt;is_type, T&gt;</code>: A template parameter <code>T</code> must satisfy the <code>is_*</code> type trait and <code>is_type&lt;value_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
<li><code>require_not_*_vt&lt;is_type, T&gt;</code>: A template parameter <code>T</code> must not satisfy the <code>is_*</code> type trait or <code>is_type&lt;value_type&lt;T&gt;&gt;::value</code> must not evaluate to true.</li>
<li><code>require_all_*_vt&lt;is_type, T&gt;</code>: All types in the parameter pack of types must satisfy the <code>is_*</code> type trait and all <code>is_type&lt;value_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
<li><code>require_any_*_vt&lt;is_type, T&gt;</code>: Any type in the parameter pack of types must satisfy the <code>is_*</code> type trait and any <code>is_type&lt;value_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
<li><code>require_any_not_*_vt&lt;is_type, T&gt;</code>: At least one type in the parameter pack must not satisfy the <code>is_*</code> type trait and one of <code>is_type&lt;value_type&lt;T&gt;&gt;::value</code> must evaluate to false.</li>
<li><code>require_all_not_*_vt&lt;is_type, T&gt;</code>: None of the types in the parameter pack must satisfy the <code>is_*</code> type trait and none of <code>is_type&lt;value_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
<li><code>require_*_st&lt;is_type, T&gt;</code>: A template parameter <code>T</code> must satisfy the <code>is_*</code> type trait and <code>is_type&lt;scalar_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
<li><code>require_not_*_st&lt;is_type, T&gt;</code>: A template parameter <code>T</code> must not satisfy the <code>is_*</code> type trait or <code>is_type&lt;scalar_type&lt;T&gt;&gt;::value</code> must not evaluate to true.</li>
<li><code>require_all_*_st&lt;is_type, T&gt;</code>: All types in the parameter pack of types must satisfy the <code>is_*</code> type trait and all <code>is_type&lt;scalar_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
<li><code>require_any_*_st&lt;is_type, T&gt;</code>: Any type in the parameter pack of types must satisfy the <code>is_*</code> type trait and any <code>is_type&lt;scalar_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
<li><code>require_any_not_*_st&lt;is_type, T&gt;</code>: At least one type in the parameter pack must not satisfy the <code>is_*</code> type trait and one of <code>is_type&lt;scalar_type&lt;T&gt;&gt;::value</code> must evaluate to false.</li>
<li><code>require_all_not_*_st&lt;is_type, T&gt;</code>: None of the types in the parameter pack must satisfy the <code>is_*</code> type trait and none of <code>is_type&lt;scalar_type&lt;T&gt;&gt;::value</code> must evaluate to true.</li>
</ol>
<h2><a class="anchor" id="requires_impl"></a>
Implementation details of requires&lt;&gt; type traits</h2>
<p>The <a class="el" href="group__require__meta.html">`requires` template parameters</a> type traits are aliases for <code>std::enable_if_t</code> that have premade conditions for turning on and off function definitions during compilation. These are useful for having generalized templates while still overloading a function or class. You can think of these as "legacy concepts." These are used in a very similar fashion to C++20's <code>requires</code> keyword.</p>
<p><code>requires</code> template parameters are <a href="https://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if_t</code></a> aliases such as the following example definition of <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">stan::require_t</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using </span>require_t = std::enable_if_t&lt;T::value&gt;;</div>
</div><!-- fragment --><p>This differs from <code>std::enable_if_t</code> in that <code>std::enable_if_t</code>'s argument must be boolean, but the alias <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">stan::require_t</a> 's template type <code>T</code> must have a valid boolean member named <code>value</code>. This allows us to directly call <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">stan::require_t</a> with type traits instead of having to do the extra step of accessing the type traits boolean member struct value explicity with calls such as <code>a_type_trait::value</code>.</p>
<p>The most common use case for a <code>requires</code> template parameters is to overload a function or declare specializations of a class. For example, the function below will only work on types derived from <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html"><code>Eigen::DenseBase</code></a> with only 1 row or column at compile time such as <code>Eigen::Matrix&lt;double, -1, 1&gt;</code> or <code>Eigen::Matrix&lt;double, 1, -1&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vector_t&lt;EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> my_func(<span class="keyword">const</span> EigVec&amp; x) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For overloading classes and structs with this scheme we create an initial forward definition with a <code>void</code> non-type template parameter. Then the class overloads use the <code>requires</code> template parameter in place of the non-type template parameter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><span class="keyword">class </span>a_class;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>a_class&lt;T, require_std_vector_st&lt;is_var, T&gt;&gt; {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>a_class</code> has an overload specifically for standard vectors with a <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a> of <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a>.</p>
<p>There are also <code>requires</code> template parameters for generically checking if a type's <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> or <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a> is correct. To differentiate them from the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> and standard library vector checks the <code>vt</code> and <code>st</code> come <em>before</em> the type such as <code>require_vt_var&lt;T&gt;</code> which checks if a type <code>T</code>'s <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> satisfies <a class="el" href="structstan_1_1is__var.html">stan::is_var</a>.</p>
<p>The <code>requires</code> template parameters type traits allow Stan to have more generic types so that the library can forward <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression and have better move semantics. For instance, the code below will accept any arbitrary <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression that, if it's an rvalue, can be forwarded to another function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mat1, <span class="keyword">typename</span> Mat2,</div>
<div class="line"> require_all_eigen_vt&lt;is_arithmetic, Mat1, Mat2&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> a_func(Mat1&amp;&amp; m1, Mat2&amp;&amp; m2) {</div>
<div class="line">  check_not_nan(m1);</div>
<div class="line">  check_not_nan(m2);</div>
<div class="line">  <span class="keywordflow">return</span> another_func(std::forward&lt;Mat1&gt;(m1), std::forward&lt;Mat2&gt;(m2));</div>
</div><!-- fragment --><h1><a class="anchor" id="requires_dev_guide"></a>
Developing new requires type traits</h1>
<p>Every requires type trait is not implemented for every boolean type trait available. This was done intentionally to allow us to identify which requires type traits are currently in use. If you need a requires type trait and it is not currently available, please feel free to implement the one you need and add a pull request.</p>
<h2><a class="anchor" id="autotoc_md111"></a>
Adding a new boolean type trait</h2>
<p>If you are adding a new boolean type trait, please add the primary function template to <code>stan/math/prim/meta/</code>, then add any autodiff specialization to the appropriate <code>stan/math/{rev, fwd, mix}/meta/</code> folder.</p>
<h2><a class="anchor" id="autotoc_md112"></a>
Adding a new requires</h2>
<p>The Stan Math library requires a strict API to ensure consistency for the <code>requires</code>. The below go over all of the possible API configurations a developer should use when writing a new <code>requires</code>.</p>
<p>For the API docs below, let <code>T</code> represent the type parameter we want to check, <code>is_type</code> is a generic type trait which will be replaced by the developer, and <code>InnerCheck</code> is a type trait used to check either the value_type or scalar_type of <code>T</code>.</p>
<p>Each requires ends in <code>_t</code>, <code>_vt</code>, or <code>_st</code>. They differ in the following ways</p>
<ul>
<li><p class="startli"><code>_t</code> uses <code>Check</code> to test the type <code>T</code> passed in</p>
<p class="startli">Ex:</p>
<div class="fragment"><div class="line">// Always decay types coming into the requires</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">require_autodiff_t = require_t&lt;is_autodiff&lt;std::decay_t&lt;T&gt;&gt;&gt;;</div>
</div><!-- fragment --></li>
<li><p class="startli"><code>_vt</code> uses <code>Check</code> to test the type <code>T</code> passed in and uses <code>InnerCheck</code> to test the value_type of <code>T</code></p>
<div class="fragment"><div class="line">template &lt;template &lt;class...&gt; class TypeCheck, class... Check&gt;   </div>
<div class="line">require_std_vector_vt = require_vt&lt;is_std_vector, TypeCheck, std::decay_t&lt;Check&gt;...&gt;;</div>
<div class="line"> </div>
<div class="line">// Ex: Used to define a signature for `std::vectors` with a value type that is @ref stan::math::var</div>
<div class="line">template &lt;typename StdVec, require_std_vector_vt&lt;is_var, StdVec&gt;* = nullptr&gt;</div>
<div class="line">auto my_func(StdVec&amp;&amp; vec);</div>
</div><!-- fragment --></li>
<li><code>_st</code> uses <code>Check</code> to test the type <code>T</code> passed in and uses <code>InnerCheck</code> to test the scalar_type of <code>T</code></li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class </span>TypeCheck, <span class="keyword">class</span>... Check&gt;   </div>
<div class="line">require_std_vector_st = require_st&lt;is_std_vector, TypeCheck, std::decay_t&lt;Check&gt;...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Ex: Used to define a signature for `std::vectors` with a scalar type that is autodiffable</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StdVec, require_std_vector_st&lt;is_var, StdVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> my_func(StdVec&amp;&amp; vec);</div>
<div class="line"> </div>
<div class="line">The variant of the <span class="keyword">requires</span> that places the `vt` or `st` before the</div>
<div class="line">type trait name only checks the @ref value_type or @ref `scalar_type`</div>
<div class="line">of `T` without testing `T`.</div>
</div><!-- fragment --><p> // Require the scalar type is an std::vector template &lt;typename T&gt; <br  />
 require_st_std_vector = require_t&lt;is_std_vector&lt;scalar_type_t&lt;std::decay_t&lt;T&gt;&gt;&gt;&gt;;</p>
<p>// Ex: Used to define a signature for <code>std::vectors</code> with a scalar type that is autodiffable template &lt;typename StdVec, require_std_vector_st&lt;is_var, StdVec&gt;* = nullptr&gt; auto my_func(StdVec&amp;&amp; vec); ```</p>
<p>In the below, <code>{TYPE_TRAIT}</code> represents the name of the trait the requires checks. Each new require <em>must</em> follow this standard API.</p>
<ol type="1">
<li><code>require_{TYPE_TRAIT}_t</code>: The template parameter must return <code>true</code> when passed to the type trait</li>
<li><code>require_not_{TYPE_TRAIT}_t</code>: The template parameter must return <code>false</code> when passed to the type trait</li>
<li><code>require_all_{TYPE_TRAIT}_t</code>: The template parameters must all return <code>true</code> when passed to the type trait</li>
<li><code>require_all_not_{TYPE_TRAIT}_t</code>: The template parameters must all return <code>false</code> when passed to the type trait</li>
<li><code>require_any_{TYPE_TRAIT}_t</code>: At least one of the template parameters must return <code>true</code> when passed to the type trait</li>
<li><code>require_any_not_{TYPE_TRAIT}_t</code>: At least one of the template parameters must return <code>false</code> when passed to the type trait</li>
</ol>
<p>In addition to all the requires with an <code>_t</code> at the end, the requires also have <code>_st</code>, <code>_vt</code> variants where in addition to the logic above, the value_type or scalar_type must follow the same logic as the type for <code>T</code>. The <code>_st_</code>, and <code>_vt_</code> variants must also follow the same logic but for checking only the inner value_type or @scalar_type. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
