<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: stan Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacestan.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">stan Namespace Reference<div class="ingroups"><a class="el" href="group__eigen__expressions.html">Eigen expressions</a> &raquo; <a class="el" href="group__returning__expressions.html">Returning expressions</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The lgamma implementation in stan-math is based on either the reentrant safe lgamma_r implementation from C or the boost::math::lgamma implementation. </p>
<p>Operations in <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Expressions hold their arguments either by value or by reference.</p>
<p>The reentrant safe lgamma_r implementation is preferred as it is faster when compared to the boost version. However, the reentrant safe lgamma_r C function is not available with MinGW compilers used on Windows. Therefore, the boost version is used on Windows with MinGW compilers as fall back. For details on the speed evaluations, please refer to <a href="https://github.com/stan-dev/math/pull/1255">https://github.com/stan-dev/math/pull/1255</a> .</p>
<p>Which one is chosen depends on type of the argument. Other operations are held by value. "Heavy" objects that can hold data themselves, such as <code>Eigen::Matrix</code> or <code>Eigen::Ref</code> are instead held by reference. THis is the only criterion - holding rvalue arguments by value is not supported, so we can not use perfect forwarding.</p>
<p>When returning an expression from function we have to be careful that any arguments in this expression that are held by reference do not go out of scope. For instance, consider the function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> f(<span class="keyword">const</span> T&amp; x){</div>
<div class="line">  <span class="keyword">const</span> Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp; x_ref = x;</div>
<div class="line">  <span class="keywordflow">return</span> x_ref.cwiseProduct(x_ref);</div>
<div class="line">}</div>
</div><!-- fragment --><p> And the code calling it: </p><div class="fragment"><div class="line">Eigen::MatrixXd test_mat(2,2);</div>
<div class="line">test_mat &lt;&lt; 5, 5, 5, 5;</div>
<div class="line">VectorXd X  = f(test_mat.diagonal());</div>
</div><!-- fragment --><p> This function will return back a <code>CwiseBinaryOp</code> <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression, which is then evaluated out of the function scope when assigned to <code>X</code>. The expression references <code>x_ref</code>, which was created withing function and destroyed when the function returned. The returned expression is evaluated after the function returned, so its evaluation references a matrix that was already deleted. In other words the returned expression contains a dangling reference.</p>
<p>So a function returning an expression referencing local matrices or matrices that were rvalue reference arguments to the function will not work.</p>
<p>A workarount to this issue is allocating and constructing or moving such objects to heap. <code>Holder</code> object is a no-op operation that can also take pointers to such objects and release them when it goes out of scope. It can be created either by directly supplying pointers to such objects to <code>holder</code> function or by forwarding function arguments and moving local variables to <code>make_holder</code>, which will move any rvalues to heap first. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestan_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestan_1_1math"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math.html">math</a></td></tr>
<tr class="memdesc:namespacestan_1_1math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrices and templated mathematical functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type.html">base_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base base type of a template argument.  <a href="structstan_1_1base__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html">base_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base type for values stored in a complex number.  <a href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4.html">base_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base base type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <a href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html">base_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstan_1_1base__type.html" title="Metaprogram structure to determine the base base type of a template argument.">base_type</a> for vector to recursively return the inner base type.  <a href="structstan_1_1base__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1conditional__var__value.html">conditional_var_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally construct a var_value container based on a scalar type.  <a href="structstan_1_1conditional__var__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1conditional__var__value_3_01_t__scalar_00_01_t__container_00_01require__std__vecto0d0d39ee52856f623bdb847159bc770a.html">conditional_var_value&lt; T_scalar, T_container, require_std_vector_t&lt; T_container &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1error__index.html">error_index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1eval__return__type.html">eval_return_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines return type of calling <code></code>.eval() on <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression.  <a href="structstan_1_1eval__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__any__var__matrix.html">is_any_var_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any types in a parameter pack are a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__any__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__arena__matrix.html">is_arena_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is <code>arena_matrix&lt;T&gt;</code>  <a href="structstan_1_1is__arena__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__arena__matrix_3_01_t_00_01require__t_3_01internal_1_1is__arena__matrix__impl_382c328ab88094a24a9cfff97c4ae9a76.html">is_arena_matrix&lt; T, require_t&lt; internal::is_arena_matrix_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is <code>arena_matrix&lt;T&gt;</code>  <a href="structstan_1_1is__arena__matrix_3_01_t_00_01require__t_3_01internal_1_1is__arena__matrix__impl_382c328ab88094a24a9cfff97c4ae9a76.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__arena__matrix__cl.html">is_arena_matrix_cl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var or fvar.  <a href="structstan_1_1is__autodiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__base__pointer__convertible.html">is_base_pointer_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type's pointer is convertible to a templated base type's pointer.  <a href="structstan_1_1is__base__pointer__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T has a static comple time constant type <code>ColsAtCompileTime</code> equal to 1 this has a static member with a value of true.  <a href="structstan_1_1is__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is a complex type (that is, an instance of <code>std::complex</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__complex__impl_3_046b16e5efef3928dd1fd82ec1007e683.html">is_complex&lt; T, std::enable_if_t&lt; internal::is_complex_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex__ad.html">is_complex_ad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is a complex type with an inner autodiff type (that is, an instance of <code>std::complex&lt;var&gt;</code> or <code>std::complex&lt;fvar&lt;T&gt;&gt;</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__complex__ad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex__ad_3_01_t_00_01std_1_1enable__if__t_3_01stan_1_1math_1_1conjunction_38883c89e3ab84deeeba2b303818ae572.html">is_complex_ad&lt; T, std::enable_if_t&lt; stan::math::conjunction&lt; is_autodiff&lt; base_type_t&lt; T &gt; &gt;, internal::is_complex_impl&lt; std::decay_t&lt; T &gt; &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex__arithmetic.html">is_complex_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is a complex type with an inner arithmetic type (that is, an instance of <code>std::complex&lt;Arithmetic&gt;</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__complex__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__complex__arithmetic_3_01_t_00_01std_1_1enable__if__t_3_01stan_1_1math_1_1conju8cf6495b11a29663a3c09f429d245681.html">is_complex_arithmetic&lt; T, std::enable_if_t&lt; stan::math::conjunction&lt; std::is_arithmetic&lt; base_type_t&lt; T &gt; &gt;, internal::is_complex_impl&lt; std::decay_t&lt; T &gt; &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant.html">is_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming struct to detect whether a given type is constant in the mathematical sense (not the C++ <code>const</code> sense).  <a href="structstan_1_1is__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html">is_constant&lt; T, require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value and sets it to true if the type of the elements in the provided matrix_cl is constant, false otherwise.  <a href="structstan_1_1is__constant_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">is_constant&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a public enum named value and sets it to true if the type of the elements in the provided <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix is constant, false otherwise.  <a href="structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">is_constant&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value and sets it to true if the type of the elements in the provided std::vector is constant, false otherwise.  <a href="structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__detected.html">is_detected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__detected_3_01_t_00_01_op_00_01void__t_3_01_op_3_01_t_01_4_01_4_01_4.html">is_detected&lt; T, Op, void_t&lt; Op&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a valid type is detected.  <a href="structstan_1_1is__detected_3_01_t_00_01_op_00_01void__t_3_01_op_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a double or integer.  <a href="structstan_1_1is__double__or__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen.html">is_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type derives from <code>EigenBase</code>  <a href="structstan_1_1is__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::ArrayBase</code>  <a href="structstan_1_1is__eigen__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 row at compile time this has a static member with a value of true.  <a href="structstan_1_1is__eigen__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__contiguous__map.html">is_eigen_contiguous_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Map</code> with contiguous stride.  <a href="structstan_1_1is__eigen__contiguous__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__dense__base.html">is_eigen_dense_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase.  <a href="structstan_1_1is__eigen__dense__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::MatrixBase.  <a href="structstan_1_1is__eigen__matrix__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::MatrixBase and has columns and rows not equal to 1.  <a href="structstan_1_1is__eigen__matrix__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column at compile time this has a static member with a value of true.  <a href="structstan_1_1is__eigen__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__sparse__base.html">is_eigen_sparse_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::SparseMatrixBase.  <a href="structstan_1_1is__eigen__sparse__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column or 1 row at compile time this has a static member with a value of true.  <a href="structstan_1_1is__eigen__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__fvar.html">is_fvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member function type which is defined to be false as the primitive scalar types cannot be a <a class="el" href="structstan_1_1math_1_1fvar.html" title="This template class represents scalars used in forward-mode automatic differentiation,...">stan::math::fvar</a> type.  <a href="structstan_1_1is__fvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__fvar_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__fvar__impl_3_01std_1b6277f746b82df74a03be21cd1ddf918.html">is_fvar&lt; T, std::enable_if_t&lt; internal::is_fvar_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__kernel__expression.html">is_kernel_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type is is a valid kernel generator expression.  <a href="structstan_1_1is__kernel__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__kernel__expression__and__not__scalar.html">is_kernel_expression_and_not_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type is non-scalar type that is a valid kernel generator expression.  <a href="structstan_1_1is__kernel__expression__and__not__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__kernel__expression__and__not__scalar_3_01_t_00_01require__matrix__cl__t_3_01_t_01_4_01_4.html">is_kernel_expression_and_not_scalar&lt; T, require_matrix_cl_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__kernel__expression__lhs.html">is_kernel_expression_lhs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type is an assignable kernel generator expression.  <a href="structstan_1_1is__kernel__expression__lhs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__kernel__expression__lhs_3_01_t_00_01require__matrix__cl__t_3_01_t_01_4_01_4.html">is_kernel_expression_lhs&lt; T, require_matrix_cl_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__matrix.html">is_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::EigenBase</code> or is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the decayed type of T is a matrix_cl.  <a href="structstan_1_1is__matrix__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type is either a non-scalar kernel generator expression or a var containing a non-scalar kernel generator expression.  <a href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__prim__or__rev__kernel__expression.html">is_prim_or_rev_kernel_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type is either a kernel generator expression or a var containing a kernel generator expression.  <a href="structstan_1_1is__prim__or__rev__kernel__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__real.html">is_real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var, fvar, or arithmetic.  <a href="structstan_1_1is__real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__col__vector.html">is_rev_col_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__col__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_30dc403fb8542198c3091e4e6e1e54ba5.html">is_rev_col_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_col_vector&lt; T &gt;, is_eigen_col_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__col__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_30dc403fb8542198c3091e4e6e1e54ba5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__kernel__expression.html">is_rev_kernel_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a type is a var containing a kernel generator expression.  <a href="structstan_1_1is__rev__kernel__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__rev__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__matrix_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3_01_t1ddd3dfbec50668d893a6befdfb0b45a.html">is_rev_matrix&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; math::conjunction&lt; is_var&lt; T &gt;, is_eigen&lt; value_type_t&lt; T &gt; &gt; &gt;, is_eigen&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__rev__matrix_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3_01_t1ddd3dfbec50668d893a6befdfb0b45a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__row__vector.html">is_rev_row_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__row__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3f675c2ac2e6bea3e3104996f22b12a50.html">is_rev_row_vector&lt; T, require_all_t&lt; is_var&lt; scalar_type_t&lt; T &gt; &gt;, math::disjunction&lt; is_eigen_row_vector&lt; T &gt;, is_eigen_row_vector&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__row__vector_3_01_t_00_01require__all__t_3_01is__var_3_01scalar__type__t_3f675c2ac2e6bea3e3104996f22b12a50.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__vector.html">is_rev_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__rev__vector_3_01_t_00_01require__any__t_3_01is__rev__col__vector_3_01_t_01_4_0ee983b7fdcdd0eeacbfc45ed12837bd6.html">is_rev_vector&lt; T, require_any_t&lt; is_rev_col_vector&lt; T &gt;, is_rev_row_vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be true if the type is either a type derived from <code>Eigen::EigenBase</code> with a <code>Scalar</code> type of <code>var_value&lt;double&gt;</code> or a <code>var_value&lt;T&gt;</code> where T is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__rev__vector_3_01_t_00_01require__any__t_3_01is__rev__col__vector_3_01_t_01_4_0ee983b7fdcdd0eeacbfc45ed12837bd6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__row__vector.html">is_row_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T has a static comple time constant type <code>RowsAtCompileTime</code> equal to 1 this has a static member with a value of true.  <a href="structstan_1_1is__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var, fvar, or arithmetic.  <a href="structstan_1_1is__stan__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base implementation for checking if type is std vector.  <a href="structstan_1_1is__std__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__std__vector_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__std__vector__28c6aea3001284899b87957f6f2ae7d6.html">is_std_vector&lt; T, std::enable_if_t&lt; internal::is_std_vector_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the decayed type of T is a standard vector.  <a href="structstan_1_1is__std__vector_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__std__vector__28c6aea3001284899b87957f6f2ae7d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var.html">is_var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be false as the primitive scalar types cannot be a <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> type.  <a href="structstan_1_1is__var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__var__impl_3_01std_1_14fc46eebc2d7d167cda3892bd7b10182.html">is_var&lt; T, std::enable_if_t&lt; internal::is_var_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier is a var_value.  <a href="structstan_1_1is__var_3_01_t_00_01std_1_1enable__if__t_3_01internal_1_1is__var__impl_3_01std_1_14fc46eebc2d7d167cda3892bd7b10182.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__col__vector.html">is_var_col_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__var__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__dense__dynamic.html">is_var_dense_dynamic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code> and has dynamic rows and columns.  <a href="structstan_1_1is__var__dense__dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__eigen.html">is_var_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__var__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>  <a href="structstan_1_1is__var__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__or__arithmetic__type.html">is_var_or_arithmetic_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member value which is defined to be true (1) if the unqualified cv of type T or its underlying type (if a container) is either var or an arithmetic type, and false (0) otherwise.  <a href="structstan_1_1is__var__or__arithmetic__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__row__vector.html">is_var_row_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__var__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__var__vector.html">is_var_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is a <code>var_value</code> whose <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> is derived from <code>Eigen::EigenBase</code>.  <a href="structstan_1_1is__var__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vari.html">is_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier and pointer is a vari.  <a href="structstan_1_1is__vari.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vari_3_01_t_00_01require__t_3_01internal_1_1is__vari__impl_3_01std_1_1decay__t_3_01_t_01_4_01_4_01_4_01_4.html">is_vari&lt; T, require_t&lt; internal::is_vari_impl&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for checking if value of T minus cv qualifier and pointer is a vari_value.  <a href="structstan_1_1is__vari_3_01_t_00_01require__t_3_01internal_1_1is__vari__impl_3_01std_1_1decay__t_3_01_t_01_4_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vector.html">is_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is either an eigen matrix with 1 column or 1 row at compile time or a standard vector, this has a static member with a value of true.  <a href="structstan_1_1is__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram indicates whether a type is vector_like.  <a href="structstan_1_1is__vector__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vt__complex.html">is_vt_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> of the type <code>T</code> is of type <code>std::complex</code> or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__vt__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1is__vt__not__complex.html">is_vt_not_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code><a class="el" href="structstan_1_1value__type.html" title="Primary template class for metaprogram to compute the type of values stored in a container.">value_type</a></code> of the type <code>T</code> is not of type <code>std::complex</code> or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="structstan_1_1is__vt__not__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1make__void.html">make_void</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1operation__cl__base.html">operation_cl_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-templated base of <code>operation_cl</code> is needed for easy checking if something is a subclass of <code>operation_cl</code>.  <a href="classstan_1_1operation__cl__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1operation__cl__lhs__base.html">operation_cl_lhs_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-templated base of <code>operation_cl_lhs</code> is needed for easy checking if something is a subclass of <code>operation_cl_lhs</code>.  <a href="classstan_1_1operation__cl__lhs__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__return__type.html">partials_return_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the partial derivative type resulting from promoting all the scalar types of the template parameters.  <a href="structstan_1_1partials__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__return__type_3_01_t_01_4.html">partials_return_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__type.html">partials_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base implementation will contain a static member function named type equal to the type passed into it.  <a href="structstan_1_1partials__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__type_3_01_t_00_01require__fvar__t_3_01_t_01_4_01_4.html">partials_type&lt; T, require_fvar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html">partials_type&lt; T, require_var_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of partials type returns double if input type is a double.  <a href="structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1plain__type.html">plain_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines plain (non expression) type associated with <code>T</code>.  <a href="structstan_1_1plain__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1plain__type_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html">plain_type&lt; T, require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines plain (non expression) type associated with <code>T</code>.  <a href="structstan_1_1plain__type_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1plain__type_3_01_t_00_01require__t_3_01bool__constant_3_01internal_1_1has__eval_3_3bab9f31b4aa571acc18fbbe4901599a.html">plain_type&lt; T, require_t&lt; bool_constant&lt; internal::has_eval&lt; T &gt;::value &amp;&amp;is_eigen&lt; T &gt;::value &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines plain (non expression) type associated with <code>T</code>.  <a href="structstan_1_1plain__type_3_01_t_00_01require__t_3_01bool__constant_3_01internal_1_1has__eval_3_3bab9f31b4aa571acc18fbbe4901599a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1plain__type_3_01_t_00_01require__t_3_01bool__constant_3_9internal_1_1has__eval_3_0efb41e50ff6b5292a8696a8405e220b1.html">plain_type&lt; T, require_t&lt; bool_constant&lt;!internal::has_eval&lt; T &gt;::value &amp;&amp;internal::has_plain_object&lt; T &gt;::value &amp;&amp;is_eigen&lt; T &gt;::value &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1plain__type_3_01_t_00_01require__t_3_01stan_1_1math_1_1conjunction_3_01is__var_3_07504fa89f82ef6358551ab505323783d.html">plain_type&lt; T, require_t&lt; stan::math::conjunction&lt; is_var&lt; T &gt;, is_eigen&lt; value_type_t&lt; T &gt; &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines plain (non expression) type associated with <code>T</code>.  <a href="structstan_1_1plain__type_3_01_t_00_01require__t_3_01stan_1_1math_1_1conjunction_3_01is__var_3_07504fa89f82ef6358551ab505323783d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1real__return.html">real_return</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member type alias named <code>type</code>, the value of which is the least type under Stan's assignability relation that can be assigned a <code>double</code> and all of the base types of the specified arguments after removing qualifiers (<code>const</code> and <code>volatile</code>) and decaying (lvalue to rvalue by removing references) and array to pointer).  <a href="structstan_1_1real__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1real__return_3_01_t_00_01_ts_8_8_8_01_4.html">real_return&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1ref__type__if.html">ref_type_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the condition is true determines appropriate type for assigning expression of given type to, to evaluate expensive expressions, but not make a copy if T involves no calculations.  <a href="structstan_1_1ref__type__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1ref__type__if_3_01_condition_00_01_t_00_01require__all__kernel__expressions__t_3_01_t_01_4_01_4.html">ref_type_if&lt; Condition, T, require_all_kernel_expressions_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1ref__type__if_3_01_condition_00_01_t_00_01require__all__t_3_01is__eigen_3_01_t_01_5c5243287cb62f4577a3e2a53563ad88.html">ref_type_if&lt; Condition, T, require_all_t&lt; is_eigen&lt; T &gt;, bool_constant&lt;!is_arena_matrix&lt; T &gt;::value &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1ref__type__if_3_01_condition_00_01_t_00_01require__arena__matrix__t_3_01_t_01_4_01_4.html">ref_type_if&lt; Condition, T, require_arena_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1return__type.html">return_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the base scalar return type resulting from promoting all the scalar types of the template parameters to the least type to which all the base types of the arguments are assignable.  <a href="structstan_1_1return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1rev__matrix__type.html">rev_matrix_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines a return type for a function that accepts given inputs and wants to return a matrix (or vector or row vector) with given compile time number of rows and columns.  <a href="structstan_1_1rev__matrix__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__lub.html">scalar_lub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a member type named <code>type</code> that is the least scalar type to which both template parameter scalar types are assignable in Stan.  <a href="structstan_1_1scalar__lub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__lub_3_01std_1_1complex_3_01_t1_01_4_00_01std_1_1complex_3_01_t2_01_4_01_4.html">scalar_lub&lt; std::complex&lt; T1 &gt;, std::complex&lt; T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__lub_3_01std_1_1complex_3_01_t1_01_4_00_01_t2_01_4.html">scalar_lub&lt; std::complex&lt; T1 &gt;, T2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__lub_3_01_t1_00_01std_1_1complex_3_01_t2_01_4_01_4.html">scalar_lub&lt; T1, std::complex&lt; T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1scalar__seq__view.html">scalar_seq_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1scalar__seq__view.html" title="scalar_seq_view provides a uniform sequence-like wrapper around either a scalar or a sequence of scal...">scalar_seq_view</a> provides a uniform sequence-like wrapper around either a scalar or a sequence of scalars.  <a href="classstan_1_1scalar__seq__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1scalar__seq__view_3_01_c_00_01require__eigen__vector__t_3_01_c_01_4_01_4.html">scalar_seq_view&lt; C, require_eigen_vector_t&lt; C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1scalar__seq__view_3_01_c_00_01require__stan__scalar__t_3_01_c_01_4_01_4.html">scalar_seq_view&lt; C, require_stan_scalar_t&lt; C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization handles wrapping a scalar as if it were a sequence.  <a href="classstan_1_1scalar__seq__view_3_01_c_00_01require__stan__scalar__t_3_01_c_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1scalar__seq__view_3_01_c_00_01require__std__vector__t_3_01_c_01_4_01_4.html">scalar_seq_view&lt; C, require_std_vector_t&lt; C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1scalar__seq__view_3_01_c_00_01require__t_3_01std_1_1is__pointer_3_01_c_01_4_01_4_01_4.html">scalar_seq_view&lt; C, require_t&lt; std::is_pointer&lt; C &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1scalar__seq__view_3_01_c_00_01require__var__matrix__t_3_01_c_01_4_01_4.html">scalar_seq_view&lt; C, require_var_matrix_t&lt; C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type.html">scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base scalar type of a template argument.  <a href="structstan_1_1scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html">scalar_type&lt; T, require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scalar type of an OpenCL matrix.  <a href="structstan_1_1scalar__type_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html">scalar_type&lt; T, std::enable_if_t&lt; is_complex&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the scalar type for values stored in a complex number.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__complex_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_0ccf9db19ce8a9663af531dce04a2ccd4.html">scalar_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;!internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base scalar type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_0ccf9db19ce8a9663af531dce04a2ccd4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_04b21f7115cf968f92528472b60798cb7.html">scalar_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the base scalar type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_04b21f7115cf968f92528472b60798cb7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html">scalar_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstan_1_1scalar__type.html" title="Metaprogram structure to determine the base scalar type of a template argument.">scalar_type</a> for vector to recursively return the inner scalar type.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4.html">scalar_type&lt; T, std::enable_if_t&lt; is_var&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization defining the scalar type of values stored in var_value.  <a href="structstan_1_1scalar__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1_std_vector_builder.html" title="StdVectorBuilder allocates type T1 values to be used as intermediate values.">StdVectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="classstan_1_1_std_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type.html">value_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute the type of values stored in a container.  <a href="structstan_1_1value__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html">value_type&lt; T, require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value type of an OpenCL matrix.  <a href="structstan_1_1value__type_3_01_t_00_01require__all__kernel__expressions__and__none__scalar__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01require__t_3_01is__vari_3_01_t_01_4_01_4_01_4.html">value_type&lt; T, require_t&lt; is_vari&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01f58c467b4f23839dbf43671c1d1794e4.html">value_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;!internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01f58c467b4f23839dbf43671c1d1794e4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01d6460066794d0b0fe8aa7bc4db11e6ce.html">value_type&lt; T, std::enable_if_t&lt; is_eigen&lt; T &gt;::value &amp;&amp;internal::has_scalar_trait&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining the type of values stored in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__eigen_3_01_t_01_4_1_1value_01d6460066794d0b0fe8aa7bc4db11e6ce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html">value_type&lt; T, std::enable_if_t&lt; is_std_vector&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of values stored in a standard vector.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__std__vector_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01is__var_3_01_t_01_4_1_1value_01_4_01_4.html">value_type&lt; T, std::enable_if_t&lt; is_var&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html">value_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for pointers returns the underlying value the pointer is pointing to.  <a href="structstan_1_1value__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1vector__seq__view.html">vector_seq_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a low-cost wrapper for situations where you either need an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Vector or RowVector or a std::vector of them and you want to be agnostic between those two options.  <a href="classstan_1_1vector__seq__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1vector__seq__view_3_01_t_00_01require__matrix__t_3_01_t_01_4_01_4.html">vector_seq_view&lt; T, require_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a low-cost wrapper for situations where you either need an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Vector or RowVector or a std::vector of them and you want to be agnostic between those two options.  <a href="classstan_1_1vector__seq__view_3_01_t_00_01require__matrix__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1vector__seq__view_3_01_t_00_01require__std__vector__vt_3_01internal_1_1is__matrix__1bc347e42a093a8dd822f8eeff69f8d8.html">vector_seq_view&lt; T, require_std_vector_vt&lt; internal::is_matrix_or_std_vector, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a low-cost wrapper for situations where you either need an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Vector or RowVector or a std::vector of them and you want to be agnostic between those two options.  <a href="classstan_1_1vector__seq__view_3_01_t_00_01require__std__vector__vt_3_01internal_1_1is__matrix__1bc347e42a093a8dd822f8eeff69f8d8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values.">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="classstan_1_1_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_vector_builder_helper.html">VectorBuilderHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values.">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="classstan_1_1_vector_builder_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01false_01_4.html">VectorBuilderHelper&lt; T1, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html">VectorBuilderHelper&lt; T1, true, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for using a vector.  <a href="classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac0fcd9f3e82f72b645ce2eaf9d9a3eea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0fcd9f3e82f72b645ce2eaf9d9a3eea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a> = typename <a class="el" href="structstan_1_1base__type.html">base_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ac0fcd9f3e82f72b645ce2eaf9d9a3eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gad1046e42476333dc3c08c35bfe420302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for structs used for wraps a static constant of bool.  <br /></td></tr>
<tr class="separator:gad1046e42476333dc3c08c35bfe420302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaaa1b1eb615a4b1b30b46ef33ace88cdf.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">contains_std_vector</a> = <a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; Ts &gt;... &gt;</td></tr>
<tr class="memdesc:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any types are std vectors.  <br /></td></tr>
<tr class="separator:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e48cb1884aea7f3c6708b6d3d8d27f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga88e48cb1884aea7f3c6708b6d3d8d27f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arena__matrix__types_ga88e48cb1884aea7f3c6708b6d3d8d27f.html#ga88e48cb1884aea7f3c6708b6d3d8d27f">require_arena_matrix_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__arena__matrix.html">is_arena_matrix</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga88e48cb1884aea7f3c6708b6d3d8d27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__arena__matrix.html">is_arena_matrix</a>.  <br /></td></tr>
<tr class="separator:ga88e48cb1884aea7f3c6708b6d3d8d27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528d8aa9f718bbf0e92cca342ccb41e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga528d8aa9f718bbf0e92cca342ccb41e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arena__matrix__types_ga528d8aa9f718bbf0e92cca342ccb41e6.html#ga528d8aa9f718bbf0e92cca342ccb41e6">require_not_arena_matrix_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt;!<a class="el" href="structstan_1_1is__arena__matrix.html">is_arena_matrix</a>&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</td></tr>
<tr class="memdesc:ga528d8aa9f718bbf0e92cca342ccb41e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__arena__matrix.html">is_arena_matrix</a>.  <br /></td></tr>
<tr class="separator:ga528d8aa9f718bbf0e92cca342ccb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0ebeb539d0429f2cbceb0fdb24c2d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9c0ebeb539d0429f2cbceb0fdb24c2d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga9c0ebeb539d0429f2cbceb0fdb24c2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga9c0ebeb539d0429f2cbceb0fdb24c2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7ae63931f33367e3ea01a5cd728c3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1d7ae63931f33367e3ea01a5cd728c3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga1d7ae63931f33367e3ea01a5cd728c3d.html#ga1d7ae63931f33367e3ea01a5cd728c3d">require_not_autodiff_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga1d7ae63931f33367e3ea01a5cd728c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga1d7ae63931f33367e3ea01a5cd728c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931ce2c4a020cdda2a81faed3783ec8e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga931ce2c4a020cdda2a81faed3783ec8e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga931ce2c4a020cdda2a81faed3783ec8e.html#ga931ce2c4a020cdda2a81faed3783ec8e">require_all_autodiff_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga931ce2c4a020cdda2a81faed3783ec8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga931ce2c4a020cdda2a81faed3783ec8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b677072627547a42cf26c004ec18aa1"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga6b677072627547a42cf26c004ec18aa1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga6b677072627547a42cf26c004ec18aa1.html#ga6b677072627547a42cf26c004ec18aa1">require_any_autodiff_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga6b677072627547a42cf26c004ec18aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga6b677072627547a42cf26c004ec18aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1e8523785c39ec00d8d2b3105b6a12"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaee1e8523785c39ec00d8d2b3105b6a12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_gaee1e8523785c39ec00d8d2b3105b6a12.html#gaee1e8523785c39ec00d8d2b3105b6a12">require_all_not_autodiff_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaee1e8523785c39ec00d8d2b3105b6a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:gaee1e8523785c39ec00d8d2b3105b6a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa05dcbc3e9a592ef51685d71b18e470e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaa05dcbc3e9a592ef51685d71b18e470e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_gaa05dcbc3e9a592ef51685d71b18e470e.html#gaa05dcbc3e9a592ef51685d71b18e470e">require_any_not_autodiff_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaa05dcbc3e9a592ef51685d71b18e470e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:gaa05dcbc3e9a592ef51685d71b18e470e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4ce7e2eb4fc700d81bd5f082a1bae9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d4ce7e2eb4fc700d81bd5f082a1bae9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga3d4ce7e2eb4fc700d81bd5f082a1bae9.html#ga3d4ce7e2eb4fc700d81bd5f082a1bae9">require_not_vt_autodiff</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga3d4ce7e2eb4fc700d81bd5f082a1bae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type does not satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga3d4ce7e2eb4fc700d81bd5f082a1bae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93acf9a608eec9a14494f60ffd9f5349"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga93acf9a608eec9a14494f60ffd9f5349"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga93acf9a608eec9a14494f60ffd9f5349.html#ga93acf9a608eec9a14494f60ffd9f5349">require_all_not_vt_autodiff</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga93acf9a608eec9a14494f60ffd9f5349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the value types satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga93acf9a608eec9a14494f60ffd9f5349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga357866e7904bf9ed2b55b4d99c34af1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga357866e7904bf9ed2b55b4d99c34af1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga357866e7904bf9ed2b55b4d99c34af1b.html#ga357866e7904bf9ed2b55b4d99c34af1b">require_st_autodiff</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga357866e7904bf9ed2b55b4d99c34af1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type satisfies <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga357866e7904bf9ed2b55b4d99c34af1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1239707c3883de97b6c74f9c41269da1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1239707c3883de97b6c74f9c41269da1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga1239707c3883de97b6c74f9c41269da1.html#ga1239707c3883de97b6c74f9c41269da1">require_not_st_autodiff</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga1239707c3883de97b6c74f9c41269da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga1239707c3883de97b6c74f9c41269da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6616a05cabec4f81562db410ade4d2a5"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga6616a05cabec4f81562db410ade4d2a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga6616a05cabec4f81562db410ade4d2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the scalar types satisfy <a class="el" href="structstan_1_1is__autodiff.html" title="Checks if decayed type is a var or fvar.">is_autodiff</a>.  <br /></td></tr>
<tr class="separator:ga6616a05cabec4f81562db410ade4d2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1429c7448a296d62bf6b4b037d1a6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9e1429c7448a296d62bf6b4b037d1a6f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_ga9e1429c7448a296d62bf6b4b037d1a6f.html#ga9e1429c7448a296d62bf6b4b037d1a6f">require_complex_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga9e1429c7448a296d62bf6b4b037d1a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:ga9e1429c7448a296d62bf6b4b037d1a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d92736c03356df12307fb596d0fd805"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3d92736c03356df12307fb596d0fd805"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_ga3d92736c03356df12307fb596d0fd805.html#ga3d92736c03356df12307fb596d0fd805">require_not_complex_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga3d92736c03356df12307fb596d0fd805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:ga3d92736c03356df12307fb596d0fd805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d38526ce888d8f8f1e452f16cca2f2c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga3d38526ce888d8f8f1e452f16cca2f2c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_ga3d38526ce888d8f8f1e452f16cca2f2c.html#ga3d38526ce888d8f8f1e452f16cca2f2c">require_all_complex_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga3d38526ce888d8f8f1e452f16cca2f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:ga3d38526ce888d8f8f1e452f16cca2f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf50be6f85054e2e28517fc2deef6f3"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaaaf50be6f85054e2e28517fc2deef6f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_gaaaf50be6f85054e2e28517fc2deef6f3.html#gaaaf50be6f85054e2e28517fc2deef6f3">require_any_complex_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaaaf50be6f85054e2e28517fc2deef6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:gaaaf50be6f85054e2e28517fc2deef6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3024186a248e51f8539efef0985a33"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga7e3024186a248e51f8539efef0985a33"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_ga7e3024186a248e51f8539efef0985a33.html#ga7e3024186a248e51f8539efef0985a33">require_all_not_complex_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga7e3024186a248e51f8539efef0985a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:ga7e3024186a248e51f8539efef0985a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadecb897e57f78882c24b9c94e1b9331"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaadecb897e57f78882c24b9c94e1b9331"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_gaadecb897e57f78882c24b9c94e1b9331.html#gaadecb897e57f78882c24b9c94e1b9331">require_vt_complex</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaadecb897e57f78882c24b9c94e1b9331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type satisfies <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:gaadecb897e57f78882c24b9c94e1b9331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97088f55325ec04904868db4312bf537"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97088f55325ec04904868db4312bf537"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_ga97088f55325ec04904868db4312bf537.html#ga97088f55325ec04904868db4312bf537">require_not_vt_complex</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga97088f55325ec04904868db4312bf537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type does not satisfy <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:ga97088f55325ec04904868db4312bf537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a378cb9e01f1a9b1db92d4a3e3acbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac6a378cb9e01f1a9b1db92d4a3e3acbc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_gac6a378cb9e01f1a9b1db92d4a3e3acbc.html#gac6a378cb9e01f1a9b1db92d4a3e3acbc">require_not_st_complex</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gac6a378cb9e01f1a9b1db92d4a3e3acbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy <a class="el" href="structstan_1_1is__complex.html">is_complex</a>.  <br /></td></tr>
<tr class="separator:gac6a378cb9e01f1a9b1db92d4a3e3acbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c903fceb2dfd2cea898b67c57383a48"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class Check &gt; </td></tr>
<tr class="memitem:ga2c903fceb2dfd2cea898b67c57383a48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__complex__types_ga2c903fceb2dfd2cea898b67c57383a48.html#ga2c903fceb2dfd2cea898b67c57383a48">require_complex_bt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>&lt; Check &gt;, TypeCheck&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; Check &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga2c903fceb2dfd2cea898b67c57383a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga2c903fceb2dfd2cea898b67c57383a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga880b82cbb2b83ccaba2426e73996b8bd.html#ga880b82cbb2b83ccaba2426e73996b8bd">is_constant_all</a> = <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__constant.html">is_constant</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram defining an enum <code>value</code> which is <code>true</code> if all of the type parameters are constant (i.e., primitive types) and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e806f60387beb53da953bd393e8b1cb"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a1e806f60387beb53da953bd393e8b1cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a> = <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; Container &gt;, <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; Container &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:a1e806f60387beb53da953bd393e8b1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces whether type is eigen matrix or standard vector.  <br /></td></tr>
<tr class="separator:a1e806f60387beb53da953bd393e8b1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5dfcc325ecaff91dd97f8a1a8f09431"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac5dfcc325ecaff91dd97f8a1a8f09431"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gac5dfcc325ecaff91dd97f8a1a8f09431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:gac5dfcc325ecaff91dd97f8a1a8f09431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459f89baca338578dee731a64a13cbe0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga459f89baca338578dee731a64a13cbe0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_ga459f89baca338578dee731a64a13cbe0.html#ga459f89baca338578dee731a64a13cbe0">require_not_container_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga459f89baca338578dee731a64a13cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:ga459f89baca338578dee731a64a13cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf1d2303424cf90bfc85868e892dce9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga0cf1d2303424cf90bfc85868e892dce9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_ga0cf1d2303424cf90bfc85868e892dce9.html#ga0cf1d2303424cf90bfc85868e892dce9">require_all_container_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga0cf1d2303424cf90bfc85868e892dce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:ga0cf1d2303424cf90bfc85868e892dce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c7c607453d5d13db814b69546ea415"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga67c7c607453d5d13db814b69546ea415"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga67c7c607453d5d13db814b69546ea415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:ga67c7c607453d5d13db814b69546ea415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0bb8a697162d702a167b7a3918cf09"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gafd0bb8a697162d702a167b7a3918cf09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_gafd0bb8a697162d702a167b7a3918cf09.html#gafd0bb8a697162d702a167b7a3918cf09">require_all_not_container_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gafd0bb8a697162d702a167b7a3918cf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:gafd0bb8a697162d702a167b7a3918cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bc6670ad3273187c8b6fff5c86288ae"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga7bc6670ad3273187c8b6fff5c86288ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_ga7bc6670ad3273187c8b6fff5c86288ae.html#ga7bc6670ad3273187c8b6fff5c86288ae">require_container_st</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga7bc6670ad3273187c8b6fff5c86288ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:ga7bc6670ad3273187c8b6fff5c86288ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga846e5c75f0e49887b255adb8e56e1a7e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga846e5c75f0e49887b255adb8e56e1a7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>, <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga846e5c75f0e49887b255adb8e56e1a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:ga846e5c75f0e49887b255adb8e56e1a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b135bb62a0729e31b4233e370170a53"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga1b135bb62a0729e31b4233e370170a53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_ga1b135bb62a0729e31b4233e370170a53.html#ga1b135bb62a0729e31b4233e370170a53">require_not_container_st</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga1b135bb62a0729e31b4233e370170a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:ga1b135bb62a0729e31b4233e370170a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097f517435706b1230d9d9f60a9b521b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga097f517435706b1230d9d9f60a9b521b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1math_1_1disjunction.html">stan::math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; T &gt; &gt;, <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga097f517435706b1230d9d9f60a9b521b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>.  <br /></td></tr>
<tr class="separator:ga097f517435706b1230d9d9f60a9b521b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ebeeecefb495fe40b1111a2fe68fa0"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a64ebeeecefb495fe40b1111a2fe68fa0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a64ebeeecefb495fe40b1111a2fe68fa0.html#a64ebeeecefb495fe40b1111a2fe68fa0">is_container_or_var_matrix</a> = <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>&lt; Container &gt;, <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>&lt; Container &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:a64ebeeecefb495fe40b1111a2fe68fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces whether type is eigen matrix, standard vector, or var&lt;Matrix&gt;.  <br /></td></tr>
<tr class="separator:a64ebeeecefb495fe40b1111a2fe68fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad118aaa390bacd754a1a06c9518739ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad118aaa390bacd754a1a06c9518739ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gad118aaa390bacd754a1a06c9518739ce.html#gad118aaa390bacd754a1a06c9518739ce">is_dense_dynamic</a> = <a class="el" href="structstan_1_1internal_1_1is__dense__dynamic__impl.html">internal::is_dense_dynamic_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gad118aaa390bacd754a1a06c9518739ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns or is a <code>var_value&lt;&gt;</code> whose inner type satisfies the conditions above.  <br /></td></tr>
<tr class="separator:gad118aaa390bacd754a1a06c9518739ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc6ef15ef129c59966a6861f428b17ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacc6ef15ef129c59966a6861f428b17ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dense__dynamic__types_gacc6ef15ef129c59966a6861f428b17ea.html#gacc6ef15ef129c59966a6861f428b17ea">require_dense_dynamic_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="group__type__trait_gad118aaa390bacd754a1a06c9518739ce.html#gad118aaa390bacd754a1a06c9518739ce">is_dense_dynamic</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gacc6ef15ef129c59966a6861f428b17ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="group__type__trait_gad118aaa390bacd754a1a06c9518739ce.html#gad118aaa390bacd754a1a06c9518739ce">is_dense_dynamic</a>.  <br /></td></tr>
<tr class="separator:gacc6ef15ef129c59966a6861f428b17ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15092c074bb2f943af795ea65c01bc09"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga15092c074bb2f943af795ea65c01bc09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dense__dynamic__types_ga15092c074bb2f943af795ea65c01bc09.html#ga15092c074bb2f943af795ea65c01bc09">require_all_dense_dynamic_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="group__type__trait_gad118aaa390bacd754a1a06c9518739ce.html#gad118aaa390bacd754a1a06c9518739ce">is_dense_dynamic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga15092c074bb2f943af795ea65c01bc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="group__type__trait_gad118aaa390bacd754a1a06c9518739ce.html#gad118aaa390bacd754a1a06c9518739ce">is_dense_dynamic</a>.  <br /></td></tr>
<tr class="separator:ga15092c074bb2f943af795ea65c01bc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6fe36a907f2d44df999ac7995c2ca9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8f6fe36a907f2d44df999ac7995c2ca9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__double__or__int__types_ga8f6fe36a907f2d44df999ac7995c2ca9.html#ga8f6fe36a907f2d44df999ac7995c2ca9">require_double_or_int_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga8f6fe36a907f2d44df999ac7995c2ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>.  <br /></td></tr>
<tr class="separator:ga8f6fe36a907f2d44df999ac7995c2ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaada450161b8a363c99c1e1da0ec2f24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaada450161b8a363c99c1e1da0ec2f24"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__double__or__int__types_gaaada450161b8a363c99c1e1da0ec2f24.html#gaaada450161b8a363c99c1e1da0ec2f24">require_not_double_or_int_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaaada450161b8a363c99c1e1da0ec2f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>.  <br /></td></tr>
<tr class="separator:gaaada450161b8a363c99c1e1da0ec2f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae418e50f546e45d37e444c2c494b242e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gae418e50f546e45d37e444c2c494b242e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__double__or__int__types_gae418e50f546e45d37e444c2c494b242e.html#gae418e50f546e45d37e444c2c494b242e">require_all_double_or_int_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gae418e50f546e45d37e444c2c494b242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>.  <br /></td></tr>
<tr class="separator:gae418e50f546e45d37e444c2c494b242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59a8b1092c15d5bb0fa7ae256fd4a44"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gad59a8b1092c15d5bb0fa7ae256fd4a44"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__double__or__int__types_gad59a8b1092c15d5bb0fa7ae256fd4a44.html#gad59a8b1092c15d5bb0fa7ae256fd4a44">require_any_double_or_int_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad59a8b1092c15d5bb0fa7ae256fd4a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>.  <br /></td></tr>
<tr class="separator:gad59a8b1092c15d5bb0fa7ae256fd4a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a0da8b8068c3c394d0e05534179ce9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga48a0da8b8068c3c394d0e05534179ce9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__double__or__int__types_ga48a0da8b8068c3c394d0e05534179ce9.html#ga48a0da8b8068c3c394d0e05534179ce9">require_all_not_double_or_int_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga48a0da8b8068c3c394d0e05534179ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>.  <br /></td></tr>
<tr class="separator:ga48a0da8b8068c3c394d0e05534179ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f0833e31cac60485bc17cb70bfe191"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga10f0833e31cac60485bc17cb70bfe191"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__double__or__int__types_ga10f0833e31cac60485bc17cb70bfe191.html#ga10f0833e31cac60485bc17cb70bfe191">require_any_not_double_or_int_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga10f0833e31cac60485bc17cb70bfe191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__double__or__int.html">is_double_or_int</a>.  <br /></td></tr>
<tr class="separator:ga10f0833e31cac60485bc17cb70bfe191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d00afce3fb9f594503231c52b2db40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga58d00afce3fb9f594503231c52b2db40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga58d00afce3fb9f594503231c52b2db40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga58d00afce3fb9f594503231c52b2db40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4f9e63ae91ddc6d41c9570149edab2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabf4f9e63ae91ddc6d41c9570149edab2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_gabf4f9e63ae91ddc6d41c9570149edab2.html#gabf4f9e63ae91ddc6d41c9570149edab2">require_not_eigen_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gabf4f9e63ae91ddc6d41c9570149edab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:gabf4f9e63ae91ddc6d41c9570149edab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ddfa0f3f9bf9e64ce2cbe4082b31a8"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga53ddfa0f3f9bf9e64ce2cbe4082b31a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga53ddfa0f3f9bf9e64ce2cbe4082b31a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga53ddfa0f3f9bf9e64ce2cbe4082b31a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga251d4f37bdda3638307d8d2b2abfe76e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga251d4f37bdda3638307d8d2b2abfe76e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga251d4f37bdda3638307d8d2b2abfe76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga251d4f37bdda3638307d8d2b2abfe76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833fd8fa0379ab702da58d15e0fb3df9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga833fd8fa0379ab702da58d15e0fb3df9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga833fd8fa0379ab702da58d15e0fb3df9.html#ga833fd8fa0379ab702da58d15e0fb3df9">require_all_not_eigen_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga833fd8fa0379ab702da58d15e0fb3df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga833fd8fa0379ab702da58d15e0fb3df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae769f755e76ef11b4c41f82675b77ae1"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gae769f755e76ef11b4c41f82675b77ae1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_gae769f755e76ef11b4c41f82675b77ae1.html#gae769f755e76ef11b4c41f82675b77ae1">require_any_not_eigen_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gae769f755e76ef11b4c41f82675b77ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:gae769f755e76ef11b4c41f82675b77ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45feac0cfd40358ee2842a7f5cce57ea"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga45feac0cfd40358ee2842a7f5cce57ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga45feac0cfd40358ee2842a7f5cce57ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga45feac0cfd40358ee2842a7f5cce57ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93918b2590606552cac973a4397ab38a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga93918b2590606552cac973a4397ab38a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga93918b2590606552cac973a4397ab38a.html#ga93918b2590606552cac973a4397ab38a">require_not_eigen_vt</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga93918b2590606552cac973a4397ab38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a> or.  <br /></td></tr>
<tr class="separator:ga93918b2590606552cac973a4397ab38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64cf4d09f74bffc664e44cfdc368ffc"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gae64cf4d09f74bffc664e44cfdc368ffc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_gae64cf4d09f74bffc664e44cfdc368ffc.html#gae64cf4d09f74bffc664e44cfdc368ffc">require_any_eigen_vt</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gae64cf4d09f74bffc664e44cfdc368ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:gae64cf4d09f74bffc664e44cfdc368ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf62838f3a4f94164369e03105d45b587"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gaf62838f3a4f94164369e03105d45b587"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_gaf62838f3a4f94164369e03105d45b587.html#gaf62838f3a4f94164369e03105d45b587">require_any_not_eigen_vt</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gaf62838f3a4f94164369e03105d45b587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:gaf62838f3a4f94164369e03105d45b587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fcddbaf041c31d2c20c8b006ebba79"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga06fcddbaf041c31d2c20c8b006ebba79"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga06fcddbaf041c31d2c20c8b006ebba79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga06fcddbaf041c31d2c20c8b006ebba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30da5b4d9bf217de273208379b7b92e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gac30da5b4d9bf217de273208379b7b92e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_gac30da5b4d9bf217de273208379b7b92e.html#gac30da5b4d9bf217de273208379b7b92e">require_all_not_eigen_vt</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gac30da5b4d9bf217de273208379b7b92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:gac30da5b4d9bf217de273208379b7b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f433bbb5e3f53af4ef6dc9bc84b7af"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga51f433bbb5e3f53af4ef6dc9bc84b7af"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga51f433bbb5e3f53af4ef6dc9bc84b7af.html#ga51f433bbb5e3f53af4ef6dc9bc84b7af">require_eigen_st</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga51f433bbb5e3f53af4ef6dc9bc84b7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga51f433bbb5e3f53af4ef6dc9bc84b7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4081f38bdc92d5ed05764bb62a7cda"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gabb4081f38bdc92d5ed05764bb62a7cda"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_gabb4081f38bdc92d5ed05764bb62a7cda.html#gabb4081f38bdc92d5ed05764bb62a7cda">require_not_eigen_st</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:gabb4081f38bdc92d5ed05764bb62a7cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:gabb4081f38bdc92d5ed05764bb62a7cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e812ad5ec49fdf5c586d791df1d788a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga8e812ad5ec49fdf5c586d791df1d788a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga8e812ad5ec49fdf5c586d791df1d788a.html#ga8e812ad5ec49fdf5c586d791df1d788a">require_any_eigen_st</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga8e812ad5ec49fdf5c586d791df1d788a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga8e812ad5ec49fdf5c586d791df1d788a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331d9d1cc27822820f27c55a579d1097"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga331d9d1cc27822820f27c55a579d1097"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga331d9d1cc27822820f27c55a579d1097.html#ga331d9d1cc27822820f27c55a579d1097">require_any_not_eigen_st</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga331d9d1cc27822820f27c55a579d1097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga331d9d1cc27822820f27c55a579d1097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacdb91c9b32a7c57333c45d2c97de495"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gaacdb91c9b32a7c57333c45d2c97de495"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_gaacdb91c9b32a7c57333c45d2c97de495.html#gaacdb91c9b32a7c57333c45d2c97de495">require_all_eigen_st</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gaacdb91c9b32a7c57333c45d2c97de495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types does not satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:gaacdb91c9b32a7c57333c45d2c97de495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d11723d6227d8bd46bd9d0c9a954f03"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga6d11723d6227d8bd46bd9d0c9a954f03"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__types_ga6d11723d6227d8bd46bd9d0c9a954f03.html#ga6d11723d6227d8bd46bd9d0c9a954f03">require_all_not_eigen_st</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga6d11723d6227d8bd46bd9d0c9a954f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>.  <br /></td></tr>
<tr class="separator:ga6d11723d6227d8bd46bd9d0c9a954f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7415d03224d3d9b31287a36797e12fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab7415d03224d3d9b31287a36797e12fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__array__types_gab7415d03224d3d9b31287a36797e12fa.html#gab7415d03224d3d9b31287a36797e12fa">require_eigen_array_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab7415d03224d3d9b31287a36797e12fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>.  <br /></td></tr>
<tr class="separator:gab7415d03224d3d9b31287a36797e12fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1b91fc653c360446d9636e416bf259"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gade1b91fc653c360446d9636e416bf259"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__array__types_gade1b91fc653c360446d9636e416bf259.html#gade1b91fc653c360446d9636e416bf259">require_not_eigen_array_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gade1b91fc653c360446d9636e416bf259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>.  <br /></td></tr>
<tr class="separator:gade1b91fc653c360446d9636e416bf259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ff87cbf37ee2edf8d0bad2f9313f98"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga46ff87cbf37ee2edf8d0bad2f9313f98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__array__types_ga46ff87cbf37ee2edf8d0bad2f9313f98.html#ga46ff87cbf37ee2edf8d0bad2f9313f98">require_any_eigen_array_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga46ff87cbf37ee2edf8d0bad2f9313f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>.  <br /></td></tr>
<tr class="separator:ga46ff87cbf37ee2edf8d0bad2f9313f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga3e24dfe00dd09775b290fc2221b2739d.html#ga3e24dfe00dd09775b290fc2221b2739d">is_eigen_matrix_or_array</a> = <a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga3e24dfe00dd09775b290fc2221b2739d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is derived from <code>Eigen::MatrixBase</code> or <code>Eigen::ArrayBase</code>  <br /></td></tr>
<tr class="separator:ga3e24dfe00dd09775b290fc2221b2739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6db561292e912aa93487ec77aa1daf57"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga6db561292e912aa93487ec77aa1daf57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__array__types_ga6db561292e912aa93487ec77aa1daf57.html#ga6db561292e912aa93487ec77aa1daf57">require_eigen_array_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga6db561292e912aa93487ec77aa1daf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__array.html">is_eigen_array</a>.  <br /></td></tr>
<tr class="separator:ga6db561292e912aa93487ec77aa1daf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832fc80ea0f3c9c728c1fefd681be76d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga832fc80ea0f3c9c728c1fefd681be76d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__dense__base__types_ga832fc80ea0f3c9c728c1fefd681be76d.html#ga832fc80ea0f3c9c728c1fefd681be76d">require_eigen_dense_base_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__dense__base.html">is_eigen_dense_base</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga832fc80ea0f3c9c728c1fefd681be76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__dense__base.html">is_eigen_dense_base</a>.  <br /></td></tr>
<tr class="separator:ga832fc80ea0f3c9c728c1fefd681be76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c34d1cf87ed443d70cab727ea3da73"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga79c34d1cf87ed443d70cab727ea3da73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__dense__base__types_ga79c34d1cf87ed443d70cab727ea3da73.html#ga79c34d1cf87ed443d70cab727ea3da73">require_eigen_dense_base_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__dense__base.html">is_eigen_dense_base</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga79c34d1cf87ed443d70cab727ea3da73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__dense__base.html">is_eigen_dense_base</a>.  <br /></td></tr>
<tr class="separator:ga79c34d1cf87ed443d70cab727ea3da73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f64859b99515465810d1dbf2885a8e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9f64859b99515465810d1dbf2885a8e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">is_eigen_dense_dynamic</a> = <a class="el" href="structstan_1_1internal_1_1is__eigen__matrix__dynamic__impl.html">stan::internal::is_eigen_matrix_dynamic_impl</a>&lt; std::decay_t&lt; T &gt;, <a class="el" href="structstan_1_1is__eigen__dense__base.html">stan::is_eigen_dense_base</a>&lt; std::decay_t&lt; T &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga9f64859b99515465810d1dbf2885a8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether type T is derived from Eigen::DenseBase and has dynamic rows and columns.  <br /></td></tr>
<tr class="separator:ga9f64859b99515465810d1dbf2885a8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9ea2ce30eb6b679b63ac5630027d95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b9ea2ce30eb6b679b63ac5630027d95"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__dense__dynamic__types_ga7b9ea2ce30eb6b679b63ac5630027d95.html#ga7b9ea2ce30eb6b679b63ac5630027d95">require_eigen_dense_dynamic_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">is_eigen_dense_dynamic</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7b9ea2ce30eb6b679b63ac5630027d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">is_eigen_dense_dynamic</a>.  <br /></td></tr>
<tr class="separator:ga7b9ea2ce30eb6b679b63ac5630027d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc7066843610131f9c7519c66e0b3da"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga1fc7066843610131f9c7519c66e0b3da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__dense__dynamic__types_ga1fc7066843610131f9c7519c66e0b3da.html#ga1fc7066843610131f9c7519c66e0b3da">require_all_eigen_dense_dynamic_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">is_eigen_dense_dynamic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga1fc7066843610131f9c7519c66e0b3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">is_eigen_dense_dynamic</a>.  <br /></td></tr>
<tr class="separator:ga1fc7066843610131f9c7519c66e0b3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36cbcf4b98f8305631d3ddc70ffc8565"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga36cbcf4b98f8305631d3ddc70ffc8565"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__dense__dynamic__types_ga36cbcf4b98f8305631d3ddc70ffc8565.html#ga36cbcf4b98f8305631d3ddc70ffc8565">require_eigen_dense_dynamic_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">is_eigen_dense_dynamic</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga36cbcf4b98f8305631d3ddc70ffc8565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="group__type__trait_ga9f64859b99515465810d1dbf2885a8e7.html#ga9f64859b99515465810d1dbf2885a8e7">is_eigen_dense_dynamic</a>.  <br /></td></tr>
<tr class="separator:ga36cbcf4b98f8305631d3ddc70ffc8565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcfd29c39378e841a8abdc54a8277c01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabcfd29c39378e841a8abdc54a8277c01"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gabcfd29c39378e841a8abdc54a8277c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>.  <br /></td></tr>
<tr class="separator:gabcfd29c39378e841a8abdc54a8277c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec9030ce72bf1905d7df48b204222f6"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga8ec9030ce72bf1905d7df48b204222f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__matrix__dynamic__types_ga8ec9030ce72bf1905d7df48b204222f6.html#ga8ec9030ce72bf1905d7df48b204222f6">require_all_eigen_matrix_dynamic_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga8ec9030ce72bf1905d7df48b204222f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>.  <br /></td></tr>
<tr class="separator:ga8ec9030ce72bf1905d7df48b204222f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499aa52e1233ffe0149363e86eee179d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga499aa52e1233ffe0149363e86eee179d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__matrix__dynamic__types_ga499aa52e1233ffe0149363e86eee179d.html#ga499aa52e1233ffe0149363e86eee179d">require_any_eigen_matrix_dynamic_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga499aa52e1233ffe0149363e86eee179d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>.  <br /></td></tr>
<tr class="separator:ga499aa52e1233ffe0149363e86eee179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae725537ef0b9f4ef9857fa1b28bd1076"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gae725537ef0b9f4ef9857fa1b28bd1076"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__matrix__dynamic__types_gae725537ef0b9f4ef9857fa1b28bd1076.html#gae725537ef0b9f4ef9857fa1b28bd1076">require_eigen_matrix_dynamic_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:gae725537ef0b9f4ef9857fa1b28bd1076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__matrix__dynamic.html">is_eigen_matrix_dynamic</a>.  <br /></td></tr>
<tr class="separator:gae725537ef0b9f4ef9857fa1b28bd1076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e88e238adbdeb15d2dd2418edac888"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga29e88e238adbdeb15d2dd2418edac888"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__matrix__base__types_ga29e88e238adbdeb15d2dd2418edac888.html#ga29e88e238adbdeb15d2dd2418edac888">require_eigen_matrix_base_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga29e88e238adbdeb15d2dd2418edac888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>.  <br /></td></tr>
<tr class="separator:ga29e88e238adbdeb15d2dd2418edac888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a5a34d38ab300e936c2ec66794bcca"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga98a5a34d38ab300e936c2ec66794bcca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__matrix__base__types_ga98a5a34d38ab300e936c2ec66794bcca.html#ga98a5a34d38ab300e936c2ec66794bcca">require_eigen_matrix_base_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga98a5a34d38ab300e936c2ec66794bcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>.  <br /></td></tr>
<tr class="separator:ga98a5a34d38ab300e936c2ec66794bcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b37f9344722276cf99c50d0afc4ff03"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga9b37f9344722276cf99c50d0afc4ff03"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__matrix__base__types_ga9b37f9344722276cf99c50d0afc4ff03.html#ga9b37f9344722276cf99c50d0afc4ff03">require_all_eigen_matrix_base_vt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__matrix__base.html">is_eigen_matrix_base</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga9b37f9344722276cf99c50d0afc4ff03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__eigen__matrix__base.html" title="Checks whether type T is derived from Eigen::MatrixBase.">is_eigen_matrix_base</a>.  <br /></td></tr>
<tr class="separator:ga9b37f9344722276cf99c50d0afc4ff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007f362a9a4d897bcbd2e4c948a0bf6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga007f362a9a4d897bcbd2e4c948a0bf6d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__sparse__base__types_ga007f362a9a4d897bcbd2e4c948a0bf6d.html#ga007f362a9a4d897bcbd2e4c948a0bf6d">require_eigen_sparse_base_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__sparse__base.html">is_eigen_sparse_base</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga007f362a9a4d897bcbd2e4c948a0bf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__sparse__base.html">is_eigen_sparse_base</a>.  <br /></td></tr>
<tr class="separator:ga007f362a9a4d897bcbd2e4c948a0bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36397aaabf5accbfc5a0909ce0e3290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab36397aaabf5accbfc5a0909ce0e3290"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_gab36397aaabf5accbfc5a0909ce0e3290.html#gab36397aaabf5accbfc5a0909ce0e3290">require_fvar_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab36397aaabf5accbfc5a0909ce0e3290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:gab36397aaabf5accbfc5a0909ce0e3290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ca446563403081ee19f97627328108"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa4ca446563403081ee19f97627328108"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_gaa4ca446563403081ee19f97627328108.html#gaa4ca446563403081ee19f97627328108">require_not_fvar_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaa4ca446563403081ee19f97627328108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:gaa4ca446563403081ee19f97627328108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb76e02d812dfa1a87195a940175e5e9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gabb76e02d812dfa1a87195a940175e5e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_gabb76e02d812dfa1a87195a940175e5e9.html#gabb76e02d812dfa1a87195a940175e5e9">require_all_fvar_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gabb76e02d812dfa1a87195a940175e5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:gabb76e02d812dfa1a87195a940175e5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acbafcf4967524342a974e6afed202a"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga0acbafcf4967524342a974e6afed202a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_ga0acbafcf4967524342a974e6afed202a.html#ga0acbafcf4967524342a974e6afed202a">require_any_fvar_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga0acbafcf4967524342a974e6afed202a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:ga0acbafcf4967524342a974e6afed202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9f8cb26dfa852cbb053b65e03ba2a0"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaab9f8cb26dfa852cbb053b65e03ba2a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_gaab9f8cb26dfa852cbb053b65e03ba2a0.html#gaab9f8cb26dfa852cbb053b65e03ba2a0">require_all_not_fvar_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaab9f8cb26dfa852cbb053b65e03ba2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:gaab9f8cb26dfa852cbb053b65e03ba2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac883b91b2f0d04c60d1f2c452b612faa"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gac883b91b2f0d04c60d1f2c452b612faa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_gac883b91b2f0d04c60d1f2c452b612faa.html#gac883b91b2f0d04c60d1f2c452b612faa">require_any_not_fvar_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gac883b91b2f0d04c60d1f2c452b612faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:gac883b91b2f0d04c60d1f2c452b612faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bbeba0604a99a81b25f2f6249be82c1"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga0bbeba0604a99a81b25f2f6249be82c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_ga0bbeba0604a99a81b25f2f6249be82c1.html#ga0bbeba0604a99a81b25f2f6249be82c1">require_any_vt_fvar</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga0bbeba0604a99a81b25f2f6249be82c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the value types satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:ga0bbeba0604a99a81b25f2f6249be82c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af52367fd6b72c88688720fcc50d6c7"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga2af52367fd6b72c88688720fcc50d6c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_ga2af52367fd6b72c88688720fcc50d6c7.html#ga2af52367fd6b72c88688720fcc50d6c7">require_all_not_vt_fvar</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga2af52367fd6b72c88688720fcc50d6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the value types satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:ga2af52367fd6b72c88688720fcc50d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6b88f6073a3279466855e1c59032dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4c6b88f6073a3279466855e1c59032dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_ga4c6b88f6073a3279466855e1c59032dd.html#ga4c6b88f6073a3279466855e1c59032dd">require_st_fvar</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga4c6b88f6073a3279466855e1c59032dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type satisfies <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:ga4c6b88f6073a3279466855e1c59032dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f10d6a4639f17f8c8fd7b47d9c098d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6f10d6a4639f17f8c8fd7b47d9c098d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_ga6f10d6a4639f17f8c8fd7b47d9c098d8.html#ga6f10d6a4639f17f8c8fd7b47d9c098d8">require_not_st_fvar</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga6f10d6a4639f17f8c8fd7b47d9c098d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:ga6f10d6a4639f17f8c8fd7b47d9c098d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45226eaefc79330cad798db7c5a3a62d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga45226eaefc79330cad798db7c5a3a62d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_ga45226eaefc79330cad798db7c5a3a62d.html#ga45226eaefc79330cad798db7c5a3a62d">require_any_st_fvar</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga45226eaefc79330cad798db7c5a3a62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the scalar types satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:ga45226eaefc79330cad798db7c5a3a62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dee1b38ad7fddd862fd650d513a6a04"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga2dee1b38ad7fddd862fd650d513a6a04"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fvar__types_ga2dee1b38ad7fddd862fd650d513a6a04.html#ga2dee1b38ad7fddd862fd650d513a6a04">require_all_not_st_fvar</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga2dee1b38ad7fddd862fd650d513a6a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the scalar types satisfy <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>.  <br /></td></tr>
<tr class="separator:ga2dee1b38ad7fddd862fd650d513a6a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecc749b7850d3620ecb9f94cf94fd8a2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaecc749b7850d3620ecb9f94cf94fd8a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__kernel__expression__and__not__scalar.html">is_kernel_expression_and_not_scalar</a>&lt; Types &gt;... &gt;</td></tr>
<tr class="memdesc:gaecc749b7850d3620ecb9f94cf94fd8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a template if all given types are non-scalar types that are a valid kernel generator expressions.  <br /></td></tr>
<tr class="separator:gaecc749b7850d3620ecb9f94cf94fd8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca27ada59d198e78c07d1c6dcd79e835"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaca27ada59d198e78c07d1c6dcd79e835"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__kernel__expression.html">is_kernel_expression</a>&lt; Types &gt;... &gt;</td></tr>
<tr class="memdesc:gaca27ada59d198e78c07d1c6dcd79e835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a template if all given types are are a valid kernel generator expressions.  <br /></td></tr>
<tr class="separator:gaca27ada59d198e78c07d1c6dcd79e835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c44716e311a75053a72c4e3d53bd46e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1c44716e311a75053a72c4e3d53bd46e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__kernel__expression__lhs__types_ga1c44716e311a75053a72c4e3d53bd46e.html#ga1c44716e311a75053a72c4e3d53bd46e">require_kernel_expression_lhs_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__kernel__expression__lhs.html">is_kernel_expression_lhs</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga1c44716e311a75053a72c4e3d53bd46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__kernel__expression__lhs.html">is_kernel_expression_lhs</a>.  <br /></td></tr>
<tr class="separator:ga1c44716e311a75053a72c4e3d53bd46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga342349b94220ace8566a8192f00a7c2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga342349b94220ace8566a8192f00a7c2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__kernel__expression__types_ga342349b94220ace8566a8192f00a7c2a.html#ga342349b94220ace8566a8192f00a7c2a">require_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__rev__kernel__expression.html">is_rev_kernel_expression</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga342349b94220ace8566a8192f00a7c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__rev__kernel__expression.html">is_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:ga342349b94220ace8566a8192f00a7c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dbd83c66335a907683810caa2f9ab9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4dbd83c66335a907683810caa2f9ab9e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__kernel__expression__types_ga4dbd83c66335a907683810caa2f9ab9e.html#ga4dbd83c66335a907683810caa2f9ab9e">require_not_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__rev__kernel__expression.html">is_rev_kernel_expression</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga4dbd83c66335a907683810caa2f9ab9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__rev__kernel__expression.html">is_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:ga4dbd83c66335a907683810caa2f9ab9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ddfa21efd7d1722ff0e7333c51f209"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga03ddfa21efd7d1722ff0e7333c51f209"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__prim__or__rev__kernel__expression.html">is_prim_or_rev_kernel_expression</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga03ddfa21efd7d1722ff0e7333c51f209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__prim__or__rev__kernel__expression.html">is_prim_or_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:ga03ddfa21efd7d1722ff0e7333c51f209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7effde0ee735fbb4b95bacac8bea2c78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7effde0ee735fbb4b95bacac8bea2c78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7effde0ee735fbb4b95bacac8bea2c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:ga7effde0ee735fbb4b95bacac8bea2c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55c0f71f335505ceeac88af143771e88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga55c0f71f335505ceeac88af143771e88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga55c0f71f335505ceeac88af143771e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:ga55c0f71f335505ceeac88af143771e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca58d90e4acb3d445bdf708cbd6daec2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaca58d90e4acb3d445bdf708cbd6daec2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaca58d90e4acb3d445bdf708cbd6daec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:gaca58d90e4acb3d445bdf708cbd6daec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e58259e90935ab5ef20d2a5835104df"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga1e58259e90935ab5ef20d2a5835104df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga1e58259e90935ab5ef20d2a5835104df.html#ga1e58259e90935ab5ef20d2a5835104df">require_any_nonscalar_prim_or_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga1e58259e90935ab5ef20d2a5835104df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:ga1e58259e90935ab5ef20d2a5835104df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7958557ed570a1f54df851d41b610eff"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga7958557ed570a1f54df851d41b610eff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga7958557ed570a1f54df851d41b610eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__nonscalar__prim__or__rev__kernel__expression.html">is_nonscalar_prim_or_rev_kernel_expression</a>.  <br /></td></tr>
<tr class="separator:ga7958557ed570a1f54df851d41b610eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32daaff2841306298c81dc15071b7693"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga32daaff2841306298c81dc15071b7693"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga32daaff2841306298c81dc15071b7693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:ga32daaff2841306298c81dc15071b7693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8b7e7f43a20a6e3ca35cae5b956cbd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a8b7e7f43a20a6e3ca35cae5b956cbd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_ga3a8b7e7f43a20a6e3ca35cae5b956cbd.html#ga3a8b7e7f43a20a6e3ca35cae5b956cbd">require_not_matrix_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga3a8b7e7f43a20a6e3ca35cae5b956cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:ga3a8b7e7f43a20a6e3ca35cae5b956cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf571cd97ea582011192429cf63696f97"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaf571cd97ea582011192429cf63696f97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaf571cd97ea582011192429cf63696f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:gaf571cd97ea582011192429cf63696f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1922331b5c670c8a19b234064e174cf9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga1922331b5c670c8a19b234064e174cf9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_ga1922331b5c670c8a19b234064e174cf9.html#ga1922331b5c670c8a19b234064e174cf9">require_any_matrix_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga1922331b5c670c8a19b234064e174cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:ga1922331b5c670c8a19b234064e174cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74341babe2d2bbac91a7205c6d0b142"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gad74341babe2d2bbac91a7205c6d0b142"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_gad74341babe2d2bbac91a7205c6d0b142.html#gad74341babe2d2bbac91a7205c6d0b142">require_all_not_matrix_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad74341babe2d2bbac91a7205c6d0b142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:gad74341babe2d2bbac91a7205c6d0b142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c16a1cddf15a4e247b27efdf8fe3d3"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga70c16a1cddf15a4e247b27efdf8fe3d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_ga70c16a1cddf15a4e247b27efdf8fe3d3.html#ga70c16a1cddf15a4e247b27efdf8fe3d3">require_any_matrix_st</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga70c16a1cddf15a4e247b27efdf8fe3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:ga70c16a1cddf15a4e247b27efdf8fe3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb3c2790817a1e89e13bdbf460bce37b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gabb3c2790817a1e89e13bdbf460bce37b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_gabb3c2790817a1e89e13bdbf460bce37b.html#gabb3c2790817a1e89e13bdbf460bce37b">require_all_matrix_st</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gabb3c2790817a1e89e13bdbf460bce37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types does not satisfy <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:gabb3c2790817a1e89e13bdbf460bce37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5983b53cc2875bec421ecdbd43d336b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gad5983b53cc2875bec421ecdbd43d336b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__types_gad5983b53cc2875bec421ecdbd43d336b.html#gad5983b53cc2875bec421ecdbd43d336b">require_all_not_matrix_st</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gad5983b53cc2875bec421ecdbd43d336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>.  <br /></td></tr>
<tr class="separator:gad5983b53cc2875bec421ecdbd43d336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf18202a28f3c86c16368f08c04f6532d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf18202a28f3c86c16368f08c04f6532d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaf18202a28f3c86c16368f08c04f6532d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:gaf18202a28f3c86c16368f08c04f6532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af53d2ea2874ab39e60e796c8f2c074"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1af53d2ea2874ab39e60e796c8f2c074"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_ga1af53d2ea2874ab39e60e796c8f2c074.html#ga1af53d2ea2874ab39e60e796c8f2c074">require_not_matrix_cl_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga1af53d2ea2874ab39e60e796c8f2c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:ga1af53d2ea2874ab39e60e796c8f2c074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794af1511d51a7fed4349bb5d6ef2844"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga794af1511d51a7fed4349bb5d6ef2844"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_ga794af1511d51a7fed4349bb5d6ef2844.html#ga794af1511d51a7fed4349bb5d6ef2844">require_all_matrix_cl_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga794af1511d51a7fed4349bb5d6ef2844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:ga794af1511d51a7fed4349bb5d6ef2844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d106b6982ce7feee38e12dd3f05940d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga7d106b6982ce7feee38e12dd3f05940d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_ga7d106b6982ce7feee38e12dd3f05940d.html#ga7d106b6982ce7feee38e12dd3f05940d">require_any_matrix_cl_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga7d106b6982ce7feee38e12dd3f05940d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:ga7d106b6982ce7feee38e12dd3f05940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc65db98334ee4508c7b9769dc6184ab"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gafc65db98334ee4508c7b9769dc6184ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_gafc65db98334ee4508c7b9769dc6184ab.html#gafc65db98334ee4508c7b9769dc6184ab">require_all_not_matrix_cl_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gafc65db98334ee4508c7b9769dc6184ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:gafc65db98334ee4508c7b9769dc6184ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4802e6e684e41876f70e386cf043c7c3"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga4802e6e684e41876f70e386cf043c7c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_ga4802e6e684e41876f70e386cf043c7c3.html#ga4802e6e684e41876f70e386cf043c7c3">require_any_not_matrix_cl_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga4802e6e684e41876f70e386cf043c7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:ga4802e6e684e41876f70e386cf043c7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256ad962975a8c674eec514f14fe6231"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga256ad962975a8c674eec514f14fe6231"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_ga256ad962975a8c674eec514f14fe6231.html#ga256ad962975a8c674eec514f14fe6231">require_matrix_cl_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga256ad962975a8c674eec514f14fe6231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:ga256ad962975a8c674eec514f14fe6231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c274c8caeeb10500c594d72f60c397"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gaa1c274c8caeeb10500c594d72f60c397"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_gaa1c274c8caeeb10500c594d72f60c397.html#gaa1c274c8caeeb10500c594d72f60c397">require_not_matrix_cl_vt</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:gaa1c274c8caeeb10500c594d72f60c397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a> or.  <br /></td></tr>
<tr class="separator:gaa1c274c8caeeb10500c594d72f60c397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306bc314da32027cdfdbd4e752896c00"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga306bc314da32027cdfdbd4e752896c00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_ga306bc314da32027cdfdbd4e752896c00.html#ga306bc314da32027cdfdbd4e752896c00">require_any_matrix_cl_vt</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga306bc314da32027cdfdbd4e752896c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:ga306bc314da32027cdfdbd4e752896c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c74c066e9bc04bb71e0d68f83d734f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga34c74c066e9bc04bb71e0d68f83d734f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_ga34c74c066e9bc04bb71e0d68f83d734f.html#ga34c74c066e9bc04bb71e0d68f83d734f">require_any_not_matrix_cl_vt</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga34c74c066e9bc04bb71e0d68f83d734f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:ga34c74c066e9bc04bb71e0d68f83d734f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1a31c9867caeda1b9f1927727c0ec9"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gaca1a31c9867caeda1b9f1927727c0ec9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_gaca1a31c9867caeda1b9f1927727c0ec9.html#gaca1a31c9867caeda1b9f1927727c0ec9">require_all_matrix_cl_vt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gaca1a31c9867caeda1b9f1927727c0ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:gaca1a31c9867caeda1b9f1927727c0ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6210ba90e9d4e451bff653abba7c23"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gacd6210ba90e9d4e451bff653abba7c23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_gacd6210ba90e9d4e451bff653abba7c23.html#gacd6210ba90e9d4e451bff653abba7c23">require_all_not_matrix_cl_vt</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gacd6210ba90e9d4e451bff653abba7c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:gacd6210ba90e9d4e451bff653abba7c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace64828b1d0e81550a510d7ce11155e4"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gace64828b1d0e81550a510d7ce11155e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrix__cl__types_gace64828b1d0e81550a510d7ce11155e4.html#gace64828b1d0e81550a510d7ce11155e4">require_matrix_cl_st</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:gace64828b1d0e81550a510d7ce11155e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>.  <br /></td></tr>
<tr class="separator:gace64828b1d0e81550a510d7ce11155e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a> = std::is_same&lt; std::decay_t&lt; S &gt;, <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; S &gt; &gt;</td></tr>
<tr class="memdesc:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the template type <code>T</code> is an assignable type.  <br /></td></tr>
<tr class="separator:ga17bf5c3cd4cc2794e47ea0e0609bbf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd996783c61ffc8c2bd222af67fea0c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafd996783c61ffc8c2bd222af67fea0c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__plain__type__types_gafd996783c61ffc8c2bd222af67fea0c0.html#gafd996783c61ffc8c2bd222af67fea0c0">require_plain_type_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gafd996783c61ffc8c2bd222af67fea0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>.  <br /></td></tr>
<tr class="separator:gafd996783c61ffc8c2bd222af67fea0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137082975fcf6b148ee009741564d4fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga137082975fcf6b148ee009741564d4fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__plain__type__types_ga137082975fcf6b148ee009741564d4fd.html#ga137082975fcf6b148ee009741564d4fd">require_not_plain_type_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga137082975fcf6b148ee009741564d4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>.  <br /></td></tr>
<tr class="separator:ga137082975fcf6b148ee009741564d4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a302e26e34e181e474fe1604634e4b"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaf7a302e26e34e181e474fe1604634e4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__plain__type__types_gaf7a302e26e34e181e474fe1604634e4b.html#gaf7a302e26e34e181e474fe1604634e4b">require_all_plain_type_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaf7a302e26e34e181e474fe1604634e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>.  <br /></td></tr>
<tr class="separator:gaf7a302e26e34e181e474fe1604634e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba15f4b33ddc052edfb7f089da2f0a8"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaeba15f4b33ddc052edfb7f089da2f0a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__plain__type__types_gaeba15f4b33ddc052edfb7f089da2f0a8.html#gaeba15f4b33ddc052edfb7f089da2f0a8">require_any_not_plain_type_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaeba15f4b33ddc052edfb7f089da2f0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="group__type__trait_ga17bf5c3cd4cc2794e47ea0e0609bbf9f.html#ga17bf5c3cd4cc2794e47ea0e0609bbf9f">is_plain_type</a>.  <br /></td></tr>
<tr class="separator:gaeba15f4b33ddc052edfb7f089da2f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc83011a2f62637a4c0cd0501b420b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5cc83011a2f62637a4c0cd0501b420b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__real__types_ga5cc83011a2f62637a4c0cd0501b420b0.html#ga5cc83011a2f62637a4c0cd0501b420b0">require_real_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__real.html">is_real</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga5cc83011a2f62637a4c0cd0501b420b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__real.html">is_real</a>.  <br /></td></tr>
<tr class="separator:ga5cc83011a2f62637a4c0cd0501b420b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d29c98ea57cdf39651f49366230b15f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6d29c98ea57cdf39651f49366230b15f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__real__types_ga6d29c98ea57cdf39651f49366230b15f.html#ga6d29c98ea57cdf39651f49366230b15f">require_not_real_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__real.html">is_real</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga6d29c98ea57cdf39651f49366230b15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__real.html">is_real</a>.  <br /></td></tr>
<tr class="separator:ga6d29c98ea57cdf39651f49366230b15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227bd42e0663af336de7dff0d96d964f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga227bd42e0663af336de7dff0d96d964f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__real__types_ga227bd42e0663af336de7dff0d96d964f.html#ga227bd42e0663af336de7dff0d96d964f">require_all_real_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__real.html">is_real</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga227bd42e0663af336de7dff0d96d964f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__real.html">is_real</a>.  <br /></td></tr>
<tr class="separator:ga227bd42e0663af336de7dff0d96d964f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ea5f0c7b8d5938fdfe90ef6674d48f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga35ea5f0c7b8d5938fdfe90ef6674d48f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__real__types_ga35ea5f0c7b8d5938fdfe90ef6674d48f.html#ga35ea5f0c7b8d5938fdfe90ef6674d48f">require_any_real_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__real.html">is_real</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga35ea5f0c7b8d5938fdfe90ef6674d48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__real.html">is_real</a>.  <br /></td></tr>
<tr class="separator:ga35ea5f0c7b8d5938fdfe90ef6674d48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb895739ee92aa85c45433ed084b8f47"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gacb895739ee92aa85c45433ed084b8f47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__real__types_gacb895739ee92aa85c45433ed084b8f47.html#gacb895739ee92aa85c45433ed084b8f47">require_all_not_real_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__real.html">is_real</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gacb895739ee92aa85c45433ed084b8f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__real.html">is_real</a>.  <br /></td></tr>
<tr class="separator:gacb895739ee92aa85c45433ed084b8f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5126851655293afb028c258de12ca9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga7b5126851655293afb028c258de12ca9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__real__types_ga7b5126851655293afb028c258de12ca9.html#ga7b5126851655293afb028c258de12ca9">require_any_not_real_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__real.html">is_real</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga7b5126851655293afb028c258de12ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__real.html">is_real</a>.  <br /></td></tr>
<tr class="separator:ga7b5126851655293afb028c258de12ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e59582149b6984c54b85901e74b55a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4e59582149b6984c54b85901e74b55a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga4e59582149b6984c54b85901e74b55a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>.  <br /></td></tr>
<tr class="separator:ga4e59582149b6984c54b85901e74b55a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bcca863ac22d5e256ec4d8146db7bf3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7bcca863ac22d5e256ec4d8146db7bf3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__matrix__types_ga7bcca863ac22d5e256ec4d8146db7bf3.html#ga7bcca863ac22d5e256ec4d8146db7bf3">require_not_rev_matrix_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7bcca863ac22d5e256ec4d8146db7bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>.  <br /></td></tr>
<tr class="separator:ga7bcca863ac22d5e256ec4d8146db7bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad207a403d4b54a4d3c2f24912fda464c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gad207a403d4b54a4d3c2f24912fda464c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__matrix__types_gad207a403d4b54a4d3c2f24912fda464c.html#gad207a403d4b54a4d3c2f24912fda464c">require_all_rev_matrix_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad207a403d4b54a4d3c2f24912fda464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>.  <br /></td></tr>
<tr class="separator:gad207a403d4b54a4d3c2f24912fda464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4749960545a52cc23c445f7dc781c4"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga5b4749960545a52cc23c445f7dc781c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__matrix__types_ga5b4749960545a52cc23c445f7dc781c4.html#ga5b4749960545a52cc23c445f7dc781c4">require_any_rev_matrix_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga5b4749960545a52cc23c445f7dc781c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>.  <br /></td></tr>
<tr class="separator:ga5b4749960545a52cc23c445f7dc781c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25731d78a40a9cd73951067cafc79fc3"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga25731d78a40a9cd73951067cafc79fc3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__matrix__types_ga25731d78a40a9cd73951067cafc79fc3.html#ga25731d78a40a9cd73951067cafc79fc3">require_all_not_rev_matrix_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga25731d78a40a9cd73951067cafc79fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__rev__matrix.html">is_rev_matrix</a>.  <br /></td></tr>
<tr class="separator:ga25731d78a40a9cd73951067cafc79fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa81c7fb1967639684eea7892b90c65c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaa81c7fb1967639684eea7892b90c65c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__rev__col__vector.html">is_rev_col_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaaa81c7fb1967639684eea7892b90c65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__rev__col__vector.html">is_rev_col_vector</a>.  <br /></td></tr>
<tr class="separator:gaaa81c7fb1967639684eea7892b90c65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f0ef9dce633c87a3496b8c51c2eb5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae5f0ef9dce633c87a3496b8c51c2eb5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__rev__vector__types_gae5f0ef9dce633c87a3496b8c51c2eb5b.html#gae5f0ef9dce633c87a3496b8c51c2eb5b">require_rev_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__rev__vector.html">is_rev_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gae5f0ef9dce633c87a3496b8c51c2eb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__rev__vector.html">is_rev_vector</a>.  <br /></td></tr>
<tr class="separator:gae5f0ef9dce633c87a3496b8c51c2eb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5003c32d9e63471c92ab63280a61b8ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5003c32d9e63471c92ab63280a61b8ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga5003c32d9e63471c92ab63280a61b8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga5003c32d9e63471c92ab63280a61b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2ecf4866780c76833f71cd4d28e3cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8e2ecf4866780c76833f71cd4d28e3cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga8e2ecf4866780c76833f71cd4d28e3cf.html#ga8e2ecf4866780c76833f71cd4d28e3cf">require_not_stan_scalar_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga8e2ecf4866780c76833f71cd4d28e3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga8e2ecf4866780c76833f71cd4d28e3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354988e53bb2c7810e74e3f9c4ab537b"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga354988e53bb2c7810e74e3f9c4ab537b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga354988e53bb2c7810e74e3f9c4ab537b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga354988e53bb2c7810e74e3f9c4ab537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga538634dc8f8389f2986205f6098c04a2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga538634dc8f8389f2986205f6098c04a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga538634dc8f8389f2986205f6098c04a2.html#ga538634dc8f8389f2986205f6098c04a2">require_any_stan_scalar_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga538634dc8f8389f2986205f6098c04a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga538634dc8f8389f2986205f6098c04a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c53542c941050f5955538f4068266ae"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga5c53542c941050f5955538f4068266ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga5c53542c941050f5955538f4068266ae.html#ga5c53542c941050f5955538f4068266ae">require_all_not_stan_scalar_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga5c53542c941050f5955538f4068266ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga5c53542c941050f5955538f4068266ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c85677422e2e114002a5efa68cfc3f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga09c85677422e2e114002a5efa68cfc3f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga09c85677422e2e114002a5efa68cfc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga09c85677422e2e114002a5efa68cfc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b593d9762ab87780009f9552b2c68b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b593d9762ab87780009f9552b2c68b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga0b593d9762ab87780009f9552b2c68b1.html#ga0b593d9762ab87780009f9552b2c68b1">require_not_vt_stan_scalar</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga0b593d9762ab87780009f9552b2c68b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type does not satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga0b593d9762ab87780009f9552b2c68b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31bbf2a920ae0a54f6932cd10f8ff44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf31bbf2a920ae0a54f6932cd10f8ff44"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_gaf31bbf2a920ae0a54f6932cd10f8ff44.html#gaf31bbf2a920ae0a54f6932cd10f8ff44">require_st_stan_scalar</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaf31bbf2a920ae0a54f6932cd10f8ff44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type satisfies <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:gaf31bbf2a920ae0a54f6932cd10f8ff44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1f6cb3b45a1cfd320c062892b5d4fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1a1f6cb3b45a1cfd320c062892b5d4fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_ga1a1f6cb3b45a1cfd320c062892b5d4fa.html#ga1a1f6cb3b45a1cfd320c062892b5d4fa">require_not_st_stan_scalar</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga1a1f6cb3b45a1cfd320c062892b5d4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:ga1a1f6cb3b45a1cfd320c062892b5d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0326ae68f45d604f606567bf6c318e2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaf0326ae68f45d604f606567bf6c318e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__types_gaf0326ae68f45d604f606567bf6c318e2.html#gaf0326ae68f45d604f606567bf6c318e2">require_all_st_stan_scalar</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaf0326ae68f45d604f606567bf6c318e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the scalar types satisfy <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>.  <br /></td></tr>
<tr class="separator:gaf0326ae68f45d604f606567bf6c318e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597c18eee233b7aa27f52a2068e5b881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga597c18eee233b7aa27f52a2068e5b881"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga597c18eee233b7aa27f52a2068e5b881.html#ga597c18eee233b7aa27f52a2068e5b881">is_stan_scalar_or_eigen</a> = <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>&lt; std::decay_t&lt; T &gt; &gt;::value||<a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; std::decay_t&lt; T &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga597c18eee233b7aa27f52a2068e5b881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type if all the provided types are either a Stan Scalar type or a type inheriting from <code>EigenBase</code>.  <br /></td></tr>
<tr class="separator:ga597c18eee233b7aa27f52a2068e5b881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027699aeeab5c068a93df2a4693c8bda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga027699aeeab5c068a93df2a4693c8bda"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="group__type__trait_ga597c18eee233b7aa27f52a2068e5b881.html#ga597c18eee233b7aa27f52a2068e5b881">is_stan_scalar_or_eigen</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga027699aeeab5c068a93df2a4693c8bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="group__type__trait_ga597c18eee233b7aa27f52a2068e5b881.html#ga597c18eee233b7aa27f52a2068e5b881">is_stan_scalar_or_eigen</a>.  <br /></td></tr>
<tr class="separator:ga027699aeeab5c068a93df2a4693c8bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a> = std::is_convertible&lt; T, std::string &gt;</td></tr>
<tr class="memdesc:ga0f2252ae22390725feb09d9ea11b7896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces whether type is convertible to string.  <br /></td></tr>
<tr class="separator:ga0f2252ae22390725feb09d9ea11b7896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c8dcaf12599c431afe7567feb7fafc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf3c8dcaf12599c431afe7567feb7fafc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__convertible__types_gaf3c8dcaf12599c431afe7567feb7fafc.html#gaf3c8dcaf12599c431afe7567feb7fafc">require_string_convertible_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaf3c8dcaf12599c431afe7567feb7fafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>.  <br /></td></tr>
<tr class="separator:gaf3c8dcaf12599c431afe7567feb7fafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be7bba5656de0d37e01049b19c2e1aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4be7bba5656de0d37e01049b19c2e1aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__convertible__types_ga4be7bba5656de0d37e01049b19c2e1aa.html#ga4be7bba5656de0d37e01049b19c2e1aa">require_not_string_convertible_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga4be7bba5656de0d37e01049b19c2e1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>.  <br /></td></tr>
<tr class="separator:ga4be7bba5656de0d37e01049b19c2e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7e607b2930bd870447500b6076cb67"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaec7e607b2930bd870447500b6076cb67"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__convertible__types_gaec7e607b2930bd870447500b6076cb67.html#gaec7e607b2930bd870447500b6076cb67">require_all_string_convertible_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaec7e607b2930bd870447500b6076cb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>.  <br /></td></tr>
<tr class="separator:gaec7e607b2930bd870447500b6076cb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33dc1e42cee2a591bcb8f9d097ee1c4b"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga33dc1e42cee2a591bcb8f9d097ee1c4b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__convertible__types_ga33dc1e42cee2a591bcb8f9d097ee1c4b.html#ga33dc1e42cee2a591bcb8f9d097ee1c4b">require_any_string_convertible_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga33dc1e42cee2a591bcb8f9d097ee1c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>.  <br /></td></tr>
<tr class="separator:ga33dc1e42cee2a591bcb8f9d097ee1c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44906eefc8fabe097d55d5e734b15c8d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga44906eefc8fabe097d55d5e734b15c8d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__convertible__types_ga44906eefc8fabe097d55d5e734b15c8d.html#ga44906eefc8fabe097d55d5e734b15c8d">require_all_not_string_convertible_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga44906eefc8fabe097d55d5e734b15c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>.  <br /></td></tr>
<tr class="separator:ga44906eefc8fabe097d55d5e734b15c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad981ea6f9b0dfe26d2fd9b6f5fd61004"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gad981ea6f9b0dfe26d2fd9b6f5fd61004"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string__convertible__types_gad981ea6f9b0dfe26d2fd9b6f5fd61004.html#gad981ea6f9b0dfe26d2fd9b6f5fd61004">require_any_not_string_convertible_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad981ea6f9b0dfe26d2fd9b6f5fd61004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="group__type__trait_ga0f2252ae22390725feb09d9ea11b7896.html#ga0f2252ae22390725feb09d9ea11b7896">is_string_convertible</a>.  <br /></td></tr>
<tr class="separator:gad981ea6f9b0dfe26d2fd9b6f5fd61004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d7285b1a3ce33eb11e113827345d30"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab0d7285b1a3ce33eb11e113827345d30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gab0d7285b1a3ce33eb11e113827345d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:gab0d7285b1a3ce33eb11e113827345d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga202c72c7f8418f766eeb3e013a43e25c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga202c72c7f8418f766eeb3e013a43e25c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga202c72c7f8418f766eeb3e013a43e25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga202c72c7f8418f766eeb3e013a43e25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de32dfaeac1a3b183d7825c3231a2a2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga2de32dfaeac1a3b183d7825c3231a2a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga2de32dfaeac1a3b183d7825c3231a2a2.html#ga2de32dfaeac1a3b183d7825c3231a2a2">require_all_var_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga2de32dfaeac1a3b183d7825c3231a2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga2de32dfaeac1a3b183d7825c3231a2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d733e03bef0f79faee9c5cc6dd8711c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga6d733e03bef0f79faee9c5cc6dd8711c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga6d733e03bef0f79faee9c5cc6dd8711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga6d733e03bef0f79faee9c5cc6dd8711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd1267e326cb7764f47ddfba577dabdb"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gacd1267e326cb7764f47ddfba577dabdb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_gacd1267e326cb7764f47ddfba577dabdb.html#gacd1267e326cb7764f47ddfba577dabdb">require_all_not_var_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gacd1267e326cb7764f47ddfba577dabdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:gacd1267e326cb7764f47ddfba577dabdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eba6905791c2e6beaf3fcf653775301"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga3eba6905791c2e6beaf3fcf653775301"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga3eba6905791c2e6beaf3fcf653775301.html#ga3eba6905791c2e6beaf3fcf653775301">require_any_not_var_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga3eba6905791c2e6beaf3fcf653775301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga3eba6905791c2e6beaf3fcf653775301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29fde8e89258f50345408f2d23070d60"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga29fde8e89258f50345408f2d23070d60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga29fde8e89258f50345408f2d23070d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga29fde8e89258f50345408f2d23070d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c705510643b752453ec4dbed687e86"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga71c705510643b752453ec4dbed687e86"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga71c705510643b752453ec4dbed687e86.html#ga71c705510643b752453ec4dbed687e86">require_any_var_vt</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga71c705510643b752453ec4dbed687e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__var.html" title="Defines a static member named value which is defined to be false as the primitive scalar types cannot...">is_var</a>.  <br /></td></tr>
<tr class="separator:ga71c705510643b752453ec4dbed687e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf43b7e7d8793f9f9df153d953680032"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gacf43b7e7d8793f9f9df153d953680032"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_gacf43b7e7d8793f9f9df153d953680032.html#gacf43b7e7d8793f9f9df153d953680032">require_all_var_vt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gacf43b7e7d8793f9f9df153d953680032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__var.html" title="Defines a static member named value which is defined to be false as the primitive scalar types cannot...">is_var</a>.  <br /></td></tr>
<tr class="separator:gacf43b7e7d8793f9f9df153d953680032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49bd546c64ba1da0a583715b7162c898"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga49bd546c64ba1da0a583715b7162c898"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga49bd546c64ba1da0a583715b7162c898.html#ga49bd546c64ba1da0a583715b7162c898">require_not_vt_var</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga49bd546c64ba1da0a583715b7162c898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type does not satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga49bd546c64ba1da0a583715b7162c898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3005eb7ae8907ba19f66470146dfd6b6"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga3005eb7ae8907ba19f66470146dfd6b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga3005eb7ae8907ba19f66470146dfd6b6.html#ga3005eb7ae8907ba19f66470146dfd6b6">require_any_vt_var</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga3005eb7ae8907ba19f66470146dfd6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the value_types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga3005eb7ae8907ba19f66470146dfd6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c77b10bca27291f016c8e19f90965b0"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga3c77b10bca27291f016c8e19f90965b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga3c77b10bca27291f016c8e19f90965b0.html#ga3c77b10bca27291f016c8e19f90965b0">require_all_not_vt_var</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga3c77b10bca27291f016c8e19f90965b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the value_types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga3c77b10bca27291f016c8e19f90965b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd233f257c8219f5b318a96ca31c6f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9cd233f257c8219f5b318a96ca31c6f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga9cd233f257c8219f5b318a96ca31c6f2.html#ga9cd233f257c8219f5b318a96ca31c6f2">require_st_var</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga9cd233f257c8219f5b318a96ca31c6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a> satisfies <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga9cd233f257c8219f5b318a96ca31c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2976a84494e5b9a15e396836a1762ec0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2976a84494e5b9a15e396836a1762ec0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga2976a84494e5b9a15e396836a1762ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga2976a84494e5b9a15e396836a1762ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1027292c8c5b7c1da51c40fcd93fd3f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gab1027292c8c5b7c1da51c40fcd93fd3f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_gab1027292c8c5b7c1da51c40fcd93fd3f.html#gab1027292c8c5b7c1da51c40fcd93fd3f">require_all_st_var</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gab1027292c8c5b7c1da51c40fcd93fd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the scalar types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:gab1027292c8c5b7c1da51c40fcd93fd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4fb966d630ab09756dbc3a1bfd495d4"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gad4fb966d630ab09756dbc3a1bfd495d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad4fb966d630ab09756dbc3a1bfd495d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the scalar types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:gad4fb966d630ab09756dbc3a1bfd495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5baf3b48a8485cd74f29449ce74755"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga1b5baf3b48a8485cd74f29449ce74755"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga1b5baf3b48a8485cd74f29449ce74755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the scalar types satisfy <a class="el" href="structstan_1_1is__var.html">is_var</a>.  <br /></td></tr>
<tr class="separator:ga1b5baf3b48a8485cd74f29449ce74755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2d91e7563632c296825ea46b0482f52"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gab2d91e7563632c296825ea46b0482f52"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gab2d91e7563632c296825ea46b0482f52.html#gab2d91e7563632c296825ea46b0482f52">is_var_and_matrix_types</a> = <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Types... &gt; &gt;::value &amp;&amp;<a class="el" href="structstan_1_1math_1_1disjunction.html">stan::math::disjunction</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; Types &gt;... &gt;::value &gt;</td></tr>
<tr class="memdesc:gab2d91e7563632c296825ea46b0482f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with at least one type that has a var <code><a class="el" href="structstan_1_1scalar__type.html" title="Metaprogram structure to determine the base scalar type of a template argument.">scalar_type</a></code> and at least one type is a matrix.  <br /></td></tr>
<tr class="separator:gab2d91e7563632c296825ea46b0482f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bd66f94354326e52c8335de0d9f69b"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a27bd66f94354326e52c8335de0d9f69b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a27bd66f94354326e52c8335de0d9f69b.html#a27bd66f94354326e52c8335de0d9f69b">require_all_not_var_and_matrix_types</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="group__type__trait_gab2d91e7563632c296825ea46b0482f52.html#gab2d91e7563632c296825ea46b0482f52">is_var_and_matrix_types</a>&lt; Types... &gt; &gt;</td></tr>
<tr class="separator:a27bd66f94354326e52c8335de0d9f69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab3371e340e96abeddafec0edb8b04b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacab3371e340e96abeddafec0edb8b04b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__dense__dynamic__types_gacab3371e340e96abeddafec0edb8b04b.html#gacab3371e340e96abeddafec0edb8b04b">require_var_dense_dynamic_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__var__dense__dynamic.html">is_var_dense_dynamic</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gacab3371e340e96abeddafec0edb8b04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__var__dense__dynamic.html" title="Check if a type is a var_value whose value_type is derived from Eigen::EigenBase and has dynamic rows...">is_var_dense_dynamic</a>.  <br /></td></tr>
<tr class="separator:gacab3371e340e96abeddafec0edb8b04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b69286a639fc88718de93b0db9c172"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36b69286a639fc88718de93b0db9c172"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga36b69286a639fc88718de93b0db9c172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>.  <br /></td></tr>
<tr class="separator:ga36b69286a639fc88718de93b0db9c172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473bd4130f7623863172475fcb56344a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga473bd4130f7623863172475fcb56344a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga473bd4130f7623863172475fcb56344a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>.  <br /></td></tr>
<tr class="separator:ga473bd4130f7623863172475fcb56344a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7710dc79942af3d9b6fe40a51a0f2e7"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaa7710dc79942af3d9b6fe40a51a0f2e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__matrix__types_gaa7710dc79942af3d9b6fe40a51a0f2e7.html#gaa7710dc79942af3d9b6fe40a51a0f2e7">require_all_var_matrix_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaa7710dc79942af3d9b6fe40a51a0f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>.  <br /></td></tr>
<tr class="separator:gaa7710dc79942af3d9b6fe40a51a0f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9240f628acb5b6ce46e70cd20f93e0f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaf9240f628acb5b6ce46e70cd20f93e0f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaf9240f628acb5b6ce46e70cd20f93e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>.  <br /></td></tr>
<tr class="separator:gaf9240f628acb5b6ce46e70cd20f93e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f57b6105cb69165aeee0f2de2e50db"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gae0f57b6105cb69165aeee0f2de2e50db"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gae0f57b6105cb69165aeee0f2de2e50db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__var__matrix.html">is_var_matrix</a>.  <br /></td></tr>
<tr class="separator:gae0f57b6105cb69165aeee0f2de2e50db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab1faff10d276e9d0584855350f3365"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4ab1faff10d276e9d0584855350f3365"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__col__vector__types_ga4ab1faff10d276e9d0584855350f3365.html#ga4ab1faff10d276e9d0584855350f3365">require_var_col_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__var__col__vector.html">is_var_col_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga4ab1faff10d276e9d0584855350f3365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__var__col__vector.html">is_var_col_vector</a>.  <br /></td></tr>
<tr class="separator:ga4ab1faff10d276e9d0584855350f3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8330892cb798019dfb7d5271487877e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8330892cb798019dfb7d5271487877e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__col__vector__types_ga8330892cb798019dfb7d5271487877e7.html#ga8330892cb798019dfb7d5271487877e7">require_not_var_col_vector_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__var__col__vector.html">is_var_col_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga8330892cb798019dfb7d5271487877e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__var__col__vector.html">is_var_col_vector</a>.  <br /></td></tr>
<tr class="separator:ga8330892cb798019dfb7d5271487877e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756776ef3e68ee2d4530be69a953d742"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga756776ef3e68ee2d4530be69a953d742"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__row__vector__types_ga756776ef3e68ee2d4530be69a953d742.html#ga756776ef3e68ee2d4530be69a953d742">require_var_row_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__var__row__vector.html">is_var_row_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga756776ef3e68ee2d4530be69a953d742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__var__row__vector.html">is_var_row_vector</a>.  <br /></td></tr>
<tr class="separator:ga756776ef3e68ee2d4530be69a953d742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9869e92fcfb027eedfe8de77507769"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b9869e92fcfb027eedfe8de77507769"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__var__vector.html">is_var_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7b9869e92fcfb027eedfe8de77507769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__var__vector.html">is_var_vector</a>.  <br /></td></tr>
<tr class="separator:ga7b9869e92fcfb027eedfe8de77507769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafefbf7d697343b6b73101e76f6cfe08f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gafefbf7d697343b6b73101e76f6cfe08f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__vector__types_gafefbf7d697343b6b73101e76f6cfe08f.html#gafefbf7d697343b6b73101e76f6cfe08f">require_all_var_vector_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__var__vector.html">is_var_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gafefbf7d697343b6b73101e76f6cfe08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__var__vector.html">is_var_vector</a>.  <br /></td></tr>
<tr class="separator:gafefbf7d697343b6b73101e76f6cfe08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79377c870c4afd3682311972ce62b63a"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga79377c870c4afd3682311972ce62b63a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__vector__types_ga79377c870c4afd3682311972ce62b63a.html#ga79377c870c4afd3682311972ce62b63a">require_any_var_vector_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__var__vector.html">is_var_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga79377c870c4afd3682311972ce62b63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__var__vector.html">is_var_vector</a>.  <br /></td></tr>
<tr class="separator:ga79377c870c4afd3682311972ce62b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a> = <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var__or__arithmetic__type.html">is_var_or_arithmetic_type</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type if all the provided types are either var or an arithmetic type, extends std::false_type otherwise.  <br /></td></tr>
<tr class="separator:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fb2bdcd7561f26fb52540025ce94ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37fb2bdcd7561f26fb52540025ce94ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__or__arithmetic__types_ga37fb2bdcd7561f26fb52540025ce94ca.html#ga37fb2bdcd7561f26fb52540025ce94ca">require_var_or_arithmetic_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga37fb2bdcd7561f26fb52540025ce94ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>.  <br /></td></tr>
<tr class="separator:ga37fb2bdcd7561f26fb52540025ce94ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0a0ffec82340cada6680d13b892cad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaed0a0ffec82340cada6680d13b892cad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__or__arithmetic__types_gaed0a0ffec82340cada6680d13b892cad.html#gaed0a0ffec82340cada6680d13b892cad">require_not_var_or_arithmetic_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaed0a0ffec82340cada6680d13b892cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>.  <br /></td></tr>
<tr class="separator:gaed0a0ffec82340cada6680d13b892cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga923911a644fb93b170093cb89df482a1"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga923911a644fb93b170093cb89df482a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__or__arithmetic__types_ga923911a644fb93b170093cb89df482a1.html#ga923911a644fb93b170093cb89df482a1">require_all_var_or_arithmetic_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga923911a644fb93b170093cb89df482a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>.  <br /></td></tr>
<tr class="separator:ga923911a644fb93b170093cb89df482a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c317c73009a96b8feeeff3e26355f4"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gac6c317c73009a96b8feeeff3e26355f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__or__arithmetic__types_gac6c317c73009a96b8feeeff3e26355f4.html#gac6c317c73009a96b8feeeff3e26355f4">require_any_var_or_arithmetic_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gac6c317c73009a96b8feeeff3e26355f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>.  <br /></td></tr>
<tr class="separator:gac6c317c73009a96b8feeeff3e26355f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa77d282eaee0ae8f27a755b75be205d5"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaa77d282eaee0ae8f27a755b75be205d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__or__arithmetic__types_gaa77d282eaee0ae8f27a755b75be205d5.html#gaa77d282eaee0ae8f27a755b75be205d5">require_all_not_var_or_arithmetic_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaa77d282eaee0ae8f27a755b75be205d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>.  <br /></td></tr>
<tr class="separator:gaa77d282eaee0ae8f27a755b75be205d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67bdec3a2047f8c8bee36605650350b7"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga67bdec3a2047f8c8bee36605650350b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__or__arithmetic__types_ga67bdec3a2047f8c8bee36605650350b7.html#ga67bdec3a2047f8c8bee36605650350b7">require_any_not_var_or_arithmetic_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga67bdec3a2047f8c8bee36605650350b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>.  <br /></td></tr>
<tr class="separator:ga67bdec3a2047f8c8bee36605650350b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5061e6f2e948a07b90bd6b0cde025e9e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga5061e6f2e948a07b90bd6b0cde025e9e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__var__or__arithmetic__types_ga5061e6f2e948a07b90bd6b0cde025e9e.html#ga5061e6f2e948a07b90bd6b0cde025e9e">require_all_st_var_or_arithmetic</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga5061e6f2e948a07b90bd6b0cde025e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the scalar types satisfy <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>.  <br /></td></tr>
<tr class="separator:ga5061e6f2e948a07b90bd6b0cde025e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d884dd17cfd961ad12df40a9ba3aaa2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2d884dd17cfd961ad12df40a9ba3aaa2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga2d884dd17cfd961ad12df40a9ba3aaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>.  <br /></td></tr>
<tr class="separator:ga2d884dd17cfd961ad12df40a9ba3aaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e63e3ea85c77800e3a4cda6aed0357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga76e63e3ea85c77800e3a4cda6aed0357"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__col__vector__types_ga76e63e3ea85c77800e3a4cda6aed0357.html#ga76e63e3ea85c77800e3a4cda6aed0357">require_not_eigen_col_vector_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga76e63e3ea85c77800e3a4cda6aed0357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>.  <br /></td></tr>
<tr class="separator:ga76e63e3ea85c77800e3a4cda6aed0357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba3a075f0d641022a8da364d3159bfa"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gadba3a075f0d641022a8da364d3159bfa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gadba3a075f0d641022a8da364d3159bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>.  <br /></td></tr>
<tr class="separator:gadba3a075f0d641022a8da364d3159bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16729dba6fafa4f518defdf9cccd3488"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga16729dba6fafa4f518defdf9cccd3488"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__col__vector__types_ga16729dba6fafa4f518defdf9cccd3488.html#ga16729dba6fafa4f518defdf9cccd3488">require_eigen_col_vector_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga16729dba6fafa4f518defdf9cccd3488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>.  <br /></td></tr>
<tr class="separator:ga16729dba6fafa4f518defdf9cccd3488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58096049cb8906ec6ad5f44f1e6fe082"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga58096049cb8906ec6ad5f44f1e6fe082"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga58096049cb8906ec6ad5f44f1e6fe082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>.  <br /></td></tr>
<tr class="separator:ga58096049cb8906ec6ad5f44f1e6fe082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91963f6a218d172b07857bf3d5a8aa86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga91963f6a218d172b07857bf3d5a8aa86"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__col__vector__types_ga91963f6a218d172b07857bf3d5a8aa86.html#ga91963f6a218d172b07857bf3d5a8aa86">require_not_col_vector_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga91963f6a218d172b07857bf3d5a8aa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>.  <br /></td></tr>
<tr class="separator:ga91963f6a218d172b07857bf3d5a8aa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdf3846bf05a9740b053aa952f0bc0dd"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gafdf3846bf05a9740b053aa952f0bc0dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__col__vector__types_gafdf3846bf05a9740b053aa952f0bc0dd.html#gafdf3846bf05a9740b053aa952f0bc0dd">require_all_col_vector_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gafdf3846bf05a9740b053aa952f0bc0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>.  <br /></td></tr>
<tr class="separator:gafdf3846bf05a9740b053aa952f0bc0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aff7daad297cba7bc223382ac23d8ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2aff7daad297cba7bc223382ac23d8ff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__row__vector__types_ga2aff7daad297cba7bc223382ac23d8ff.html#ga2aff7daad297cba7bc223382ac23d8ff">require_eigen_row_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga2aff7daad297cba7bc223382ac23d8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>.  <br /></td></tr>
<tr class="separator:ga2aff7daad297cba7bc223382ac23d8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6220707783fb954ce7b6d851566053e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae6220707783fb954ce7b6d851566053e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__row__vector__types_gae6220707783fb954ce7b6d851566053e.html#gae6220707783fb954ce7b6d851566053e">require_row_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__row__vector.html">is_row_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gae6220707783fb954ce7b6d851566053e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__row__vector.html">is_row_vector</a>.  <br /></td></tr>
<tr class="separator:gae6220707783fb954ce7b6d851566053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80033ba22a52674ccb5e966be1abb6dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga80033ba22a52674ccb5e966be1abb6dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga80033ba22a52674ccb5e966be1abb6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga80033ba22a52674ccb5e966be1abb6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96346a2dd6e69cd00862a734ed66532d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga96346a2dd6e69cd00862a734ed66532d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga96346a2dd6e69cd00862a734ed66532d.html#ga96346a2dd6e69cd00862a734ed66532d">require_not_eigen_vector_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga96346a2dd6e69cd00862a734ed66532d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga96346a2dd6e69cd00862a734ed66532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c3e4d9b301746f5374ae7237eeab66"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaf8c3e4d9b301746f5374ae7237eeab66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaf8c3e4d9b301746f5374ae7237eeab66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:gaf8c3e4d9b301746f5374ae7237eeab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89321076f6dc15c0aae4c88a93710ca"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gad89321076f6dc15c0aae4c88a93710ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_gad89321076f6dc15c0aae4c88a93710ca.html#gad89321076f6dc15c0aae4c88a93710ca">require_any_eigen_vector_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad89321076f6dc15c0aae4c88a93710ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:gad89321076f6dc15c0aae4c88a93710ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dbff765391bd92eb3f1e6fcae426c27"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga2dbff765391bd92eb3f1e6fcae426c27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga2dbff765391bd92eb3f1e6fcae426c27.html#ga2dbff765391bd92eb3f1e6fcae426c27">require_all_not_eigen_vector_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga2dbff765391bd92eb3f1e6fcae426c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga2dbff765391bd92eb3f1e6fcae426c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed4232cba6921e25b1d3eb2aeebfcb4d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaed4232cba6921e25b1d3eb2aeebfcb4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_gaed4232cba6921e25b1d3eb2aeebfcb4d.html#gaed4232cba6921e25b1d3eb2aeebfcb4d">require_any_not_eigen_vector_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaed4232cba6921e25b1d3eb2aeebfcb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:gaed4232cba6921e25b1d3eb2aeebfcb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896401ad33967867f49cd60ca10d990e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga896401ad33967867f49cd60ca10d990e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga896401ad33967867f49cd60ca10d990e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga896401ad33967867f49cd60ca10d990e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7a68915972729ed235e67d57093278"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga3a7a68915972729ed235e67d57093278"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga3a7a68915972729ed235e67d57093278.html#ga3a7a68915972729ed235e67d57093278">require_not_eigen_vector_vt</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga3a7a68915972729ed235e67d57093278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a> or.  <br /></td></tr>
<tr class="separator:ga3a7a68915972729ed235e67d57093278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7114bbdfd50f06da7666803c1dda6f1e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga7114bbdfd50f06da7666803c1dda6f1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga7114bbdfd50f06da7666803c1dda6f1e.html#ga7114bbdfd50f06da7666803c1dda6f1e">require_any_eigen_vector_vt</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga7114bbdfd50f06da7666803c1dda6f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga7114bbdfd50f06da7666803c1dda6f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d84dd035b59601a5b52fb99480b2a85"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga0d84dd035b59601a5b52fb99480b2a85"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga0d84dd035b59601a5b52fb99480b2a85.html#ga0d84dd035b59601a5b52fb99480b2a85">require_any_not_eigen_vector_vt</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga0d84dd035b59601a5b52fb99480b2a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga0d84dd035b59601a5b52fb99480b2a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78109e803a8f77575fbac2f5940550eb"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga78109e803a8f77575fbac2f5940550eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga78109e803a8f77575fbac2f5940550eb.html#ga78109e803a8f77575fbac2f5940550eb">require_all_eigen_vector_vt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga78109e803a8f77575fbac2f5940550eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga78109e803a8f77575fbac2f5940550eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga328ab21c13c16a0b4d385f53cf48bcb3"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga328ab21c13c16a0b4d385f53cf48bcb3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga328ab21c13c16a0b4d385f53cf48bcb3.html#ga328ab21c13c16a0b4d385f53cf48bcb3">require_all_not_eigen_vector_vt</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga328ab21c13c16a0b4d385f53cf48bcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga328ab21c13c16a0b4d385f53cf48bcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf976c7e88d5ac3136d7ce57911e851b2"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gaf976c7e88d5ac3136d7ce57911e851b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_gaf976c7e88d5ac3136d7ce57911e851b2.html#gaf976c7e88d5ac3136d7ce57911e851b2">require_eigen_vector_st</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:gaf976c7e88d5ac3136d7ce57911e851b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:gaf976c7e88d5ac3136d7ce57911e851b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4aaaf87d58b792d8b7ab5e9b42d56f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga3b4aaaf87d58b792d8b7ab5e9b42d56f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga3b4aaaf87d58b792d8b7ab5e9b42d56f.html#ga3b4aaaf87d58b792d8b7ab5e9b42d56f">require_not_eigen_vector_st</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga3b4aaaf87d58b792d8b7ab5e9b42d56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga3b4aaaf87d58b792d8b7ab5e9b42d56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cbf54125b5475e76f3003d37702fe94"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga8cbf54125b5475e76f3003d37702fe94"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_ga8cbf54125b5475e76f3003d37702fe94.html#ga8cbf54125b5475e76f3003d37702fe94">require_any_eigen_vector_st</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga8cbf54125b5475e76f3003d37702fe94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:ga8cbf54125b5475e76f3003d37702fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd97cdb9418e39573884321e4be8b8f9"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gacd97cdb9418e39573884321e4be8b8f9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_gacd97cdb9418e39573884321e4be8b8f9.html#gacd97cdb9418e39573884321e4be8b8f9">require_any_not_eigen_vector_st</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gacd97cdb9418e39573884321e4be8b8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:gacd97cdb9418e39573884321e4be8b8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2f50ead6ac79f3ddfd175d7bb4206b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gafc2f50ead6ac79f3ddfd175d7bb4206b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_gafc2f50ead6ac79f3ddfd175d7bb4206b.html#gafc2f50ead6ac79f3ddfd175d7bb4206b">require_all_eigen_vector_st</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gafc2f50ead6ac79f3ddfd175d7bb4206b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types does not satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:gafc2f50ead6ac79f3ddfd175d7bb4206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2116169002297c49595f7e0403afac0"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gab2116169002297c49595f7e0403afac0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eigen__vector__types_gab2116169002297c49595f7e0403afac0.html#gab2116169002297c49595f7e0403afac0">require_all_not_eigen_vector_st</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gab2116169002297c49595f7e0403afac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__eigen__vector.html">is_eigen_vector</a>.  <br /></td></tr>
<tr class="separator:gab2116169002297c49595f7e0403afac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308053ee9550b3fca823589e3ebf0258"><td class="memTemplParams" colspan="2">template&lt;typename Row , typename Col &gt; </td></tr>
<tr class="memitem:a308053ee9550b3fca823589e3ebf0258"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a308053ee9550b3fca823589e3ebf0258.html#a308053ee9550b3fca823589e3ebf0258">require_eigen_row_and_col_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>&lt; Row &gt;, <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; Col &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a308053ee9550b3fca823589e3ebf0258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require <code>Row</code> is a row vector and <code>Col</code> is a column vector.  <br /></td></tr>
<tr class="separator:a308053ee9550b3fca823589e3ebf0258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4146fe117dbf61403c3c021c07c728"><td class="memTemplParams" colspan="2">template&lt;typename Row , typename Col &gt; </td></tr>
<tr class="memitem:a1f4146fe117dbf61403c3c021c07c728"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a1f4146fe117dbf61403c3c021c07c728.html#a1f4146fe117dbf61403c3c021c07c728">require_not_eigen_row_and_col_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>&lt; Row &gt;, <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; Col &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a1f4146fe117dbf61403c3c021c07c728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require <code>Row</code> is not a row vector and <code>Col</code> is not a column vector.  <br /></td></tr>
<tr class="separator:a1f4146fe117dbf61403c3c021c07c728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae507d2c91337fb5e46024439310b5f70"><td class="memTemplParams" colspan="2">template&lt;typename Row , typename Col &gt; </td></tr>
<tr class="memitem:ae507d2c91337fb5e46024439310b5f70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_ae507d2c91337fb5e46024439310b5f70.html#ae507d2c91337fb5e46024439310b5f70">require_row_and_col_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__row__vector.html">is_row_vector</a>&lt; Row &gt;, <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>&lt; Col &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ae507d2c91337fb5e46024439310b5f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require <code>Row</code> is a row vector and <code>Col</code> is a column vector.  <br /></td></tr>
<tr class="separator:ae507d2c91337fb5e46024439310b5f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239a870a9b8b94102aac34d707938d6a"><td class="memTemplParams" colspan="2">template&lt;typename Row , typename Col &gt; </td></tr>
<tr class="memitem:a239a870a9b8b94102aac34d707938d6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a239a870a9b8b94102aac34d707938d6a.html#a239a870a9b8b94102aac34d707938d6a">require_not_row_and_col_vector_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__row__vector.html">is_row_vector</a>&lt; Row &gt;, <a class="el" href="structstan_1_1is__col__vector.html">is_col_vector</a>&lt; Col &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a239a870a9b8b94102aac34d707938d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require <code>Row</code> is not a row vector and <code>Col</code> is not a column vector.  <br /></td></tr>
<tr class="separator:a239a870a9b8b94102aac34d707938d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49bbe2450e11ac6a02210ab0dcde62bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga49bbe2450e11ac6a02210ab0dcde62bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga49bbe2450e11ac6a02210ab0dcde62bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga49bbe2450e11ac6a02210ab0dcde62bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf768edd5d3dc64fdbd7f9b3781723dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacf768edd5d3dc64fdbd7f9b3781723dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_gacf768edd5d3dc64fdbd7f9b3781723dd.html#gacf768edd5d3dc64fdbd7f9b3781723dd">require_not_vector_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gacf768edd5d3dc64fdbd7f9b3781723dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:gacf768edd5d3dc64fdbd7f9b3781723dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4c392b9d20db66ae254ef9833f9717"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga1b4c392b9d20db66ae254ef9833f9717"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga1b4c392b9d20db66ae254ef9833f9717.html#ga1b4c392b9d20db66ae254ef9833f9717">require_all_vector_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga1b4c392b9d20db66ae254ef9833f9717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga1b4c392b9d20db66ae254ef9833f9717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b57bdd6be03bbb97e34236e194bdde"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaf4b57bdd6be03bbb97e34236e194bdde"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_gaf4b57bdd6be03bbb97e34236e194bdde.html#gaf4b57bdd6be03bbb97e34236e194bdde">require_any_vector_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaf4b57bdd6be03bbb97e34236e194bdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:gaf4b57bdd6be03bbb97e34236e194bdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65230b204e8d2c62f9804a1b7e92a27"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gac65230b204e8d2c62f9804a1b7e92a27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_gac65230b204e8d2c62f9804a1b7e92a27.html#gac65230b204e8d2c62f9804a1b7e92a27">require_all_not_vector_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gac65230b204e8d2c62f9804a1b7e92a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:gac65230b204e8d2c62f9804a1b7e92a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1941ef9299454741910bee0ef3ffd9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga5c1941ef9299454741910bee0ef3ffd9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga5c1941ef9299454741910bee0ef3ffd9.html#ga5c1941ef9299454741910bee0ef3ffd9">require_any_not_vector_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga5c1941ef9299454741910bee0ef3ffd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga5c1941ef9299454741910bee0ef3ffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038ee4f0c3ca5d626e5159485ac74c8a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga038ee4f0c3ca5d626e5159485ac74c8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga038ee4f0c3ca5d626e5159485ac74c8a.html#ga038ee4f0c3ca5d626e5159485ac74c8a">require_vector_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga038ee4f0c3ca5d626e5159485ac74c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga038ee4f0c3ca5d626e5159485ac74c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7160f75ddad050b378ef620b948038b9"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga7160f75ddad050b378ef620b948038b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga7160f75ddad050b378ef620b948038b9.html#ga7160f75ddad050b378ef620b948038b9">require_not_vector_vt</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga7160f75ddad050b378ef620b948038b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a> or.  <br /></td></tr>
<tr class="separator:ga7160f75ddad050b378ef620b948038b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8d00beb0bd96023d22e4857679d2309"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gab8d00beb0bd96023d22e4857679d2309"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_gab8d00beb0bd96023d22e4857679d2309.html#gab8d00beb0bd96023d22e4857679d2309">require_any_vector_vt</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gab8d00beb0bd96023d22e4857679d2309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:gab8d00beb0bd96023d22e4857679d2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b63c02c5a28640209efbe825e29422a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga6b63c02c5a28640209efbe825e29422a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga6b63c02c5a28640209efbe825e29422a.html#ga6b63c02c5a28640209efbe825e29422a">require_any_not_vector_vt</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga6b63c02c5a28640209efbe825e29422a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga6b63c02c5a28640209efbe825e29422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a36277063444f6bd36844e7cc5c106a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga6a36277063444f6bd36844e7cc5c106a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga6a36277063444f6bd36844e7cc5c106a.html#ga6a36277063444f6bd36844e7cc5c106a">require_all_vector_vt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga6a36277063444f6bd36844e7cc5c106a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga6a36277063444f6bd36844e7cc5c106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5390f372ebdfda00b5b6ba7d474376"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gafb5390f372ebdfda00b5b6ba7d474376"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_gafb5390f372ebdfda00b5b6ba7d474376.html#gafb5390f372ebdfda00b5b6ba7d474376">require_all_not_vector_vt</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gafb5390f372ebdfda00b5b6ba7d474376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:gafb5390f372ebdfda00b5b6ba7d474376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ee195dfac10dcd24307d8b949d4451"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga29ee195dfac10dcd24307d8b949d4451"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga29ee195dfac10dcd24307d8b949d4451.html#ga29ee195dfac10dcd24307d8b949d4451">require_vector_st</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga29ee195dfac10dcd24307d8b949d4451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga29ee195dfac10dcd24307d8b949d4451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151ee1d723e38f34c4153b33a14bf2c4"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga151ee1d723e38f34c4153b33a14bf2c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga151ee1d723e38f34c4153b33a14bf2c4.html#ga151ee1d723e38f34c4153b33a14bf2c4">require_not_vector_st</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga151ee1d723e38f34c4153b33a14bf2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga151ee1d723e38f34c4153b33a14bf2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977102fd1d955a9d2dc7bcc54d64d64f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga977102fd1d955a9d2dc7bcc54d64d64f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga977102fd1d955a9d2dc7bcc54d64d64f.html#ga977102fd1d955a9d2dc7bcc54d64d64f">require_any_vector_st</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga977102fd1d955a9d2dc7bcc54d64d64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga977102fd1d955a9d2dc7bcc54d64d64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7619f346db283392c880bf4e14bf739"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gad7619f346db283392c880bf4e14bf739"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_gad7619f346db283392c880bf4e14bf739.html#gad7619f346db283392c880bf4e14bf739">require_any_not_vector_st</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gad7619f346db283392c880bf4e14bf739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:gad7619f346db283392c880bf4e14bf739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fde843951403b7396adc80631b963f8"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga8fde843951403b7396adc80631b963f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga8fde843951403b7396adc80631b963f8.html#ga8fde843951403b7396adc80631b963f8">require_all_vector_st</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga8fde843951403b7396adc80631b963f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types does not satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga8fde843951403b7396adc80631b963f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d53ed589b52cf0f67603ca86cb8552"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga49d53ed589b52cf0f67603ca86cb8552"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__types_ga49d53ed589b52cf0f67603ca86cb8552.html#ga49d53ed589b52cf0f67603ca86cb8552">require_all_not_vector_st</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga49d53ed589b52cf0f67603ca86cb8552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__vector.html">is_vector</a>.  <br /></td></tr>
<tr class="separator:ga49d53ed589b52cf0f67603ca86cb8552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a685e43e184497f9b2b5056242ad2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga61a685e43e184497f9b2b5056242ad2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga61a685e43e184497f9b2b5056242ad2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga61a685e43e184497f9b2b5056242ad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af219a43381a19e0d730d1d1b2e59f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0af219a43381a19e0d730d1d1b2e59f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga0af219a43381a19e0d730d1d1b2e59f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga0af219a43381a19e0d730d1d1b2e59f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f22fe1b1531ec88ec38ef8c9087694e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga9f22fe1b1531ec88ec38ef8c9087694e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga9f22fe1b1531ec88ec38ef8c9087694e.html#ga9f22fe1b1531ec88ec38ef8c9087694e">require_all_std_vector_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga9f22fe1b1531ec88ec38ef8c9087694e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga9f22fe1b1531ec88ec38ef8c9087694e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54997c700516cc36fa3763bbd951ed31"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga54997c700516cc36fa3763bbd951ed31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga54997c700516cc36fa3763bbd951ed31.html#ga54997c700516cc36fa3763bbd951ed31">require_any_std_vector_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga54997c700516cc36fa3763bbd951ed31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga54997c700516cc36fa3763bbd951ed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613a895eb09b0a2c56cf757f08e3b1d0"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga613a895eb09b0a2c56cf757f08e3b1d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga613a895eb09b0a2c56cf757f08e3b1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga613a895eb09b0a2c56cf757f08e3b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafea5128387a9da4d189c1d8801798e50"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gafea5128387a9da4d189c1d8801798e50"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_gafea5128387a9da4d189c1d8801798e50.html#gafea5128387a9da4d189c1d8801798e50">require_any_not_std_vector_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gafea5128387a9da4d189c1d8801798e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:gafea5128387a9da4d189c1d8801798e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177ca10358abdf201cabb12e8bdb2e91"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga177ca10358abdf201cabb12e8bdb2e91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga177ca10358abdf201cabb12e8bdb2e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga177ca10358abdf201cabb12e8bdb2e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e43fa0e91d1b0d0dfa7e1982b9fc0e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga46e43fa0e91d1b0d0dfa7e1982b9fc0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga46e43fa0e91d1b0d0dfa7e1982b9fc0e.html#ga46e43fa0e91d1b0d0dfa7e1982b9fc0e">require_not_std_vector_vt</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga46e43fa0e91d1b0d0dfa7e1982b9fc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a> or.  <br /></td></tr>
<tr class="separator:ga46e43fa0e91d1b0d0dfa7e1982b9fc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3afcaf0367c4551052698fb0868ebe6b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga3afcaf0367c4551052698fb0868ebe6b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga3afcaf0367c4551052698fb0868ebe6b.html#ga3afcaf0367c4551052698fb0868ebe6b">require_any_std_vector_vt</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga3afcaf0367c4551052698fb0868ebe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga3afcaf0367c4551052698fb0868ebe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07217200f5f72297a082d838d214bc59"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga07217200f5f72297a082d838d214bc59"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga07217200f5f72297a082d838d214bc59.html#ga07217200f5f72297a082d838d214bc59">require_any_not_std_vector_vt</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga07217200f5f72297a082d838d214bc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga07217200f5f72297a082d838d214bc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed7c65cf5f86dd50b639dc85ec56a86"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga9ed7c65cf5f86dd50b639dc85ec56a86"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga9ed7c65cf5f86dd50b639dc85ec56a86.html#ga9ed7c65cf5f86dd50b639dc85ec56a86">require_all_std_vector_vt</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga9ed7c65cf5f86dd50b639dc85ec56a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga9ed7c65cf5f86dd50b639dc85ec56a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9116dc1de39b3b79c992219b13683f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gafe9116dc1de39b3b79c992219b13683f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_gafe9116dc1de39b3b79c992219b13683f.html#gafe9116dc1de39b3b79c992219b13683f">require_all_not_std_vector_vt</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gafe9116dc1de39b3b79c992219b13683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:gafe9116dc1de39b3b79c992219b13683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513b41fcdff562ebb8bc2cd5e3ea8faa"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga513b41fcdff562ebb8bc2cd5e3ea8faa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga513b41fcdff562ebb8bc2cd5e3ea8faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga513b41fcdff562ebb8bc2cd5e3ea8faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ce4da15d8b84b02322aa45cf21bb2f"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga90ce4da15d8b84b02322aa45cf21bb2f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga90ce4da15d8b84b02322aa45cf21bb2f.html#ga90ce4da15d8b84b02322aa45cf21bb2f">require_not_std_vector_st</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga90ce4da15d8b84b02322aa45cf21bb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga90ce4da15d8b84b02322aa45cf21bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6aecd12fa196c5e0a4322b23d544e61"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gad6aecd12fa196c5e0a4322b23d544e61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_gad6aecd12fa196c5e0a4322b23d544e61.html#gad6aecd12fa196c5e0a4322b23d544e61">require_any_std_vector_st</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gad6aecd12fa196c5e0a4322b23d544e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:gad6aecd12fa196c5e0a4322b23d544e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7760f72286ab5bd3b039617725914846"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga7760f72286ab5bd3b039617725914846"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga7760f72286ab5bd3b039617725914846.html#ga7760f72286ab5bd3b039617725914846">require_any_not_std_vector_st</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga7760f72286ab5bd3b039617725914846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types does not satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga7760f72286ab5bd3b039617725914846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4815cad96da8d8e1e287161867e23b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:gaba4815cad96da8d8e1e287161867e23b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_gaba4815cad96da8d8e1e287161867e23b.html#gaba4815cad96da8d8e1e287161867e23b">require_all_std_vector_st</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:gaba4815cad96da8d8e1e287161867e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types does not satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:gaba4815cad96da8d8e1e287161867e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a11b2ab085c654e101b617643a91264"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga3a11b2ab085c654e101b617643a91264"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__std__vector__types_ga3a11b2ab085c654e101b617643a91264.html#ga3a11b2ab085c654e101b617643a91264">require_all_not_std_vector_st</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>, TypeCheck, Check &gt;... &gt;</td></tr>
<tr class="memdesc:ga3a11b2ab085c654e101b617643a91264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>.  <br /></td></tr>
<tr class="separator:ga3a11b2ab085c654e101b617643a91264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31fc91e7b403b5b036cc35a3994ef614"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga31fc91e7b403b5b036cc35a3994ef614"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__like__types_ga31fc91e7b403b5b036cc35a3994ef614.html#ga31fc91e7b403b5b036cc35a3994ef614">require_vector_like_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga31fc91e7b403b5b036cc35a3994ef614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>.  <br /></td></tr>
<tr class="separator:ga31fc91e7b403b5b036cc35a3994ef614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb764d0ebbfbfe39064be0c6bb2d8728"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaeb764d0ebbfbfe39064be0c6bb2d8728"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__like__types_gaeb764d0ebbfbfe39064be0c6bb2d8728.html#gaeb764d0ebbfbfe39064be0c6bb2d8728">require_not_vector_like_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaeb764d0ebbfbfe39064be0c6bb2d8728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>.  <br /></td></tr>
<tr class="separator:gaeb764d0ebbfbfe39064be0c6bb2d8728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10cdbdbc3f7058615c7e454f77bc4aa"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaa10cdbdbc3f7058615c7e454f77bc4aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__like__types_gaa10cdbdbc3f7058615c7e454f77bc4aa.html#gaa10cdbdbc3f7058615c7e454f77bc4aa">require_all_vector_like_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaa10cdbdbc3f7058615c7e454f77bc4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>.  <br /></td></tr>
<tr class="separator:gaa10cdbdbc3f7058615c7e454f77bc4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aef75f272608f5c9878f7ca0df2530c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga2aef75f272608f5c9878f7ca0df2530c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__like__types_ga2aef75f272608f5c9878f7ca0df2530c.html#ga2aef75f272608f5c9878f7ca0df2530c">require_any_vector_like_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga2aef75f272608f5c9878f7ca0df2530c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>.  <br /></td></tr>
<tr class="separator:ga2aef75f272608f5c9878f7ca0df2530c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ebdb9b8fd44ae91fdbbf22f354895e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gac6ebdb9b8fd44ae91fdbbf22f354895e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__like__types_gac6ebdb9b8fd44ae91fdbbf22f354895e.html#gac6ebdb9b8fd44ae91fdbbf22f354895e">require_all_not_vector_like_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gac6ebdb9b8fd44ae91fdbbf22f354895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>.  <br /></td></tr>
<tr class="separator:gac6ebdb9b8fd44ae91fdbbf22f354895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e35c0f459a9b05c8bbeaa9980592154"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga4e35c0f459a9b05c8bbeaa9980592154"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__like__types_ga4e35c0f459a9b05c8bbeaa9980592154.html#ga4e35c0f459a9b05c8bbeaa9980592154">require_any_not_vector_like_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga4e35c0f459a9b05c8bbeaa9980592154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>.  <br /></td></tr>
<tr class="separator:ga4e35c0f459a9b05c8bbeaa9980592154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc2edd8fe49e19d7ed95187d927c0c0"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:ga3bc2edd8fe49e19d7ed95187d927c0c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vector__like__types_ga3bc2edd8fe49e19d7ed95187d927c0c0.html#ga3bc2edd8fe49e19d7ed95187d927c0c0">require_vector_like_vt</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a>&lt; <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>, TypeCheck, Check... &gt; &gt;</td></tr>
<tr class="memdesc:ga3bc2edd8fe49e19d7ed95187d927c0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1is__vector__like.html">is_vector_like</a>.  <br /></td></tr>
<tr class="separator:ga3bc2edd8fe49e19d7ed95187d927c0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaa16e71f5249e2921c992ae2006995"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aabaa16e71f5249e2921c992ae2006995"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_aabaa16e71f5249e2921c992ae2006995.html#aabaa16e71f5249e2921c992ae2006995">partials_return_t</a> = typename <a class="el" href="structstan_1_1partials__return__type.html">partials_return_type</a>&lt; Args... &gt;::type</td></tr>
<tr class="separator:aabaa16e71f5249e2921c992ae2006995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga1310fb459dbad72fa5594b6d1eaad959.html#ga1310fb459dbad72fa5594b6d1eaad959">partials_type_t</a> = typename <a class="el" href="structstan_1_1partials__type.html">partials_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga1310fb459dbad72fa5594b6d1eaad959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for accessing the partial type.  <br /></td></tr>
<tr class="separator:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6467d85854e3794e24a3218113dd08ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6467d85854e3794e24a3218113dd08ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a> = typename <a class="el" href="structstan_1_1plain__type.html">plain_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a6467d85854e3794e24a3218113dd08ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c9627344315e78e4321a8e1bcccde3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94c9627344315e78e4321a8e1bcccde3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a94c9627344315e78e4321a8e1bcccde3.html#a94c9627344315e78e4321a8e1bcccde3">eval_return_type_t</a> = typename <a class="el" href="structstan_1_1eval__return__type.html">eval_return_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a94c9627344315e78e4321a8e1bcccde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga546483131616701876a9f1307f5a413d.html#ga546483131616701876a9f1307f5a413d">promote_args_t</a> = typename boost::math::tools::promote_args&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ga546483131616701876a9f1307f5a413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for boost tools promote_args.  <br /></td></tr>
<tr class="separator:ga546483131616701876a9f1307f5a413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f14126101865ddd8f5562480ad4927"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98f14126101865ddd8f5562480ad4927"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a98f14126101865ddd8f5562480ad4927.html#a98f14126101865ddd8f5562480ad4927">ref_type_t</a> = typename <a class="el" href="structstan_1_1ref__type__if.html">ref_type_if</a>&lt; true, T &gt;::type</td></tr>
<tr class="separator:a98f14126101865ddd8f5562480ad4927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d61bc435b316497445078a8be2de1e"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T &gt; </td></tr>
<tr class="memitem:a69d61bc435b316497445078a8be2de1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a69d61bc435b316497445078a8be2de1e.html#a69d61bc435b316497445078a8be2de1e">ref_type_if_t</a> = typename <a class="el" href="structstan_1_1ref__type__if.html">ref_type_if</a>&lt; Condition, T &gt;::type</td></tr>
<tr class="separator:a69d61bc435b316497445078a8be2de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6b8d3c5ab19278c4c5baa786490d56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f6b8d3c5ab19278c4c5baa786490d56"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a4f6b8d3c5ab19278c4c5baa786490d56.html#a4f6b8d3c5ab19278c4c5baa786490d56">ref_type_if_not_constant_t</a> = typename <a class="el" href="structstan_1_1ref__type__if.html">ref_type_if</a>&lt;!<a class="el" href="structstan_1_1is__constant.html">is_constant</a>&lt; T &gt;::value, T &gt;::type</td></tr>
<tr class="separator:a4f6b8d3c5ab19278c4c5baa786490d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29595127b6ba2b597e5723c80dee1b61"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga29595127b6ba2b597e5723c80dee1b61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga29595127b6ba2b597e5723c80dee1b61.html#ga29595127b6ba2b597e5723c80dee1b61">require_same_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga29595127b6ba2b597e5723c80dee1b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require types <code>T</code> and <code>S</code> satisfies std::is_same.  <br /></td></tr>
<tr class="separator:ga29595127b6ba2b597e5723c80dee1b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151adb676402a791de98a5d743d7a10d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga151adb676402a791de98a5d743d7a10d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga151adb676402a791de98a5d743d7a10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require types <code>T</code> and <code>S</code> does not satisfy std::is_same.  <br /></td></tr>
<tr class="separator:ga151adb676402a791de98a5d743d7a10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d778e91aefa883ada22a64d478d7d10"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga1d778e91aefa883ada22a64d478d7d10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga1d778e91aefa883ada22a64d478d7d10.html#ga1d778e91aefa883ada22a64d478d7d10">require_all_same_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga1d778e91aefa883ada22a64d478d7d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require <code>T</code> and all of the <code>Types</code> satisfy std::is_same.  <br /></td></tr>
<tr class="separator:ga1d778e91aefa883ada22a64d478d7d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac675059f94945dd3bdda5208e51be69d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gac675059f94945dd3bdda5208e51be69d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_gac675059f94945dd3bdda5208e51be69d.html#gac675059f94945dd3bdda5208e51be69d">require_any_same_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gac675059f94945dd3bdda5208e51be69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the <code>Types</code> and <code>T</code> satisfy std::is_same.  <br /></td></tr>
<tr class="separator:gac675059f94945dd3bdda5208e51be69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5061d1cbda1f94e8c42561d768a58d1c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga5061d1cbda1f94e8c42561d768a58d1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga5061d1cbda1f94e8c42561d768a58d1c.html#ga5061d1cbda1f94e8c42561d768a58d1c">require_all_not_same_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga5061d1cbda1f94e8c42561d768a58d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the <code>Types</code> and <code>T</code> satisfy std::is_same.  <br /></td></tr>
<tr class="separator:ga5061d1cbda1f94e8c42561d768a58d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69adc21a23c58f17eb245dc4fedef241"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga69adc21a23c58f17eb245dc4fedef241"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga69adc21a23c58f17eb245dc4fedef241.html#ga69adc21a23c58f17eb245dc4fedef241">require_any_not_same_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga69adc21a23c58f17eb245dc4fedef241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any one of the <code>Types</code> and <code>T</code> do not satisfy std::is_same.  <br /></td></tr>
<tr class="separator:ga69adc21a23c58f17eb245dc4fedef241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga138d3e9c6d2deaf56afdac86932d73bd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga138d3e9c6d2deaf56afdac86932d73bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga138d3e9c6d2deaf56afdac86932d73bd.html#ga138d3e9c6d2deaf56afdac86932d73bd">require_st_same</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_same&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga138d3e9c6d2deaf56afdac86932d73bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that value types of <code>T</code> and <code>S</code> satisfies std::is_same.  <br /></td></tr>
<tr class="separator:ga138d3e9c6d2deaf56afdac86932d73bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9b312b4f31cd3817e63d6c03ab68a4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga2b9b312b4f31cd3817e63d6c03ab68a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga2b9b312b4f31cd3817e63d6c03ab68a4.html#ga2b9b312b4f31cd3817e63d6c03ab68a4">require_not_st_same</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_same&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga2b9b312b4f31cd3817e63d6c03ab68a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar types of <code>T</code> and <code>S</code> does not satisfy std::is_same.  <br /></td></tr>
<tr class="separator:ga2b9b312b4f31cd3817e63d6c03ab68a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043fb726038d356f89f88fa6e6cb912f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga043fb726038d356f89f88fa6e6cb912f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_ga043fb726038d356f89f88fa6e6cb912f.html#ga043fb726038d356f89f88fa6e6cb912f">require_all_st_same</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_same&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga043fb726038d356f89f88fa6e6cb912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">All scalar types of <code>T</code> and all of the <code>Types</code> satisfy std::is_same.  <br /></td></tr>
<tr class="separator:ga043fb726038d356f89f88fa6e6cb912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdfafe4f366d00df6f8156ec041899e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gacdfafe4f366d00df6f8156ec041899e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_gacdfafe4f366d00df6f8156ec041899e4.html#gacdfafe4f366d00df6f8156ec041899e4">require_any_not_st_same</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_same&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gacdfafe4f366d00df6f8156ec041899e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the scalar types <code>Types</code> and <code>T</code> do not satisfy std::is_same.  <br /></td></tr>
<tr class="separator:gacdfafe4f366d00df6f8156ec041899e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb31dadf505ab2b2cb62931dfc09a625"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gafb31dadf505ab2b2cb62931dfc09a625"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_same&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gafb31dadf505ab2b2cb62931dfc09a625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and <code>S</code> satisfies std::is_same.  <br /></td></tr>
<tr class="separator:gafb31dadf505ab2b2cb62931dfc09a625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc6c66ae3d249abb30aaa0140c8d080c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gafc6c66ae3d249abb30aaa0140c8d080c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__same__types_gafc6c66ae3d249abb30aaa0140c8d080c.html#gafc6c66ae3d249abb30aaa0140c8d080c">require_all_vt_same</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_same&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gafc6c66ae3d249abb30aaa0140c8d080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and all of the <code>Types</code> satisfy std::is_same.  <br /></td></tr>
<tr class="separator:gafc6c66ae3d249abb30aaa0140c8d080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ccdf76808b5de55da12ea4d5e09625"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga75ccdf76808b5de55da12ea4d5e09625"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convertible__types_ga75ccdf76808b5de55da12ea4d5e09625.html#ga75ccdf76808b5de55da12ea4d5e09625">require_convertible_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_convertible&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga75ccdf76808b5de55da12ea4d5e09625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require types <code>T</code> and <code>S</code> satisfies std::is_convertible.  <br /></td></tr>
<tr class="separator:ga75ccdf76808b5de55da12ea4d5e09625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e25308196e3296b11db45151390c8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga06e25308196e3296b11db45151390c8d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convertible__types_ga06e25308196e3296b11db45151390c8d.html#ga06e25308196e3296b11db45151390c8d">require_not_convertible_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_convertible&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga06e25308196e3296b11db45151390c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require types <code>T</code> and <code>S</code> does not satisfy std::is_convertible.  <br /></td></tr>
<tr class="separator:ga06e25308196e3296b11db45151390c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee321b9f6ce391f8203c7ac97db8c4cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gaee321b9f6ce391f8203c7ac97db8c4cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convertible__types_gaee321b9f6ce391f8203c7ac97db8c4cb.html#gaee321b9f6ce391f8203c7ac97db8c4cb">require_all_convertible_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_convertible&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaee321b9f6ce391f8203c7ac97db8c4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require <code>T</code> and all of the <code>Types</code> satisfy std::is_convertible.  <br /></td></tr>
<tr class="separator:gaee321b9f6ce391f8203c7ac97db8c4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96152944a3fdc52f91541bd423d094aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga96152944a3fdc52f91541bd423d094aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__convertible__types_ga96152944a3fdc52f91541bd423d094aa.html#ga96152944a3fdc52f91541bd423d094aa">require_any_not_convertible_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_convertible&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga96152944a3fdc52f91541bd423d094aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any one of the <code>Types</code> and <code>T</code> do not satisfy.  <br /></td></tr>
<tr class="separator:ga96152944a3fdc52f91541bd423d094aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga229ee0eb3e2f4d8dd8a13fb9ae198699"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga229ee0eb3e2f4d8dd8a13fb9ae198699"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga229ee0eb3e2f4d8dd8a13fb9ae198699.html#ga229ee0eb3e2f4d8dd8a13fb9ae198699">require_assignable_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_assignable&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga229ee0eb3e2f4d8dd8a13fb9ae198699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require types <code>T</code> and <code>S</code> satisfies std::is_assignable.  <br /></td></tr>
<tr class="separator:ga229ee0eb3e2f4d8dd8a13fb9ae198699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa449c12664ab55e63ba54887a8712868"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gaa449c12664ab55e63ba54887a8712868"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_gaa449c12664ab55e63ba54887a8712868.html#gaa449c12664ab55e63ba54887a8712868">require_not_assignable_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_assignable&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaa449c12664ab55e63ba54887a8712868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require types <code>T</code> and <code>S</code> does not satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:gaa449c12664ab55e63ba54887a8712868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7050fa60e1f583c9d6b01065170d447b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga7050fa60e1f583c9d6b01065170d447b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga7050fa60e1f583c9d6b01065170d447b.html#ga7050fa60e1f583c9d6b01065170d447b">require_st_assignable</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_assignable&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7050fa60e1f583c9d6b01065170d447b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that value types of <code>T</code> and <code>S</code> satisfies std::is_assignable.  <br /></td></tr>
<tr class="separator:ga7050fa60e1f583c9d6b01065170d447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893cbd5da5ea2a9da02fb6248a1e9007"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga893cbd5da5ea2a9da02fb6248a1e9007"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga893cbd5da5ea2a9da02fb6248a1e9007.html#ga893cbd5da5ea2a9da02fb6248a1e9007">require_not_st_assignable</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_assignable&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga893cbd5da5ea2a9da02fb6248a1e9007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar types of <code>T</code> and <code>S</code> does not satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:ga893cbd5da5ea2a9da02fb6248a1e9007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162f85695b326fa615ffef1f9d18305d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga162f85695b326fa615ffef1f9d18305d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga162f85695b326fa615ffef1f9d18305d.html#ga162f85695b326fa615ffef1f9d18305d">require_all_st_assignable</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_assignable&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga162f85695b326fa615ffef1f9d18305d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All scalar types of <code>T</code> and all of the <code>Types</code> satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:ga162f85695b326fa615ffef1f9d18305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777f539820c4eb93b02fbafc09191501"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga777f539820c4eb93b02fbafc09191501"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga777f539820c4eb93b02fbafc09191501.html#ga777f539820c4eb93b02fbafc09191501">require_any_st_assignable</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; std::is_assignable&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga777f539820c4eb93b02fbafc09191501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the scalar types of <code>Types</code> and <code>T</code> satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:ga777f539820c4eb93b02fbafc09191501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dce7f797fa58425217d1559657f4c9a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga4dce7f797fa58425217d1559657f4c9a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga4dce7f797fa58425217d1559657f4c9a.html#ga4dce7f797fa58425217d1559657f4c9a">require_all_not_st_assignable</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; std::is_assignable&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga4dce7f797fa58425217d1559657f4c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">None of the scalar types of <code>Types</code> and <code>T</code> satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:ga4dce7f797fa58425217d1559657f4c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66eb1b740b70a2f1513c0482729641ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga66eb1b740b70a2f1513c0482729641ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga66eb1b740b70a2f1513c0482729641ea.html#ga66eb1b740b70a2f1513c0482729641ea">require_any_not_st_assignable</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_assignable&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga66eb1b740b70a2f1513c0482729641ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the scalar types <code>Types</code> and <code>T</code> do not satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:ga66eb1b740b70a2f1513c0482729641ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbf24d8e0848c809e5451cbe528078f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga4bbf24d8e0848c809e5451cbe528078f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga4bbf24d8e0848c809e5451cbe528078f.html#ga4bbf24d8e0848c809e5451cbe528078f">require_vt_assignable</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_assignable&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga4bbf24d8e0848c809e5451cbe528078f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and <code>S</code> satisfies std::is_assignable.  <br /></td></tr>
<tr class="separator:ga4bbf24d8e0848c809e5451cbe528078f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33492be65234ac0c3beed9a3bb54aa8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gaf33492be65234ac0c3beed9a3bb54aa8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_gaf33492be65234ac0c3beed9a3bb54aa8.html#gaf33492be65234ac0c3beed9a3bb54aa8">require_not_vt_assignable</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_assignable&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaf33492be65234ac0c3beed9a3bb54aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and <code>S</code> does not satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:gaf33492be65234ac0c3beed9a3bb54aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8162b655bd5afc74e27111965bd6ddbf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga8162b655bd5afc74e27111965bd6ddbf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_ga8162b655bd5afc74e27111965bd6ddbf.html#ga8162b655bd5afc74e27111965bd6ddbf">require_all_vt_assignable</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_assignable&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga8162b655bd5afc74e27111965bd6ddbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and all of the <code>Types</code> satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:ga8162b655bd5afc74e27111965bd6ddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0868a198cfac261330a84255abd56d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gaec0868a198cfac261330a84255abd56d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_gaec0868a198cfac261330a84255abd56d.html#gaec0868a198cfac261330a84255abd56d">require_any_vt_assignable</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; std::is_assignable&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaec0868a198cfac261330a84255abd56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the value types of <code>Types</code> and <code>T</code> satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:gaec0868a198cfac261330a84255abd56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c19dbd65d190c825cdd14548211812"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gaa4c19dbd65d190c825cdd14548211812"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_gaa4c19dbd65d190c825cdd14548211812.html#gaa4c19dbd65d190c825cdd14548211812">require_all_not_vt_assignable</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; std::is_assignable&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaa4c19dbd65d190c825cdd14548211812"><td class="mdescLeft">&#160;</td><td class="mdescRight">None of the value types of <code>Types</code> and <code>T</code> satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:gaa4c19dbd65d190c825cdd14548211812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83c68f00112439b268e9ea655cd3a68"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gae83c68f00112439b268e9ea655cd3a68"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__assignable__types_gae83c68f00112439b268e9ea655cd3a68.html#gae83c68f00112439b268e9ea655cd3a68">require_any_not_vt_assignable</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_assignable&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gae83c68f00112439b268e9ea655cd3a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the value types <code>Types</code> and <code>T</code> do not satisfy std::is_assignable.  <br /></td></tr>
<tr class="separator:gae83c68f00112439b268e9ea655cd3a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace83beabc05af15d3a0c7632e9733625"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gace83beabc05af15d3a0c7632e9733625"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_gace83beabc05af15d3a0c7632e9733625.html#gace83beabc05af15d3a0c7632e9733625">require_constructible_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_constructible&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gace83beabc05af15d3a0c7632e9733625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require types <code>T</code> and <code>S</code> satisfies std::is_constructible.  <br /></td></tr>
<tr class="separator:gace83beabc05af15d3a0c7632e9733625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad632b47290b3b6ec1526ddb82db5f260"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gad632b47290b3b6ec1526ddb82db5f260"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_gad632b47290b3b6ec1526ddb82db5f260.html#gad632b47290b3b6ec1526ddb82db5f260">require_st_constructible</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_constructible&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gad632b47290b3b6ec1526ddb82db5f260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that value types of <code>T</code> and <code>S</code> satisfies std::is_constructible.  <br /></td></tr>
<tr class="separator:gad632b47290b3b6ec1526ddb82db5f260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289e53bca528b4a391c47797e4b84c3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga289e53bca528b4a391c47797e4b84c3a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga289e53bca528b4a391c47797e4b84c3a.html#ga289e53bca528b4a391c47797e4b84c3a">require_not_st_constructible</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_constructible&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga289e53bca528b4a391c47797e4b84c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar types of <code>T</code> and <code>S</code> does not satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga289e53bca528b4a391c47797e4b84c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91c39782b33bc71ce1c190f791b604ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga91c39782b33bc71ce1c190f791b604ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga91c39782b33bc71ce1c190f791b604ce.html#ga91c39782b33bc71ce1c190f791b604ce">require_all_st_constructible</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_constructible&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga91c39782b33bc71ce1c190f791b604ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">All scalar types of <code>T</code> and all of the <code>Types</code> satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga91c39782b33bc71ce1c190f791b604ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2e20779e9f810194527a90f499511b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gade2e20779e9f810194527a90f499511b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_gade2e20779e9f810194527a90f499511b.html#gade2e20779e9f810194527a90f499511b">require_any_st_constructible</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; std::is_constructible&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gade2e20779e9f810194527a90f499511b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the scalar types of <code>Types</code> and <code>T</code> satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:gade2e20779e9f810194527a90f499511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14246b0ca7c03b78cb0100214c562095"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga14246b0ca7c03b78cb0100214c562095"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga14246b0ca7c03b78cb0100214c562095.html#ga14246b0ca7c03b78cb0100214c562095">require_all_not_st_constructible</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; std::is_constructible&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga14246b0ca7c03b78cb0100214c562095"><td class="mdescLeft">&#160;</td><td class="mdescRight">None of the scalar types of <code>Types</code> and <code>T</code> satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga14246b0ca7c03b78cb0100214c562095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c16f837144bb603ee976c04517c722"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:gad5c16f837144bb603ee976c04517c722"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_gad5c16f837144bb603ee976c04517c722.html#gad5c16f837144bb603ee976c04517c722">require_any_not_st_constructible</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_constructible&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad5c16f837144bb603ee976c04517c722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the scalar types <code>Types</code> and <code>T</code> do not satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:gad5c16f837144bb603ee976c04517c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde2d2c17abcc503b316f4e6df4b3239"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gabde2d2c17abcc503b316f4e6df4b3239"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_gabde2d2c17abcc503b316f4e6df4b3239.html#gabde2d2c17abcc503b316f4e6df4b3239">require_vt_constructible</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_constructible&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gabde2d2c17abcc503b316f4e6df4b3239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and <code>S</code> satisfies std::is_constructible.  <br /></td></tr>
<tr class="separator:gabde2d2c17abcc503b316f4e6df4b3239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a86599d0c4f06e981e52523ab66690d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga8a86599d0c4f06e981e52523ab66690d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga8a86599d0c4f06e981e52523ab66690d.html#ga8a86599d0c4f06e981e52523ab66690d">require_not_vt_constructible</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_constructible&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; S &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga8a86599d0c4f06e981e52523ab66690d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and <code>S</code> does not satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga8a86599d0c4f06e981e52523ab66690d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a49e9c0931d3330f62f088eecf86b1d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga2a49e9c0931d3330f62f088eecf86b1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga2a49e9c0931d3330f62f088eecf86b1d.html#ga2a49e9c0931d3330f62f088eecf86b1d">require_all_vt_constructible</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_constructible&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga2a49e9c0931d3330f62f088eecf86b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types of <code>T</code> and all of the <code>Types</code> satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga2a49e9c0931d3330f62f088eecf86b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375daba025d96467aa6a39b16f412b30"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga375daba025d96467aa6a39b16f412b30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga375daba025d96467aa6a39b16f412b30.html#ga375daba025d96467aa6a39b16f412b30">require_any_vt_constructible</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; std::is_constructible&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga375daba025d96467aa6a39b16f412b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the value types of <code>Types</code> and <code>T</code> satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga375daba025d96467aa6a39b16f412b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4ce6220e0a1b17b8b2571305495cc4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga6c4ce6220e0a1b17b8b2571305495cc4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga6c4ce6220e0a1b17b8b2571305495cc4.html#ga6c4ce6220e0a1b17b8b2571305495cc4">require_all_not_vt_constructible</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; std::is_constructible&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga6c4ce6220e0a1b17b8b2571305495cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">None of the value types of <code>Types</code> and <code>T</code> satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga6c4ce6220e0a1b17b8b2571305495cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5b00473f2a723e0948e6d46e7b7d88"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ga1c5b00473f2a723e0948e6d46e7b7d88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constructible__types_ga1c5b00473f2a723e0948e6d46e7b7d88.html#ga1c5b00473f2a723e0948e6d46e7b7d88">require_any_not_vt_constructible</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_constructible&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga1c5b00473f2a723e0948e6d46e7b7d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the value types <code>Types</code> and <code>T</code> do not satisfy std::is_constructible.  <br /></td></tr>
<tr class="separator:ga1c5b00473f2a723e0948e6d46e7b7d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fad8aea7b9f231cb2a85d59a9af6d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21fad8aea7b9f231cb2a85d59a9af6d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_arithmetic&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga21fad8aea7b9f231cb2a85d59a9af6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga21fad8aea7b9f231cb2a85d59a9af6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40125f31ec8c3027b2e85215f20b5702"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga40125f31ec8c3027b2e85215f20b5702"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga40125f31ec8c3027b2e85215f20b5702.html#ga40125f31ec8c3027b2e85215f20b5702">require_not_arithmetic_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_arithmetic&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga40125f31ec8c3027b2e85215f20b5702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga40125f31ec8c3027b2e85215f20b5702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09986c7ec9fdfe2f4648356230c938ff"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga09986c7ec9fdfe2f4648356230c938ff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_arithmetic&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga09986c7ec9fdfe2f4648356230c938ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga09986c7ec9fdfe2f4648356230c938ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a77edba3f6fb2bd60267c7a9bdc08e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga75a77edba3f6fb2bd60267c7a9bdc08e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga75a77edba3f6fb2bd60267c7a9bdc08e.html#ga75a77edba3f6fb2bd60267c7a9bdc08e">require_any_arithmetic_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; std::is_arithmetic&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga75a77edba3f6fb2bd60267c7a9bdc08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga75a77edba3f6fb2bd60267c7a9bdc08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5a52d7d9a8b3ae17e6dd8a9149bfc25"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gac5a52d7d9a8b3ae17e6dd8a9149bfc25"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_gac5a52d7d9a8b3ae17e6dd8a9149bfc25.html#gac5a52d7d9a8b3ae17e6dd8a9149bfc25">require_all_not_arithmetic_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; std::is_arithmetic&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gac5a52d7d9a8b3ae17e6dd8a9149bfc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:gac5a52d7d9a8b3ae17e6dd8a9149bfc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5c059c1d9e54bdf3ee973388a47896"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gacd5c059c1d9e54bdf3ee973388a47896"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_arithmetic&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gacd5c059c1d9e54bdf3ee973388a47896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:gacd5c059c1d9e54bdf3ee973388a47896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac93fca88594a61f619dd4ba85418e16c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gac93fca88594a61f619dd4ba85418e16c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_gac93fca88594a61f619dd4ba85418e16c.html#gac93fca88594a61f619dd4ba85418e16c">require_all_vt_arithmetic</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gac93fca88594a61f619dd4ba85418e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the value types satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:gac93fca88594a61f619dd4ba85418e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcdfb7a137ea7438b15072cd94f0dba"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga8bcdfb7a137ea7438b15072cd94f0dba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga8bcdfb7a137ea7438b15072cd94f0dba.html#ga8bcdfb7a137ea7438b15072cd94f0dba">require_any_not_vt_arithmetic</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga8bcdfb7a137ea7438b15072cd94f0dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the value types do not satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga8bcdfb7a137ea7438b15072cd94f0dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948d431ec5773ff848a6bfa0d0b7aa79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga948d431ec5773ff848a6bfa0d0b7aa79"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga948d431ec5773ff848a6bfa0d0b7aa79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type satisfies std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga948d431ec5773ff848a6bfa0d0b7aa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405fec5a34ff4c65e052577d247f1a60"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga405fec5a34ff4c65e052577d247f1a60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga405fec5a34ff4c65e052577d247f1a60.html#ga405fec5a34ff4c65e052577d247f1a60">require_not_st_arithmetic</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga405fec5a34ff4c65e052577d247f1a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga405fec5a34ff4c65e052577d247f1a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ccb7bb7ca23838c90e98961789c1153"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga3ccb7bb7ca23838c90e98961789c1153"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga3ccb7bb7ca23838c90e98961789c1153.html#ga3ccb7bb7ca23838c90e98961789c1153">require_all_st_arithmetic</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga3ccb7bb7ca23838c90e98961789c1153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the scalar types satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga3ccb7bb7ca23838c90e98961789c1153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb711d86d9eff9f4edf38129c910c87"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga3eb711d86d9eff9f4edf38129c910c87"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga3eb711d86d9eff9f4edf38129c910c87.html#ga3eb711d86d9eff9f4edf38129c910c87">require_any_st_arithmetic</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga3eb711d86d9eff9f4edf38129c910c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the scalar types satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga3eb711d86d9eff9f4edf38129c910c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6edc00dc67d479efca08150a952d7588"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga6edc00dc67d479efca08150a952d7588"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__types_ga6edc00dc67d479efca08150a952d7588.html#ga6edc00dc67d479efca08150a952d7588">require_any_not_st_arithmetic</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga6edc00dc67d479efca08150a952d7588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the scalar types do not satisfy std::is_arithmetic.  <br /></td></tr>
<tr class="separator:ga6edc00dc67d479efca08150a952d7588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fb93a2c53b62e4f71947afbf3de358"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga94fb93a2c53b62e4f71947afbf3de358"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__floating__point__types_ga94fb93a2c53b62e4f71947afbf3de358.html#ga94fb93a2c53b62e4f71947afbf3de358">require_floating_point_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_floating_point&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga94fb93a2c53b62e4f71947afbf3de358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies std::is_floating_point.  <br /></td></tr>
<tr class="separator:ga94fb93a2c53b62e4f71947afbf3de358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31729c13937697c747fee3e83c0b957e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga31729c13937697c747fee3e83c0b957e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__types_ga31729c13937697c747fee3e83c0b957e.html#ga31729c13937697c747fee3e83c0b957e">require_integral_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_integral&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga31729c13937697c747fee3e83c0b957e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies std::is_integral.  <br /></td></tr>
<tr class="separator:ga31729c13937697c747fee3e83c0b957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354e01c2052e5b9575fc6ddf20f76fba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga354e01c2052e5b9575fc6ddf20f76fba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__types_ga354e01c2052e5b9575fc6ddf20f76fba.html#ga354e01c2052e5b9575fc6ddf20f76fba">require_vt_integral</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_integral&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga354e01c2052e5b9575fc6ddf20f76fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type satisfies std::is_integral.  <br /></td></tr>
<tr class="separator:ga354e01c2052e5b9575fc6ddf20f76fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d10ea9813909bf7fc1a2394e880165a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8d10ea9813909bf7fc1a2394e880165a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_integral&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga8d10ea9813909bf7fc1a2394e880165a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type satisfies std::is_integral.  <br /></td></tr>
<tr class="separator:ga8d10ea9813909bf7fc1a2394e880165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fcc2a2bbf248f49e94e429643d2e29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85fcc2a2bbf248f49e94e429643d2e29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__types_ga85fcc2a2bbf248f49e94e429643d2e29.html#ga85fcc2a2bbf248f49e94e429643d2e29">require_not_st_integral</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::is_integral&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga85fcc2a2bbf248f49e94e429643d2e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy std::is_integral.  <br /></td></tr>
<tr class="separator:ga85fcc2a2bbf248f49e94e429643d2e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03fa77ef458ec3315ad03502d43d2b9c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga03fa77ef458ec3315ad03502d43d2b9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__integral__types_ga03fa77ef458ec3315ad03502d43d2b9c.html#ga03fa77ef458ec3315ad03502d43d2b9c">require_all_not_st_integral</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; std::is_integral&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga03fa77ef458ec3315ad03502d43d2b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the scalar types satisfy std::is_integral.  <br /></td></tr>
<tr class="separator:ga03fa77ef458ec3315ad03502d43d2b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93583561a7a3642b498cf2b059d29c0"><td class="memTemplParams" colspan="2">template&lt;class Check &gt; </td></tr>
<tr class="memitem:ad93583561a7a3642b498cf2b059d29c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a> = std::enable_if_t&lt; Check::value &gt;</td></tr>
<tr class="memdesc:ad93583561a7a3642b498cf2b059d29c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If condition is true, template is enabled.  <br /></td></tr>
<tr class="separator:ad93583561a7a3642b498cf2b059d29c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0828f8f3d9b2ed5e8c7fd38e7600f9df"><td class="memTemplParams" colspan="2">template&lt;typename Check &gt; </td></tr>
<tr class="memitem:a0828f8f3d9b2ed5e8c7fd38e7600f9df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a> = std::enable_if_t&lt;!Check::value &gt;</td></tr>
<tr class="memdesc:a0828f8f3d9b2ed5e8c7fd38e7600f9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">If condition is false, template is disabled.  <br /></td></tr>
<tr class="separator:a0828f8f3d9b2ed5e8c7fd38e7600f9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddf362fef97adf67b57ba8818d73a67"><td class="memTemplParams" colspan="2">template&lt;class... Checks&gt; </td></tr>
<tr class="memitem:adddf362fef97adf67b57ba8818d73a67"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a> = std::enable_if_t&lt; <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; Checks... &gt;::value &gt;</td></tr>
<tr class="memdesc:adddf362fef97adf67b57ba8818d73a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">If all conditions are true, template is enabled Returns a type void if all conditions are true and otherwise fails.  <br /></td></tr>
<tr class="separator:adddf362fef97adf67b57ba8818d73a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ded958a60b3f73671c8ed20e2ff426f"><td class="memTemplParams" colspan="2">template&lt;class... Checks&gt; </td></tr>
<tr class="memitem:a0ded958a60b3f73671c8ed20e2ff426f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a> = std::enable_if_t&lt; <a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; Checks... &gt;::value &gt;</td></tr>
<tr class="memdesc:a0ded958a60b3f73671c8ed20e2ff426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If any condition is true, template is enabled.  <br /></td></tr>
<tr class="separator:a0ded958a60b3f73671c8ed20e2ff426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557173ff88d2e9cf7c48e3527d470219"><td class="memTemplParams" colspan="2">template&lt;class... Checks&gt; </td></tr>
<tr class="memitem:a557173ff88d2e9cf7c48e3527d470219"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a> = std::enable_if_t&lt;!<a class="el" href="structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; Checks... &gt;::value &gt;</td></tr>
<tr class="memdesc:a557173ff88d2e9cf7c48e3527d470219"><td class="mdescLeft">&#160;</td><td class="mdescRight">If all conditions are false, template is enabled.  <br /></td></tr>
<tr class="separator:a557173ff88d2e9cf7c48e3527d470219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab02e1df7877fb9e7ffb376469932e27"><td class="memTemplParams" colspan="2">template&lt;class... Checks&gt; </td></tr>
<tr class="memitem:aab02e1df7877fb9e7ffb376469932e27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a> = std::enable_if_t&lt;!<a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; Checks... &gt;::value &gt;</td></tr>
<tr class="memdesc:aab02e1df7877fb9e7ffb376469932e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">If any condition is false, template is enabled.  <br /></td></tr>
<tr class="separator:aab02e1df7877fb9e7ffb376469932e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae3e78a5551e87a4a6d6b18b6765adf"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class ContainerCheck, template&lt; class... &gt; class ValueCheck, template&lt; class... &gt; class TypeCheck, class... Check&gt; </td></tr>
<tr class="memitem:a8ae3e78a5551e87a4a6d6b18b6765adf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a8ae3e78a5551e87a4a6d6b18b6765adf.html#a8ae3e78a5551e87a4a6d6b18b6765adf">container_type_check_base</a> = <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt; <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; ContainerCheck&lt; std::decay_t&lt; Check &gt; &gt;..., TypeCheck&lt; ValueCheck&lt; Check &gt; &gt;... &gt;::value &gt;</td></tr>
<tr class="memdesc:a8ae3e78a5551e87a4a6d6b18b6765adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as the base for checking whether a type is a container with an underlying scalar type.  <br /></td></tr>
<tr class="separator:a8ae3e78a5551e87a4a6d6b18b6765adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a> = typename <a class="el" href="structstan_1_1real__return.html">real_return</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gac9d3fe14d5102916bf0b5b05712c833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the real return type.  <br /></td></tr>
<tr class="separator:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a> = std::complex&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:gaf21bb3c3ca46c48bb58c33a5260b74c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga876ae6b470c58e692b4a4273a32f7ea3.html#ga876ae6b470c58e692b4a4273a32f7ea3">std_vector_return_t</a> = std::vector&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:ga876ae6b470c58e692b4a4273a32f7ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gab3412a1caaad7f8eef55a9ee2a0d3921.html#gab3412a1caaad7f8eef55a9ee2a0d3921">matrix_return_t</a> = Eigen::Matrix&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, -1 &gt;</td></tr>
<tr class="memdesc:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga1b070b6ae219eccccf07b44243307b8b.html#ga1b070b6ae219eccccf07b44243307b8b">vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, 1 &gt;</td></tr>
<tr class="memdesc:ga1b070b6ae219eccccf07b44243307b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:ga1b070b6ae219eccccf07b44243307b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga2fa4e21b37c08e6abce2919ac4c2cd57.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">row_vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, 1, -1 &gt;</td></tr>
<tr class="memdesc:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gace9d2d5da99a3e14fcadd7bf0f6cffee.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">scalar_lub_t</a> = typename <a class="el" href="structstan_1_1scalar__lub.html">scalar_lub</a>&lt; T1, T2 &gt;::type</td></tr>
<tr class="memdesc:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering.  <br /></td></tr>
<tr class="separator:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a> = typename <a class="el" href="structstan_1_1return__type.html">return_type</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gacbaff683cd2683209e6855e2c7aaeffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the return type of the specified template parameters.  <br /></td></tr>
<tr class="separator:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3671feedf945127c24a500b77adc594c"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Check, typename... Ts&gt; </td></tr>
<tr class="memitem:a3671feedf945127c24a500b77adc594c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a3671feedf945127c24a500b77adc594c.html#a3671feedf945127c24a500b77adc594c">require_return_type_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; Check&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ts... &gt; &gt; &gt;</td></tr>
<tr class="separator:a3671feedf945127c24a500b77adc594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb74ad577894a6af9b619632bc1c604"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Check, typename... Ts&gt; </td></tr>
<tr class="memitem:afbb74ad577894a6af9b619632bc1c604"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_afbb74ad577894a6af9b619632bc1c604.html#afbb74ad577894a6af9b619632bc1c604">require_not_return_type_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; Check&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ts... &gt; &gt; &gt;</td></tr>
<tr class="separator:afbb74ad577894a6af9b619632bc1c604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6abe3bad95e25c29cc69722502dc41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f6abe3bad95e25c29cc69722502dc41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a> = typename <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a9f6abe3bad95e25c29cc69722502dc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a> = typename <a class="el" href="structstan_1_1value__type.html">value_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga57121ded0440567e8dfb0d80b1290922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for accessing underlying type.  <br /></td></tr>
<tr class="separator:ga57121ded0440567e8dfb0d80b1290922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5985fa1de76fad7a0637d86c496156"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aef5985fa1de76fad7a0637d86c496156"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_aef5985fa1de76fad7a0637d86c496156.html#aef5985fa1de76fad7a0637d86c496156">void_t</a> = typename <a class="el" href="structstan_1_1make__void.html">make_void</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:aef5985fa1de76fad7a0637d86c496156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that maps a sequence of any types to the type void This metafunction is used in template metaprogramming to detect ill-formed types or the validity of an expression in an SFINAE context:  <br /></td></tr>
<tr class="separator:aef5985fa1de76fad7a0637d86c496156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a8d862930229bc6ac4f3ac13514585"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8a8d862930229bc6ac4f3ac13514585"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a> = typename <a class="el" href="structstan_1_1internal_1_1arena__type__impl.html">internal::arena_type_impl</a>&lt; std::decay_t&lt; T &gt; &gt;::type</td></tr>
<tr class="memdesc:ab8a8d862930229bc6ac4f3ac13514585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines a type that can be used in place of <code>T</code> that does any dynamic allocations on the AD stack.  <br /></td></tr>
<tr class="separator:ab8a8d862930229bc6ac4f3ac13514585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe823797b2241e12d2dc0de8a606a29"><td class="memTemplParams" colspan="2">template&lt;typename T_scalar , typename T_container &gt; </td></tr>
<tr class="memitem:adfe823797b2241e12d2dc0de8a606a29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_adfe823797b2241e12d2dc0de8a606a29.html#adfe823797b2241e12d2dc0de8a606a29">conditional_var_value_t</a> = typename <a class="el" href="structstan_1_1conditional__var__value.html">conditional_var_value</a>&lt; T_scalar, T_container &gt;::type</td></tr>
<tr class="separator:adfe823797b2241e12d2dc0de8a606a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2896e43e9a849cd86d9f9b9a42bcdf95"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename... Types&gt; </td></tr>
<tr class="memitem:a2896e43e9a849cd86d9f9b9a42bcdf95"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a2896e43e9a849cd86d9f9b9a42bcdf95.html#a2896e43e9a849cd86d9f9b9a42bcdf95">promote_var_matrix_t</a> = std::conditional_t&lt; <a class="el" href="structstan_1_1is__any__var__matrix.html">is_any_var_matrix</a>&lt; ReturnType, Types... &gt;::value, <a class="el" href="classstan_1_1math_1_1var__value.html">stan::math::var_value</a>&lt; <a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">stan::math::promote_scalar_t</a>&lt; double, ReturnType &gt; &gt;, <a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">stan::math::promote_scalar_t</a>&lt; <a class="el" href="classstan_1_1math_1_1var__value.html">stan::math::var_value</a>&lt; double &gt;, ReturnType &gt; &gt;</td></tr>
<tr class="memdesc:a2896e43e9a849cd86d9f9b9a42bcdf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type and several inputs, determine if a matrix should be <code>var&lt;Matrix&gt;</code> or <code>Matrix&lt;var&gt;</code>.  <br /></td></tr>
<tr class="separator:a2896e43e9a849cd86d9f9b9a42bcdf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22a7771e96057958bffbf7eabe87487"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename... Types&gt; </td></tr>
<tr class="memitem:ae22a7771e96057958bffbf7eabe87487"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_ae22a7771e96057958bffbf7eabe87487.html#ae22a7771e96057958bffbf7eabe87487">return_var_matrix_t</a> = std::conditional_t&lt; <a class="el" href="structstan_1_1is__any__var__matrix.html">is_any_var_matrix</a>&lt; ReturnType, Types... &gt;::value, <a class="el" href="classstan_1_1math_1_1var__value.html">stan::math::var_value</a>&lt; <a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">stan::math::promote_scalar_t</a>&lt; double, <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; ReturnType &gt; &gt; &gt;, <a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">stan::math::promote_scalar_t</a>&lt; <a class="el" href="classstan_1_1math_1_1var__value.html">stan::math::var_value</a>&lt; double &gt;, <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; ReturnType &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ae22a7771e96057958bffbf7eabe87487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type and several inputs, determine if a matrix should be <code>var&lt;Matrix&gt;</code> or <code>Matrix&lt;var&gt;</code>.  <br /></td></tr>
<tr class="separator:ae22a7771e96057958bffbf7eabe87487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24eae7736af8b472086c137776afb4bc"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols, typename... Inputs&gt; </td></tr>
<tr class="memitem:a24eae7736af8b472086c137776afb4bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_a24eae7736af8b472086c137776afb4bc.html#a24eae7736af8b472086c137776afb4bc">rev_matrix_t</a> = typename <a class="el" href="structstan_1_1rev__matrix__type.html">rev_matrix_type</a>&lt; Rows, Cols, Inputs... &gt;::type</td></tr>
<tr class="separator:a24eae7736af8b472086c137776afb4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gad2a93cdd718b76d4994d0f7c6c05fbba.html#gad2a93cdd718b76d4994d0f7c6c05fbba">get</a> (const T &amp;x, size_t n)</td></tr>
<tr class="memdesc:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the provided element.  <br /></td></tr>
<tr class="separator:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga431bd201f09a215cccb16cda10a1e840.html#ga431bd201f09a215cccb16cda10a1e840">get</a> (const std::vector&lt; T &gt; &amp;x, size_t n)</td></tr>
<tr class="memdesc:ga431bd201f09a215cccb16cda10a1e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the n-th element of the provided std::vector.  <br /></td></tr>
<tr class="separator:ga431bd201f09a215cccb16cda10a1e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_eigen_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_gad2a93cdd718b76d4994d0f7c6c05fbba.html#gad2a93cdd718b76d4994d0f7c6c05fbba">get</a> (const T &amp;m, size_t n)</td></tr>
<tr class="memdesc:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the n-th element of the provided <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afa686f9493cedb22eeb5f029e9aefeab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa686f9493cedb22eeb5f029e9aefeab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_afa686f9493cedb22eeb5f029e9aefeab.html#afa686f9493cedb22eeb5f029e9aefeab">is_real_v</a> = <a class="el" href="structstan_1_1is__real.html">is_real</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afa686f9493cedb22eeb5f029e9aefeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestan.html">stan</a></li>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
